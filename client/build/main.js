(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*jshint node:true*/
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
/*global App, document, window */
'use strict';
var React = require('react');
var debug = require('debug');
var bootstrapDebug = debug('mydrive');
var app = require('./app.jsx');
var dehydratedState = window.App; // Sent from the server

window.React = React; // For chrome dev tool support
debug.enable('*');

// bootstrapDebug('rehydrating app');
app.rehydrate(dehydratedState, function (err, context) {
    if (err) {
        throw err;
    }
    window.context = context;
    var mountNode = document.getElementById('app');

    // bootstrapDebug('React Rendering');
    React.withContext(context.getComponentContext(), function () {
        React.render(app.getAppComponent()(), mountNode, function () {
            // bootstrapDebug('React Rendered');
        });
    });
});

},{"./app.jsx":5,"debug":42,"react":"react"}],2:[function(require,module,exports){
/*jshint node:true */
'use strict';
var debug = require('debug')('Example:showChatAction');
// var MessageStore = require('../stores/MessageStore');
// var openThread = require('../actions/openThread');

function fetchMessages(context, payload, done) {
    debug('fetching messages');
    context.service.read('message', {}, {}, function (err, messages) {
        context.dispatch('RECEIVE_MESSAGES', messages);
        // context.executeAction(openThread, payload, function() {
        //     context.dispatch('SHOW_CHAT_END');
        //     done();
        // });;
        done();
    });

}

module.exports = function (context, payload, done) {
    // context.dispatch('SHOW_CHAT_START');
    // var messageStore = context.getStore(MessageStore);
    fetchMessages(context,payload,done);
    done();
    // if (Object.keys(messageStore.getAll()).length === 0) {
    //     fetchMessages(context, payload, done);
    // } else {
    //     debug('dispatching SHOW_CHAT_END');
    //     context.dispatch('SHOW_CHAT_END');
    //     done();
    // }
};
},{"debug":42}],3:[function(require,module,exports){
/*jshint node:true */
'use strict';
var debug = require('debug')('mydrive5:showChatAction');
// var MessageStore = require('../stores/MessageStore');
// var openThread = require('../actions/openThread');
var request = require('superagent');
// var csrf = require('superagent-csrf')(request);
var navigateAction = require('flux-router-component').navigateAction;


function login(context, payload, done) {
    // console.log(context);
    // console.log(window.App.context.plugins.FetchrPlugin.xhrContext._csrf);
    // console.log('payload',payload);
    // var cookie=document.cookie;
    // var token=getCookie('_csrf');
    payload._csrf=window.App.context.plugins.FetchrPlugin.xhrContext._csrf;
    // console.log('token',token);
    request.post('/auth/local')
    .send(payload)
    .end(function(error,res){
        console.log(res);
        if(res.body.token && res.body.user){
            context.dispatch('SET_TOKEN',res.body.token);
            context.dispatch('SET_USER',res.body.user);
            context.executeAction(navigateAction, { url: '/admin' }, function(){});
        }
        done();
    });
    // debug('fetching messages');
    // context.service.create('message', {}, {}, function (err, messages) {
    //     context.dispatch('RECEIVE_MESSAGES', messages);
    //     // context.executeAction(openThread, payload, function() {
    //     //     context.dispatch('SHOW_CHAT_END');
    //     //     done();
    //     // });;
    //     done();
    // });

}

module.exports = function (context, payload, done) {
    // context.dispatch('SHOW_CHAT_START');
    // var messageStore = context.getStore(MessageStore);
    login(context,payload,done);
    done();
    // if (Object.keys(messageStore.getAll()).length === 0) {
    //     fetchMessages(context, payload, done);
    // } else {
    //     debug('dispatching SHOW_CHAT_END');
    //     context.dispatch('SHOW_CHAT_END');
    //     done();
    // }
};
},{"debug":42,"flux-router-component":46,"superagent":119}],4:[function(require,module,exports){
/*jshint node:true */
'use strict';
var debug = require('debug')('mydrive5:showChatAction');
// var MessageStore = require('../stores/MessageStore');
// var openThread = require('../actions/openThread');
var request = require('superagent');
// var csrf = require('superagent-csrf')(request);
var navigateAction = require('flux-router-component').navigateAction;


function signup(context, payload, done) {
    // console.log(context);
    // console.log(window.App.context.plugins.FetchrPlugin.xhrContext._csrf);
    // console.log('payload',payload);
    // var cookie=document.cookie;
    // var token=getCookie('_csrf');
    payload._csrf=window.App.context.plugins.FetchrPlugin.xhrContext._csrf;
    // console.log('token',token);

    var url='/auth/stripe/?'+decodeURIComponent($.param(payload));
    console.log(url);
    window.location.href=url;


    // debug('fetching messages');
    // context.service.create('message', {}, {}, function (err, messages) {
    //     context.dispatch('RECEIVE_MESSAGES', messages);
    //     // context.executeAction(openThread, payload, function() {
    //     //     context.dispatch('SHOW_CHAT_END');
    //     //     done();
    //     // });;
    //     done();
    // });

}

module.exports = function (context, payload, done) {
    // context.dispatch('SHOW_CHAT_START');
    // var messageStore = context.getStore(MessageStore);
    signup(context,payload,done);
    done();
    // if (Object.keys(messageStore.getAll()).length === 0) {
    //     fetchMessages(context, payload, done);
    // } else {
    //     debug('dispatching SHOW_CHAT_END');
    //     context.dispatch('SHOW_CHAT_END');
    //     done();
    // }
};
},{"debug":42,"flux-router-component":46,"superagent":119}],5:[function(require,module,exports){
/*jshint node:true*/

/** @jsx React.DOM */

/*ReadMe:
  Components are where you will be designing your view in the
  render section.  This code is written in jsx; <this.props.activeRouteHandler/>
  is used below for changing views for routing.  

  To add components, you can run react-fullstack:component, and it will create a new component file in the folder.
*/


'use strict';

var React = require('react');

var Fluxible = require('fluxible');
var fetchrPlugin = require('fluxible-plugin-fetchr');
var routrPlugin = require('fluxible-plugin-routr');

var app = new Fluxible({
    appComponent: React.createFactory(require('./components/MyDrive.jsx'))
});

app.plug(fetchrPlugin({
    xhrPath: '/resources'
}));

app.plug(routrPlugin({
    routes: require('./routes/routes')
}));

app.registerStore(require('./stores/ApplicationStore'));
app.registerStore(require('./stores/SessionStore'));



// var AppRoutes=require('./routes.jsx');
// var Router = require('react-router');


var injectTapEventPlugin = require("react-tap-event-plugin");
injectTapEventPlugin();
//Needed for onTouchTap
//Can go away when react 1.0 release
//Check this repo:
//https://github.com/zilverline/react-tap-event-plugin


module.exports = app;



// Router
//   // Runs the router, similiar to the Router.run method. You can think of it as an 
//   // initializer/constructor method.
//   .create({
//     routes: AppRoutes,
//     scrollBehavior: Router.ScrollToTopBehavior
//   })
//   // This is our callback function, whenever the url changes it will be called again. 
//   // Handler: The ReactComponent class that will be rendered  
//   .run(function (Handler) {
//     React.render( <Handler/>, document.body);
//   });
// // module.exports = React.render(routes, document.body);


},{"./components/MyDrive.jsx":6,"./routes/routes":31,"./stores/ApplicationStore":32,"./stores/SessionStore":33,"fluxible":77,"fluxible-plugin-fetchr":52,"fluxible-plugin-routr":66,"react":"react","react-tap-event-plugin":97}],6:[function(require,module,exports){
/*jshint node:true*/
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';
var React = require('react');
var NavBar = require('./layouts/navbar/NavBar.jsx');
var Home = require('./pages/Home.jsx');
var Login = require('./pages/Login.jsx');
var Signup = require('./pages/Signup.jsx');
var SideNav = require('./pages/SideNav.jsx');
var Admin = require('./pages/admin/admin.jsx');
// var About = require('./About.jsx');
// var Page = require('./Page.jsx');
var ApplicationStore = require('../stores/ApplicationStore');
var RouterMixin = require('flux-router-component').RouterMixin;
var FluxibleMixin = require('fluxible').Mixin;

var Application = React.createClass({displayName: "Application",
    mixins: [RouterMixin, FluxibleMixin],
    statics: {
        storeListeners: [ApplicationStore]
    },

    getInitialState: function () {
        return this.getStore(ApplicationStore).getState();
    },
    onChange: function () {
        var state = this.getStore(ApplicationStore).getState();
        this.setState(state);
    },
    render: function () {
        var output = '';
        //choose the right page based on the route
        switch (this.state.currentPageName) {
            case 'home':
                output = React.createElement(Home, null);
                break;
            case 'about':
                output = React.createElement(Login, null);
                break;
            case 'login':
                output = React.createElement(Login, null);
                break;
            case 'signup':
                output = React.createElement(Signup, null);
                break;
            case 'sidenav':
                output = React.createElement(SideNav, null);
                break;
            case 'admin':
                output=React.createElement(Admin, null);
                break;
            default:
                output = React.createElement(Home, null);
                break;
        }
        //render content
        return (
            React.createElement("div", null, 
                React.createElement(NavBar, {selected: this.state.currentPageName, links: this.state.pages}), 
                output
            )
        );
    },

    componentDidUpdate: function(prevProps, prevState) {
        var newState = this.state;
        if (newState.pageTitle === prevState.pageTitle) {
            return;
        }
        document.title = newState.pageTitle;
    }
});

module.exports = Application;

},{"../stores/ApplicationStore":32,"./layouts/navbar/NavBar.jsx":17,"./pages/Home.jsx":19,"./pages/Login.jsx":20,"./pages/SideNav.jsx":21,"./pages/Signup.jsx":22,"./pages/admin/admin.jsx":24,"flux-router-component":46,"fluxible":77,"react":"react"}],7:[function(require,module,exports){
/* jshint node:true */
'use strict';
var React = require('react');

var PopArrow = React.createClass({displayName: "PopArrow",
  render: function () {
    return (
      React.createElement("nav", {className: "nav-circlepop"}, 
        React.createElement("a", React.__spread({},  this.props), 
          React.createElement("span", {className: "icon-wrap"}
          )
        )
      )
    );
  }
});

module.exports = PopArrow;
},{"react":"react"}],8:[function(require,module,exports){
/* jshint node:true */
'use strict';
var React = require('react');

var Mui = require('material-ui');
var Tooltip = Mui.Tooltip;

var HoverTrigger = React.createClass({displayName: "HoverTrigger",
  getInitialState: function() {
    return {hovering: false};
  },
  propTypes: {
    label: React.PropTypes.string.isRequired
  },
  render: function () {
    return (
      React.createElement("div", {onMouseEnter: this._onMouseEnter, onMouseLeave: this._onMouseLeave, className: "tooltip-hover"}, 
        this.props.children, 
        React.createElement(Tooltip, {label: this.props.label, show: this.state.hovering, className: "tooltip-right"})
      )
    );
  },
  _onMouseEnter: function() {
    this.setState({hovering:true});
  },
  _onMouseLeave: function() {
    this.setState({hovering:false});
  }
});

module.exports = HoverTrigger;
},{"material-ui":"material-ui","react":"react"}],9:[function(require,module,exports){
/** @jsx React.DOM */
/* jshint node:true*/


'use strict';

var React = require('react');
var usStates = [
    { name: 'ALABAMA', abbreviation: 'AL'},
    { name: 'ALASKA', abbreviation: 'AK'},
    { name: 'AMERICAN SAMOA', abbreviation: 'AS'},
    { name: 'ARIZONA', abbreviation: 'AZ'},
    { name: 'ARKANSAS', abbreviation: 'AR'},
    { name: 'CALIFORNIA', abbreviation: 'CA'},
    { name: 'COLORADO', abbreviation: 'CO'},
    { name: 'CONNECTICUT', abbreviation: 'CT'},
    { name: 'DELAWARE', abbreviation: 'DE'},
    { name: 'DISTRICT OF COLUMBIA', abbreviation: 'DC'},
    { name: 'FEDERATED STATES OF MICRONESIA', abbreviation: 'FM'},
    { name: 'FLORIDA', abbreviation: 'FL'},
    { name: 'GEORGIA', abbreviation: 'GA'},
    { name: 'GUAM', abbreviation: 'GU'},
    { name: 'HAWAII', abbreviation: 'HI'},
    { name: 'IDAHO', abbreviation: 'ID'},
    { name: 'ILLINOIS', abbreviation: 'IL'},
    { name: 'INDIANA', abbreviation: 'IN'},
    { name: 'IOWA', abbreviation: 'IA'},
    { name: 'KANSAS', abbreviation: 'KS'},
    { name: 'KENTUCKY', abbreviation: 'KY'},
    { name: 'LOUISIANA', abbreviation: 'LA'},
    { name: 'MAINE', abbreviation: 'ME'},
    { name: 'MARSHALL ISLANDS', abbreviation: 'MH'},
    { name: 'MARYLAND', abbreviation: 'MD'},
    { name: 'MASSACHUSETTS', abbreviation: 'MA'},
    { name: 'MICHIGAN', abbreviation: 'MI'},
    { name: 'MINNESOTA', abbreviation: 'MN'},
    { name: 'MISSISSIPPI', abbreviation: 'MS'},
    { name: 'MISSOURI', abbreviation: 'MO'},
    { name: 'MONTANA', abbreviation: 'MT'},
    { name: 'NEBRASKA', abbreviation: 'NE'},
    { name: 'NEVADA', abbreviation: 'NV'},
    { name: 'NEW HAMPSHIRE', abbreviation: 'NH'},
    { name: 'NEW JERSEY', abbreviation: 'NJ'},
    { name: 'NEW MEXICO', abbreviation: 'NM'},
    { name: 'NEW YORK', abbreviation: 'NY'},
    { name: 'NORTH CAROLINA', abbreviation: 'NC'},
    { name: 'NORTH DAKOTA', abbreviation: 'ND'},
    { name: 'NORTHERN MARIANA ISLANDS', abbreviation: 'MP'},
    { name: 'OHIO', abbreviation: 'OH'},
    { name: 'OKLAHOMA', abbreviation: 'OK'},
    { name: 'OREGON', abbreviation: 'OR'},
    { name: 'PALAU', abbreviation: 'PW'},
    { name: 'PENNSYLVANIA', abbreviation: 'PA'},
    { name: 'PUERTO RICO', abbreviation: 'PR'},
    { name: 'RHODE ISLAND', abbreviation: 'RI'},
    { name: 'SOUTH CAROLINA', abbreviation: 'SC'},
    { name: 'SOUTH DAKOTA', abbreviation: 'SD'},
    { name: 'TENNESSEE', abbreviation: 'TN'},
    { name: 'TEXAS', abbreviation: 'TX'},
    { name: 'UTAH', abbreviation: 'UT'},
    { name: 'VERMONT', abbreviation: 'VT'},
    { name: 'VIRGIN ISLANDS', abbreviation: 'VI'},
    { name: 'VIRGINIA', abbreviation: 'VA'},
    { name: 'WASHINGTON', abbreviation: 'WA'},
    { name: 'WEST VIRGINIA', abbreviation: 'WV'},
    { name: 'WISCONSIN', abbreviation: 'WI'},
    { name: 'WYOMING', abbreviation: 'WY' }
];
var STATES  = React.createClass({displayName: "STATES",
  getDefaultProps:function(){

  },
  propTypes:{
    required:React.PropTypes.bool,
    multiple:React.PropTypes.bool,
    selected:React.PropTypes.string,
    value:React.PropTypes.string,
    onChange:React.PropTypes.func
  },
  render: function(){
    var states = usStates.map(function(state){
      return React.createElement("option", {key: state.abbreviation, value: state.abbreviation}, state.name);
    });
    return (
      React.createElement("select", React.__spread({},  this.props), 
        states
      )
    );
  }
});

module.exports = STATES;
},{"react":"react"}],10:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

var STYLE_LOADING = {
  color: 'gray',
  fontFamily: 'sans-serif',
  fontSize: '12px',
  left: 0,
  marginTop: -6,
  position: 'absolute',
  right: 0,
  textAlign: 'center',
  top: '50%',
};

var STYLE_CAPTION = {
  background: 'rgba(16, 16, 16, 0.5)',
  bottom: 0,
  color: 'white',
  fontFamily: 'sans-serif',
  fontSize: '16px',
  lineHeight: '48px',
  left: 0,
  position: 'absolute',
  right: 0,
  textAlign: 'center'
};

var ImageCard = React.createClass({displayName: "ImageCard",
  render: function() {
    var imgStyle = {
      backgroundImage: 'url(' + this.props.url + ')',
      backgroundSize: 'contain',
      backgroundRepeat: 'no-repeat',
      backgroundPosition: 'center',
      height: this.props.height,
      left: 0,
      position: 'absolute',
      top: 0,
      width: this.props.width
    };

    var outerStyle = {
      height: this.props.height,
      position: 'relative',
      width: this.props.width
    };

    // The loading text is composited behind the image so it's hidden
    // when the image is loaded. Normally you'd use Image.onload, but
    // that only tells you when the bytes are ready, not when the paint
    // is done.

    return (
      React.createElement("div", {style: outerStyle}, 
        React.createElement("div", {style: STYLE_LOADING}, "Loading..."), 
        React.createElement("div", {style: imgStyle}, 
          React.createElement("span", {style: STYLE_CAPTION}, this.props.caption)
        )
      )
    );
  }
});

module.exports = ImageCard;
},{"react":"react"}],11:[function(require,module,exports){

/** @jsx React.DOM */

var AnimatableContainer = require('../../primitives/AnimatableContainer.jsx');
var EasingFunctions = require('../../../../../lib/math/easing');
var ImageCard = require('./ImageCard.jsx');
var React = require('react');

var ImageCardContainer = React.createClass({displayName: "ImageCardContainer",
  render: function() {
    var pct = (this.props.left - (this.props.index * this.props.width)) / this.props.width;
    var x = this.props.index * this.props.width - this.props.left;
    var z = Math.abs(pct * 200) * -1;
    var yAxis = this.props.left > this.props.index * this.props.width ? 1 : -1;
    var deg = Math.abs(pct * 69);

    var card = React.createElement(ImageCard, React.__spread({},  this.props));

    return (
      React.createElement(AnimatableContainer, {
        className: "ImageCardContainer", 
        opacity: EasingFunctions.easeOutCubic(1 - Math.abs(pct)), 
        rotate: {y: yAxis, deg: deg}, 
        translate: {x: x, z: z}}, 
        card
      )
    );
  }
});

module.exports = ImageCardContainer;
},{"../../../../../lib/math/easing":35,"../../primitives/AnimatableContainer.jsx":25,"./ImageCard.jsx":10,"react":"react"}],12:[function(require,module,exports){
/** @jsx React.DOM */

// Implicit require of Scroller from Zynga
var ImageCardContainer = require('./ImageCardContainer.jsx');
var React = require('react');

var Scroller = require('scroller').Scroller;

var TouchableArea = require('../../primitives/TouchableArea.jsx');

var PopArrow = require('../../elements/popArrow/PopArrow.jsx');

var Viewer = React.createClass({displayName: "Viewer",
  componentWillMount: function() {
    this.scroller = new Scroller(this.handleScroll, {
      snapping: true
    });
  },

  componentDidMount: function() {
    this.scroller.setDimensions(
      this.props.width,
      this.props.height,
      this.props.width * this.props.images.urls.length,
      this.props.height
    );
    this.scroller.setSnapSize(this.props.width, this.props.height);
  },

  getInitialState: function() {
    return {left: 0};
  },

  // direction-integer
  handleTapRight:function(){
    this.scroller.scrollBy(this.props.width,0,true);
  },
  handleTapLeft:function(){
    this.scroller.scrollBy(this.props.width*-1,0,true);
  },

  handleScroll: function(left, top, zoom) {
    this.setState({left: left});
  },

  render: function() {
    var images = this.props.images.urls.map(function(url, i) {
      if (this.state.left < (i - 1) * this.props.width || this.state.left > (i + 1) * this.props.width) {
        return null;
      }

      // Find the highest resolution image
      return (
        React.createElement(ImageCardContainer, {
          left: this.state.left, 
          key: i, 
          index: i, 
          url: url, 
          width: this.props.width, 
          height: this.props.height, 
          caption: 'LoremPixel photo #' + (i + 1)}
        )
      );
    }, this);

    return (
      React.createElement("div", null, 
        React.createElement(PopArrow, {className: "next", onClick: this.handleTapRight}), 
        React.createElement(PopArrow, {className: "previous", onClick: this.handleTapLeft}), 
        React.createElement(TouchableArea, {
          className: "viewer", 
          style: {width: this.props.width, height: this.props.height}, 
          scroller: this.scroller}, 
          images
        )
      )
    );
  }
});

module.exports = Viewer;
},{"../../elements/popArrow/PopArrow.jsx":7,"../../primitives/TouchableArea.jsx":27,"./ImageCardContainer.jsx":11,"react":"react","scroller":116}],13:[function(require,module,exports){

/*jshint node:true*/

'use strict';
var LeftNavBehaviors = {
  PARALLAX_FADE: {
    side: {
      translate: function(sideWidth, scrollLeft) {
        return {
          x: sideWidth - 0.5 * scrollLeft
        };
      },
      rotate: function() {
        return null;
      },
      opacity: function(sideWidth, scrollLeft) {
        return 0.5 + 0.5 * (1 - scrollLeft / sideWidth);
      }
    },
    top: {
      translate: function(sideWidth, scrollLeft) {
        return {x: sideWidth - scrollLeft};
      },
      rotate: function() {
        return null;
      },
      opacity: function() {
        return null;
      }
    },
    content: {
      translate: function(sideWidth, scrollLeft) {
        return {x: sideWidth - scrollLeft};
      },
      rotate: function() {
        return null;
      },
      opacity: function() {
        return null;
      }
    }
  }
};

module.exports = LeftNavBehaviors;
},{}],14:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

var AnimatableContainer = require('../../primitives/AnimatableContainer.jsx');
var LeftNavBehaviors = require('./LeftNavBehaviors');
var TouchableArea = require('../../primitives/TouchableArea.jsx');
var Scroller = require('../../../environment/Scroller');
var Scroller = require('scroller').Scroller;


var LeftNavContainer = React.createClass({displayName: "LeftNavContainer",
  componentWillMount: function() {
    this.scroller = new Scroller(this._handleScroll, {
      bouncing: false,
      scrollingX: true,
      scrollingY: false,
      snapping: true
    });
  },

  componentDidMount: function() {
    this._measure();
  },

  _measure: function() {
    var node = this.getDOMNode();
    this.scroller.setDimensions(
      node.clientWidth,
      node.clientHeight,
      node.clientWidth + this.props.sideWidth,
      node.clientHeight
    );
    this.scroller.setSnapSize(this.props.sideWidth, node.clientHeight);
    this.scroller.scrollTo(this.props.sideWidth, 0);
  },

  componentDidUpdate: function(prevProps) {
    if (this.props.sideWidth !== prevProps.sideWidth) {
      this._measure();
    }
  },

  closeNav: function() {
    if (this.isNavOpen()) {
      this.scroller.scrollTo(this.props.sideWidth, 0, true);
    }
  },

  _handleScroll: function(left, top, zoom) {
    this.setState({scrollLeft: left});
  },

  getInitialState: function() {
    return {scrollLeft: 0};
  },

  getDefaultProps: function() {
    return {
      behavior: LeftNavBehaviors.PARALLAX_FADE
    };
  },

  _handleTap: function() {
    console.log('hanlde tap');
    if (this.isNavOpen()) {
      this.scroller.scrollTo(this.props.sideWidth, 0, true);
    } else {
      this.scroller.scrollTo(0, 0, true);
    }
  },

  _handleContentTouchTap: function(e) {
    if (!this.isNavOpen()) {
      return;
    }

    this.scroller.scrollTo(this.props.sideWidth, 0, true);
    e.preventDefault();
  },

  isNavOpen: function() {
    return this.state.scrollLeft !== this.props.sideWidth;
  },

  render: function() {
    // props:
    // sideWidth
    // topHeight
    // topContent
    // button
    // sideContent
    // children (big content area)
    var sidebarX = (this.props.sideWidth - this.state.scrollLeft);

    var side = null;

    // TODO: we could do this with style calc
    var sideStyle = {
      bottom: 0,
      left: this.props.sideWidth * -1,
      position: 'absolute',
      top: 0,
      width: this.props.sideWidth
    };

    var behavior = this.props.behavior;

    if (this.isNavOpen()) {
      side = (
        React.createElement(AnimatableContainer, {
          style: sideStyle, 
          translate: behavior.side.translate(this.props.sideWidth, this.state.scrollLeft), 
          rotate: behavior.side.rotate(this.props.sideWidth, this.state.scrollLeft), 
          opacity: behavior.side.opacity(this.props.sideWidth, this.state.scrollLeft)}, 
          this.props.sideContent
        )
      );
    }

    var contentTouchableAreaStyle = {
      bottom: 0,
      left: 0,
      position: 'absolute',
      right: 0,
      top: 0
    };

    var topStyle = {
      height: this.props.topHeight,
      left: 0,
      position: 'absolute',
      right: 0,
      top: 0
    };

    var contentStyle = {
      bottom: 0,
      left: 0,
      position: 'absolute',
      right: 0,
      top: this.props.topHeight
    };

    return(
      React.createElement("div", React.__spread({},  this.props), 
        side, 
        React.createElement(AnimatableContainer, {
          style: contentStyle, 
          translate: behavior.content.translate(this.props.sideWidth, this.state.scrollLeft), 
          rotate: behavior.content.rotate(this.props.sideWidth, this.state.scrollLeft), 
          opacity: behavior.content.opacity(this.props.sideWidth, this.state.scrollLeft)}, 
          React.createElement(TouchableArea, {
            style: contentTouchableAreaStyle, 
            scroller: this.scroller, 
            touchable: this.isNavOpen(), 
            onClick: this._handleContentTouchTap
            }, 
            this.props.children
          )
        ), 
        React.createElement(AnimatableContainer, {
          style: topStyle, 
          translate: behavior.top.translate(this.props.sideWidth, this.state.scrollLeft), 
          rotate: behavior.top.rotate(this.props.sideWidth, this.state.scrollLeft), 
          opacity: behavior.top.opacity(this.props.sideWidth, this.state.scrollLeft)}, 
          React.createElement(TouchableArea, {
            onClick: this._handleTap, 
            scroller: this.scroller, 
            touchable: true
            }, 
            this.props.button
          ), 
          this.props.topContent
        )
      )
    );
  }
});

module.exports = LeftNavContainer;
},{"../../../environment/Scroller":29,"../../primitives/AnimatableContainer.jsx":25,"../../primitives/TouchableArea.jsx":27,"./LeftNavBehaviors":13,"react":"react","scroller":116}],15:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

var AnimatableContainer = require('../../primitives/AnimatableContainer.jsx');
var TouchableArea = require('../../primitives/TouchableArea.jsx');
var Scroller = require('scroller').Scroller;

var ANIMATABLE_CONTAINER_STYLE = {
  bottom: 0,
  left: 0,
  position: 'absolute',
  right: 0,
  top: 0
};

var SimpleScroller = React.createClass({displayName: "SimpleScroller",
  getInitialState: function() {
    return {left: 0, top: 0};
  },

  componentWillMount: function() {
    this.scroller = new Scroller(this.handleScroll, this.props.options);
    this.configured = false;
  },

  componentDidMount: function() {
    this.configure();
  },

  componentDidUpdate: function() {
    this.configure();
  },

  configure: function() {
    if (this.configured) {
      return;
    }
    this.configured = true;
    var node = this.refs.content.getDOMNode();
    this.scroller.setDimensions(
      this.getDOMNode().clientWidth,
      this.getDOMNode().clientHeight,
      node.clientWidth,
      node.clientHeight
    );
  },

  handleScroll: function(left, top) {
    // TODO: zoom
    this.setState({
      left: left,
      top: top
    });
  },

  render: function() {
    return(
      React.createElement(TouchableArea, React.__spread({},  this.props, {scroller: this.scroller, style: {overflow: 'hidden'}}), 
        React.createElement(AnimatableContainer, {
          translate: {x: -1 * this.state.left, y: -1 * this.state.top}, 
          style: ANIMATABLE_CONTAINER_STYLE}, 
          React.createElement("div", {ref: "content"}, this.props.children)
        )
      )
    );
  }
});

module.exports = SimpleScroller;
},{"../../primitives/AnimatableContainer.jsx":25,"../../primitives/TouchableArea.jsx":27,"react":"react","scroller":116}],16:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

// var App = require('react-touch/lib/primitives/App');
// var RoutedLink = require('react-touch/lib/routing/RoutedLink');
// var Header = require('../components/Header');
var LeftNavContainer = require('../interactives/leftNav/LeftNavContainer.jsx');


// Keep in sync with Layout.css
// TODO: deprecate the CSS standard
var SIDEBAR_WIDTH = 192;
var TOPBAR_HEIGHT = 51; // + 1 for the border

var Layout = React.createClass({displayName: "Layout",
  handleNavClick: function() {
    this.refs.LeftNavContainer.closeNav();
  },

  render: function() {
    var STYLE = {
      bottom: 0,
      left: 0,
      overflow: 'hidden',
      position: 'fixed',
      right: 0,
      top: 0
    };
    var button = (
      React.createElement("div", {className: "Layout-hamburger fa fa-bars"})
    );

    var topContent = (
      React.createElement("h1", {className: "Layout-topBar"}, "React touch demos")
    );

    var sideContent = (
      React.createElement("div", {className: "Layout-nav"}, 
        React.createElement("a", {className: "Layout-navLink"}, "asdlfkj"), 
        React.createElement("a", {className: "Layout-navLink"}, "asdlfkj"), 
        React.createElement("a", {className: "Layout-navLink"}, "asdlfkj"), 
        React.createElement("a", {className: "Layout-navLink"}, "asdlfkj"), 
        React.createElement("a", {className: "Layout-navLink"}, "asdlfkj")
      )
    );
        // <RoutedLink href="/home" className="Layout-navLink" onClick={this.handleNavClick}>Home</RoutedLink>
        // <RoutedLink href="/scroll" className="Layout-navLink" onClick={this.handleNavClick}>Simple scroll</RoutedLink>
        // <RoutedLink href="/glass" className="Layout-navLink" onClick={this.handleNavClick}>Frosted glass</RoutedLink>
        // <RoutedLink href="/viewer" className="Layout-lastNavLink" onClick={this.handleNavClick}>Photo gallery</RoutedLink>

    return(
      React.createElement("div", {style: STYLE}, 
        React.createElement(LeftNavContainer, {
          ref: "leftNavContainer", 
          button: button, 
          topContent: topContent, 
          sideContent: sideContent, 
          topHeight: TOPBAR_HEIGHT, 
          sideWidth: SIDEBAR_WIDTH}, 
          React.createElement("div", {className: "Layout-content"}, 
            this.props.children
          )
        )
      )
    );
  }
});

Layout.TOPBAR_HEIGHT = TOPBAR_HEIGHT; // account for border

module.exports = Layout;
},{"../interactives/leftNav/LeftNavContainer.jsx":14,"react":"react"}],17:[function(require,module,exports){
/** @jsx React.DOM */
/* jshint node:true*/

'use strict';
var React = require('react');
var NavLink = require('flux-router-component').NavLink;

var SessionStore=require('../../../stores/SessionStore');
var ApplicationStore=require('../../../stores/ApplicationStore');

var mui = require('material-ui');
var Toolbar = mui.Toolbar;
var ToolbarGroup = mui.ToolbarGroup;
var AppBar=mui.AppBar;
var DropDownIcon = mui.DropDownIcon;

// var Bootstrap=require('react-bootstrap');

var FluxibleMixin = require('fluxible').Mixin;
// var Nav=Bootstrap.Nav;
// var Navbar = Bootstrap.Navbar;
// var NavItem = Bootstrap.NavItem;
// var DropdownButton = Bootstrap.DropdownButton;
// var MenuItem = Bootstrap.MenuItem;

var NavLink = require('flux-router-component').NavLink;

var NavInstance = React.createClass({displayName: "NavInstance",

  mixins: [FluxibleMixin],
  statics: {
    storeListeners: [SessionStore,ApplicationStore]
  },

  getInitialState: function() {
      return this.getStateFromStores();
  },

  getStateFromStores: function () {
    return {
      currentUser: this.getStore(SessionStore).getCurrentUser(),
      title:this.getStore(ApplicationStore).getPageTitle()
    };
  },
  /**
   * Event handler for 'change' events coming from the stores
   */
  onChange: function() {
    this.setState(this.getStateFromStores());
  },

  getDefaultProps: function () {
    return {
      selected: 'home',
      links: {}
    };
  },
  isActive:function(name){
    if(name===this.props.selected){
      return 'active';
    }
    return null;
  },
  render: function() {
    var selected = this.props.selected,
      links = this.props.links,
      context = this.props.contex;

    var iconMenuItems = [
      { payload: '1', text: 'Download' },
      { payload: '2', text: 'More Info' }
    ];
    var NavbarHeaderStyle={
      float:'right'
    };

    var navbarRight=null;
    if(typeof this.state.currentUser._id ==='undefined'){
      navbarRight=(
        React.createElement("ul", {className: "nav navbar-nav navbar-right"}, 
          React.createElement("li", {className: this.isActive(links.login.page)}, React.createElement(NavLink, {routeName: links.login.page, label: "login"}, "Login")), 
          React.createElement("li", {className: this.isActive(links.signup.page)}, React.createElement(NavLink, {routeName: links.signup.page, label: "login"}, "Signup"))
        )
        );
    }else{
      navbarRight=(
        React.createElement("ul", {className: "nav navbar-nav navbar-right"}, 
          React.createElement("li", null, React.createElement("span", {className: "navbar-text"}, "Welcome ", this.state.currentUser.name)), 
          React.createElement("li", null, React.createElement(NavLink, {routeName: links.login.page, label: "logout"}, "Logout"))
        )
        );
    }

    var NavbarHeader=(
      React.createElement("div", {className: "navbar-header", style: NavbarHeaderStyle}, 
        React.createElement(NavLink, {routeName: links.home.page, className: "navbar-brand navbar-brand-left"}, 
          "MyDrive5"
        )
      )
    );
    return(
      React.createElement("nav", {className: "navbar navbar-inverse navbar-static-top"}, 
        React.createElement("div", {className: "container"}, 
          React.createElement("div", {className: "navbar-header"}, 
            React.createElement("button", {type: "button", className: "navbar-toggle collapsed", "data-toggle": "collapse", "data-target": "#navbar", "aria-expanded": "false", "aria-controls": "navbar"}, 
              React.createElement("span", {className: "sr-only"}, "Toggle navigation"), 
              React.createElement("span", {className: "icon-bar"}), 
              React.createElement("span", {className: "icon-bar"}), 
              React.createElement("span", {className: "icon-bar"})
            ), 
            React.createElement(NavLink, {className: "navbar-brand", routeName: links.admin.home, href: "/"}, "MyDrive5")
          ), 
          React.createElement("div", {className: "navbar-title"}, 
            this.state.title
          ), 
          React.createElement("div", {id: "navbar", className: "navbar-collapse collapse"}, 
            React.createElement("ul", {className: "nav navbar-nav"}, 
              React.createElement("li", {className: this.isActive(links.admin.page)}, React.createElement(NavLink, {routeName: links.admin.page}, "Admin"))
            ), 
            navbarRight
          )
        )
      )

      );
    // return (
    //  <Navbar className="navbar-inverse navbar-static-top">
    //     {NavbarHeader}
    //     <Nav className="navbar-right">
    //       <DropdownButton eventKey={3} title={userIcon}>
    //         <MenuItem eventKey="1">Action</MenuItem>
    //         <MenuItem eventKey="2">Another action</MenuItem>
    //         <MenuItem eventKey="3">Something else here</MenuItem>
    //         <MenuItem divider />
    //         <MenuItem eventKey="4">Separated link</MenuItem>
    //       </DropdownButton>
    //       <NavItem eventKey={1} href={links.login.path}>
    //         Login
    //       </NavItem>
    //       <NavItem eventKey={2} href="#">Register</NavItem>
    //     </Nav>
    //   </Navbar>
    // );
  }
});

module.exports = NavInstance;
},{"../../../stores/ApplicationStore":32,"../../../stores/SessionStore":33,"flux-router-component":46,"fluxible":77,"material-ui":"material-ui","react":"react"}],18:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

var Images = require('../../../assets/Images');
var NAVBAR_HEIGHT = require('../../constants/AppConstants').NAVBAR_HEIGHT;
var Viewer = require('../interactives/imageCard/Viewer.jsx');

var NUM_IMAGES = 10;

var START_INDEX = 5;

var GalleryPage = React.createClass({displayName: "GalleryPage",
  getInitialState: function() {
    return {width: 0, height: 0};
  },

  getUsername: function() {
    return this.props.routeParams[0] || 'JustinBieber';
  },

  componentDidMount: function() {
    window.addEventListener("resize", this.setDimensions);
    this.setDimensions();
  },

  setDimensions:function(){
    this.setState({
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    });
  },

  render: function() {
    if (!this.state.width || !this.state.height) {
      return React.createElement("span", null, "Loading...");
    }

    return (
      React.createElement(Viewer, {
        width: this.state.width, 
        height: this.state.height - NAVBAR_HEIGHT, 
        images: Images}
      )
    );
  }
});

module.exports = GalleryPage;
},{"../../../assets/Images":34,"../../constants/AppConstants":28,"../interactives/imageCard/Viewer.jsx":12,"react":"react"}],19:[function(require,module,exports){
/*jshint node:true*/
'use strict';
var React = require('react');

var Home = React.createClass({displayName: "Home",
    getInitialState: function () {
        return {};
    },
    render: function() {
        return (
            React.createElement("p", null, "Welcome to the site!")
        );
    }
});

module.exports = Home;
},{"react":"react"}],20:[function(require,module,exports){
/** @jsx React.DOM */
/* jshint node:true*/


'use strict';

var React = require('react');

// var AppStore = require('../stores/AppStore');
var LoginAction = require('../../actions/authentication/LoginActions');

var FluxibleMixin = require('fluxible').Mixin;

// var NAV = require('./NavBar.jsx');
// var BANNER = require('./Banner.jsx');

var mui=require('material-ui');
var RaisedButton=mui.RaisedButton;
var TextField=mui.TextField;

var TooltipHover = require('../elements/toolTipHover.jsx');


var LOGIN  = React.createClass({displayName: "LOGIN",
  mixins:[FluxibleMixin],

  getInitialState:function(){
    return {email:'',password:''};
  },

  handleSubmit: function(e){
    e.preventDefault();
    this.executeAction(LoginAction,this.state);
  },

  handleInput: function(e) {
    console.log("at handleInput in Login");
  },

  _onPasswordChange:function(event){
    this.setState({password:event.target.value});
  },

  _onEmailChange:function(event){
    this.setState({email:event.target.value});
  },
  
  render: function(){
    return (
      React.createElement("div", {className: "login-page"}, 
        React.createElement("form", null, 
          React.createElement("input", {
            floatingLabelText: "email", 
            value: this.state.email, 
            onChange: this._onEmailChange, 
            hintText: "email"}), 
          React.createElement("input", {
            floatingLabelText: "password", 
            hintText: "password", 
            onChange: this._onPasswordChange, 
            value: this.state.password, 
            type: "password"}), 
          React.createElement(RaisedButton, {secondary: true, label: "login", onClick: this.handleSubmit})
        )
      )
      // <div>
      //   <div className="container">
      //     <h1>Login</h1>
      //       <form className="form-horizontal" role="form">
      //         <div className="form-group">
      //           <label for="inputEmail3" className="control-label" >Email</label>
      //           <div className="container">
      //             <input type="email" className="form-control" id="inputEmail3" placeholder="Email" onKeyPress={this.handleInput}/>
      //           </div>
      //         </div>
      //         <div className="form-group">
      //           <label for="inputPassword3" className="control-label">Password</label>
      //           <div className="container">
      //             <input type="password" className="form-control" id="inputPassword3" placeholder="Password" onKeyPress={this.handleInput}/>
      //           </div>
      //         </div>
      //         <div className="form-group">
      //           <div>
      //             <div className="checkbox">
      //               <label>
      //                 <input type="checkbox"/> Remember me
      //               </label>
      //             </div>
      //           </div>
      //         </div>
      //         <div className="form-group">
      //           <div className="control-button">
      //             <button type="submit" className="btn btn-default" onClick={this.handleClick} >Sign in</button>
      //           </div>
      //         </div>
      //       </form>
      //   </div>
      // </div>
      );
  }
});

module.exports = LOGIN;

},{"../../actions/authentication/LoginActions":3,"../elements/toolTipHover.jsx":8,"fluxible":77,"material-ui":"material-ui","react":"react"}],21:[function(require,module,exports){
// /** @jsx React.DOM */
/*jshint node:true*/

// 'use strict';

// var React = require('react');

// // var AppStore = require('../stores/AppStore');
// // var AppActions = require('../actions/AppActions');

// // var NAV = require('./NavBar.jsx');
// // var BANNER = require('./Banner.jsx');

'use strict';
var React = require('react');

var SideNav = require('../layouts/SideNav.jsx');
var ImageGallery = require('./GalleryPage.jsx');
var SimpleScroll = require('./SimpleScroll.jsx');


var Signup = React.createClass({displayName: "Signup",
    getInitialState: function () {
        return {};
    },
    render: function() {
        return (
            React.createElement(SideNav, null, 
                React.createElement("div", null, 
                    React.createElement(ImageGallery, null)
                )
            )
        );
    }
});

module.exports = Signup;
},{"../layouts/SideNav.jsx":16,"./GalleryPage.jsx":18,"./SimpleScroll.jsx":23,"react":"react"}],22:[function(require,module,exports){
// /** @jsx React.DOM */
/*jshint node:true*/

// 'use strict';

// var React = require('react');

// // var AppStore = require('../stores/AppStore');
// // var AppActions = require('../actions/AppActions');

// // var NAV = require('./NavBar.jsx');
// // var BANNER = require('./Banner.jsx');

'use strict';
var React = require('react');

var mui = require('material-ui');
var TextField = mui.TextField;
var Tooltip = mui.Tooltip;
var RaisedButton = mui.RaisedButton;
var StatesSelect = require('../../components/forms/address/states.jsx');
var FluxibleMixin = require('fluxible').Mixin;

var SignupAction = require('../../actions/authentication/SignupAction');

var Signup = React.createClass({displayName: "Signup",
  mixins:[FluxibleMixin],

  getInitialState: function () {
    return {
      email:'pgruenbacher@gmail.com',
      firstName:'paul',
      lastName:'gruen',
      phoneNumber:'(513) 319-8238',
      dob: '05/08/1990',
      businessName:'something name',
      productDescription:'description description',
      businessType:'sole_prop',
      zip:45014,
      streetAddress:'1867 Harrowgate',
      state:'OH',
      city:'fairfield'
    };
  },
  handleChange:function(value){
    var self=this;
    return function(event){
      var obj={};
      obj[value]=event.target.value;
      self.setState(obj);
    };
  },
  handleSubmit:function(e){
    e.preventDefault();
    var obj=this.state;
    obj.phoneNumber=this.state.phoneNumber.replace(/\D/g,'');

    console.log(this.state.dob.split('/'));
    this.executeAction(SignupAction,obj);
  },
  render: function() {
    return (
      React.createElement("div", null, 
        React.createElement("form", null, 
          React.createElement("div", {style: {width:'450px',margin:'40px',display:'inline-block'}}, 
            React.createElement(TextField, {
              floatingLabelText: "email", 
              value: this.state.email, 
              onChange: this.handleChange('email'), 
              hintText: "email"}), 
            React.createElement(TextField, {
              floatingLabelText: "firstName", 
              value: this.state.firstName, 
              onChange: this.handleChange('firstName'), 
              hintText: "firstName"}), 
            React.createElement(TextField, {
              floatingLabelText: "lastName", 
              value: this.state.lastName, 
              onChange: this.handleChange('lastName'), 
              hintText: "lastName"}), 
            React.createElement(TextField, {
              floatingLabelText: "phoneNumber", 
              value: this.state.phoneNumber, 
              onChange: this.handleChange('phoneNumber'), 
              hintText: "phoneNumber"}), 
            React.createElement(TextField, {
              floatingLabelText: "dob", 
              value: this.state.dob, 
              onChange: this.handleChange('dob'), 
              hintText: "dob"})
          ), 
          React.createElement("div", {style: {width:'450px',margin:'40px',display:'inline-block'}}, 
            React.createElement(TextField, {
              floatingLabelText: "businessName", 
              value: this.state.businessName, 
              onChange: this.handleChange('businessName'), 
              hintText: "businessName"}), 
            React.createElement(TextField, {
              value: this.state.productDescription, 
              multiLine: true, 
              onChange: this.handleChange('productDescription'), 
              hintText: "productDescription"}), 
            React.createElement(TextField, {
              floatingLabelText: "businessType", 
              value: this.state.businessType, 
              onChange: this.handleChange('businessType'), 
              hintText: "businessType"}), 
            React.createElement(TextField, {
              floatingLabelText: "streetAddress", 
              value: this.state.streetAddress, 
              onChange: this.handleChange('streetAddress'), 
              hintText: "streetAddress"}), 
            React.createElement(TextField, {
              floatingLabelText: "city", 
              value: this.state.city, 
              onChange: this.handleChange('city'), 
              hintText: "city"}), 
            React.createElement(StatesSelect, {
              value: this.state.state, 
              onChange: this.handleChange('state')}), 
            React.createElement(TextField, {
              floatingLabelText: "zip", 
              value: this.state.zip, 
              onChange: this.handleChange('zip'), 
              hintText: "zip"})
          ), 
          React.createElement(RaisedButton, {
            onClick: this.handleSubmit, 
            secondary: true, 
            label: "submit"})
        )
      )
    );
  }
});

module.exports = Signup;
},{"../../actions/authentication/SignupAction":4,"../../components/forms/address/states.jsx":9,"fluxible":77,"material-ui":"material-ui","react":"react"}],23:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

var SimpleScroller =  require('../interactives/simpleScroller/SimpleScroller.jsx');

var ScrollPage = React.createClass({displayName: "ScrollPage",
  render: function() {
    var content = [];

    for (var i = 0; i < 100; i++) {
      content.push(React.createElement("p", {key: i}, "Item ", i));
    }

    return (
      React.createElement(SimpleScroller, {className: "ScrollPage", options: {scrollingX: false}}, 
        React.createElement("div", {className: "ScrollPage-content"}, content)
      )
    );
  }
});

module.exports = ScrollPage;
},{"../interactives/simpleScroller/SimpleScroller.jsx":15,"react":"react"}],24:[function(require,module,exports){
// /** @jsx React.DOM */
/*jshint node:true*/

// 'use strict';

// var React = require('react');

// // var AppStore = require('../stores/AppStore');
// // var AppActions = require('../actions/AppActions');

// // var NAV = require('./NavBar.jsx');
// // var BANNER = require('./Banner.jsx');

'use strict';
var React = require('react');

var mui = require('material-ui');
var TextField = mui.TextField;
var Tooltip = mui.Tooltip;
var RaisedButton = mui.RaisedButton;
var FluxibleMixin = require('fluxible').Mixin;

var AdminPage = React.createClass({displayName: "AdminPage",
  mixins:[FluxibleMixin],

  getInitialState: function () {
    return {};
  },
  handleChange:function(e){
  },
  handleSubmit:function(e){
  },
  render: function() {
    return (
      React.createElement("div", null, 
        "Admin!"
      )
    );
  }
});

module.exports = AdminPage;
},{"fluxible":77,"material-ui":"material-ui","react":"react"}],25:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

var StaticContainer = require('./StaticContainer.jsx');
var StyleKeys = require('../../environment/StyleKeys');

var POLL_FACTOR = 0.5;

var AnimatableContainer = React.createClass({
  displayName: 'AnimatableContainer',

  getDefaultProps: function() {
    return {
      blockUpdates: true,
      opacity: 1,
      rotate: null,
      scale: null,
      timeout: 200,
      translate: null
    };
  },

  componentWillMount: function() {
    this.wasEverOnGPU = false;
    this.isAnimating = false;
    this.lastAnimationTime = 0;
    this.animationInterval = null;
  },

  componentWillUnmount: function() {
    if (this.animationInterval) {
      window.clearInterval(this.animationInterval);
    }
  },

  componentWillReceiveProps: function(nextProps) {
    var prevStyle = this.getStyle(this.props);
    var style = this.getStyle(nextProps);

    this.isAnimating = (
      style.opacity !== prevStyle.opacity ||
      style[StyleKeys.TRANSFORM] !== prevStyle[StyleKeys.TRANSFORM]
    );

    if (this.isAnimating) {
      this.lastAnimationTime = Date.now();
      if (this.props.timeout && !this.animationInterval) {
        this.animationInterval = window.setInterval(
          this.checkAnimationEnd,
          this.props.timeout * POLL_FACTOR
        );
      }
    }
  },

  checkAnimationEnd: function() {
    if (Date.now() - this.lastAnimationTime > this.props.timeout) {
      window.clearInterval(this.animationInterval);
      this.animationInterval = null;
      this.isAnimating = false;
      this.forceUpdate();
    }
  },

  getStyle: function(props) {
    var style = {};

    if (this.props.style) {
      for (var key in this.props.style) {
        style[key] = this.props.style[key];
      }
    }

    var transforms = '';
    if (props.opacity !== 1) {
      style.opacity = props.opacity;
    }

    if (props.translate) {
      transforms += (
        'translate3d(' + (props.translate.x || 0) + 'px, ' +
        (props.translate.y || 0) + 'px, ' +
        (props.translate.z || 0) + 'px) '
      );
    }

    if (props.rotate) {
      transforms += (
        'rotate3d(' + (props.rotate.x || 0) + ', ' +
        (props.rotate.y || 0) + ', ' +
        (props.rotate.z || 0) + ', ' +
        props.rotate.deg + 'deg) '
      );
    }

    if (props.scale) {
      transforms += 'scale(' + props.scale + ') ';
    }

    if (transforms.length > 0) {
      style[StyleKeys.TRANSFORM] = transforms;
      this.wasEverOnGPU = true;
    } else {
      if (this.wasEverOnGPU) {
        // on iOS when you go from translate3d to non-translate3d you get
        // flicker. Let's avoid it
        style[StyleKeys.TRANSFORM] = 'translate3d(0, 0, 0)';
      }
    }

    return style;
  },

  render: function() {

    return (
      React.createElement("div", {className: this.props.className, style: this.getStyle(this.props)}, 
        React.createElement(StaticContainer, {shouldUpdate: !this.props.blockUpdates || !this.isAnimating}, 
          React.createElement("span", null, 
            this.props.children
          )
        )
      )
    );
  }
});

module.exports = AnimatableContainer;
},{"../../environment/StyleKeys":30,"./StaticContainer.jsx":26,"react":"react"}],26:[function(require,module,exports){
/** @jsx React.DOM */

var React = require('react');

var StaticContainer = React.createClass({displayName: "StaticContainer",
  getDefaultProps: function() {
    return {shouldUpdate: false};
  },

  shouldComponentUpdate: function(nextProps) {
    return nextProps.shouldUpdate || (this.props.staticKey !== nextProps.staticKey);
  },

  render: function() {
    return this.props.children;
  }
});

module.exports = StaticContainer;
},{"react":"react"}],27:[function(require,module,exports){
/** @jsx React.DOM */
/*jshint node:true*/
'use strict';

var React = require('react');
React.initializeTouchEvents(true);
var TouchableArea = React.createClass({displayName: "TouchableArea",
  getDefaultProps: function() {
    return {
      touchable: true
    };
  },

  handleTouchStart: function(e) {
    if (!this.props.scroller || !this.props.touchable) {
      return;
    }

    this.props.scroller.doTouchStart(e.touches, e.timeStamp);
    e.preventDefault();
  },


  handleTouchMove: function(e) {
    if (!this.props.scroller || !this.props.touchable) {
      return;
    }
    this.props.scroller.doTouchMove(e.touches, e.timeStamp, e.scale);
    e.preventDefault();
  },

  handleTouchEnd: function(e) {
    if (!this.props.scroller || !this.props.touchable) {
      return;
    }
    this.props.scroller.doTouchEnd(e.timeStamp);
    e.preventDefault();
  },

  render: function() {
    return(
      React.createElement("div", React.__spread({}, 
        this.props, 
        {onTouchStart: this.handleTouchStart, 
        onTouchMove: this.handleTouchMove, 
        onTouchEnd: this.handleTouchEnd, 
        onTouchCancel: this.handleTouchEnd}), 
        this.props.children
      )
    );
  }
});

module.exports = TouchableArea;
},{"react":"react"}],28:[function(require,module,exports){
/*jshint node:true*/
'use strict';

module.exports={
  NAVBAR_HEIGHT:50

};

},{}],29:[function(require,module,exports){
if(typeof window ==='undefined'){
  Scroller = {};
}else{
  Scroller = window.Scroller;
}

module.exports = Scroller;
},{}],30:[function(require,module,exports){
if(typeof document !=='undefined'){
  var TRANSFORM_KEY = typeof document.body.style.MozTransform !== 'undefined' ? 'MozTransform' : 'WebkitTransform';
  var FILTER_KEY = typeof document.body.style.MozFilter !== 'undefined' ? 'MozFilter' : 'WebkitFilter';
}

module.exports = {
  TRANSFORM: TRANSFORM_KEY,
  FILTER: FILTER_KEY
};
},{}],31:[function(require,module,exports){
var showChat = require('../actions/MessageActions');
// var openThread = require('../actions/openThread');
// var NavActions = require('../actions/NavActions.js');

module.exports = {
    home: {
        path: '/',
        method: 'get',
        page: 'home',
        label: 'Home',

        action: function (context, payload, done) {
            context.dispatch('UPDATE_PAGE_TITLE', { pageTitle: 'Home' });
            done();
        }
    },
    about: {
        path: '/about',
        method: 'get',
        page: 'about',
        label: 'About',
        action: function (context, payload, done) {
            context.dispatch('UPDATE_PAGE_TITLE', { pageTitle: 'About' });
            done();
        }
    },
    login: {
        path: '/login',
        method: 'get',
        page: 'login',
        label: 'Login',
        action: function (context, payload, done) {
            context.dispatch('UPDATE_PAGE_TITLE', { pageTitle: 'Login' });
            done();
        }
    },
    signup:{
        path:'/signup',
        method:'get',
        page:'signup',
        label:'Signup',
        action:function(context,payload,done){
            context.dispatch('UPDATE_PAGE_TITLE',{pageTitle:'Signup'});
            done();
        }
    },
    sidenav:{
        path:'/sidenav',
        method:'get',
        page:'sidenav',
        label:'SideNav',
        action:function(context,payload,done){
            context.dispatch('UPDATE_PAGE_TITLE',{pageTItle:'SideNav'});
            done();
        }
    },
    admin:{
        path:'/admin',
        method:'get',
        page:'admin',
        label:'Admin',
        auth:{
            roles:['admin']
        },
        action:function(context,payload,done){
            context.dispatch('UPDATE_PAGE_TITLE',{pageTitle:'Admin'});
            done();
        }
    }
    // dynamicpage: {
    //     path: '/page/:id',
    //     method: 'get',
    //     page: 'page',
    //     action: function (context, payload, done) {
    //         context.dispatch('LOAD_PAGE', { id: payload.params.id });
    //         context.dispatch('UPDATE_PAGE_TITLE', { pageTitle: payload.params.id + ' [Dynamic Page] | flux-examples | routing' });
    //         done();
    //     }
    // }
};
},{"../actions/MessageActions":2}],32:[function(require,module,exports){
/*jshint node:true*/
'use strict';
var createStore = require('fluxible/utils/createStore');
var SessionStore = require('./SessionStore');

var routesConfig= require('../routes/routes');

var ApplicationStore = createStore({
    storeName: 'ApplicationStore',
    handlers: {
        'SET_USER' : 'handleUser',
        'CHANGE_ROUTE_SUCCESS' : 'handleNavigate',
        'UPDATE_PAGE_TITLE'    : 'updatePageTitle'
    },
    initialize: function (dispatcher) {
        this.currentPageName = null;
        this.currentPage = null;
        this.currentRoute = null;
        this.pages = routesConfig;
        this.pageTitle = '';
        this.currentUser= {};
    },
    handleUser: function (user) {
        this.currentUser = user;
        this.emitChange();
    },
    checkPermission:function(route){
        var config = route.config;
        // var user = SessionStore.getCurrentUser();
        if(typeof config.auth!=='undefined'){
            if(typeof config.auth.roles!=='undefined'){
                if(typeof this.currentUser.role==='undefined'){
                    return false;
                }else if(config.auth.roles.indexOf(this.currentUser.role) ===-1){
                    return false;
                }
            }
        }
        return true;
    },
    handleNavigate: function (route) {
        if (this.currentRoute && (this.currentRoute.url === route.url)) {
            return;
        }
        if(!this.checkPermission(route)){
            return;
        }
        var pageName = route.config.page;
        var page = this.pages[pageName];

        this.currentPageName = pageName;
        this.currentPage = page;
        this.currentRoute = route;
        this.emitChange();
    },
    updatePageTitle: function (title) {
        this.pageTitle = title.pageTitle;
        this.emitChange();
    },
    getCurrentPageName: function () {
        return this.currentPageName;
    },
    getPageTitle: function () {
        return this.pageTitle;
    },
    getState: function () {
        return {
            currentPageName: this.currentPageName,
            currentPage: this.currentPage,
            pages: this.pages,
            route: this.currentRoute,
            pageTitle: this.pageTitle
        };
    },
    dehydrate: function () {
        return this.getState();
    },
    rehydrate: function (state) {
        this.currentPageName = state.currentPageName;
        this.currentPage = state.currentPage;
        this.pages = state.pages;
        this.currentRoute = state.route;
        this.pageTitle = state.pageTitle;
    }
});


module.exports = ApplicationStore;
},{"../routes/routes":31,"./SessionStore":33,"fluxible/utils/createStore":91}],33:[function(require,module,exports){
/*jshint node:true*/
'use strict';
var createStore = require('fluxible/utils/createStore');
var cookie = require('cookies-js');


var SessionStore = createStore({
    storeName: 'SessionStore',
    handlers: {
        'SET_USER' : 'handleUser',
        'SET_TOKEN':'handleToken'
    },
    initialize: function (dispatcher) {
        this.currentUser={};
        if(typeof window !=='undefined'){
            this.token=cookie.get('token');
        }else{
            this.token=null;
        }
    },
    handleUser: function (user) {
        this.currentUser = user;
        this.emitChange();
    },
    handleToken:function(token){
        cookie('token',token);
        this.token = token;
        this.emitChange();
    },
    updatePageTitle: function (title) {
        this.pageTitle = title.pageTitle;
        this.emitChange();
    },
    getCurrentUser: function () {
        return this.currentUser;
    },
    getState: function () {
        return {
            token:this.token,
            curentUser:this.currentUser
        };
    },
    dehydrate: function () {
        return this.getState();
    },
    rehydrate: function (state) {
        this.token = state.token;
        this.currentUser = state.currentUser;
    }
});


module.exports = SessionStore;
},{"cookies-js":41,"fluxible/utils/createStore":91}],34:[function(require,module,exports){
module.exports.urls = ["data:image/jpeg;base64,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", "data:image/jpeg;base64,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", "data:image/jpeg;base64,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", "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD//gA+Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBkZWZhdWx0IHF1YWxpdHkK/9sAQwAIBgYHBgUIBwcHCQkICgwUDQwLCwwZEhMPFB0aHx4dGhwcICQuJyAiLCMcHCg3KSwwMTQ0NB8nOT04MjwuMzQy/9sAQwEJCQkMCwwYDQ0YMiEcITIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy/8AAEQgBmgFAAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A6HbRsFT7KTZ6V9RzGHKQlOKTZU+w0oSjmDlKvlZ7UvlAVZ2UhQUcwchWKelRNHnrV3ZmmlKakDiUTCDQIR6Vb8ulEftVe0J5Cr5A9KcsA9KuLEx7VIIAOtS6haplMQgdqQxVcaPFMMZqecrkKTRA1EYR2FaPk5pfJAqvaC9mZn2Yntij7MBWiyY7Uwx5o9ow9mjOMHoKT7LnqK0RD60FAvan7QPZoz/s4UdKFt16kZq2wzSbeKfOx8iKF3FuXAFZz2zVtMMmoWQZ6VcajSM5003cw7i3P2WfP/PNv5V5TdocAtjjHH517TcoBazf9c2/lXjfl+akzbQQuGye1eDnEryizejDlR1tnEr6Lbk8NGQc+uRXSywHceKwdHi8zSozu6bG57/IM110gGc4rLh+TTn/AF3NcbFNRMo25PamG2OcmtIgVGwr6lTZ5jpozjbZqM25rQYYqJqtTZDgiiYOOlQtD7VebFROfQVakyHFFIxe1RmHParbGomJq02ZuKKphFRtDzzVpmqNziqTZm4orGP2phj79KnZvQVEzetUmxWR7T5ZJ6U4QjvU1G0189zHvcpEUHYU3y81NinBCelHMPlIPLAGAKb5easFWHagIT2o5h8pDsHTFMMOatmIgUm32o5x8hWEFPEIFWNlNIpczBRGbAKQpUlJ0pXZViIx0hTAqXIppYU7hZERSmFT6VMWFNMgHaqTYrIh2H0o8r1p7S1GZSaeonZDvLFRSJnpTjLgdaiaUelNJibQzywDzSMQRgUx3J9qiLkVpZshsVlz06VEyDFBlNRNI3PNWkyG0hk8YMMg9VIrxm5dBAoUFAyYfjqRn/GvYZJGKMM9jXjNwzSxAuw2qCABx0x/jXh5utYmtN32Ox0Ur/ZkZ6N8qj127RXZSGuGsGxp9uC4Utt6D2rsXckD6VjkPxzRpjH7qByKiZxSF81GTX1aR5jkNZqhZqexqNvatEjNsjZuKhZqmPOajIFUrGbIGY+lRM1TkDmoz9K0TIZATntTCT6VO3sKiLc4pohkOCT0pNozzUpJPHejyz1p3Jse4CHmpRGAOlTqhNKyccCvmXI+mUSs0QJpVjxVhISTUhhpOY+UplM9qCmOlWTHTSlCkFiuQaaRU7KaYUNUmFiA57Uw5qwY/akMRp8wrFU5zSEVa8k0eT60+YXKUmzUZz6VfMNNMQHampoXIyhtY0eWaumMelN8o+lPnDkKZQ+lRlDWgYhjk1C4AGBVKYnApmPAqIrmrLg1GVx1q1IzaK7LgVAwNWX68VEwNXGRDRWYVEyYqyymonWtEyWrlVkzkZxmvGZwMOGAJxnI7Gvayh3V4rOwjnDg856GvDzd6xNaSOhsBus4CwyAifyFd06gqMCuIsWaWyAbAwFI46niu+EZManHYVhkTtOZri1eMSpsHpTGQdhV0xH0pjR+1fU8x5rgUDH7Uwx1eMdMMdUpk8hQMXbFMMVX2jqNoxVKZLplFoqiMdXmQVGVWqUyHApNH0qNo/UVeKj0qIrVKZLgUxHz0pSmBVtY8npTJExwKOcXIe7iLFP8sUuaXNfLXZ9HYTaB0FNYU7NJQBHspClSGm1VwsRmOk8oCpCR3ppYCndhYaVX0pu1fSlY5puapAIcUwkelKetMNMBDj0ppNKaaatANZsVE0hp7AmmmPNPQnUru5qJiattFkVH5XtVJoTiyoQTSmHC5q0sXPNK4GKfOLkMtkOTxUZQk1oFBUbKKtTM3AomI0xojV1hionAq+clxKXl814bdQ5llywAXd19R2r3huorwW/c/apB/D5h4/E15GaO7iVFaHR6Yv8Aoq8k52/zr0hF2xIPRQK88sI4o9OtCsuWdASvodxFeioD5S/7ornyZ/vJmlde6hhAqNhU+2mMtfSqRxtFZgajYGrJAphAq0zNxKrKTUTRsattTG4qlIlxKbRmmmGrRqI9atSZPKisYsU0xCrDc00pmjmJ5UQhNoqKRe9WymBVdkJzTUgcT2/NGaMe9GPevnbnt2E3Um6nYHrSYX1ouFhpJpvNSZWjetFwI8E0m3Jp5kWmNIO1NAJlQcU1lOaZyTS5b0pgBFNIoLGmlzVK4Btpu3mgvSGSnqApWm4FI0g9aYXpiHMBUZIpGeomkppAOZqYx4qIvk0heqsJsUnNRtSF6jZq0SIbBjUTYoZqiZqpIzbI2PzCvCNQUpeS5H/LQnp7mvdG+9Xh+oBU1SZZem9+Pzrysz+yOOxtaXkWcBYZ4UcfUV6Yjfuk/wB0V5npj/8AEvt89DjgfWvTIhmGP/dH8q58mf7yZrXXuoXcajYnNS7eOlIU4r6S6OTlZXOaYRVkoMUwqtUpi5WVytMK1ZKrTCB1Ao50TyFYrTSlWCPamkGq5ieQr+XxmjaF96lI5p/k/L70OQKBVYZFR7AO1TNGd1SRxdzQ5WDkbZ6xk0hBqXYT2pfLNeFc9axBg0YNTiH3p3lLinzoLFUqaTYaubFFNJUdqOcLFTyz70eXU7SLUTSj2p3YWGbcUwsM4pJJeOKreYQatJsROetMameYCKaXqkgHGmE4ppemM9USOLUxnppJphzVIBS1Rkkmn7c0YHSncLEOcGmMalKZNJ5Yp3I5WQtTDU5QCm7RT5hcpXI5pjKasMAD0pj9OlVzEuJVZa8J1992p3G3OPNfAz05r2bxDqEul6RLeRBNyMo+cEgZYDoOe9eaNpFnqrPN5jee7b3I+7ycnAryswkm0g0WgumsE0+wZgGDAjp0+Y16db/8e0X+4P5V5VJafZXSH7QqRIePnyR+nrirDvd3JEs2tzeVEcgCQjAHsMY4zXDg6n1ecpPW5Uqikkj1BnRM7mAwMnJ7VSl1fToiRJf2yEdmmUH+deXzE219HG108rJlvMkcHjqBg+5NVbScu7gxZZ5NwMYOR+nriu95lLojLU9Mm8T6PEcm9RgDgmNSwH1wKhXxNZzKTbx3EpyQMR4Bx356DtXCi3+1Su1xZSBS2S0UZP8ATBrXimnszsEM0iseCVUfnUPMar2QrM1NV8R3caqLCBU4LM1wpPHsAcZ+pqS31LUonKXTwzExiVSkZUYIBx1rnr2G6kJDGODIJGW647cDqa27iTyzESASlpGDtPXCf5/KuDF4+umnGRvQpKfxHQWMxu7OOdlCls8A+hxU+welM0a3VNGtevKbufc5/rV8RL3r6TDVXKlFy3sZyp66FRY8t0p7RccdatpDk4UUSxFa1c9RqnZGcU56VIsXFWkhLnpgVM0IVcCk6gRpnom9fWmmVRWeZ29aaZSe9ebyHXY0GnAqNriqW4mkOTTUEBZacnvURmNR4NGwmqsgsK0hNRliafspNh9KaCxESaTHNS7KTYfSquKxEV9KaVNWQmetBgNLmHylXac0hU+lWvIfsKPs7ntT5w5SpsPpR5fvV37Me9J5B7ClzhylURgUxkzVw2zehpRbHHNLnHylDy6Tyh6GtDyCO1Hkkfw0/aByGf5XtSeSPStDyiOwpCmPSj2gchQ+z/7NIbcDqKukD1qNgD2NHOx8iOS8b22/wnfKi5fCbfrvXFeS22jauZyDdeW7DBCYyQOf0zXumrafFqenzWU6v5UoAbYcHgg/0rwHVr3VrXUL21F4ywxytGBtHKg4wePauDFavU569N3TRpx6Hp7Sus73M9yF3feOOf51cXStIV7aJ41DSHAXkls+4rk7dru2e1kLuytyPmIAzwcY6V7ronh2xk020ujY2ollgRmcxKWOVHU9a5qcOd2uKFFs5C6tNNt4i6pbJJGmdnA74/Os0zOunAoXkmkHEcKZI5yM4/CvWo9Jt4PuJHGf9hQKebRO5J/Gt1g9b8xr7E8oiXUWRV/s+9lYAncIXAyR0GRVk2Op3dqkb6dODuDPuCDOOccnrnvXpv2eMdEpjQgdIx+VbLDRS3J+rI8f8S3cukfZ4by1YpJGwXoWOMckg8da1dPgi1XS4tUluVjtjF5flFhvG3I6D1qD4rrtk0/5ADtf+lY+mahdpotvbxSgBQMK4DDBJPevJxtOK27mlKHLOyPTtMiDadb+WrCPYAobrgcCr4t/U1B4ft530OyaTG8xAttGBmtqOyJPzV71CramvQfsikkZAwoqNkJOCua3BEiLt4qMwr1Bq/al+zMfymA6YqNgQe9a7w5qFocdBTVQXszc2Cl2CjPvQG96yuOwoWlxxSbh60uV9aAsJgUv4UZX1pcikFhKTFP4oJUd6LhYbj2o257UpkUU3zhRqOw4LThUJmpPNPriizAsZA6mgMvqKqGQHqwpPMjH8VLlAu5XuaQzIvTmqXnR/Wjzx2WjlGXPtA/u0n2g9lqp5rnoBRulPcCjlCxZ85/7oppkc9SBUGyQ9XpfK9XosgsSHHeSmlox1Ymk8mMdW/Wl2wr1Io0HYQTQr/DmlNwv8MWfwpBLCpwBT/OjxxSHylaWaQg7YsfhXzT4nkT+378cbjcvuwe+TX0xPcYBwK+ZfE4VvEV+MAH7S/b/AGjXJiFqjKurRL9rHHJZ2Z2g47H617zoNmzaJYHfx9njx/3yK8I09AbGxByRtyTn3r3XQ7rZoliu/pbxj/x0Vy4K/tJJF09lc2FsFA5YmniziHaqpvBjljSG7Ujlq9S0i9C59niXsKY4iUcbaoSXyKOoqnJqsYFNQkwckjzX4ysDd6cFxgRuf1rltHcC2jzyQqj9Ca2fixeC4vLAIuCsbEn8en6Vg2Lj7LCegKJk/h/9evIxkbJpmHMvaux7poUoXQ7EY5ECfyrRMxrltO1XydOtkAHyxKP0FWG1lj0r2KFGXIivbRN13J70zew/ixWA2rP61E2qSk/eNb+xkT7eJ0Zcn+M1Gz+rVzjalJ/fP51Gb9/7x/OqVCQvrETtzKaBP71RNwP71RtcBe9Ryhzo1RJml801mx3Kkfep7XSgdaOUrmRf86l84+tZDXoz1prX+BwaPZsXOjZNwaYbg1im/c0fb2PU0/ZsXtEa/ntTTK/rWSb5uxppv29ar2bD2sTXLt3Y03d6tWM185HWmG8c9zT9kyfaxNwOg6mgzxL71hfaWPc0huTjrR7IPao3ftcVSLeR47Vzf2k+tKLo460exD2yNyTUQrYGBTk1RSeRXONMznk8UokI/ip+xQe2Z0r364yDVVtS561iGZv7xqIyE80KihOuzokvg3U1Dc35UbUPNY0cxHeh5xnqKFSSY3W0LYuJg4feTWnHduyjGKx4Z1x1FTrdIvORSlG/QunJdy9PLdYyqgj6188eJnB8QXhI+f7Q+f8Avo17tLqagfe/WvCfEhD63cyY+9O3Of8AaNedi001cVaScdGaums32S0AH3QD/I16bYX0yafbhSQBEoAHbgV5npg3w2qDqU4xXoMDmO2iTphAP0rmypXrT/rqTOVoqxonUZu7mkGpyj+Ks8yZoAzX0PJE5/aS7l19QZu5NQi/dGzgVGFT+JgPxp4EH94GhqKQJyb3PPfiPd+ff2ny4xCf5ms+xV2tIcDI2qMD6CrvxDaL+1rQIN2Ic4H+81RaSN0NuuONqsefYV8zj3q/U2p/G7nf2z4toh5ecIv8ql3sf4MVDBNtt4xxwoH6VJ54PevoqH8NGD33Hhjj7madkn+Co1lz3ApxkGOZAPxrVjVh23cfu0ohz/dFRiaHvIKkSe3HV80m2UkjVS7y2GbmiWcKR83WsVLpjKMYJA5qe8uHVug+tDh7yRh7TQ0BcEd6U3JPesn7V/o5YHkGmfa+apQuL2prmc00zVlfayaX7UTT5Be1NQTFe9H2jNZn2mj7RRyB7U0jL70nmj1rNNzjvTTdH1p8gvao0/MB70eYB3rKN0cdcVG10fWjkYe1RsG4AHUVGbhfWsg3B9c0huMDrT9mL2xrm4Wmm5Wsg3HvTTP7mnyC9sbJulqNrzBrINwfWmeefWjkQe2Zrm8PrTWvD61km496Ybiq5ET7Vmqbwg9aja6LHrWYZ/emGc560+REuqzWF8y8ZpjXrH+I/nWWZzTfPo5EL2rNI3ee9eY625/tGXOMeYx/Wu4M/OK4fV0P21ix4Lsc/WvIzNJOJvRnc39C4Fs7dlP4HNdc1zg9eK5/wvB58CJweDgnuTV6dmjmdG4KnBrhyZXrTOjFS5YxNH7WR0NBvGP8VZPmH1pPMPrX0vKef7Vmqbr3qNro881mmU+tMaWk4gqhz3i6XdqSSE8+TgD8T/jVzSnRbeNhxnGPptrH8UHdqCE/88sD8z/jV3TkJgTHO1Af0FfJZjFcz9T0sNI7D7SVUAHgCk+1n1rOaQjikMtfU0I+4jzZ1Hc0Tdn1o+1ms3zD60eb71ryk+0Zpfaj60hujWd53vQZc0uUamzZWUs6jOGzjPrVvUZCJBzxjNZVs+64jB6bhVm8nEkSyAnIYg5pyXvoal7rJkctZycnr0phlOAfbNQRORABzgg9P8+1NjY7ceikUXsx7k/nn1pVuDWf5vNKZDnFa8qMuZml5/vR55rOEpBxUnm5FS42HzMtmak83iqhkpDLzSFctGXPemmX3qt51IZc0Bcs+ZTfNNVxKBmjzBQO5OZD2pC5x1qHzAKQyClcZKWNJmozIOxppkGKLhYkLGkyfWovMFIZR60cwrEvPrTeneojLSebTuImppNRebTfNouBL3ri7+bzNUlUoBhio/lXXCT3rjtQG3V3JPVyf1rx8z1sdWHPSNBsY7jSbFYAUMUReSUH5Sd5wPriqt24luZGB6sTk0zwtM6xCME7ZAMjP1/xqG4bbM6g9GIrgyVr2szfGL3UBOKaTzUZkOaTzPWvpeY86xISc0080wvTSxzSlLQaRzniIg3qAjnb1ratbuL7EkUULB1jXnOd3HPasLxD81+mf7oFdlo9/pmnWe0WwluWjRd6gjGVHqTXyOYWc/mephtiBzkk0zNNdyXNM319XSlaKPLnuP3UbqjLH0pu45rTmJsS7hS76g3UBvejmGkdBbWzxz7iQdoYkDqODUoSa6tZFEEm5TkfuzyPyq3/AMItqxjx9qO7/rseP0qN/COrsoBvf/Ih/wAK8b67iG7uJ631SmtLlYWlwkcbmG44O3CxMSPwx0p0cUybi1tcAdj5D9PyqYeDdWOc3kZHYFicfpTv+EM1PjddxfgT/UU/rdd/ZD6tT7mY9nc78rbTbd3J2H/Cn/Y7h2BEEuOP4SM1f/4Qe/JJa8jYe/8A+qk/4QS6IAM8IPc8n+lH13E/yi+qUu5TNhdDcRbSEHPdR/M0LZ3hA/0Vz/wNP/iqvL4BmVcfa4/++c0n/CATYOb5P+/dH1zEv7IfVKXcpfYrs8fZW/7+R/8AxVIbG8xxaktjgGWMf+zVe/4V+463qn6J/wDXpo+HpGf9NHtlDx+tH1rE9hfVaRRWwusfvYVRvTz4z/7MKH0+5CkgRZ7b50A/ma0B8PyMf6cP+/f/ANen/wDCCYUAXafXyv8A69H1nFdhrC0jK+xTBcmS2H1uE/xpGspgoYT2QHq1wK1m8Dudv/EwOB22H/GpG8Fl9okvdyD+Hy//AK9S8Ti+w1haJg/ZZCQftunY7j7R1/GnpZSt0utO/wDAr/7Gtk+CIwfluUA9PK/+vTF8DYzuvyf+2Y/xoVfFdg+r0jFeDYxVr3Thj/p5J/8AZaikCouTe2H/AAGR2/kldB/wgyYx9sb/AL46/rSnwRGel4wHcBT/AI0nXxXYFh6RzDXECg5uoSfRQ/8A8RULX1uuN0gA9cHiumk8Bo5/4/nA9Nn/ANeqcnw4Vzn+0nyOh8v/AOvU+1xQPD01sYH9rWZIAmY5PVYz/UipW1KxYlY5Jgw/vRj/AOKrX/4VwAABe5wc/wCr/wDr1aj8AwrIGe6LYH9z/wCvUOri2xqhTObS/hCZkZ1bttiyPz30ovLUZJmlB9Ps+f8A2pXWr4KtgTunZhnOCgxWmugWSDi2s84xk2qH+eaTq4tD+r0TzttRtennOP8AtgP/AI5XO3zeZqZPVc5BxjrzXpreCLJXZvOkwewA4rzzWLYWuuSQjlVYqpPfFY1pVW17QPZRj8J2OhRHbCQSCT/jXP3mrvHqcqFdqLIwBYZ3Cut0KPEET9CAfzyabP4HsruVpZJpcuSxxjjNcGXuo5z9mbVoRaVzlTrMOGIjLbepB7/lUMetZZhIg6nbtI6fkea6weBLJDgTSBfoM00+A9PZgWln4ORyP8K9W2JfX8TD2dM5Y6s29V4UseAUzVk3ykgbWz6b1z/6DXTjwZYYGWmOPVh/hTm8KWIJw0oyOfm/+tU8mK7/AIlclE831iYSXqPtYcDhiCf0ArYVtt3s/wCuX45Vaq+KNPSx1pYId3lhB1Oa2IbUNPG5/i8v/wBBFcGIk00pb6jpQ1dtii+rxrn5HOO+9P8A4iojqMjbXDHZ3XC8/jiti30fRLvWn0uK2u2nDFS2RtyOeua1ZfBmnQsYWSXKHBG/pXbB1ZPkjLUz5I72OTfVdoBGTk+v/wBamDUndmG3gcffIrqj4Q0w4JWTj/bpB4U09eAkh5zy1a+xxD6k2gcy162B8nI/6aNTftbFxlBzx/rXB/nXVN4Y0/vGx/4FTf8AhGNODhxG24dDuNCoYnuV+77HqQHvTttMAPrTj0616BQuBRxTQvvRgigBT7ClFJ+FGKAFI+lJge1GB70hA96AEJ+lH4ijtSY70AJzmkOacKaxpisJ+NB+ppD0paAGnFJSn6UUAN60hpxpKQDSKbj0qQnimE4oGNx7UmKXdSE0CDFBHFJupC+KAI5AMV5D4i2R67KzAECQnH4165I9eTawAPEMxfdhnbGcep6V5mYPb5mkDsdG+WzXtw3H54ro0xsX6Cub0l82CHI6Nx+Jroo3BiQ9ioxXn5K/3kzXEbIeQKZxmlL1G0mO1fSHGKSBUbU1nNMaRs4GKTBM878YShtenjZRwigN6cCughtlSG3HcrHz/wABFY3iSNptbmVR8zBQD6cCuttLQPbRSEjKEAn6CvlMdP8AepeZ30Y6MxPD8jJ49n24P79sDHrwT+VdhqAxfz55O81x/hXL/ECcjn99IP511WoOW1CfB/jPrXp4H/epvyOWfwkRHFNNRljj5iTTSynoOfevaRz3Hk9aYenXmkJAXn9KjPPc4piO9xS4zSAjPWl/GsbnSGKMfSj6GinzBYMUYFHailcBcCkNJmkyaLhYDSZoz7U0mncBxNNJFJupuadxCk0mcU0nmkJpXAdmk3U3NJmi4Ck0hNJmmk5ouIUnmkzTSaQmi4Ck8VXu722sYfNupkhTOAWOMn0HqakkdlX5F3Oeg/z2rlNW8PWsO7W/EeptJKkqmCBeFCA5IVQc5465+uaxqVlB26id7aHVowdFdejDIyMUE1Vsbg3NokvkNCjAeWjDB244yO30qwela3uhoilPB5ryHXJHHiOXJztkcD8zXrkh4rxnXJc61dvuyRM4/U1wYxXsUtDtPDs5l09cnny2Y/8AfRrqbdt1tEwYEFAQevauM8MyIukRvxvMRBJ9N5rs04VRnsK4cqVq9Q3r/BEkyfWoyDnk04gn2ppH0r37nHYYwOepqNzUpIqM49BQ2CRxutgjVBIHAIkAIJ7V1VsxjsS7cKMe3H1riNfkzrMoU8b/AF7gf411urh4fDF1JExEix5Ug8jJwPx5r5HFQbrx9X+Z6FN2gzI8Jw3EHjGe+lgkS186QiVhhSDnoTW1Jqtlc6jKiX9sJGYnBfHevNrtbtmILuxYZxksR/hUPmOdxlfgqMA9iPrXfSlOE3UT3OaVlG1j1bZG3/L1CfoW/wAKFW2yfMmfA6bFzn9RXkqzmMkpxjoV4/UYrZ0ubU7m+s7aK9lBnkCYySV/76Jrr+tuKvNv8DJK+yPRHOngDYLljj+LA/xpr3FoowLUkY/ikP8AQCsVlvrSKzMtw0xmfa25FAxxnGMeoq9la6MLWp4hNxbKqRlT0aO+FLmmjFKK6Ll2DJzRnmjilouFhM0UDFBouFgzSZpMUUXCwE00mlNNouKwhNITkUGmnrRcLAaTJoJpCadxBk0nNGabmkFgNJRkUmfWgBCcU3NMubiG1geaZtkaDLMe1UjenUoxbaSwlvJz5UQ5+Vj/ABH0AHP4UN2JcktDW8NmG/s579lOxp2jQ54KqcDH16/jS6iltIXTyEIbIYsoJIPYk1fPhi703T7ZrC5cWlsBCbZMgbQcFz7kkseOlZd1MJpiyZCDhc1wU4e0qczKT92xF0AA4HYCgnim8+tNP413iGSV4TrBb+2bzJ6zP/M17nJxXh2rYfVrrbyDM2PzrlxD1RNRe6bWi3pW0ijHQAL/AOPV6ZFMTGhHQqK8gs7wQQbCq5UA59w1Tw+K9bjGEvWKjorKp/mK48P+6qSlbc1nUThFHrnm+9Jvz3rzaDxZq5i8wyRyezR/4Yq1H44uVIElrE30JX/Gu5YqBm0d62SOtRs2BXIp47iCjzrCRfdZAf5gVOvjfSXxvS5T32A/yNX7eD6iukc7r43anMR187t/vGvR5Qq2627mORW3AYGQcEfn0zXmV1Mt1ctOvKtIWGeOCeK9Qu7Jo7G0mk2xrFgsSQOor5yvU5a9NvuztpxTjI8haS503UTdEA/vHCqTx3FdHolzBrJlieDy1xhsP656A1jzwSXmpSRlG2I7kemM9a3/AAnYRwahcNsPmLHjH412SjCpNRe//BMYQlFNrYc3g+AHMF1Iv++ob/Cs+6D+G9XsZ5mMg5ZfLHccdD9a7zaSOmPwrjPG7CK4sCVzwxyfwruxGHp8jdiIyaOultkn0fTLmNsElt4J6EEZx+QqM7cZrZvreFNM0to0C+ZbK7AHjdjr/Ks0pxwtRlMIxoKS6l4huUtTpbS/mmimku7KSzER/jZW3DGc/LmqX/CV6f5hSNLhwCAWEeB+uKqeNNSFlpsEIcq9zOqYB52g5P8AID8azmeMoU2KXGD1655Fc2Nx8sO1GKuzSFNyeh28cgkRXU5VhkH1FP4rN0uUSW3ljH7r5cCtAda9GhWVSmprqS42dhSKO1BpM1tcVgxSEUuaaTQKwh6U00uaQ0xCU004nikJoCwwkUhpxHFNPFFwsN4pDS4oxRcVhpxTSRTmHoKYeaXMFiC5giuo/LmQOmclG6H6jvTvD94/hLUJJ7e0W5sJeZYc4eL1ZM8H6U8rnvVW7EpiCQkh3YLu67R3P5Z/HFTJKSIlBbs7rUJ52099Y0a/NxZXGS6jB8sEdu4xXGYHrW34d1mLSIprWaFpLaZcMFPI4x365rKKrk4HGeM1MFy6BFPZlcgdqMHHSp+KQ4xWly1EqPGT1FeMXNm819NNtCgyNlSeRzXtkmMV5BrN3HDrV7GEHyzv/wChGuLFOWlirLqZX2V98hwQApP9a1ZPCslnBaO91HuuYy4BU/LgAnn8ak0iP7XZygchVP4cV1fiNEL6SE5AkeMAe64/pXGqjan5FqjFcr7nOW3hLVIpCUjilHcCTB7+uPSq+r6VNpduJ7myKpu2liQRn8DXoOjxn7VOz/xLkc5/iOP51k/ECUDSbe2G1Ully5PsCQPz/lRQiqtJVZPUqpFRbSPPzPDMcR4bj7p4IqKW1VSMMM45GelbXg+1im162k2qSrE4/EV6bqENr9jmlnhicIjN86A9B71rCN72exiocy1PILQO6qCxKZ27RXrXjS6tT4OvIlmzKoVdu0Zzx6V5np+ntcXaogCq1xtBPQcj/wCtXo+reFL26dLS73pE7hS69AM4/PH9K8nGTh7WDb2f+R2UYWizzs61qunNHDC6GMIp2NGG6iug0a51fVraW5tYrSJ0YISUIL8Z9/WuavZmj1CePJbY5TJ9BwK9F8I24i0CKTHMzM5/kP0FejQownNXVn3RElyx3MUa5qME7Q3dugaM4bbgn644qtqX9n6+YftMzQGPIBK46+w3eld9JCkikOisPRhmuH8YoLG4tTbBYw6ncoUYOPatK9GrFX59BRcJaNG7bXim2hh+0QyCNQiFp9oxk44bHrVa9l1szKNP0zzogvzMjq5J9uf6UzTNKF3Zh8R7+PvpkY/Cp5dFMWGEaH02bsj8hXJRliIU1yL3TSVOm3vqYvxBuBL4x0+3bdshh3Y9yT/gKmtLjfcJCARxl2z/AJ/yKPEsA1DxtMdvywRopJ9cZ/qa07bSzJqLjiONQGYnjAPSufMqsXOz6GeGi7ts6XRUIglmPWRzznrjvWru4rkV8S6do9u1uvmTyKxO2IAjr659KzpviEWyIbMQ9NryZcfpj+dephK0IUIryJnbmZ32+jcMV5ufFmsXHzW9xZuQPuxMBn8G/wAanXxjfQR5mXpgEywnBPfleB+tdCxUGZOaPQN1ITXH23jVJiAY7ZxnBMdwM/kRWrF4ksJFy0jR4/vrx+YyK0jWi9mO6NrOKaWGapRaja3P+puYpD6K4Jonvbe3x500aZ6bmAzWnMtwuW9w9aQtWPL4gsEB2yGTHZB/jiqcviqwTtLjGSxXAH41DxFNbsk6HeKQuK4+bxbJJIVtY4QcHHmP1qu+sanMN8l0trHnHEeQfo3/ANasJY+mikmztTIB3qCXULaIEvcRqB1+YcVyCy227N1qF3J3O1C2foTtxUUs+m25LR2rSE4O+4nAP5KCf1rnlmK6IpU5PodBeeJ7SOM/Zs3MnQbc4B9z2/KsefxRqruVgslRQM7iN2fplh/KqbauXwkQiXAwBb2+4j8Tk1AY7ycEx2V8+4dWyqmsfrdab91Fex7uwk3iHWFDTtdsuCDtCBQB07jmpLfxlqfIeG3nz02HGPxB/pVK58O6zc27KltHDkdC4yf1rNi8I+IUBIt1bHq6/wCNb03XtdmE0ouydzsrXxrbykCa0mjOcfKc/wA8Vox+KNNfh5miPpIh/mMiuATQdcBxLYynI6iUcfrTkt9bs1KPaXLL7pv/AFBrT21dboLHpMGq2l3/AMe91DL/ALjg1Y87HWvKJZ5DxcaeyE9WEJGPwxS22pSW3yxXlxEgOdpLD8OmKtYp9YibaPUXlznmvGfES416/YHrO3866GLxHqAIUXqyZHGFVv8AA1iahEZ5ZLhyzSOSxwMZJNRUxEZNJCa5ol/w+JYbSfap/exYBx35rpfEQ8mLSVT5THNxj2U1yFtqUyWoiiUBlXGG71rte6jrE6CaEGKJ2aN0U45GBmuSKa57rc6HONoxOn0IlLuUO7FtuME+hrH+IPy/2dLwcMylSMg9P/r/AJ1peHnd4ZbuT78rEFP7mCRtrF8fSl4rEEcbn/pXVh6UoYa0iZzTlcyvCNwq+JIgqooZjgemfSvRNbdzpUu1QVypcf7ORmvMPDEix+ILU7cnfXqUkiyRsh5DDBrWlS5oSXclS2ucRZajbC9CLtWJJywJ6ctn/CvTZ/EX2i6hV33AHOffHFeHkFbt1/6aEfrXQR6g4JlBwADhT64NeFisGpTTuehSknF3MuS2muLqSYxsRK5cfia9M0e4hh0q1hV1+SJQee+K8uF5KG4JBB9TVhbx9uDkn/eNejSqypyuYzUWrHrBuk/vCuI8czCS7sgGH3W/nWINQkXp+pNQXTzaneQB3PAIFbVcRGcLMyjGz0PUdOkjWxgVMf6tc4q35gHU1y9lcNHBaR7id3X862Sc960y6UXRS7BWTUjitGvdR0mBi1qlxNIQGc53BR2A9fen3Pia8luZwIkhL8rEcnbwMenpVeK2vogwieaNeo3cr+Tcj86sW9zIHP2m3glbH3hj+VeLOEXJzaTZdKbtZGEt3eRscwJKWPO1iM/hkVaj1ZYwI7qKa2bsqgqCfx6/nXT6VoP9sO862qiNWw2WwM/TFdtD4b0xbYQtaRSLjkONwr0KNF1o3asZSi7nlElzYXjOzpbux5+aPY2f+A8VCrRw48j7RET0KSEgfga9OuvAXh+4JP2BYmPeF2X9AcVjz/DS3Vt1lqV1BjoHAkA/lWjws0tDOULnILcXhTbGYZT381I+frgA0rtdLu3aXaHPeFih/wDHSDW5ceANWV8rNZ3Q/vEvE/6ZFZ8nhXU7SUNNplw6L3gdZc/yP6VHsprdGbi0Zs13Ih2mO5iYdPmDDP4gH9ae15DcoFu7ed5VBCM6dPoMHFalu9laOq6hDPGgPzbomjcj0+YEfkRWtA/heSNlUXRJ5yAM/qaSpSnoCucYmoyQ/KC8YJyD5hH6Nx+lPGo7ownnszM2DliSR9c/0rorxLHeDaoZBuyRdRRn8BgZohmsyCkml2MsZ7LHtI/HmtVhW9wszEtUg2EMDuz1aQNj8DgfpW/ZWVpdIEea+dxjiMoq/l1FWbdPD28l9M8vI525K4/MVrWdt4eQZgSGPnPIK8/jVQwXvXlqaRlNaJiW/hjS3USG1d29ZXYn8s4rQj0XT4iCljbgjv5YzV21hgiT9wF2n+6cirIUE8iu5UILZFNt9SiLdUGFUKPQcUeUKvmMHvTDHj3rRRSIaKLRe1Q3AkigDxKW2HLKO471duJobdN0zrGmcbmOBVSw3eILt4LSZYrSPiSU8s/sv+NKTUVqRKyLllpq38Uk7uUiQZyByazTCM9OPet+bMdq1jY2skVvDwzYxurKIA60Upc2o0UvJUDAJHOeuahkt0f76q/1Aq8wFRMBWtkBlSaZZEEG2j5znK5rzXVs2+r3aQHYiyttVeAOfSvWJAMV5ZrCq+s3hB485ufxrhxiSSNKauMtHmm3MX+YDOcDg16LZ4a1ibaVJUZHoa86tCscb84yK9ItnD20TAjDKD+lZYG3PIuskoqxXhRbfUpo4x8k6iUgDo3Q/ngfka5/xv8ANHZx/wAWWP4cV1h253YGcYzXL+MY99rBKAMqxBPtXXiFam7GcNZanO+Hoiuu2/s39K9GPJxXnvh9tmrQMT/FXoBYdjWWElpJDqRStY8wkYpeMOu1z1+tXrVmuZ44d20M3QCoJ4SbyYj/AJ6H+dbdhZbb6BiuMMDXmVJRUkmdcIys7HP3CGO6kTP3XIrZ06wFzaLJjk5FZmo4TUbjI/jJra8OToLKVXbGH4z9K2pxjKVpbGVS6Wg19L2ntSwWZju4ySv4VBd3kpuZVRvlDHHFVle5dwcsTWdT2eyCMWtTqYwFe3JfhT61ptfQqeZBXGxrcnHyuanCXGcmM/jRTqypq0IluCk/eZ1/j+3htba0nSIqocp8vTn1rkkmSVlII5Fen+LbAX2gXMeMso3r9RXlkVudgyOazxsIxkOi+h6D4Jf93cQehD12Hlj2rhPBEUiXM0mSE2Ba7oOR1rvwLbooir8QGMdjTSuPen7waZj5utdhmMKgjpUTRg1YPFMIo0ArNEGGCAR6VRn0TTrg5lsoGPrsAP51pnFNzTSQmYb+G9PwdsTL/wADJH5EmqLeFhESbeYAdgyD+ldOzA0wnjGaqxNkcwNHuYyu+FJAP7shH6GnLZxrtWW1YZ9Fzg10RNRnHpTQrIoW1pCM+WQvPbINakYKqPnzVcgdcUm4qPlNMd7F3eOlIeKpeew6gGg3I/2hRYLj7u2ivLd4J13Rt1GcVnNZR6XALjTkaOWE7wNxIYdwc1dE4YfeFNklAQ55BqXG+jIkkx0muz3EMUNtC/lPhzMoJDA9uOhpjMCeOlVdLMdvataMxKo5Kg9gaSaRYnLLIu3uCa5KU/Zz5WLpcnYg96ibvg1F9oz1/OkL9wa7xXGPnmvKtS3JqlyP+mrfzr1GR+teXayxGq3B9XJrhxmtjak7FTc2COa0bfXbmCJU3HCjA5qhEC4JrSTRpZIVZUByM1xRbvaJrJ9WWYvEs+QCDjvUOq6y19ZiEjHzg1GdFnQcgj8Kgk0yZex/GrcqmzuReJXs53tbyKU/wkH6110fiCBsFsj8a5F7SROqH8KjYOvVcUQqShsJ2e5pRSrJc5B+/J/M1013NDbuiqwyDyfSuKgdldCOua3NQgcWLzMTmuCtD94rs7KcvdZnXflG9ct8wJzmr2lRw3Mzx7cLjOKzrlAtpFNjqSKsaDKwuycEA8GuqEfeTZzyn7rSOkWwtx/ADUywQpyEFLAYpL23tpZ1hM77FdwdoPviuni8J71J+3xHH92Jj/Su6rXwuHdqjSZyxVSfwo5vgfdUflSMCw5rrE8III2d74nHZYjn9aSHwtC8crtcyjbyoKKP/Zuf0rneb4GP20WsPWfQ6GcCWF0PRlIrh7rw48cjeWMjtXZGSmsQ3Wtq2HjV+IuM3HYzfDVi1jZuGHLNmt3dVRWC8CneZx1rWnBQiooTld3ZZL03dVfzRSebnvViuTl6YZOKh82ml6YXJS9MLc1EXpjOapMGyUtg00tUJkNIXppiuSlqazVCZMd6jMppiuTlsCmMwqEykUxpTTE2SlqYzCoTJ700tQK49iMc1HuB6EimlqYXp3FcdJuKnafmHTNc1fazZXj/ANmataPb3RcKknIyPUMK6AvVW7tbe9RVuIVfBypI5B9Qe1ZVKSm7kyv0JoEaGBY2kaTaMBm6kUp9elMDAKFHQcUhbitlsIHYnpXm2tA/2rNkc55r0VmrhNbQf2nMfU8VxYx2sbUtSrYxbgDiu5tAv2WMdeK5bTYx5IGPxrqrUZtkx2Fc2BlerI1r6RRKyL6VC8MZ6qD9alNNNevyo4+YrPbRH+BfyqrJp9uxyYwavsCaifgVEqcWtgUmcZNEEviFGAG4robpUuLZYTwGx0rCu8/b34438VvRLueLP8IzXgThzVox8z0lK1Nshl01GtYoAD8nrSWtitswK8VonHWonxXtrDw3sea6jCJ86/pOApVZWY5Gei138XiNAmYlJbjKjFeXXjyxXto8TFGBbDA+wqfzdUb5zcyk9PvV85m+EjWr3k9kergn+7PTE8UtId/2WNwMgFn4x+FPGv8Anbitnb7VPOG4H6V5gsOpyHmSTPu/NP8AsN3g73H/AAJ815Ty6kuqOxPyPTzLR5ue9UzJSeZ719zynh3Lvm+9J5vNU/No833osFy55tJ5tVPN96TzaVguW/MpPNqoJc0vmUWC5Z35pC9VvM96XfnvSHcnLg0wtUe7Apu/FFxEhPrTCRSFqQsMU7jEbNMNOLA00kUcwrDCaQ5pT1pKfMFiM5ppqQgU1gKOYViKkNS7RSFfSnzBYh25NG3mpdtKF70+YViApxz0ridaT/iZSD3rvdvHNcTrSf8AE0lPYmuDHS91G9Fai6dGfKBrpbVP9HX6Vh2C4gxXSWqD7Kn0rky6X76RtiV7qIzHxmoylXCnFRFc+le7zHA4lUrULLuOMVcKnPTiomTBNKUhKOpx19ERqDez1uwx4Vazb9P9PbjndWrH0U1897TlxEX5npcl6TQFc0xkxVraB2pjL+dfRKR5TiZl1atNJC6sAY2zyKuo5VecZHelK89KQrXHXwdKtLmkdFLEVKStEDOdpP8AFjHSoxPtU7gCT+lKR6VEwxWKyyh2NPr1budtvxSeZVbeetIZO9egY3LXmU3zcGq3mHNNMtArlvzKTzaqeZmgy0guW/MpPN96qeZ60ebQwuW/NHrSiXHeqXm0nnVNh3L/AJ1J51UfOzzmk86lYOYv+aKBLWf52aPOpWDmL5lHrSeZmqPm+9KJeeDSHzFwvmjfVQS0okGaAuWifSjNQB/el8zNA7k2aKh8w9qXdQFyUEYp1Qb+4pDJTFcmYjFcXrWDqLn/ACa6syGuT1jm+Y+tcOO+FHRQepYsCPKwa6S2b9worl7FiIxW9DJiLANcmX/xZGuIfuovF6jLCoC/FNL17dziuSs1QseaaZB+NRs/qalsRgXv/IRf/erUjIASse/b/T2+vX1q/vwEwfSvnqy/ep+Z6cfgfoaWRimMRUe/FJv4r6GL0PLaHHpTCaa0nbNNLDFVcQGmsAaaWyfakL4NHMKx0Zem76ZnFNJrSwXH76bvphNN3c0WFcfv96QuaYTTc4osFybfTS+KiLUmaQrkpemmT2qIn3pCaAuTGSm+YelRZppegVyfzOKPN4qvu49aN1KwXJ/Np3mVVD07dxSsO5ZElSCTmqgbinBqOUFItiTNOElVA2KXeaOUpSLXmGl8zmqu+gvx1pWQ7loy+9N31W389aN9IEydpDyK5jVGBujW6z8da57Ujm5PrXBjdkdNDctWR+UVrwvlKxLHlcVqwsAmK4sFpVZtX+FFovSFs1B5lJ5lezc4iVj6VExzTDJ3pjPSbBGPdnN2cVOj5C1Uuf8Aj5qVSRjFeJUXvnoRfuGqGwvFJu496jVvkAoLV7MHoee9x240xiRSE+9RlievSruTYduNIW4ppOKYzEilzAdKWzSZJ4qMvxTS/NdliCUjOaacUzdSFs0rAOJ96aWpuc0E0WELmmlqbmm7qLAKWxSbqaSaRuaLAOJ5pmetFNLUrCYu4ijOetNBNLkUgHZ9KXNMznvRmkMmDUpaod2KXd70mwJd9KH5zUIegvUtjSJ/MppfFQbjQXqRk5kFIZO9Qb6bvNK4ycyVh6g2bk81pmSsa+ObgmuLF7I6KD1LdjIAnXkVopJlaxbVsd60I3461x4VWqm9d+4XC+abv7VBvz3pC9escRMX4qNnz3qPd2phbNS2CKN1gXPWrCL8gI7VUmOZuasRsQnWvHq/EehD4C2GIFLu461XRzt5oZvevVg/dOB7kxfI600uAOtQbiB1pC/6VVybkxfnrTWYY681Hv4pjN3FFx3Ol3ZozmoTJk0bsivRIsSbqNwFREn8KaXxSFYl380m6oQ/rRv6UASsxph55pu/NIXqbgPBpN3NR780maVxEjNxTCxptML0AShqC2DUIagvnikBKWNLuqDfRvqWwJi+OtJuwc1CH9aUvzxUjJd/NKZKgz3pNxpDJy9M8zFRZoLDFTcZLv700ueuaj3UhbPSlcBxesq6b94a0N1Zl0R5prkxOqRtR3JITgZq9FIdtZ0Z+WrULfKa5aK/eG1b4S1v5oaSocnvSFsc16NzjuS+ZkUFs1AX5pN5OamTGivM37361OrfLVWU7pKmX7leZUWp3wfuk4OAKNwIzUQb5aQE5rvg9DiluSZpCQeajLYPFIGzmquSPLdqaSfWm7vxprNRcDos+9APWmdxQfvV6g7Di3vTCxpG6ikoJsG44oDZPWmmmt0pMRITTd+KbTW6VID99Jv5pB0FJ2NIBzPTC1I1MPSkSOL0m85ph6U00mwJC/vQH4qPt+NBqQJPM4pRJUFKKTGTb6N2e9Qind6hlIlLAcUmaYfu03tUtjJC+OlJuGc1DR60guPZ8is6c5ernaqU3365q+xrS3HRnCmp4X+U5Peqy9DUkXf61z0/jNa3wlndxSFsCmdqQdK7LnIP3A03d1pppBSY0RPjzKmU4WoH/wBZUg/1dcNTc7qfwj9+BSFuajH3aBXVHY4mPJ5pN3NNbpTf4qokcTg03cO9DdaaaLjZ/9k=", "data:image/jpeg;base64,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", "data:image/jpeg;base64,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", "data:image/jpeg;base64,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", "data:image/jpeg;base64,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", "data:image/jpeg;base64,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", "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD//gA+Q1JFQVRPUjogZ2QtanBlZyB2MS4wICh1c2luZyBJSkcgSlBFRyB2NjIpLCBkZWZhdWx0IHF1YWxpdHkK/9sAQwAIBgYHBgUIBwcHCQkICgwUDQwLCwwZEhMPFB0aHx4dGhwcICQuJyAiLCMcHCg3KSwwMTQ0NB8nOT04MjwuMzQy/9sAQwEJCQkMCwwYDQ0YMiEcITIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy/8AAEQgBmgFAAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A9oDGmSZNNMgXOailukVA3ODg9K7NjnerA9cUmTmoI7tZC2eAOhPep4WWVNy9K16XLuPRd3IqXAA96TIUYFMZ+eajch6akEwzVGWMEYq7Kw9aqSuvJzW9O5DdyHbghc9KragpEYeMgHcAffnFI1x/pIUHjHNVdSnX7OQzjbkHr15rbbVk310LEyp5YyApYbTWfO8VqnyAbgp6VBc3EwkOAcDoOuRVeeOaZs9D0BNclSpVmmo6GsIKLXMwmK3UAj243HDH8KyjMi20URUiRThjjgjpWhOjW2CCzD+PFY0rb4JGVlUcjDHqOua5qsppWkaq19B8UnmyhVTO77o9wef0NQT2zRX/AJML/I3zZPIHt/Sqz3Ekix4QhkXd5g4yR3FSWV7IyyM5IMi8k9jSjOPMk43D3kSXM0f2Zknw3lyKu30XIx+lY8LANLLHwhkbCnrjPSrGpSE36+XjfhARnqQe9RWQhfy4Zy6hssQMde39aiTvOy6DjtdmkJgbhHjYYkXYzqOo69KjNx9pcRjcUPXI5AHeq32nZAWjDLtlY9OQfQVdsrWS2dWIZ5Xj3MB256V1Qpuq0zNtRRNDGIYIZGLSSueRk9Ov8qs6XgyyOQxY8KMcYxT4bhPseVU70XoV/i9Kq2s5s52hjcMSNwyfb9K6G4wqJrYyd5Rfc24QzO6tEoA6VaKDhgMcdu9VIpWcK7DY5HKjmrKSdj0r0FGLWhyttC7c5HpULoQc1ODxnNIQCKtaCumVc02pXQj6VGelaEsbim+1ONJxQSJSU40hwaBDD9KQ0/FIRzQMYQKbTzSECgRGRSU80zHSmIaaTpnFOx3pKYz1ORFlYMPvD34NULkgZiAYyD7vPQUshY4UT7cPk+w9KhMcckhlcHBJwwPQV4ns77s9OEupJHEGmSNM7VAZlYd61EwuABgVmWsqtfzIh3Kqj5v6VfVhmia6BfUmZgKhc8ZpWb3qF24qYoJMrXOXUgNtcdDWW806CQOy/KOD1q7dSlCDgn6Vgy3BlkkIBQlTwfTNbctveSISuNS9BlUSg+ZnA9Dmqur3Py7VAJbPA+lRuWuIAqyKu0k5K8g9jWfPcIbGOZmAZnIJA6HODWOIm5QduhVOPv6j49WaRU3yFkYLnaavQzgAeYA7nlVHp6VgafIiLtOGUOV3HoBWjbzF3kgjI8xSCrjkc/8A6q56enqzSdixe3BmkjaKJlUnazsehHaqP2R5Lj7M2FDAswI6Y6fzFT5nQOr/ACgPucL3Hr+NUb2YJc55JLbSSc8U21opIcdtCkilJPLeTMCHcfl5Cdv60MiLMBErbJHwvHTnmnvIr3haQqfPTYEA45z/AJ/GskSyWrKWLDyzuXOcEVjfkaaK3ViHV2WLVHKoeBn73WpbML9jad1+fYFQHk4Pp+tM1pYzEl0jkM43YY+oH/16vMYmUhNg3qsI2HOMcnj8qcIrXXUTehVVQt0yI7tFjKnGMnua6CC/DyRrFgNtwrdqz4rYIIVKK0gG0KRkAk0lzKunMzEtGyEARryGYetbRcqdn0IklLQ0LqVvLtLUNiRiGfHYD/69PhtHLGNpSytkqCBn65rLtZJHlM24B5n+Y479cew5rpLMCAKrRBXYDnNdNF875pLQyneKsiSC1ELJktkLjrVoijGeT+FL1r1Uktjicm9xu4il3Gg57U3NVuIGORg1EQKeaYaaEIRR0pTzSGgQH9Kafal65pDQMMU09Kd15pMc0ANpOtLjj3pO9AhpFN7mn4ptMBnek+lPNNwOBQB1WqTvFaOSV3OQm4dj7irxvIzpe9NpdVCYTnDelZyQRXeoEncVtwoz6seuffpUqxxyasqQjasQ3y7Twx7ZHrXl8v4/kendWSNLT4xBZRhTkkZY+p71aD1EjjOKczogGTjPApS1epEpE+7IphbNQeYQetJJMBGece9LlIlISfbisTUFDqxCEMowGA6irs13xtVct78VgX+qPCjqyZOex7U1OPK0a04t2ZQuNm4tvww5BHUjHINYlxIZY3gKIAH7njHU4/GtW9WR4VdQMOMjHXnpWIt2stzJ9oTY+zCMOeRmvMr3jV02ZtHuSWe9TcxSrkBgevGD/PpUtlcCzkkXzfkBxyOq57Ht1NVLNsxo7E5cbMd/Y/SmXPmbN+QADn3/ABrOpKpB+6tEOyka1xdbpXWEu0Y43g54qpdMyQxyKS8gcsxIwVxjOQaiheEpbKzPvz83oaZPGJQVRyx8wKCzcEHIFUp3XqFktizqd1DFbuFIZpI1KEAcMCf/AK1UtJtG1F5tpzDuAIY9uvFQtIDgAAsIzlT2OcY/lS2H7qSSIOAJcI3ohJOD/T8aqM+eV5aityrQg1SBov3RQlPMyM9EJzgfTGasaauyOaVmUynG1iensKq3nzWEESzZeSdz9704Ge1OsYQ52iTazEqFAzyOh9+tVFPm5ooH8NmzbQrhMvtRlJBHUnsD75rCmE896S+5oy+xXJ6t6/zq9LIrqqMzqc7U3rghe7f0+tNvPKHlLZ/II1JODkkZ4NXOLv7xEfIu2trLYsjzgFVkCuB16kZrpbeaO4RJNoBIPB68VmWNwZ4PJmK+Yoy28ZJGM5qx5phkVII1ZCuAem31r1aPLFWj9xyVLyd3uaQZWYgEHHXFGeeKgt3hjUInHt3qfqARzmumMltcwaA/yppGfxp3Sm56YqxDT2pvU5p/Xg0lMQzFGKcetNoEJSUtJ70AIaTtS8UGgBD096bilPTmkxQA09aSn02mA3HNN70/rSc0AbaTyWGgNeMB57r5hB7seg/lV/TIjDbhpMGaT5pG9SaxdZaY2FiPuE3MSMv8JGa243CqADnjrXHy3u/M7ZT7F4SBRuJAHeoJ5GNyuGXG3gE9TUEsm+IlTkDO4eo71nRhLljJlmWN8LL3GPT1rJwuyFK7NI3xbzlVCrxoGG7oazjfP5xkDAozKCOoXI6GqYkkaaW1DpKcYdyecVnzGLT2PlGXy5CvDc5wc8frTptbsudPsa+q6jEbVgCWcEZCDrVJpD5JmDfK6fxDrVFYWuJ9kcpKFvNZT27Y9ulaBiZ1Ecpb5ORzwBiuKTkpNr+u5pTi1GxmCEwXCwxMEWRcgg9fwrI1SGW0vVclXBBQsq/dJAOR74rRlCR3JywAiQ4cHr7Y9aUSx3NsqyEnbMjYKjoeOv41zRqJq0tGbO97oIkimsnTILBOD0IPr7HNZk5KRKZSm1yUPPC5GK32WNFkdMH+FMVzNzIq3FyGk+YkNhunPXj86xqTcrXY4pXIEuGgeNo/mYt8xBzkD2+lWp5GE5S3xucbwD3xhv6H86q3D263qGNxhDjf9BVebUY5blJYg6sz4DZztHQ49sGkpqNtSpRuw3+deSPKSE3sw+nXj8wanS1hlW4uN7KvlBoQq58x+mMfh+lJb3CzXp8tlV5kCB9uQM8fhkCmT2yWU4V53NsilVkiO3EmCRn6ZIranyLUlt7FKQsl7Am5GXDOuBgZPFa1mhUR3Mk2djBY9qfMD7DuKwYLoPc27ZP7mEE7uec5P4c1t2YDh76NTGkZzHED1B7/AP1qUdNCmaj281jsmluBPK6BQuPuDPC5/wA9axpJmurhpZlEbknJHYdv5V0yPa6jZnZOPMzg9qxby1c7YPNVedrS9uD0p1uZ2lF6MmCjtYvWMD6pbBjIYI8YV0wSw9D6GrMUE9ncCLc0luY8enOew/z1qvZsLWXyss0cZDADgjpzgdRV+bUzIYjAGQ4ypZMgjGea76NSLhqtf66mE4u9lsNjuZZL4xxjCAknPY47VZhFzEzOZAw3ZIPOPpzUUUgmhEKouACQcY/OpA8sSLGMOTz0/nUx5Yvm3B3asXFuY2OFO4+lSht6hhwD61CYC5DkrvHcDr9alUN0Ygn19a9Klz3bk9Ohxz5be6FJTjSHGa2MhlFLSdqYCYNIelO9qSgBpHrSU6kxmgBuKQjmnUlACY9KTHFLik70ANxjNNp+aSmMg1/UJplCMwRbaVGcY6kMOfpXSWEjSWqOw6jIPtXKXUco8Nym6UmSUea2R9zBB69+lat3ezmZLCJVKMm92U9E7D8elcUE43j1f+R0taaFuVZZ7v8A0KbbCQwmc8jJ/u1N5JsNPEkSiRIhlV561YYbLYRouMrgYHAqlczBjBb/AGhIwf3jk/w7f069vaqkklZEN3M+dL4WqyC0DzyEkFMDI6kZ75GazhcOb+J5SPKIBWI/wk5HGf8AIrRll1CaEPZXDmGJyzSyAfmox0wTUdtYiK8MEjLLcG4EglK/w7d2MfU1hKEm7LQ6Iz0uyeBBBc+dO52SHO0cge1TyKrvIxZgnUAHn/8AVUkjlI5IS4KD7uE6Vly3Zt1VpZfmDfOoHUV5tWoqfut6HTQXPIqXKArsbGQSOTjJqILEYZBCzfMM7cc5FR29+kt+zyyYAY8MMj/61Jc3gVYXTDYTaRjGVPNcVecFC63HZ89i5Hf28sI80EZXhgM1xd4wuL2UqcMeMNW48gks/wB2qBUbBw3X/Oax7u3jyXkf92flXyz0OM1wRrSk7SOjkSd0VVWRYv3j/K5KE+g4NQOWhVolYblOVxUhQ+QiyBljL7snr07VXmhKnfExaNzjcRmunfqTuVoJnErsJAp6fLyetSO8k7uXZivOW6dO+KZBp8yTuI4zKynhQecdelWZfJNoyLgEfM4HH0HvQ6iT0KUSCWUpcMQcxsFUjg9B6it60kdpY4FkCq/Tv0rBiiVolZc4bOQT05rRttsc3zhsqQy54zjt7Vcqqvd9B8nY6a0glivF+zECUsSUZc457+1bV3ayLaI8sBZA+6QsuFJ/3ves6DUUsY45LRVmuWXD+amVQ9j7kdh09c1FdSXGoyCXUbmW6cfdEjcL9B0H4UVcwpU4ckVd9+h7GC4erV7VKr5U/vLvm2U8sUNoEdpGCDDAcE8AnPriqayvZSTxver9ojcq0b8EYPQN0NRLCinKqB6Y7VGbRGQkglsk7iec1zRzaXY9P/Vih1my5HdrcqWKsrJ97A+YH/CrK3hSQKEJJT7x7k1kRJGsbGWYx4+XOM/y9K0LXy5LNdzxSKTtLL2x656HpXpYeqqlmmfM5hl1TCTlGSbiuvc1rS8d2WN4sZHBB6fhV7tmsyAOZ1WPcnG4jP6VpKCFGTk+te/hXLltI8Cso3vEMdqSnUnWuowGkd6KU0hFMQlJ3peKSgBvbFJjNONIc0AJSU7nHSkoHYbSEU49aTpQOw3+VJ9Kd260mKAsUtcupIdIubRsTO6sIwpycY/oDUnh/wA2fRY22iR5du6QnBIwMD8KsWmlqtubmUjzZAQ7N91VPYf41haZrE32SDSrFVa6jZ49zjKxgMcE/hXHH3Jtbt2OlK6sjsL3Uks7cI4L3MnyxwxnLMf8Pes3S9NlL+dqDi4aWQsyL/q0b+vpzUcVr/Z+64lI8zH765kcbpPXbnoPanx6zNqNpIthahIfurNP8vPqF6n68Va32u/6/ruQlbY39ny5gZSPusjcgj0rlxOF1yYyXKxvFCEIPfkjI/ACrkyypGVmuZmOfm2ny0Htgc/rXK2txG+qzyPMyxjjarEBwPT17/lXn4ms6dRNfM6KULp3N2W+cXmIneUJ0BXAbPvWbqd4ZAZZIRtYkEDnbjFLao87PNBOpRuQuMgY9feobuREs5biRQAw2sDxkEgf/Xryq0FN3b3Ouk+RlKO+igtJVVwZ5M7lbsRVBrtpFVAc45GTjA7iq8Me69lMgLMoOMHJ56fWmRxsLh2CSM7Ywn4f41xSV3qa6OVy1HdStH5AZSso3cHGAKqQOxnkfIIORgjAJqxcx/uwZYgrIOAp27gev6VWjXMgyoEZfIIPDcYJ/lUwgndlSlqSSmNVJT5w3Vf7vtn8Kihfyo1BT5QMMQvXJosbv7JfRTuimNJCHRlyGyMflW1cLayzQai4dVkQsbbBXeckDBH8I/z3xu4JRu2VQozrTUILVmLDtjlVoEYySoAp3Z2H8u9UntnV5CGZmXO/dwDiuxlmnvrVIMpHbJjZBGNqD04HU+5yagSyiTJcsx9N3Fcc8TGMnY+no8Oyklzyszl4JXVkZwCOdox1rU02J3uDIZCygA+2a0zZWrnlTxUMUkFswt04VTgH1+tYzxPMnY7cLw+qWIU5S5oryNKMBF+tOBqHzBjg8UqtXnSndn0DiWV5qQr8jY9KgVulTq3y1KkYyMyUeZbyj/a4qjZ3BtbhQ5PlOcOAeoq+v/LUf7VZN5hLpl7ZzXrYao4tWJxlCFWlKM0dhYzpFIysx2g7hyfQYxWq0fkymVZT8xAIJyDXLaXeOIwhOBkAODyK6GK5eUshVm2gEMOjV9dg6zlHXU/I8bQ9lVcOxfQuclgAPQU6o45VccMwPoRipD1r1ItPY81qzExSU7nNJjnAqxDTxmk60tJ70BYTtSE8UtRTzRW8LyyttRep/wAPeonOMIuUnojWlSnVmoQV2x2felMbqgdlKqeASMA/Sual8U3sNyHs1jiUAhdyByPfnvVN3m1C4NxqE8txKf4pWJNeFXz6EdKcbn2GF4OryV68lH01OtmdLa2kuJm2RIQp4yST0AHc8E/hWc+sxEkQQSPzw0nygj+dZc00si28Zldooz8qk5AqTeAACOOteVic9q1Ham+VHs4LhbC0EnXXO/uX3G7bzpdj92CJO6Hr+HrVlv8AR8pn990Yj+D2H+1/L69OehuTFMjxsVdTkMOCK2g6zRLKvU8MB2NelleavES9jVev5nhZ9kUcLH2+HXu9V2LsTQpBJJcGQS28ZZ4ZmB247jA5HvXHeHPtNxbT3Gmr5l9NO7OZFxGq+57n2Fb3jOaOYWmmxqTe3DhQyH5lTPP4H0rZhtLSzhRLdkiiiUKwX6V68FzNyb8l+p8unaN+5UtNPjuDFPfebdTjld6YRP8AdHT+tMumkjuYoF2xpIxxuGffFbKqY4gBJkDuR2rPvrqFoJIp4fMGMFR1P0q5zSIu2c/q+q/Z7O4iM6ks5AO3OSRgD6e9c1PqdqkiKrMrRKFAIzz3/DrRrbRvd/YA8hhQF96L8ysRwue/SuZCXjXMckrM7q2CrdxxXzeLmqs2m9j0KMHGJ2NjdRwRMhduTlTGpKt6n/69V7rW4xEsSrIcybdxwVI96yo77zAVSYRLvZQoGGAqw8cEZMaDfIHJy3QA+/SuKdW1tDdRuSTnyT5jSiTJG5hxgfhTvtCNOzoqjdggZwevJFVLi2zKVUdVzjPt/jQL7y2jkCqzj07D0rNWnruX8JbmjSZRF5uCDkYySfWq0EfmrNAwUGIlsk9Mdx+VTm9ZZ0k2AoTnJ7Z9/XrUslpvufPiKncNxDcDPoM9c1UpRjG3UcKc5ytBXM4iO4s5fM3bo/vKnT25+tWZJHkmjiJP7uNUA9ABz+uamg0s3GoQ2wUwiRwvyncOTiq8cqyX9zIvKtIxX6ZNRKSVJyTPocjw8niGpq1jUtH2qR6VYcgjNZsMmHPNWfNyMZrypSufdOnroLJJtUn0Gawd5Jya07qTEL/SscNVUVo2Eny2NK2vCAEc8djWikma59Wq7b3RBCsfoampS6otWkjbR6nR+1ZiTZxzVmOb5xzXNZpmM6bEQfvJBWTqC/6SDWojfvGPrWbqB/0hOetd9CXvIVVe5L0L2l+YWcRlA23q3p/WuvslURxs6KrHgbVyPxNclog36isQjSQuhAV+Bkc/0rrLe4dUaN42hk8zadoDfQ19nlkU6akflOfRccS/PX+vuNDaMdKXHHTFOxSY4r2T55jcHFN706mu0UUUk9xII4IwC7kZxzgADuaU5qEXKWxdOnKpJQirtjT1wBTcjsc4681x+t6/Nd3siWmYrdTtRFPJA7t6k/lVO1vJ7dhIJCr+xrwq2eKEtI6H2GE4QqVqfM52fod0T+dcjrGrfa7nyoj+4jJA/wBr1NWbrXy+kTjG25xtBUcEHqfbiuagfLc1w5pmca9NRpPTqe3w3w/PB151MSveWi/zRNyHGeR61cSXjFUnfAxSLKRXzcm2fauFzVMnyj2NPnmG7joAKzBcZBFNacmseRmfsNTSgk3OTmrUmqvYws8bDLDaARWLHPt71Bd3BkYDPArWm5RldGdXDxnpNXR2WlMmqeL9Q1WRsw2n7mEkd+n+P51vzwNOgkt4Qzt8xJJA6dKo+F9N+xaDbuYis8w81n68t/8AWxXSDO3BAHsK/S1Hlio9v6/M/C5v3tOhiWl28klxDICZz0TuB2z7VVvpFmlMyO2yOMuqD7pYDua1LzyWMrICkyDPmgYwa4LxBrckFqpsrg29nO5XcRzIT94j2965sRVVOD6hCDk9DjrnVJHv5boT5Jf/AFYPY1Il6r3HloGQbOCzZH4U+3tQhaSKQ+c65ZVUcKTwakkuLa5tQjQQoWfaXz8w59B3r5maU5NWPTSsiURxFQ20RybQBwfmHc0+BioLyh3XBBypwPf04pYY45HKuxGF+U+3pg1FObuDYu07WyAScA8nPHrn+Vc7WvKaIHvzFIzeSWUnG3IGD64FFnaM7s2xkjDHIzknHYH8aje1e0dZ3UMWwxBGMc/r0ptzImZGy7eYuYyjHg8Aj34p6WtDqCLQiNs+yTcItxIXdyPUf/Xq1BcG5mkbG1RwqjsPSsUuQBulbkcIwOTV61vbeKNQchu5xWNdS5e59fw3Cirzlo0as101tAWjcpIBkMp5Fc/FciJgehBrQvJVktgynPFYjms6KvBpn0WKapzUo9jZS5UsGU8GrPnVzCTPC2QePSte0uBPHkde4rKpR5dTbB4uNZ8j3LUrF0YeorLDYOK06y7hTFMw7HkUUuxrjlypSRIGp6viqqv71IGrRxOSFU0refPGeRV6KX94Kwo5Cjg+9aKvtdTXNUpnoUpqrHzRelnWFDI3QViG4aa7DMal1O45WMHjqao27ZmzW+FhZXZ5uMrWvBHTaPI8Ws2zp1ye2exrtI1iuppAZgW2feXgr/hXGaMu7WtPPqf6Gur1VGjXcGVVZSATnAPvjnFfXZVf2Dku5+d8SpLFRXl+psLjbwcj1o5rN06ZQgBeTanAGODn9e9afBGRXsQldHzElYYa5jxjdvHYwW4JCSOzsPUgAD+Z/OuoauJ8b3MbiOJM74W+f0+YZH8q5MxklQaPWyODljIu21zkY7pkbryK0hLuw3sKwMky8dzWmsnAr4vFq7R+qZbUsmi3PJ/ozjPaqlvJkYzzT5m/cP8ASqMTkHiuaMbxZ21qvJViag5pajikEi5/On1m0d0ZJq6FooopFiE4GarM2STUlw+1APU1W3cVpCOlzjr1LS5T3hEEMKqOigAVmatrUOmKkbfPPKdsUYOC5+vb61U1PxOquLPSYWvL2RcqqdFB7k0/SNESBGu9VKXOozLmVpMMEH91R2FfoV3LXZfn6f5n4Oo9ZFBrVtRTztUv7TyoPne1t5ML9HbPP8q8y8RaymqasAhAtYWMdvGBwseetd341W3stIkmha3ZrlhACEA2ZHUY9q8unkErO4iABwqbTwAOK83GVLvkOqhH7Rqxa4hDm4YNNEuFZwfmwDt6ccVm2NzG90Cy7HdyQ4GQB6YNE2mSeaywsJYwoLyJ90Z96sabpsU4Vll3FeTx1P8AdxXltQpycmzrSbWhqfaVkUeeoAYcFABn3+lKu2c+T5gDht69/qatTKIIWhitCEYBGYoSFc9SPwxWYfJilKw4J+4GPGfz6VxTlzttFWsWJ5RMzrJkyKoVmHAUj0/Sq4ciMBvkMZLKMZB9cfhTEXdO+SQpJyCev40SKUt2Kn5gSNwyOB35FEY9ECZPLECMLJ/q+hPy9e1Zsg2seo9qvWzLJZbVIZQ+1iTjdjmm3gWdwFlBZQei4z/n1oS6M9LAYr2FTXZ7leG52qYmPynp7VAxqKVWjYqwwajE2ODSUd2j6n61zRSb0HuMinWdyYJxk/KetReaD3qKTg5FPlurMw9s6clUg9UdWrBlBFVb6HfFvHVf5VFplx5tuM9Rwa0DgjHavPadOR9dCUcVQv3RhB6ljfNR3kRt5iP4TyKrrcqp5NdnLzK6PnnV9jNwn0LzHAq39rRIUZm5xWDcXuGGw59ahFwX6mj2DktRLNo0pNQ1ZrXV2txKGUYAGOaZbyfMx96z1kqWCTmtI01HRHJUxTqy5pdTu/DbCTWLNj/CrMf++TXYXV7CGCAqeDn2rhNAglnJKcKE2sc+pzj9K6Y3FmbYwEPvQElcElfU8f54r3cvlKNFRva7ufKZ/KNTGX7JL8DXhlE8CGKTkAn5ep9a0FO5QTxmsC1vEiKtDCvlKPmbbyo6/wBa3I5VfBB6jI969ilU5m03qj52cbdBzAivNvEzedqepAD7u0j/AID8p/nXpR6V554itTF4glD5CXKnafXI4/8AHhXJmabpp+Z7nDsoqvJPe36o45P9Z9KuK3Q1S+5Kc1GtwySZzxnpXytaDcj7yjiFSWpenvVSRbdusikg1XRqyNWuNuoRMv8ACo/ma0EfKhh3Gan2XLFPuc8cwdetOD+y/wADRt59jjJ4PBrRrBD1rWc3mwDPVeDXNVhbU93L8TzN02WRS00HrS5Ga5z1kynev+8RfbNQbuKW9b/S/ooqHdzXVFe6jxK9X97L1PbbPTbLw/Z7LVGMsmA0h+ZnP94mmahI8UYZZF3BWYbmwCO4JqzboLqeSe3uFNvtVFC/MCMZJB98j8qbrVlDcWgMkhiKsCCOnvn2r7ybvG9z8Yvd3Z5Z4wv31G8s9LhUYBB4XBJbA59eKzYreOW8NupXchIVQMEYPTn+tXVCTeLL69kd/stqGZZV55UYXB+v8q56SCW3uVadmjfq+eozz+v9a8HFRcoc19Xc9ClpZHSw2FzFb+QAGDk/PtyR8p4/E0tkPsjyQLs3q2HWOPdkY61lWV+Fl2uZ9uOHycj04rV88fafO2ylj97cvBHrkfjXk1JyS5ZK50Jdh7zAbYVjGx2Ics2A2P8ADisL/RnuJQqsVU4yoyv1zV2WfYzSJLvjXccDkY7DpVC3umuLeRSEiBI9z19P61MXJpsLAHWGQmNmcBed68ehxTp7iW6Izh4u2TgfSop1YyZTe4J5JwKc8xi2N5QAHO3JxzWl1o1uNXERZLCdZHXajYyB/D+FSFxdOJfMVcHBRRz/AICqzSiWY+aDtZednOTSQPhJWZyrJx16mh3er3KTLMdjksJmw79B6d//ANdZl1A9vKVcfj61fa682JXkKsF4AAwR+NOcrd221iN4FReUXd7H0OWSjXoug9JLVea7GKTg0pkyMGldCpII5FRGuhakSbiWLW9a1ckcg9qvprbjgqMVjGkyamVGEtWjajmOIoLlhLQ3JL1LyEpIAHHKmsS4yCeaUSEVHKQRnNVTpqD0M8ZjJYiN57rqRBiTzTzL5a+9V9xzwKa26R9oro5bnje35VpuaEUu5Cfzq3b9Qe1UYYiECDPqTW9odl5t2uUD7RuCNwrfjWahzSsjphjeRXn0Op0yMw2EEUUoSeU5LHOFPHHvx/OtyO2knkKMfJnUnzCF4I5xg/lWba3CXduYDEIkU4CqfuEdx37VvaSq3KB5VZbmJsMzDDH0yPSvbo04tqP9aHz+IrSnJzluy2tuHjiZlQ7gAXHT6fStKHyyhEePl4IHaoYLTyXfDDyj91MfdqQL5LKqDhvWvSUXHU4W7k2Kw/EelnUbHdGP9Ii+aPHf2rdpjDIqpwU4uMtmXh686FRVIbo8U1eMLdmRBhZBux6HuPzzWS3Br0Hxlo4ZDf26YQtiT6nuPauAkXBr5XGYd0p2Z95hsTHE0VUiZWo5e6/4AK07Ft9lG3pwaoz7Xujz/CB+lW9MkjUzQMw5+ZTWFT+GvI4cBU/26UW/iuW81csJdspTPDCqD8dKSC42zA9wa5ZQ5os+io4j2NWLZ0Qfk/SoYboS3EiD+Cq11drBbvJkcDisCDUJUeR0YZfrWNPDucWz0sZm8MNVhBvzfobVxIHuZCD3xULSAA1SjkYIWY8mjzN30roVO2h5M8ZzPm6s9sGlaxoE7XNjIt5bSsGmtSoTDd2Tt+FVPEXiYDQ5ZopUDHgRvwwPdWXsa6OTVj58SRjeH64jYn2+lcD4rhj1fxvbWcI2SMiiU7cD159TivqsQvdSj1dj84prml7yK0OnrbaBp9jG3/Ey1KZTMj5XKE7gD+GPrmofGVoNP1VHeRC0q/vCicZ+h+oH4Vv6mZNO1bQLy5WP7OsrRGSFDv3EYww5/Sue8f6ZcrrFzdRq5gDKpOc4O0daxxseak0l1/yNqbbmmc/Df+VKS8ZkynBJOQfbtU9kHnlPnT7kOcKh5J+nf6VmQwS3dwqhXViCVABPvx6CtTSLPzbeZ5UbeGzvMecc+vavn6sYxTtuejTpym0oq7JnA8kQtHK0ZIG3O0kenfJ96pRPFCJAqi3YZUsQSxP93Of1rVOg29/eFRqtpaxtyTMsg5HvtI//AFU268MRWGy3XU7O5DknzbdiwH1yBisWlGHNfc7Y5binPk5Hf0KtjbfbEGVPlq2C7DJbscCkOjIZVjmupI7cN8zCLc312lh/OukTy7eJYosbFGARUbRxu24qCfU1x/W3GWh9dQ4dwsYJVE2zl1sGiXIYFS3OOMiqc8BikVvmUP75rrGhRVaPHyMOPY1z99bSxqr7ztU5GD09BXTRr87PHznJlh7VKC93r5EGDHC0bOAFPYZBqETCOTKHP97HenPci4ZRISMLhsdTjpSSp5dv5qrj1Hp7muhxW3c+fp1J05KUXZofLElwu9MBvbvWfJEynkVbtzulUMDzwCOx7VIxV96sAGX070WcHY9mONo4hfvPdl+DMwoRTCKvyReW2HUjPfsaasaHOSKpTJlTvrFpmc2egpfJPViTV5olUcCmrbs3LH8BV8551bnT1KDKoOO9Wbe1Ji8zbxnHvSSQAOHCnBq7aRncGBIxzketU3ocqZM0cUVoUXAY9Sep/HsKuWM01pcJcwkomArZ6H2qF44xGFdxlnzgcmpChS1C7y27+E84FSk1Zoyk+bc6ezle/E87+Xu3KqYGB9cdR2roLAqhSZXKh0IKN/eXvWT4dhiayLJMrOuA2RjH498VJegDUYIWuAAWydgJCc8e1e1SlywjLe5wzV5NHW22pW8zbBIu7GetXcK5B67T+tc9YW3lyBvLabcud+QA2PbHArRiupIZGR1xHnGSchT3969OFR2945JR7GiSAPpVUyC4faoPldz6/wD1qiupnZC6PsiIxvBwTms2TW/JjSOFYyBlWJbAB+vSs6tdQdmVCm2tDWurWK6tngkXMbrtIryHX9Gm0u8eNxkDlWA+8Oxr06y1lJdkUjhZGB++CBn29RUmp6PDq1n5VxjeM7HUfdrDEU44uHu7o9XK8b9Tny1fglv5eZ8/3UZ+0E02FWjlBrb1vTzYarPbMQTG20kVREPSvCleHus3nUSrOcX1HeeUX5ulVXuB5m5aleA7sMeKiaFR3rOKid9XFSkkkRXV5LNhWJwKhiYrzT3UFsKM461YjiBx8jc+1a3UVZHG5TnU5pO7GpNITzk1cgV5WVVUkk4AAySantdOkmYbY2x3J4FX5dGlVomjnKpuCkqOQT0P51nbm2R1QxDp/G7nsbefpzmW6kI358tQeS3v/n1rldGb+0dcvNWnlVh5ojA2k+vH5D9a3fGt6LLR3mUOZpFKoWIPUckfTNZXh6BbXw1aOIw0r7rop03c46fSvbcF7STW0V+P/DHgQd4X+RoRzWt7r1vbsm5bMhyhONr+uB169ai8R36WmlapcyCKUSSiBUJyD8oz+OBVHR5Y1hF093tuJ5d8gMOSg5x+XHGaq3dhLq2qXEl3MJLcsTDHu2qWxgMR+VcUsXTjDl5tXfr3t/wx6SyrFySn7N8voZ9rAj6f9surdGtYmEaRb9rzORkKCvO0Drz7dTV1FeSBGnI4AwijCqB0AA4rNjT/AEnaAAqnAA6D6Vou+FA9BXztevzO0dv1P0TKsqjhKalLWb/DyHgxAcIv5VFL5O1mYYwM8VAZcHrVa8n/AHBAPU4rkV2z2eTlVyFJGRiUfqelXIbkOMdG9KylepFkIIIPStZU0yY1EzWf5kJHbkVk3J+dx261fhnDrg1Ru+JPqMVNG8ZWFXinDyOfeMx3EgYgKTkVIAJANzcNwT6VNdopUMeoP5+1V0VsZAwG6V60XzK5+Z46iqNeUFsWLaNYW3NIB5bZBHOcdqsBUjYNEoJkGWLDP4Cq1qYjuMgY7RjA7g+hqe6ClEEcLKoGNu4kionrKzOIhZzjDjDZyCfWpZ7eNbcMB85OSFPXNRssUaoCqGQ5wFPP401BIDgYJJIK54FWu4hI4xkhgHIXPXpStE6oGkAVORjNSKFe3dNh3A56dMVLcW5nt9qyqzgbVQcZ7/jVat6Gbl3K8bm8k8oxBlKkBsYwB3qWyjMTGGQYPXkdR2qAQXsCRyt91crtb+H2IqwrmXPQGEZA5yRnkD6ZJ/OnKDjoOD1NPULKKO1txbxEpKMpJtwQwHzLnvgn8iKomKRlMkmAV4BxjH1FdJot3FLaSWk33XxJCcZ2ygcfgwJU/h6VX+zW8nmG5laDeT16Nj1rSl+8WrJqe7qLYyJZ6dJLFcK8YxuABBJ7jIrKn1qeS6V12gqBggcNiobu7ChYLZhHCSeR1P1qkx2zfOHK8kEDP1NbyqNe7EyUFuz0HwxrE8weLALZ43DIBPv6V0i/NGYo1DIX2nacjPf8K838OX2+Y2/mKkZ+Ys7bRxXe3OpLDaJPGVEjnG7P3ewyBXp4ev8Au7y6HJUp+9ZC3MsUx+zbWaMDJwPu9iPwrMv5YoraW3XKxRg7SUGWPBHP1rQslumhMsxVfM4fIPPpnn3JxUd/YtLGu1WORt+VgA3UHj06UVXKUbIdNJMzLKBrzy2ZMqDuyTjZ+FdRbzbUEcgcEDhmHUfhWHocAtpjbyqDHIDtccA4/hroo4SmwKoCAY61rhebl8yK1rnjni9MeJr73kz+grHjXNdF42j2eJrvjGSp/wDHRXPpxXj4pfvGdsH7qNGw0C81reLNEYoBu3OFIz9a0f8AhWupqhlZ7d3H8BkP+GKn8F3v2XXIlJwk2Yj+PT9a6zxnrQ0vSzBG3+kXAwP9le5/pXXhqNB0XOS1Qp4qqpKnFK3oeQ3Nkbe8ZCB1wcHIzWvpVqm0NtGQcHNQbPNtxIRko2fwrXtkht4hIXCR43MzHgV50rRmkdd3KNyzDEW+6M9c+1Zuo6t5ivZWGGB+WSfH6L/jUF5qMt+v2a2zHbfxN0aT6+g9qILZY1AAq9zI3/FF6dT1q3srW6DwlVGARwP7vHpXQ+INWhsxaWukyxu5hCOyEkx442+mfz6VyOkGygvDdF4w6qcE9iO4FTRSxyXs0qZILllyedpP9KzxOMkqDUer1PYyHB0KuKUavTVeZrxDaqjuBz7mkuJmjgkYHBC8UiNlciq96+LV/cV85zOUtT9IskULe8UPiXg+taEsmVyDkVhMKI7p4OOWT0rplSvqjKGI5X7+xpM2TVS9bCL9anjkWVAynIqK9TdbkjqpzUw0krnXXfNRbj2KatUgaqytkVIGrocTyIVS1HKUYEUXkgLqPXnNVt+KZJJuKHPQYqVD3rms6/uOJHcuUTIUNyODUHnt5AhLBgufy9qsurSuFRSxI6AVVnY7lxgHGPwHauykrqx8RnNvrL9CUKixoUJDc4GeM+uaaZppFwZCAoIJHHFWJLdVslQxEOGO44xmmwL5a4Cg5XGTyB/9erseQQo+7aQfmQDGB3/rVhb0tvCxbVZuW7k96bjgCJnGRnG3vSBWfKySBXi5Vdvf0NHKmyWTAZj4jUEDI28FsmoUYRyCTKowbGxwefckdKsR70lWKXaDjnj3p95bQWV3JbuSEbo2OGojV5JkuN0U5LxhHnygpDdc5B59Kv2ZkSSGQIC+4OUPKuM9Poc1mLavGAZNpgc/ePWrH7mO6LRb2hUYDPxg1VafPsKKsapKW1+6RZ8ljvjyCMA9ufTpn2qbxC0t35F5EpIddsgxx5o6n8Rz+dZkbSSKY8MzoWkiZR8pUfeA/Dn8DWtZ+Xe27WzkBZhtDf3X/hP0z19iax5nF3XU1+Lc5krJLMnlhiz/ACn0JpWt3BKkhsdgOatOrQOwfeksRKMhGOehzVmzYtLiQohHPmNyB064znpXTTleyMnFhpMUiXNu4iZArgAsuctkdv8AGux8kvK91LZONx2CJuQvHr6+/vUkENvY2nmCbdcy4LFlGO3Hrg46VuXeo22jWqR6g/mXsg3Law43ID03nov6mvVcaNGDU5WM6NCtiKijSjdkenhXea0k3I8e1goJ6dfvd6mtf31oThmkQlRuGMVz39uXnmk20cUKE5Cld5/M/wBMVOviB4IpPOgYTZ3IU5Rj785FTDNKN7N7Hp1OGMcknFJ36XNNZY2umMyFdh45zg+o9q04DG0eY8H1wK4ptdl82N7yOGWFjhnVcMB7YrrbKSOFFg37um0/XoPf610YHFxqt8ux5uaZVXwLSq9e2x5p48XHiScjuiH/AMdFcsp5rqvHx/4qOb/cT/0EVyamvPxj/eSM6fwIvWkrQXEciHDKwYfUGuh8VR3OvaxbG1t3CtbqxZiAuOSTnoBzj8K5dGwRXq/gu5F1oflPgtC23nn5TyP608F78/Z3tcirJQ9+x5/cW1lpaqkt00qOh3siEKT/AHVJ5P1wBTooRPZyWz87TjNeia94e0u6sbu5ls4zcLEzK/IIIHHSvPrcbZUPZ0wfqOP8KjMcM6Nne50YasqidigIfJUgDlc0tmzSRFm65q7coFlPvUSBVXjgVEXdXQNa2KjzfabcyKg+VV5PGB6e/TrT9OnuJ2CQKGSIbm28gDoSayrW3u7+RobQM0argn2960LOy8qOZfO8vGAdxwG781lOlCEfeWhtSqzpzU4OzWx0Vrco3AYFe1F9k2rY+tYENysTKYvukc8962IrpbiIqTzjBrxKlFwlzLY/TMBjY4qgpX1aM7ORUbDinONkjKexphNdCFN9GFrMYZ9pPytWrwykHoaxJOmR1rTtZhLApzz0NRVj9o6MBWs3SfyKE8ZgmI7djUTSYrRvVV7dieqjIrDaQ1tS99HnY7/Z52Wz2J2mJoR8nrVUPUkbVry2R58a7lLUnkn8khsnqBx1pUBnuGIUhl557Y61VnJKg4yA2TQk7hSmTnk9a0hHTTc8HNJqVf5Gg12ZYgsnLg5VieTUtpexeduuB84JK5Hyjis6Nma4BJMmB/CKZKzlsMAuD2rVKzPLeqOhm1GxBAVAT5YCSJxhvUg1mMI7gyyzThdnO0Dl+eg9KhDJ8wVPlODuPJx6Ut3CqMDHnay/rVxTer1Fy22JoWVr+AxwlYndEG9sknI6Vp35V5WkeMOQTtySMe9ZsThbizjHAWVWB98itedASQRnnFcGIk4VYyBxsjHMyzyoI4RtXsD0+tOWSIuwbBUnqTz9KFH2dpUYABnyOcdqHlEjBguM9j0+tdSl22JcQYTROtxBOFMbfIUfkH2NaVttjlwmfKcbkz6H/JH4UtlodxqEIIRY0HIZjgt9B3q1dmzSxiit0KyQcmQ8mU/xH2A4wPY+tGIjaCudGHoTqqUo/Z3DUdHe+tFure7hDOxEsTA+YXHcYHQgjk45zVGCzvrYeW8RKjkeXjk+/fFa2m3YAeMgsswC4yeGzwcd+4/E0sku0nPWvNqYiUWkkfTZVlWGxtBuV+ZMt3epSQWSFQY7uQghQciPjkj3561StEUs00pLyMclmOST61QlnZ5izEkDge1Txzjbx0oxWIqVnzM+ky3K6OCpezp6vqzQeUFs9KJ5lNqwJ56Cs8ykmoZrg+Yik8CsYts7501FXFWZot0TYIYfLnsa7zw/uuNDsbgYMkaFOe+CRj8hXntx865HUc13vguUSeH0UHJSR1I9O/8AWvoskadRruj4zjGDeFjLs/zRxPj8f8VC56bo0PI9q5Ida7b4jR7dbjbs8Cn9SK4j+KtMarVZHxNN+4ida7/wFc7NQktyeJYsge4/ya8/j5NdX4am+y65ZN0BcIfx4/rXNRqclaD8yayvBo9M1BN2nXS+sTj9DXk5Uoh4OY3B/A8H+leu3S7rSYesbfyrzCeMyhlVRlkP/wBb9RXq5qrpLyIwD3K12Mxq4GagghMrHmrlsqXEUSuSqkgMfQVJBGgg8xM7Dg5NeNQn7tjunHW5SsbcaXpyrKzRqyb5TkDPOM/Tgise61CxvGRfmWJGIROm7PcnvVXVNSNwVhiI2jAYnksR/TOaq2+nyM5eZWSMA/MRx+tdNeSemyMoX3ZYluSUxbxoI0wGKjlj61YhuX4ZGw1VIHkj3vsZ42IDNipSBglchuWY4zuPoMVzSpc2kUevl+PdB8rejL5vBOQWG2TofelLVnk5OGBRx68Uec6jBrmdK2iPpo426vJ38yzLKADVQ3UiZCOQDUTyFupqEtWsaa6nBXxcm/ddi59vmZCjOSD1zUbNkVW3Ad6eCSvPyj1NVyJbHPLFtr33cfv4JzwKkgkDAnsO9QPGmwF2wnXaO9NkmYxqsUe1D0NPlvscbxjjK5eTEoJD/KDggdelRKoLNGhz3JzzVaCVsNGpwp5NSwzJDKWVMuOGJ7D1rWMLbHm1ajqTcn1Lrg2yqIpDux8z8gZI6VEqYUP5m9x94YzgVdubqO/MMabE8sDv8pPrVJrqRpGjwFcfKSDxis3e+hMXc0N0LQp5cQjyMuQc5P8ASpYRGql3GUTnBqhFcZADYLLwOMCrEkmYkiB5ZuaujTSu5bI642irmg0UTW8FwAFO7JzWlOn76VcdGI/WsS/k2wrEGxs4IrdlbdMXH8fzD8ea5cxilySj1RhWlexj30aLiZlJI9Bmpk02do4yWXhgCnAIzyOPcVYmi8yN0PpVeHWZ7ezS0aKOTy5CwJHzH2zWmCqQlDlnutjH3rqx0j+JTHZGwFnabB8vmmP5/wAG7c+lc3BL5jqAcFWIP0PWq88pcMSME8kGoLSfyrhSemefpWNaU5LVn3NCjQppOCsmlcu7zbTSQE52ng+o7Gr8s/nqs3TcPm/3h1/x/GqGsIV8qdRwPkY/qP6iq9rd8SRk/eGV47//AKv5VyOHPFSRhl9T+z8xdKXwy/4df5FnOaFk2HPbvTATikY5BosfUe0a1RdVgwBHSqc7YnNSWjH5l9ORUV2MTA+opRVpWNK1TnoqZKHzGRXQ+Ab3Zqd1ZMfllTeo91P+B/SuWD7VrS8IS7PFtqScB9y/mpr0ssk4YhNHzuexVbBTg+35amv8S4f3ljOO6Mh/A5/rXnX8Ves/ES283QYZgMmKbr7Ef/WFeTsPmNepmUbVWfnFB3pontxvkVR3Nb0TGC6ikH8DBvyrL0mAy3G49F5rSl4avDnUtVSXQtnr8rbrV2HdCQfwrzRTtmznJABr0XT38/RrV+u6BSf++a85xhjX0mPd4wfkYYT7RBCDFNMi5XY+R9O1XvEmk30VhpthJJG0EO3LxqR5wIyrZ74U7fY59aquHS8RnxmVA3AwPT+ldn4f8fW9vbxaLq9ks9pGpUGQZHboe3WvCpO05RPSk+rPELNjFIJmCvk4GRmrD3Ekkm2WZigB4Bzmm3NtLpk5tpYyrKf4hmpbe3GCzKoJOMHiuuUdbswTvqSqs8UwUKNsi5wMHArVVBau0OWDgglj/Hn69OOaymBhd9qoxXgHdjPPb1q4bO6a5yc7NuWZlOCB7VjKooP3dCkrrUZcxSavfeapYRxqE4HCj0/rVaW2mgneE7ZArbc54/OthYI5rcQ2bSu4Xc8agjBHfH4c06ys7aWwubi5O6WNVZYgcI2eDVuDlvv/AFsb0cVUo/A9DnZIl7h0+oqs6ENtUqR6k1tRNLHP9nK7FY5UtzxVGe0Iu5E/gbkMPfmsIy1szpnjedaqzIEi+XLbR9KqsCZM5yK0Y1eM7FUsm0gDdnvSwrCkLJIoJY9sE49v1q7tM5JVHJlLYxKHbuC9BillxiNwvOc8H9MVsafCiSZO8o2ShIxuXOM/p+YqnqMLxXIj25G/5cDqO2KFL3rdhTXVFO3YFyAAAT3qwNNlnlGyGR2fhVRSSTT9MMEd0JJo2aONi2AM89q2W1u2jdp0lcy4wAg245zn+ddNoqPMZOTvZGHNEIpSjQvDtGx0I6HvQ0gtR/o6jLDaZDzn1wKvTSWt3K05Z5CV5Vj39u9UXnxBGjKrBM7cLg4z3Ncyd3axpFiiUgjeq4wMleM1Zt2D3UP90MM1SkmknQMSuzPCDPy1atQUAfPA+YVcrKNjTm0LWpSRidsYd3HT0roI23W1q56mCP8AMKB/SuXknEk/mFGK56dO1ddpjxzaRargkxhozk575/8AZq4cTH90jObInQgq2PlPFZN8DBIWUD5upxXT3EaiBcDgVj6na5h3joa5KE+WauTFmMZTIpyST6nvUDPyKsM58lIAT5gP3fWqsinnIwRXpSjbVH0uX4pzpcj3RuI/2/SmhGC5Xbz6jkfyrno5SpDc5U1bsbgwycHpUV7CI9QcqAEl/eKB0APb+YrCnHlbj0Ns39+nTxMd1o/0NRWUjKHK9j7UdaqWhIh2k/dOKsbxWMo2dj6HCYlVqMZ90T23Ex+lLfLmMP6GmWzAzH6VLO4eGVf7tZvSZ6MeWWHa9TOd/lFbvg20a48S2rgcRbpG+gH+JFcyH3S49K9P8A6W0VnLqDrzP8kef7o6n8T/ACr28soOVdPtqfF51jYww0+7VkbHiq0+1eGL2MDlUDj8CD/LNeIOp8zFfQ91EJbOaNhw0bD9K8Eubf7PqkkLfwOV/WvQzVWafkfD4Z+4zZ0u3ENtnHzNyaS4GDVm2OLf3qvcDk18lGTdRtm56f4bfzfDlkf+me38iRXn7cSkHtXceDn3eG7Yf3Wdf/HjXET8XLj/AGj/ADr6zEu9Cm/IywukpC3x3LbSf3CY/wAMAj+tRFP34fAwAfrzj/CprpM2Ln+6yP8AoB/WmDkA56ivApytV+8773ic3fMiyfPncWJ3Y5B+lU7iWa7jE6rkZCkhcYIHNMIW9vJ2LCOBAW25H4Ac81oQeQAzRwtKsWc+W2DyOM/jXdGMlHVmN0XtKhiMdtbOxdmUlemQ2eQB16VJcW1xtuVR5NwIKhjjPPv1GKbbNfLp8aRWRjcyEiXYcn2yenGKWO6u7i42SRsm3DoqKOWIAH1p1IKLul+AJt7mlZ3Fv5nkXEawrkBmj5baRyBj+dc/dxJb3zfZVDKJC0IxkEZ6Gp0uZrRhdRStHPGxys5OGGemPWql7qT3sxKZ85+QuAoXPUfnVOd6SXUFFqVwmube5lkluWeOQjBQqDxjg/nVKe4aV18s7cHG71B/pVe4ja1k2glpGHPpg0gMzH5gPl4wO2K5Y018Rpcu3Esf3IQrBRhjjH4D1qNbUMyOdw9AFyx9hV6xeJRiNP3wUnlCd3GeBUOI3lmknl2Y5APBPoK3hG0tNSGyza2k7aatyfmcyNsRR90Drn65z/8ArqxI5msi8UccjopwGGcjvj6dR+NYt1rFw9yx/wBXgABQMYxWpa3wmcXC/KZD+8AGAr9Tj0B6j8ayrxXxpG1Nu1mY9tJIttOUiDZcDIPI57Co7tBBPtdTGrfMU64HYVd1a3FpIpt1Ijl9eme4/rWSwaUfMzNNwBk9q3jJNXIaaZLK27b5ZXAXcVz09qfLMJl42wqiDC5PP0/Os8Bt3PWpnPCg9hik463Y0mWzt8seW+5cc9uaI2UjBIyeOarxttQjaPqa17XRZ5LNJsR5mztUv8wH97HYGs5NRV2zqo4epXlyU1di2jWzwOHidiDw241t6JKPLmiByAVZRjHHQ/0rIk0mS1kjEu9VfA4GAfxrR04xW1wI42BVzsbnnOM4/MVhUhGdNyTIr0J0m4TVmdL9+3NVioltWRu1TwHKkeoqKIfvHU15Ddmcmxy7O1nqiyjIK8ghcn0purTy311JePbmPzCN5xwW9far+oSzWMzTQsEPQnaDx+P4VmrrBhkaBcy2vOI5TwT0yfwr36DjUoq7NqFeVKopozixU7gasiU3EKE/8sjj8D/9cH86qsdxJUcZqWzx55TH+sBX8eo/UVjKJ7Vat7Si1F6MuohUFvlAxk59qrXFyEdXU57GtSCHzI8HIGMHFcpcFobqWBw3yMVzWVGKm35GWEzJ0aHsvPQ04NSKXCufu960fP8A+JbLcFlG9sKCeT+Fcwis7YDV0+heFNS1edEhgkEefmlcEKo9cn+VdP1T2kkoI3hn1SlFpvv+IugaLd6xehYo38oEGWRVyEH+PtXuVpaxWdtFBAu2KNQij0AFRaXpVtpVjFZ20YWNBjIHLHuT7mtALgV9PhcNGhG3VnyWOx08VLXZEbDKketeH+J4/I1+RsY3Nur3PHNeL+OofL1bdjqWH5HFceaRvFGeFe6JLT5oh9Kiu8bqNLbfAh9qLvqK+LStUsdXQ77wO2dAx/dmYfyNcdecX0w9JGH611ngJs6ROPSc/wAhXH6i23Vroekzj9a+sqO+FpvyMsPpORdkXfp54GXhyPw//VVOL5okrQgPmW1uoPWMr+ZYVmwki34+8p/Wvm3Llqt9mdsdin5FqLWK2sbGFY5j8lzMu6SY5wcc/KB3rqPDmhrESsjwQxwyhzJHyWHZc++Aa5/TNcF3eTzPaqskqkRJtJSIgDJT05AzWlaavcLZywXaoVL7o5ADhmwM89zX0sa9OMm7apf0jmlCVjf1S7mtFjsLVI1dJz8rp9/ILAgj8KxtO+zxWkl5ckI0gMYXy+S/B3Z/hNYsF5e6jqxuVkmaM5DDdt4xkj9P0rSv9YgNgXumQyJHttolGTvwQCT04yO1YSrqbcnvYFBxVjAvbofbZbVI84c4ZmJYA45J7+1VxGsV39oQB2IHylOUA7Y79Kvadp0t9dxyiAyTuRuXg7ucZweoqlqUM9rezp5haVMqxxjGOoHqO1ck4SlDmexsmk7dTJuZBNcb2PJHHt7VMke7EUWHYrnlcc+nvVWZJiqmRcH1I5/GplUS4VH2YXlum49f8KlRvGyGIl0qGQSEgEbRjgqfrVKO4kiLIMENxk80khl2hGBC5y3P3j60jAttJOQRwcfpWkVYBcSXDjzCxc9OM5rTsyYblbdnVVkAD7gfl9D9RVVY5UKyBmxjA47dKnRDgMzg4O0jufcVMpaWLias6LLbvZ3OUkB25P8ACw6H/PY1zFzBJb3TwyFldG2tuGCCK3ZHjkgWSMfNFhZMHIx/Cfr2/Kkm0ttVhE1uVE6AJIuMbh2bP6fh71lCSp6PY6adCdeSjBXZR0fSjq2px2kc0cSHBeeU7UjXuWPpXS634d8PQRR2umancXl0G/eXAhCxYweFB+Y845J/Cs+wsJLSLypgQ+ct7+la8SRIA20bh0NY1sZbSB9bl3DsZQU6+/Y5+38L381yAwSOEDJlLZAH0659q65IooxGoLHy1CKWOTgDAqFZulMabLZrgq16lW1z3cDlNLByk6fUvXEa3Fu0cigqaxo7Gb7SqtFH5MJJVlABJ6jOK0UnzwTxTVuRFdCNvut3qIVJx0Q8Xl9HEW9qtv6sXYOGxTX/AHdyPerrJaoVZZcuRyo7VTu8Fgw9aUk931PyzEU/Z1ZQ7NozdYgWRTvGVPBxXIywovThsnCnriu6vk8yEHGQRXE6hG0V7uYtz3rvwFS65DJDnl+zWwieFGY/MW471WjkMbrMFBCuMfXrUiybrdk3cFgTnuPX9ahulCzlk2bCTt29P15rv3fKawqSh8LOstVQsSn3Dyv0PIrTTwvpl7Ctzv33MrYMMj7UGOvTk5HPUVjaTLvs7dx2XYfqD/hitR7uezuLV4A77pNrxqfvjrj26daywajDEuEluY1HLl91nISWMuia+Mx7WikEqKfY5A/Svoe0ljurSG4iOY5UDr9CM15j4x8PubCHVxGqt5m2TaxbKt0JPrnj8a6vwBd+boZtHcs9s20Z/unkfrkfhX0GFfsqrpPrscmI/eU1UR1WKKdSGvSOIYeleR/EGPF2rY/5ayDP45/rXrpryr4grmWU9kuiv5oprzcy+BHThd2YejNm1HPTjFT3fI/GqWhHMbg+tX7zpkdK+MqK1Zo6zsvh8f8AiXXg9Jgf0rjdYbZr18vbz3/ma7L4e86fecf8tV/lXGeIhjxHqA/6eH/nX1D/AN0pmVH+JI0rFiLaBvQH/wBCNVlXbLcR9ldgPzqTTTmziz6H/wBCNEigX84HQ/N+YBr5iq/3s/U7IdS9qGjWy6Rpwt3aKURszy7gAXwOcZ4GRWRJLd3Vq0cKrcyFjI0wByp4y2PqO9SxWr6hbzSRlhEh82Xc5X5QRnrxjFUH1SGBNljJITsKkMcZ6HB9eM4r36kk3zvRMyStoS3sd5aieUL5RG1JQIgqZHBHX269DmsOKNpr2KS68xMg7DwN2B0HrngVuvoF/q9lJqc7zBHdEIkOWwcEELnp/jWZd2axBpLdt5j5I9OT2rnqrllqjSLRcTxK+lM8MX7t5PvFRnA46GpdVvbG9kS78wqNgQQj0A6A45/+vWZGfLg+1TyhxygUKM47H161VuLBPJMwmk3+YNpc4GP6VPtXyqDeguVXuMktFukkMckm1ACeOlVHhDRuyFyUOD8uBVhHuYWDmTaWbCsT0p+2WSOaQFSE5LEZB7UpT2GkZMsd04UsuAuFzj1robXSnfQJgMm4JLZ9QB0pEkiktjKQkc20ovIKt065rX8NkGJ4S+8qxU+3tWVevKMbx6BsclASISybiVX5hk9M1Nb2d1dQTyxxhgmCVJwQCcCr2sWy2N7cR4CLKN8ZA4z3FVdOYohTc5eRwXz07gfzq1Pmjzo7MHRVarGm+po6Lppijf7XEVWUFOepU98exwR9Khs520zVDDcZUK3lyZH8Pr/I1oWshViD2NVPFUcjx2+pgswIEErHsQPk/wDHRj/gNc0ZupUcZdT6jGZesHh6dejvB6v5/wCZeuZCLphnO3ipEYMuRWVZTNc6fFOcnH7pj7gcfpj8jVuKTaa550+XTsfTYLGqrFVFsy5RSAggEdKWsT1LhnFVbhyZSc1aqhKcyP8AWrgtTmxUrRRsQTEiOQngirsvzR5/KseJ9tmgzyCD+ea07V/Mgx1xxWNRW1Py7PKSpY6aXWz+9XFTElsQe1ZNxYwTzbZyyq2cMoyQa1IDtdlP8VV54/mPr1FVQqunU5keSc61rC2+GKYhV6ggfjVY2u+RDKXaJTgBeuPatG68yzuw0cIaKYenA55B/Hn8qs2WhXuo6jIyxHywGJYoQOP5fSvoqP71c0VuJuy1JrOwaytUIDiOQiVN3IwePz4FbVggluYzkbky6g45IB45/GrF3H/xJ4rcuUMKMRAwI2kEdOxGBmqunMRcQ8A/MByOOeKxrx9li4y9CYvmgzuWih1HQZkZW8uZfKdewPTcP0PHHFcZ4OvW0zXVhmO0OTBL9c8H88V3WnNJDBJbkhmiwAhGSo9MZrivFNgbDWorpEEaXSBsL0Djg4/Q/jXs4xOKjWjujnwzT5qb6npn1pD0qnpF7/aOlW9z/E64b/eHB/WrpFejGalFSRyONnZjTXlPjpt5vD6X2P8AyGK9WPSvJPF5DwXz+uosPyXFefmL91HThlqzntDOXkGfStO7OI8VlaGf9KcZ/hrWv/u4/GvkK/8AHOo7L4eKf7NvD6yj+Vcb4oG3xNqA/wCm7V23gArHokzNxunJ/QCuM8XDb4pv/wDrpn9BX07/AN0gY0f4kiXSmzaoPr/OpbjA1Af7Ua/yx/SqukN+7QfWrd2MXUDccoR+v/16+Wr/AMaaOqO7Ods0vdWuIreHYqSnAyowMDqc111nomj2ttOlvPI0sR2b5VyNzcF9vbHSuVs5XtQjpOGnX5sDnHTA+tdI2qSyaWUs441mEWyYl+XXOSenB659hXv0akVFuW5NSLexFa6sju8E2+RQ6shU8OATw36e3FO1ENeNaymdJJWG1mKbQqEYAP0JrEDpCCco+ckjpjIH5j29qtKzyIQJQiMwBkPJTHzdB24rCpWlNcjGoJO6KqsUDxbclT93AB9iT6cVn3EX2mUNI5+ViWwOevvV24tQi/aI3A+YK2/knjkjPb/GnXUJhefKb3i+VinIznr+NZKi73uVzGFLveRYIo2OTwDzn/Cn7hBBksAMZKk/e56VtPfWFs21WJZsHIjHA7jnnrXP3VozXOYnKW7c7m6L61qoJe6xEhnt438sMPLc7xhtwXjpitPwtIEuJdo+RmyK5p4hFJ5YGWboQc1qaEZrXU0SQMqsMgHjNRiKd6UkgOm8V2kc1or9HHzL7jvXP2rqYFI6oRg10+qsJ4oxjlR1rGXSpIrZZkbzPPdgsSLkgDJrhwnNOlyroevk+KhRr2nonp8+gBvm3DvU1xD9u025tdgd3TMec5DDkY9zyPxrMjnMZ2t0z19K0beYo6sDyCCKmScGmuh93GUMTSlSl1VjmdEuNlw8LMAJFyPqOn9a3Q1cxet9h1uZrfMYSUsgB6DPFbySh41YdCM114iCbU11PnslxEoxnQnvF/1+Jp2smcoT7irOeKyo5djK3oa0PNUkgEetcE42dz7DC11KFm9iYdKznOZH92NW/M2qSe1UbdxLKT2HJogrXYsVUUnGHc0wmbKXA+6FP6//AF6tac37zHqKzbC6e6muIVHyeUxOPbB/pV2ybbIprOpFpNM/PeJZwnjeaG1kW5T5coPoeaS56q2OtPu0yufWoi3mWwHfFc66M+fGHcYJERVdsblVuQeOf0/UCmaRrMccy20cTuFQnanJzjk5+lOhkI2sOo71havDcadqzTW5KxyjfGV4wD2/DkfhXtZdiXH92xOKkj0Nr+yu4ZdztFLLAEWIHcDnIH0Nc/bNtwe4NQeExHf3kf2qZvNX5k3HCnb2NT7fLuJI/wC6xH5GunMJOThUFSja6PT7VBLdC4CMAy5DA4XGOhH41l+MrVL7w+8ikebauHH8iPyOfwrW0i4SbRbQ7lJ8pQRnPOMc1Qv7mz0+3ZJmiDsCskbZJKke3t617tSpTdH3no0ZYfDVp1lGnFtmR4H1JRDcWkrqqjEqEnHoD/SutEypne4UBsbmIAJPQV5NY3Uun3rm3Ybl3IpYcEEY5FXrm61HUbSK2v5t0cRZkC4HOB1x16V5VLNYUKXJLVo9rCZBUx1WVnZLfuejX88MFvunuEhBZQCWwSSeleR6+/maGkuf9bdyPn8WrU1LUn1BbNpSd9pCdxz94ruIP5YrG1z5PD1in+0M/XYD/WprYz6y7rZGeNyt5e4wk7yau/yMrRMfa2ye1a1/9w1l6EM3L59K0r8/uj9a8OtrXPOO68Ft5fh6JTwXkdxjv/nFcX4vOfFF8f8AbHT6Cul8PXMsGkRxndwgK7ADwdx/nXJ+JS512cyZ3naTnqDtFfSSqXoRiuhnShabY/S2wkXu7D9BWlfj5bZh2Zh/Ksqwbbawt6TN/Ja1b7m1jb+7IP1H/wBavmcRpXZutzm7dAspUyFEZgCiAkYFaH2hWM0cE5ABPAG3eBk5K564z9KyptQuZ4lSdVmWLCKY2wT1I479TS3U9tdKWEG7a24qHwVwCMEEfTn2r1ZRbiWLMsjzPM0Z8orgbifmx0OKmWREeMzudrgByoI9s/1pliIJmmtliIV1Lou7cMDnjjjp1q7dtBNcRNEk7fu1OyTlgefbpgcfSs5rSw0iVbqOKzeBcSRSgDfKOvfI9B2/CoZY42lMUHlE+WSSsjHC5+vPpUsV1K1q8cZKRBgF3pu2nnuPTmq2oWc8Fy5M6sz4bftCAg8hsn1H86tarULJFC+tJmdA8qqgAy6A4GcH+RFQPbiRjb2rz3GP7kWBWjKQYFRozMjp8wOVYHnBz360ttqsVokscMUqxkD5QcqD68+1aU3b4hS8imLa5hVVOy2IbaXfBxnofb61bNg9qxmlkWeVWBMhPK56D8apSajYs8qy+YoaTcCxzvHoasyTS6hl4rlAvyBlaUAv1xx3wB/KtJcnJYztJs1tRlki003EUYcqBuyeg9cd65h9UkMW9ZHUrnBXjYT3FdVBDFf6eIJ8lHXBwcVxdxZvp2pyWrktGThXxgMPWvLwbim49UXF2CK5y2HYuCMliMc1ft59hAJyOxqla6XLeztCgAKgsRnGQOTii5BtZ8IF2s2BGH3leB1rulQc48yPewGbeyahUe3Uqa/GBerKOjrz9RWnpqedpSSL1TKsKytRlE0KZ+8jd+orQ8P3awxTRyEBfvc1FRS9gu6OvB1KTzObb92a/Hf80StNsBOaz59ZeOQGH7wXac1HrF1BLORaM2z+Ltk+1ZVaUqCa5pI48fmlSM3Toy26r9DXGv3DRlXC8jBOKnt9aWOyeDyP3znPmbug9KwaXJ6Vo8PTeljijm2LT5nNs7HQ7qUXVmqR/ubiR43kB6krtA/8ezW7CNp+hrhtHjktdatmdwohlV2wcggEHr+FehzxeVdSJ2DEV5ePjGE0kceIrzrPmmyaQ7oFNVF4YqTgHpVmL5oiPSqjnBBx0NefFdDnIlOyUg+tXLiwttT00/abprcW2X3rF5hKnAxjI747+tUZzhw49av2EqLJtkGY3Gxx6g1tGbptTRpSaU05bEGkR2MF+yxyvc2zLh5ZVMeOMsQAx/nzVmd0e+meMEI7b1DdcHkfzrNvofsCPbIx4YqT6j/64xVosN0ZGcGJOv8AuiuipWlUjdn0ub4KhQoU5UFv173LttAg/fLuWQn7wJBFOvpGJVpZmbe3JY5JPqTTrM5i6d6o6tJunVAfujJ+prmVWTlyt6H1WWuLw9OSXRDbqPyriNx0cYP1H/1sVqQt5sCt3IrEMxe18tuSh3Kfb0/WtPTZAUK/jSq3cL9jzl/s2aSj0mr/ADKF0xjsrhx1KbBx6kD+WaqeIJCdKtR6zS/pgf0qXV51jWO3PG+QMT7D/wDXWdrcrNpmnA91dvzavQwl/Z3Pn+JanPjWuyS/AXQFy8jfhV3UfuAD1qvoa7YM9zzVmVfNu4Y8gBpAMt061zP3q585c6zSFjtW275HWO2XIX+8c8fQf1rjtf2nWrnbjbuxwcit77W1lOH2h5pSVi25C8EEEH14P0rntZjEWoMmzYwUbx33d817zl7iQRVmTWwxpkR/6bN/Ja17rnTyfRlP8/8AGs2OPGiWrf3nc/qB/StE/PpTf9cwfyIr5/EO9a/mWtzz+c+ZcytK7FEbaARjmrFnAssgZQNrcEB8H8qSCNVtHE5UiQKSxXdtyeue1QEy6dPgPlG5Vx/Euevt0r2WnsWbRtGhgjuQrCKRvl3Kc8Z64HqDTpNUMpEjkbtojMgXG8Y784OMj35qGz1AXLnzGVGhixGoIXed3G498Z/IUxyoaOJ4/nALFui5PPHrxUrQDaW2uIoYpEeBY/MUKIyAzjGSSp4OPWkuvJgty0spWdSEkR0xvB565OAOKqWkwnthGjA7P9WTnAI/pTbnV9lvJ5y+XeghTsUBGI4yR0zg9gKiElO66g3fYbd6nHPbiAQMkaMTtdgT9Ome1ZhZYVDBsMfmOei57U8wPcWU19cERBSFULx5jk5xj6c/lVMoJcBtygcj3q35lLYVoI2t904xG2dsiA4z+P1pbey8sr5c+7cCAcHAPpUsssbW5jXftUZEZbO09+Pyp9nNcIihEkRFcPuXIyR05pXdiTpNLmWO0XzHVNpwSxxzWJ4ovDcakqIwMcKjGDxk9f6Ve0yNLu2ltrhdwfO7J5z16+tZWr6K+mxpKj+ZCxxnHIPoa4aUYRxDu9SUQSMwKOp5254qrDfxNdSvf25lEqbdw+Up7jGMmrO4+RGdvJO3FQapdpcMoji8uNAAq+gA/rXoUJOJTjdalK/jtodQaGzuPPgGAJNpXP4GldPLh3cgYwcVAI8yBh0BrXMIe2buMVdSaTRVNtGMsLyI8kcEjqoyzYJAHvUB61qw3l4fNig85oiu11jJxt9wPT3qqluJWY5JZjhFY8n3Na3SVyNZOxDFCZQwX7wGRUYXOcnGK33tmt7Wwu2CZ/1ZKn7wH+GcVVvrSP7f+6GYn5Ht3qHUSlYfL7txtkpSNXPU8/hXo7v50FvOOfNhVvxxg/qDXAKAOgwOwrs9Ll87w/atyfKd4j+e7/2avLxy5kpeZMi5AcOQOhqCcHewpysRIKbfSLBtds7W4yO1ecl72hmV5BuiyDTLeTt6U9WDKQCCG5BFVgdk5HrWyV00Mv6zGZra3vF7fupB/wCgn+Y/AUzdmO3PrEP0JH9Kni23NvJaucLKMAnsex/PFUk3i2tt4IYKykHsQ7CiGsLdj2PrXtMCqUt4v8NTSsrlVl8lurciql6S17Jn1qEOFvbds/xYq5qUeJEmHRhg/Ws7KM15n12T1XLBx8ioo2n2PFWtPcrMFPXOMVWyGU0RyBZS2eOp/rV25otGGeS5HSxC3i/+CZniCbdqRUH7gx+NZ17eG4hto/8AnlHsH5k0y7nNxcyynq7E4qBPmnQds16dKHJBLsfG4/EfWK86vdnT6WmyIfSpA6LfI0gyvPH4UWKgRge1VL9gr85/CuKl71Y4EaSStLJGYmcTKNyRuBk8DI49eTk+lZWoO8t1vkcu7AEk9amtB9ruoYSOvLZON31NRaxCbO68twoZQAVQ5xXs628i1a5ssmPDenn13n/x9v8ACprU79OcHH3GH6ZpJUx4ZsRjpFu/NmP9aZpbblKeuR+YxXgVNZyf94OpwcCTSyfL84zkDHWrNxasYkMqOjY3IWXGV7Ee3WnaRb3F5dxrb8P1B3AAAfXj862dfs206SDMnmiYnyQH5VM9CPfnpXvuLtcbetjndPljjukM4bb0YA4yDWxfoNQ1GSO1ARi3Kx4ZMZ4HAGOPSsi7to452Ecu6TP3WGCPY9s/4Vb0rUXiPlKCJSQFkODtA5xg++M+1S1fYrfU1RYto+oC0e4hm3RrIGibKgEZx9RUl1px1EoI3CTAjaW6N9ap3cXkXMc32hZmckMUXCrjoPywfxrTibKqa8/EN06nOjO9mYmp3aXNylujkW8A2ISPvHux+p/pVSRIiWYSKmzoMH5q6PU7H7XbtcQovmoC0iheZBjqD61ywdG3DLn1GAfp3rqpVI1FzI05rhJCksbsmN5GQS2MY5oheYWoO7G44256ge1NMiKcLGy5+8OwqPYkSOS2CTkE1ouxW+pt6FckTEMea6DVF8zR7pQu4hNwH05rjtLuk+2AKOSOT612Y/e2pUHllK/mMV5mMjyVVIze5yNuyyDGciqd7EscmzBAPetFbdrZssMENtZanktZdRtJraKNP3QNxvx8xwOma64zSlfoap+7Y5mRQnGSDW5ajfbj3Wscr5q46OtaumMWtVyemRW1f4bkrRlKK/ezMkaTTq2CMAggnPf2xmoLG2+2TtCN3mv90gZx3JPtilu0RLuYsSTngD1Nadin9maNJevxPdgxQ+oT+Nvx6fnW3NeI1oyhL5i/uPNyF4yemM1ZWUvAoODs4U1QLhm3hiW7irinEMY7Yz09azmtA5tGLXUeGnL6fewf3Sso/kf5iuW710Xhn5LnaTxMpj/E9P1ArkxCvTaMzUJ5zRep51g2OSBkUx+CR6GpoSHjZfWvM2syDmkuJbd8o2Papftu9lLgA+oqO9iMNw6e+RVQnIr0VGMlcZ0UMuACO1PvXBulcNlZF349Cev5kZ/GsS0vTECrklf5Vdlm3tGytkba53ScZFRbWgXspjWN1PIbintrjS2hikQFv72aq6k4W2UnP3h0rMSaEo5Z2VgPlAXOf8K2hRU4ptHuYPMZ0KXLFmgb+QHg0Jcu9hcOM/LkE/X/ACay4XEtyqyOVQnkjsKvyM0GjiMtnznz17L/AIkn8q29jFI58Vj6taPLJ6GYx5pFfbKD6Gmk80zPzVvY8tna2JzAG9VqndQ+fKwZgsSjLsecenA98VNpDb7FT3AxVC+lbzXizhepwMk+1efh1au/IiJo6dHbussMrSFPlAZOQSM9eeOtQ679nXUY0t5A6KmS23A6np7VmrdSxWwiguJELqfM5IDEnpx2qIsHRF2swVQuWPvXq891YpLW528+DodooP8Ay7If0zWfpUmLhRnuP51fmOdNsx/07R/+gisezfZOv1rwd3L1EzPso2sYLO7MaPGRsCbWG/sTnHuOlQ316Jb10gQs64BjYHcCM8L14HWqTXty0cMaySSQ2v3cHiInuCOgziltJLoaguo27SpPv8xSo3HIPqa+gcrqzKS1uXL+1Q7rmWRTKXyUXAwMd/cccAY5qTxDZ2Flb6fdac7rdOm+dQ2QpPKle/SmXNjeyam0uoT2c0s0XmFpLlON3TJB4Iz0pRHFc2cAjaFbpCUba4cOpxjjpnJNS5W2QJMiidb3Tml3BJLcDd6OCRj8a0rGTdFjNc1PG9jcSwbwQr7W2ngkVsabL0zXHi48yuKaNprtLKIzyybFTnPvXH6jeWl1fvcQWrRK/LLngt3IHb6VreJZCLSFM/eYn8h/9euaQjvSwdNKPP3CJoRzxuzZkwNvdc4P1omij8hHEqsHJG3uKovKpAWr0lsZbfbFl3QbmZRkAY6V12Nbq1ytbosN0rmTGDwAOtdxp0m+HHfGa4yxuVjnWSSLzNmSAeme2a6PR59wHNcmOg3C5nNLobM1hDqNuUf5ZB92QdRXLQ3Fzo189tcMQ4O2TuGXtj+ddfavslI6UuqaVa6jBiZPmHIdeCD9a82jXVN8k9YsIysecapB9i1AlDmJ/nQjpj0q9pjBozt9aj1GxkiQI7F4gTtb+7T9EZbFp2uACiruX3r2JvmpaaspbaFaa3N9riWsZALuFLHoPUn6Cna5fJc3PlwgrbxqI4l9EHT8+v41BazyPeXE6g75Aw47buv6ZrOkYu5Pc10QjZJdgbHBiowO9a0S7wi5/hGPyrLUFlI/DrWmgKxx+u0ZqauxJow2abAZF+bvWhbsYCjJwVII+tVraXzosn7w61YXsK4Z36kmxfDbcF14SQB1+h5FQwPtk68U9m87TI3/AIoWKH6Hkf1/KqqOVYVwuO6EyPVIC43AfMKwTwTXVzfMoY85rmr6LyrkgD5TyK6cNO65WNFbOM1YsXPQnoaqNxUti3J+tdUl7rGjpLExOJI5ohJG64ZT6f0PvWJqWhzWc+Y2D278xyHjPsfcVq2TfOf92tEBLmF7aY/u37/3T2IrijVlSn5Fxnys4tLaUSKMBiTjAq5qjqbkQxgBIhsAHTjr+uav2SfYJ78TxZlhUKpPQHPGPfoR7ZrGbLOSa7b3dxzkV2GGqIHmpphhs1AK3WxmdToL5spBnlTxTvsQv5DtcecDhYwBl/XJJHYVU0OTFvOM4xjiq9xBMwN4CBDEFyN+CSSe3U1y0YpV5NkpF6DTT9g84uGQPtZSpOCegPOBnn8qyrlJUcxqO/KgEYP41Ye8R7BB5bkRnDHf167fwFVo280h2fLdwf6+9dklrdFK53Wd2j2B4z9nQH8BisZG2XJ/3q1IMnw9YHOcRkfkxFY0xK3BrxIr35LzZLMKWZbexRVlVlmQFti4Jwehq1ZzNBc211Cz5ZcNHGzA4OQR+Iz09az3uEezSJIUG0YyRyD3psJfz4mcSSIAF2B/yxXtmpNcXLf2hvEnCEKu9QMAcYOPpV+2lFtDJqmxY5pMxwKowM4wWx7D9T7VTtreGa48q481YVBMnlgEjA6/Si+vBcXIKLiJBsjU9l/zz+NF+iGl1HRabd3hj22zMk7EJIehx1/EVaFpdaVePZ3cbRyxnGD3HYg9CKzY7+7jfMc7RkcgpwfzqRLiaSYPLLJKemXYmoqxTjYmUW1cm8QTF2gXPAQn8z/9asUVd1J98657KBVMUUY8tNIlFiwtPtd6kW7bnPJq3axXQuWhDMGclNnc+1S+H4d93K/91P5mtW+VbZXvYx+/K+VkDpn+L8uKj21qvINPoZOoRx+YYrZcxwjaXHVm7n8/0FWdJmKNtIIYHkVFaQCOJ5bmBjvH7vJ4JqSONY5t6sSxAJ5orLmi0OWqOpjfJRx3xzWt96PPtWLZtvgA7itaB90Y+lfP1VZmaObuol8ySNlBGSMGuU1OBre6KZPlkZTPYeldxqkBWXzQOD1rltciLxK5bhOg9zXrYOpdoqN+hBaQbNIa47mbAI/3axFUiQg8EV1NpFK/hkiSLEW4ukgPQ/SufmAk+deG/iFd1Kd3JeZdtLklwkcc0bw5XKK3zc5Pf8Kt/MQu7rjmoSm/To+m5DnGOatTypL5ciHKlAOmPz96c3dCY+1l8mUH+E8GtgEMAR0rDhAd9hP3un1q9Y3BBMEnUdK5prqiTe087jNbnpKhx/vDkf1H41SJKORT4ZGilSRDhlIYH3pdTUR3RZBhHAdR7HmuNr3hdCeJ98JGaytUj3Rhx1U1btpPmx2NNuUEisvqKUPcmI51zxT7E/M1RtwSO4pbM/O1ei17rGb1ox8wfStANgj2rLtGxKtXZJRHGznoBmvOqRvIHuJrs6GKKNQPMZQ0jDv2XP0Fc+F5zTknaaRt55JzUipwTXVCPs48omylcDC1WFXbhcjH41SXrXTDYaNnSGxFOP8AZpdRZliihJYpjIA9f84qCwkEcM3qRxVq4dXFpvYKCBlu449aygv3rY1uUvKZbB3JYKGAHy5Bz2Jp6GLywkZ3yZJdscf560k7t5LwJMzRs+4rnAJHGcfjUNoNpIIrrKtodrpxD+GYcHOx3T9c/wBayrn/AFufUVf0KQPo11EP+Wcwf8xj/wBlqhdfe+hrxpRtXkiJHKurwsUbINSWshNwnmS429Cec068AEowAOlSaeobUbRWAIMq5B+tev0NbGhqUq28bQrkT3OGmYkZC/wr/U/hWMvLglgfpVjUiWvLosSSZGznvzVOH7tEdhj1GWPpWhpyWzTgXKSunPETAH8yDVCPoaJP9U1DV2PoF88b3TmIMI/4QxycVAvND/fFKvSnayMTovDMfy3Mh9VH862GUK3zDKnrWf4b/wCPKX/rp/StKbofrXkVpP27Je5k3yxQzGLknGQD0weh96psmGjx87dAqjmr2sD5LQ9/mGfyrNckMSCQdorupu8U2aXujodNm4AOQRW5A218YrltJJKLkmukQ/cryMVFKbM+pNdxB0IwCD61wHiWMwakIdwYBAePevQ5/wDV/hXnGvktrc+STggc/Stssb57FI6lIVbwskadRDgj3xXnsUhR+elei6d/yDJR2wP5V5u3+sb6134Hea8xovPOURdpO30PIqaJswIR7/zqmebY1Ytv+PVPqa6prQbJgxUgjsc1bnzhLlO/X61SFX4OdOkzzyaxlpqSX7S5E8QPccEVo3K+fpiuOWgOw/7p5H65rndKJ85hntXS2v8Ax63Y7eV/7MK5KseV6CMbzzDz70ovgzYfjNV7jr+NVJPu1oqakCEu12XD46HkVHan941LNyUz/d/rTLb/AFhrdfABsQPtkQ+4qTV5vLtgg6uf0qunb6j+dN1r/Xp/uf1NcyinUQ3uZiPscN6VsABogw71iVsWx/0JfrW1ZbMllWYffz2FZ68mtGfpJ9Kz161pT2HEsw+nOKtz4+z2zHIbaQpHbmqkZ4NatgokvtLRwGQycqeQeacfiKRueFvAt/4gvEVx5UTt8rEcv7gf1Nek3fwn0fQLH7TcvHJjkmeQ5z7AYFYdrcTQOGimkjbd1RiDVbxRe3dxbt511NJgcb5Cf510JXRolfca50rZc2tjDBG2zcTGoBOD/wDXrkb1MO3I60vh5mOvsCxI8l+/tTb/AP1715WJVsRp2RnI/9k="];

},{}],35:[function(require,module,exports){
/*
 * Easing Functions - inspired from http://gizma.com/easing/
 * only considering the t value for the range [0, 1] => [0, 1]
 *
 * Taken from: https://gist.github.com/gre/1650294
 *
 * No license attached to gist; assumed MIT based on
 * http://greweb.me/2012/02/bezier-curve-based-easing-functions-from-concept-to-implementation/
 */
 /* jshint node:true*/
var EasingFunctions = {
  // no easing, no acceleration
  linear: function (t) { return t; },
  // accelerating from zero velocity
  easeInQuad: function (t) { return t*t; },
  // decelerating to zero velocity
  easeOutQuad: function (t) { return t*(2-t); },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function (t) { return (t<0.5)? 2*t*t : -1+(4-2*t)*t; },
  // accelerating from zero velocity
  easeInCubic: function (t) { return t*t*t; },
  // decelerating to zero velocity
  easeOutCubic: function (t) { return (--t)*t*t+1; },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function (t) { return t<0.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1; },
  // accelerating from zero velocity
  easeInQuart: function (t) { return t*t*t*t; },
  // decelerating to zero velocity
  easeOutQuart: function (t) { return 1-(--t)*t*t*t; },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function (t) { return t<0.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t; },
  // accelerating from zero velocity
  easeInQuint: function (t) { return t*t*t*t*t; },
  // decelerating to zero velocity
  easeOutQuint: function (t) { return 1+(--t)*t*t*t*t; },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function (t) { return t<0.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t; }
};

module.exports = EasingFunctions;
},{}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],37:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],38:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],39:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],40:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":39,"_process":38,"inherits":37}],41:[function(require,module,exports){
/*
 * Cookies.js - 1.2.0
 * https://github.com/ScottHamper/Cookies
 *
 * This is free and unencumbered software released into the public domain.
 */
(function (global, undefined) {
    'use strict';

    var factory = function (window) {
        if (typeof window.document !== 'object') {
            throw new Error('Cookies.js requires a `window` with a `document` object');
        }

        var Cookies = function (key, value, options) {
            return arguments.length === 1 ?
                Cookies.get(key) : Cookies.set(key, value, options);
        };

        // Allows for setter injection in unit tests
        Cookies._document = window.document;

        // Used to ensure cookie keys do not collide with
        // built-in `Object` properties
        Cookies._cacheKeyPrefix = 'cookey.'; // Hurr hurr, :)
        
        Cookies._maxExpireDate = new Date('Fri, 31 Dec 9999 23:59:59 UTC');

        Cookies.defaults = {
            path: '/',
            secure: false
        };

        Cookies.get = function (key) {
            if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
                Cookies._renewCache();
            }

            return Cookies._cache[Cookies._cacheKeyPrefix + key];
        };

        Cookies.set = function (key, value, options) {
            options = Cookies._getExtendedOptions(options);
            options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);

            Cookies._document.cookie = Cookies._generateCookieString(key, value, options);

            return Cookies;
        };

        Cookies.expire = function (key, options) {
            return Cookies.set(key, undefined, options);
        };

        Cookies._getExtendedOptions = function (options) {
            return {
                path: options && options.path || Cookies.defaults.path,
                domain: options && options.domain || Cookies.defaults.domain,
                expires: options && options.expires || Cookies.defaults.expires,
                secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
            };
        };

        Cookies._isValidDate = function (date) {
            return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
        };

        Cookies._getExpiresDate = function (expires, now) {
            now = now || new Date();

            if (typeof expires === 'number') {
                expires = expires === Infinity ?
                    Cookies._maxExpireDate : new Date(now.getTime() + expires * 1000);
            } else if (typeof expires === 'string') {
                expires = new Date(expires);
            }

            if (expires && !Cookies._isValidDate(expires)) {
                throw new Error('`expires` parameter cannot be converted to a valid Date instance');
            }

            return expires;
        };

        Cookies._generateCookieString = function (key, value, options) {
            key = key.replace(/[^#$&+\^`|]/g, encodeURIComponent);
            key = key.replace(/\(/g, '%28').replace(/\)/g, '%29');
            value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
            options = options || {};

            var cookieString = key + '=' + value;
            cookieString += options.path ? ';path=' + options.path : '';
            cookieString += options.domain ? ';domain=' + options.domain : '';
            cookieString += options.expires ? ';expires=' + options.expires.toUTCString() : '';
            cookieString += options.secure ? ';secure' : '';

            return cookieString;
        };

        Cookies._getCacheFromString = function (documentCookie) {
            var cookieCache = {};
            var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

            for (var i = 0; i < cookiesArray.length; i++) {
                var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

                if (cookieCache[Cookies._cacheKeyPrefix + cookieKvp.key] === undefined) {
                    cookieCache[Cookies._cacheKeyPrefix + cookieKvp.key] = cookieKvp.value;
                }
            }

            return cookieCache;
        };

        Cookies._getKeyValuePairFromCookieString = function (cookieString) {
            // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
            var separatorIndex = cookieString.indexOf('=');

            // IE omits the "=" when the cookie value is an empty string
            separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

            return {
                key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
                value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
            };
        };

        Cookies._renewCache = function () {
            Cookies._cache = Cookies._getCacheFromString(Cookies._document.cookie);
            Cookies._cachedDocumentCookie = Cookies._document.cookie;
        };

        Cookies._areEnabled = function () {
            var testKey = 'cookies.js';
            var areEnabled = Cookies.set(testKey, 1).get(testKey) === '1';
            Cookies.expire(testKey);
            return areEnabled;
        };

        Cookies.enabled = Cookies._areEnabled();

        return Cookies;
    };

    var cookiesExport = typeof global.document === 'object' ? factory(global) : factory;

    // AMD support
    if (typeof define === 'function' && define.amd) {
        define(function () { return cookiesExport; });
    // CommonJS/Node.js support
    } else if (typeof exports === 'object') {
        // Support Node.js specific `module.exports` (which can be a function)
        if (typeof module === 'object' && typeof module.exports === 'object') {
            exports = module.exports = cookiesExport;
        }
        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
        exports.Cookies = cookiesExport;
    } else {
        global.Cookies = cookiesExport;
    }
})(typeof window === 'undefined' ? this : window);
},{}],42:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = window.localStorage;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":43}],43:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":44}],44:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],45:[function(require,module,exports){
var debug = require('debug')('navigateAction');
var queryString = require('query-string');
var searchPattern = /\?([^\#]*)/;

function parseQueryString(url) {
    var search;
    var matches = url.match(searchPattern);
    if (matches) {
        search = matches[1];
    }
    return (search && queryString.parse(search)) || {};
}

module.exports = function (context, payload, done) {
    if (!context.router || !context.router.getRoute) {
        debug('no router available for navigate handling');
        done(new Error('missing router'));
        return;
    }
    debug('executing', payload);
    
    var options = {
        navigate: payload,
        method: payload.method
    };

    var route = context.router.getRoute(payload.url, options);

    if (!route) {
        var err = new Error('Url does not exist');
        err.status = 404;
        done(err);
        return;
    }

    // add parsed query parameter object to route object,
    // and make it part of CHANGE_ROUTE_XXX action payload.
    route.query = parseQueryString(route.url);

    debug('dispatching CHANGE_ROUTE', route);
    context.dispatch('CHANGE_ROUTE_START', route);
    var action = route.config && route.config.action;

    if ('string' === typeof action && context.getAction) {
        action = context.getAction(action);
    }

    if (!action || 'function' !== typeof action) {
        debug('route has no action, dispatching without calling action');
        context.dispatch('CHANGE_ROUTE_SUCCESS', route);
        done();
        return;
    }

    debug('executing route action');
    context.executeAction(action, route, function (err) {
        if (err) {
            context.dispatch('CHANGE_ROUTE_FAILURE', route);
        } else {
            context.dispatch('CHANGE_ROUTE_SUCCESS', route);
        }
        done(err);
    });
};

},{"debug":42,"query-string":50}],46:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

module.exports = {
    NavLink: require('./lib/NavLink'),
    RouterMixin: require('./lib/RouterMixin'),
    navigateAction: require('./actions/navigate'),
    History: require('./lib/History')
};

},{"./actions/navigate":45,"./lib/History":47,"./lib/NavLink":48,"./lib/RouterMixin":49}],47:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
/*global window */
'use strict';

var EVENT_POPSTATE = 'popstate';

/**
 * This only supports pushState for the browsers with native pushState support.
 * For other browsers (mainly IE8 and IE9), it will refresh the page upon pushState()
 * and replaceState().
 * @class History
 * @constructor
 * @param {Object} [options]  The options object
 * @param {Window} [options.win=window]  The window object
 */
function History(options) {
    this.win = (options && options.win) || window;
    this._hasPushState = !!(this.win && this.win.history && this.win.history.pushState);
}

History.prototype = {
    /**
     * Add the given listener for 'popstate' event (nothing happens for browsers that
     * don't support popstate event).
     * @method on
     * @param {Function} listener
     */
    on: function (listener) {
        if (this._hasPushState) {
            this.win.addEventListener(EVENT_POPSTATE, listener);
        }
    },

    /**
     * Remove the given listener for 'popstate' event (nothing happens for browsers that
     * don't support popstate event).
     * @method off
     * @param {Function} listener
     */
    off: function (listener) {
        if (this._hasPushState) {
            this.win.removeEventListener(EVENT_POPSTATE, listener);
        }
    },

    /**
     * @method getState
     * @return {Object|null} The state object in history
     */
    getState: function () {
        return (this.win.history && this.win.history.state) || null;
    },

    /**
     * Gets the path string, including the pathname and search query (if it exists).
     * @method getUrl
     * @return {String} The url string that denotes current route path and query
     */
    getUrl: function () {
        var location = this.win.location;
        return location.pathname + location.search;
    },

    /**
     * Same as HTML5 pushState API, but with old browser support
     * @method pushState
     * @param {Object} state The state object
     * @param {String} title The title string
     * @param {String} url The new url
     */
    pushState: function (state, title, url) {
        var win = this.win;
        if (this._hasPushState) {
            win.history.pushState.apply(win.history, arguments);
        } else if (url) {
            win.location.href = url;
        }
    },

    /**
     * Same as HTML5 replaceState API, but with old browser support
     * @method replaceState
     * @param {Object} state The state object
     * @param {String} title The title string
     * @param {String} url The new url
     */
    replaceState: function (state, title, url) {
        var win = this.win;
        if (this._hasPushState) {
            win.history.replaceState.apply(win.history, arguments);
        } else if (url) {
            win.location.replace(url);
        }
    }
};

module.exports = History;

},{}],48:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
/*global window */
'use strict';

var React = require('react');
var NavLink;
var navigateAction = require('../actions/navigate');
var debug = require('debug')('NavLink');
var objectAssign = require('object-assign');

function isLeftClickEvent (e) {
    return e.button === 0;
}

function isModifiedEvent (e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}

NavLink = React.createClass({
    displayName: 'NavLink',
    contextTypes: {
        executeAction: React.PropTypes.func,
        makePath: React.PropTypes.func
    },
    propTypes: {
        context: React.PropTypes.object
    },
    dispatchNavAction: function (e) {
        debug('dispatchNavAction: action=NAVIGATE', this.props.href, this.props.navParams);

        if (isModifiedEvent(e) || !isLeftClickEvent(e)) {
            // this is a click with a modifier or not a left-click
            // let browser handle it natively
            return;
        }

        var href = this.props.href;

        if (href[0] === '#') {
            // this is a hash link url for page's internal links.
            // Do not trigger navigate action. Let browser handle it natively.
            return;
        }

        if (href[0] !== '/') {
            // this is not a relative url. check for external urls.
            var location = window.location;
            var origin = location.origin || (location.protocol + '//' + location.host);

            if (href.indexOf(origin) !== 0) {
                // this is an external url, do not trigger navigate action.
                // let browser handle it natively.
                return;
            }

            href = href.substring(origin.length) || '/';
        }

        var context;
        if (this.context && this.context.executeAction) {
            context = this.context;
        } else if (this.props.context && this.props.context.executeAction) {
            context = this.props.context;
        }

        if (context) {
            e.preventDefault();
            e.stopPropagation();
            context.executeAction(navigateAction, {
                type: 'click',
                url: href,
                params: this.props.navParams
            });
        } else {
            console.warn('NavLink.dispatchNavAction: missing dispatcher, will load from server');
        }
    },
    render: function() {
        var context;
        if (this.context && this.context.makePath) {
            context = this.context;
        } else if (this.props.context && this.props.context.makePath) {
            context = this.props.context;
        }

        var routeName = this.props.routeName;
        if (!this.props.href && routeName && context) {
            this.props.href = context.makePath(routeName, this.props.navParams);
        }
        return React.createElement(
            'a',
            objectAssign({}, {
                onClick: this.dispatchNavAction
            }, this.props),
            this.props.children
        );
    }
});

module.exports = NavLink;

},{"../actions/navigate":45,"debug":42,"object-assign":93,"react":"react"}],49:[function(require,module,exports){
/**
 * Copyright 2014-2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
/*global window */
'use strict';

var debug = require('debug')('NavLink');
var navigateAction = require('../actions/navigate');
var History = require('./History');
var React = require('react');
var TYPE_CLICK = 'click';
var TYPE_PAGELOAD = 'pageload';
var TYPE_POPSTATE = 'popstate';
var TYPE_DEFAULT = 'default'; // default value if navigation type is missing, for programmatic navigation
var RouterMixin;

require('setimmediate');

function routesEqual(route1, route2) {
    route1 = route1 || {};
    route2 = route2 || {};
    return (route1.url === route2.url);
}

function saveScrollPosition(e, history) {
    var historyState = (history.getState && history.getState()) || {};
    historyState.scroll = {x: window.scrollX, y: window.scrollY};
    debug('remember scroll position', historyState.scroll);
    history.replaceState(historyState);
}

RouterMixin = {
    contextTypes: {
        executeAction: React.PropTypes.func,
        makePath: React.PropTypes.func
    },
    componentDidMount: function() {
        var self = this;
        var context;
        var urlFromHistory;
        var urlFromState;

        if (self.context && self.context.executeAction) {
            context = self.context;
        } else if (self.props.context && self.props.context.executeAction) {
            context = self.props.context;
        }

        self._history = ('function' === typeof self.props.historyCreator) ? self.props.historyCreator() : new History();
        self._enableScroll = (self.props.enableScroll !== false);

        if (self.props.checkRouteOnPageLoad) {
            // You probably want to enable checkRouteOnPageLoad, if you use a history implementation
            // that supports hash route:
            //   At page load, for browsers without pushState AND hash is present in the url,
            //   since hash fragment is not sent to the server side, we need to
            //   dispatch navigate action on browser side to load the actual page content
            //   for the route represented by the hash fragment.

            urlFromHistory = self._history.getUrl();
            urlFromState = self.state && self.state.route && self.state.route.url;

            if (context && (urlFromHistory !== urlFromState)) {
                // put it in setImmediate, because we need the base component to have
                // store listeners attached, before navigateAction is executed.
                debug('pageload navigate to actual route', urlFromHistory, urlFromState);
                setImmediate(function navigateToActualRoute() {
                    context.executeAction(navigateAction, {type: TYPE_PAGELOAD, url: urlFromHistory});
                });
            }
        }

        self._historyListener = function (e) {
            if (context) {
                var url = self._history.getUrl();
                debug('history listener invoked', e, url, self.state.route.url);
                if (url !== self.state.route.url) {
                    context.executeAction(navigateAction, {type: TYPE_POPSTATE, url: url, params: (e.state && e.state.params)});
                }
            }
        };
        self._history.on(self._historyListener);

        if (self._enableScroll) {
            var scrollTimer;
            self._scrollListener = function (e) {
                if (scrollTimer) {
                    window.clearTimeout(scrollTimer);
                }
                scrollTimer = window.setTimeout(saveScrollPosition.bind(self, e, self._history), 150);
            };
            window.addEventListener('scroll', self._scrollListener);
        }
    },
    componentWillUnmount: function() {
        this._history.off(this._historyListener);
        this._historyListener = null;

        if (this._enableScroll) {
            window.removeEventListener('scroll', this._scrollListener);
            this._scrollListener = null;
        }

        this._history = null;
    },
    componentDidUpdate: function (prevProps, prevState) {
        debug('component did update', prevState, this.state);

        var newState = this.state;
        if (routesEqual(prevState && prevState.route, newState && newState.route)) {
            return;
        }

        var nav = newState.route.navigate;
        var navType = (nav && nav.type) || TYPE_DEFAULT;
        var historyState;

        switch (navType) {
            case TYPE_CLICK:
            case TYPE_DEFAULT:
                historyState = {params: (nav && nav.params) || {}};
                if (this._enableScroll) {
                    window.scrollTo(0, 0);
                    historyState.scroll = {x: 0, y: 0};
                    debug('on click navigation, reset scroll position to (0, 0)');
                }
                this._history.pushState(historyState, null, newState.route.url);
                break;
            case TYPE_POPSTATE:
                if (this._enableScroll) {
                    historyState = (this._history.getState && this._history.getState()) || {};
                    var scroll = (historyState && historyState.scroll) || {};
                    debug('on popstate navigation, restore scroll position to ', scroll);
                    window.scrollTo(scroll.x || 0, scroll.y || 0);
                }
                break;
        }
    }
};

module.exports = RouterMixin;

},{"../actions/navigate":45,"./History":47,"debug":42,"react":"react","setimmediate":51}],50:[function(require,module,exports){
/*!
	query-string
	Parse and stringify URL query strings
	https://github.com/sindresorhus/query-string
	by Sindre Sorhus
	MIT License
*/
(function () {
	'use strict';
	var queryString = {};

	queryString.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}

		str = str.trim().replace(/^(\?|#)/, '');

		if (!str) {
			return {};
		}

		return str.trim().split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			var key = parts[0];
			var val = parts[1];

			key = decodeURIComponent(key);
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);

			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}

			return ret;
		}, {});
	};

	queryString.stringify = function (obj) {
		return obj ? Object.keys(obj).map(function (key) {
			var val = obj[key];

			if (Array.isArray(val)) {
				return val.map(function (val2) {
					return encodeURIComponent(key) + '=' + encodeURIComponent(val2);
				}).join('&');
			}

			return encodeURIComponent(key) + '=' + encodeURIComponent(val);
		}).join('&') : '';
	};

	if (typeof define === 'function' && define.amd) {
		define(function() { return queryString; });
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = queryString;
	} else {
		window.queryString = queryString;
	}
})();

},{}],51:[function(require,module,exports){
(function (process){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(new Function("return this")()));

}).call(this,require('_process'))

},{"_process":38}],52:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
module.exports = require('./lib/fetchr-plugin');

},{"./lib/fetchr-plugin":53}],53:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';
var debug = require('debug')('Fluxible:FetchrPlugin');
var DEFAULT_API_PATH = '/api';
var Fetchr = require('fetchr');

/**
 * Collects metadata from the service calls so that they can be used for response headers
 * @param service
 * @param operation
 * @param metaArray
 * @returns {Function} The proxy method
 */
function crudProxy(service, operation, metaArray) {
    return function crudProxyMethod() {
        debug('service proxy');

        var args = Array.prototype.slice.call(arguments);
        // replace last argument (callback) with proxy callback
        // this is because 'config' is an optional param for services
        // thus ensuring the proxy callback is always passed in
        var callback = args.pop();
        // create proxy callback to add service meta to the context instance
        var proxyCallback = function (err, data, meta) {
            debug('service proxy callback', data, meta);
            if (meta) {
                metaArray.push(meta);
            }
            callback.apply(null, arguments);
        };

        args.push(proxyCallback);

        // execute service as usual
        service[operation].apply(service, args);
    };
}

/**
 * Creates a new fetchr plugin instance with options
 * @param {Object} options
 * @param {String} options.xhrPath The path to serve XHR requests from
 * @returns {FetchrPlugin}
 */
module.exports = function fetchrPlugin(options) {
    options = options || {};
    var xhrPath = options.xhrPath || DEFAULT_API_PATH;

    /**
     * @class FetchrPlugin
     */
    return {
        /**
         * @property {String} name Name of the plugin
         */
        name: 'FetchrPlugin',
        /**
         * Called to plug the FluxContext
         * @method plugContext
         * @param {Object} contextOptions options passed to the createContext method
         * @param {Object} contextOptions.req The server request object (only supplied if on server)
         * @param {Object} contextOptions.xhrContext Context object that will be used for all
         *      XHR calls from the client. This allows persistence of some values between requests
         *      and also CSRF validation. (e.g. { _csrf: 'a3fc2f', device: "tablet" })
         * @returns {Object}
         */
        plugContext: function plugContext(contextOptions) {
            var xhrContext = contextOptions.xhrContext;
            if (options.getXhrPath) {
                xhrPath = options.getXhrPath(contextOptions);
            }
            return {
                /**
                 * Adds the service CRUD and getServiceMeta methods to the action context
                 * @param actionContext
                 */
                plugActionContext: function plugActionContext(actionContext) {
                    var serviceMeta = [];
                    var service = new Fetchr({
                        req: contextOptions.req,
                        xhrPath: xhrPath,
                        context: xhrContext
                    });
                    actionContext.service = {
                        create: crudProxy(service, 'create', serviceMeta),
                        read: crudProxy(service, 'read', serviceMeta),
                        update: crudProxy(service, 'update', serviceMeta),
                        'delete': crudProxy(service, 'delete', serviceMeta)
                    };
                    actionContext.getServiceMeta = function getServiceMeta() {
                        return serviceMeta;
                    };
                },
                /**
                 * Called to dehydrate plugin options
                 * @method dehydrate
                 * @returns {Object}
                 */
                dehydrate: function dehydrate() {
                    return {
                        xhrContext: contextOptions.xhrContext,
                        xhrPath: xhrPath
                    };
                },
                /**
                 * Called to rehydrate plugin options
                 * @method rehydrate
                 * @returns {Object}
                 */
                rehydrate: function rehydrate(state) {
                    xhrContext = state.xhrContext;
                    xhrPath = state.xhrPath;
                }
            };
        },
        /**
         * Registers a service to the manager
         * @method registerService
         */
        registerService: function registerService(service) {
            Fetchr.registerFetcher(service);
        },
        /**
         * Get the express middleware. Only works on the server!
         * @method getMiddleware
         * @returns {Function}
         */
        getMiddleware: function () {
            return Fetchr.middleware();
        },
        /**
         * Provides access to the xhr path being used by the plugin
         * @method getXhrPath
         * @returns {String}
         */
        getXhrPath: function getXhrPath() {
            return xhrPath;
        }
    };
};

},{"debug":54,"fetchr":57}],54:[function(require,module,exports){
module.exports=require(42)
},{"./debug":55,"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/browser.js":42}],55:[function(require,module,exports){
module.exports=require(43)
},{"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/debug.js":43,"ms":56}],56:[function(require,module,exports){
module.exports=require(44)
},{"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/node_modules/ms/index.js":44}],57:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

/*jslint plusplus:true,nomen:true */

/**
 * Fetcher is a RESTful data store, that implements the CRUD interface.
 *
 * In addition, it allows request consolidation.
 * If /api accepts multi-request in one HTTP request, remote store
 * batches requests into one request.
 * @module Fetcher
 */
var REST = require('./util/http.client'),
    debug = require('debug')('FetchrClient'),
    _ = require('lodash'),
    CORE_REQUEST_FIELDS = ['resource', 'operation', 'params', 'body'],
    DEFAULT_GUID = 'g0',
    DEFAULT_XHR_PATH = '/api',
    // By default, wait for 20ms to trigger sweep of the queue, after an item is added to the queue.
    DEFAULT_BATCH_WINDOW = 20,
    MAX_URI_LEN = 2048,
    OP_READ = 'read',
    NAME = 'FetcherClient';

function parseResponse(response) {
    if (response && response.responseText) {
        try {
            return JSON.parse(response.responseText);
        } catch (e) {
            debug('json parse failed:' + e, 'error', NAME);
            return null;
        }
    }
    return null;
}

function jsonifyComplexType(value) {
    if (_.isArray(value) || _.isObject(value)) {
        return JSON.stringify(value);
    }
    return value;
}

/**
 * The queue sweeps and processs items in the queue when there are items in the queue.
 * When a item is pushed into the queue, a timeout is set to guarantee the item will be processd soon.
 * If there are any item in the queue before a item, this item can be processd sooner than its timeout.
 *
 * @class Queue
 * @constructor
 * @param {String} id         ID for the queue.
 * @param {Object} config    The configuration object.
 * @param {Function} sweepFn The function to be called when queue is sweeped.
 * @param {Array} sweepFn.items The current items in the queue.
 * @param {Function} callback The function to be used to process a given item in the queue.
 * @param {Object} callback.item The obj that was popped from the queue.
 */
function Queue(id, config, sweepFn, callback) {
    this.id = id;
    this.config = config || {};
    this._sweep = sweepFn;
    this._cb = callback;
    this._items = [];
    this._timer = null;
}

/**
 * Global unique id of the queue object.
 * @property id
 * @type String
 */
/**
 * The configuraiton object for this queue.
 * @property config
 * @type Object
 */

Queue.prototype = {
    /**
     * Once an item is pushed to the queue,
     * a timer will be set up immediate to sweep and process the items.  The time of the
     * timeout depends on queue's config (20ms by default).  If it is set to a number <= 0,
     * the queue will be sweeped and processed right away.
     * @method push
     * @param {Object} item   The item object to be pushed to the queue
     * @chainable
     */
    push : function (item) {
        if (!item) {
            return this;
        }

        if (this.config.wait <= 0) {
            // process immediately
            this._cb(item);
            this._items = [];
            return this;
        }

        var self = this;
        this._items.push(item);

        // setup timer
        if (!this._timer) {
            this._timer = setTimeout(function () {
                var items = self._items;
                self._items = [];
                clearTimeout(self._timer);
                self._timer = null;
                items = self._sweep(items);
                _.forEach(items, function (item) {
                    self._cb(item);
                });
            }, this.config.wait);
        }
        return this;
    }
};

    /**
     * Requests that are initiated within a time window are batched and sent to xhr endpoint.
     * The received responses are split and routed back to the callback function assigned by initiator
     * of each request.
     *
     * All requests go out from this store is via HTTP POST. Typical structure of the context param is:
     * <pre>
     * {
     *   config: {
     *     uri : '/api'
     *   },
     *   context: {
     *     _csrf : '5YFuDK6R',
     *     lang : 'en-US',
     *     ...
     *   }
     * }
     * </pre>
     *
     * @class FetcherClient
     * @param {object} options configuration options for Fetcher
     * @param {string} [options.xhrPath="/api"] The path for XHR requests
     * @param {number} [options.batchWindow=20] Number of milliseconds to wait to batch requests
     * @param {Object} [options.context] The context object that is propagated to all outgoing
     *      requests as query params.  It can contain current-session/context data that should
     *      persist to all requests.
     */

    function Fetcher (options) {
        this.xhrPath = options.xhrPath || DEFAULT_XHR_PATH;
        this.batchWindow = options.batchWindow || DEFAULT_BATCH_WINDOW;
        this.context = options.context || {};
    }

    Fetcher.prototype = {
        // ------------------------------------------------------------------
        // Data Access Wrapper Methods
        // ------------------------------------------------------------------

        /**
         * create operation (create as in CRUD).
         * @method create
         * @param {String} resource  The resource name
         * @param {Object} params    The parameters identify the resource, and along with information
         *                           carried in query and matrix parameters in typical REST API
         * @param {Object} body      The JSON object that contains the resource data that is being created
         * @param {Object} config    The "config" object for per-request config data.
         * @param {Function} callback callback convention is the same as Node.js
         * @static
         */
        create: function (resource, params, body, config, callback) {
            this._sync(resource, 'create', params, body, config, callback);
        },

        /**
         * read operation (read as in CRUD).
         * @method read
         * @param {String} resource  The resource name
         * @param {Object} params    The parameters identify the resource, and along with information
         *                           carried in query and matrix parameters in typical REST API
         * @param {Object} config    The "config" object for per-request config data.
         * @param {Function} callback callback convention is the same as Node.js
         * @static
         */
        read: function (resource, params, config, callback) {
            this._sync(resource, 'read', params, undefined, config, callback);
        },

        /**
         * update operation (update as in CRUD).
         * @method update
         * @param {String} resource  The resource name
         * @param {Object} params    The parameters identify the resource, and along with information
         *                           carried in query and matrix parameters in typical REST API
         * @param {Object} body      The JSON object that contains the resource data that is being updated
         * @param {Object} config    The "config" object for per-request config data.
         * @param {Function} callback callback convention is the same as Node.js
         * @static
         */
        update: function (resource, params, body, config, callback) {
            this._sync(resource, 'update', params, body, config, callback);
        },

        /**
         * delete operation (delete as in CRUD).
         * @method delete
         * @param {String} resource  The resource name
         * @param {Object} params    The parameters identify the resource, and along with information
         *                           carried in query and matrix parameters in typical REST API
         * @param {Object} config    The "config" object for per-request config data.
         * @param {Function} callback callback convention is the same as Node.js
         * @static
         */
        'delete': function (resource, params, config, callback) {
            this._sync(resource, 'delete', params, undefined, config, callback);
        },
        /**
         * Sync data with remote API.
         * @method _sync
         * @param {String} resource  The resource name
         * @param {String} operation The CRUD operation name: 'create|read|update|delete'.
         * @param {Object} params    The parameters identify the resource, and along with information
         *                           carried in query and matrix parameters in typical REST API
         * @param {Object} body      The JSON object that contains the resource data that is being updated. Not used
         *                           for read and delete operations.
         * @param {Object} config    The "config" object for per-request config data.
         * @param {Function} callback callback convention is the same as Node.js
         * @static
         * @private
         */
        _sync: function (resource, operation, params, body, config, callback) {
            if (typeof config === 'function') {
                callback = config;
                config = {};
            }

            config = config || {};
            config.xhr = this.xhrPath;

            var self = this,
                request = {
                    resource: resource,
                    operation: operation,
                    params: params,
                    body: body,
                    config: config,
                    callback: callback
                };

            if (!_.isFunction(this.batch) || !config.consolidate) {
                this.single(request);
                return;
            }

            // push request to queue so that it can be batched
            if (!this._q) {
                this._q = new Queue(this.name, {
                    wait: Fetcher.batchWindow
                }, function (requests) {
                    return self.batch(requests);
                }, function (batched) {
                    if (!batched) {
                        return;
                    }
                    if (!_.isArray(batched)) {
                        self.single(batched);
                    } else {
                        self.multi(batched);
                    }
                });
            }
            this._q.push(request);
        },
        // ------------------------------------------------------------------
        // Helper Methods
        // ------------------------------------------------------------------
        /**
         * @method _constructGetUri
         * @private
         */
        _constructGetUri: function (uri, resource, params, config) {
            var query = [], matrix = [], id_param = config.id_param, id_val, final_uri = uri + '/resource/' + resource;
            _.forEach(params, function (v, k) {
                if (k === id_param) {
                    id_val = encodeURIComponent(v);
                } else {
                    try {
                        matrix.push(k + '=' + encodeURIComponent(jsonifyComplexType(v)));
                    } catch (err) {
                        debug('jsonifyComplexType failed: ' + err, 'info', NAME);
                    }
                }
            });

            _.forEach(this.context, function (v, k) {
                query.push(k + '=' + encodeURIComponent(jsonifyComplexType(v)));
            });
            if (id_val) {
                final_uri += '/' + id_param + '/' + id_val;
            }
            if (matrix.length > 0) {
                final_uri += ';' + matrix.sort().join(';');
            }
            if (query.length > 0) {
                final_uri += '?' + query.sort().join('&');
            }
            return final_uri;
        },
        /**
         * @method _constructGroupUri
         * @private
         */
        _constructGroupUri: function (uri) {
            var query = [], final_uri = uri;
            _.forEach(this.context, function (v, k) {
                query.push(k + '=' + encodeURIComponent(v));
            });
            if (query.length > 0) {
                final_uri += '?' + query.sort().join('&');
            }
            return final_uri;
        },

        // ------------------------------------------------------------------
        // Actual Data Access Methods
        // ------------------------------------------------------------------

        /**
         * Execute a single request.
         * @method single
         * @param {Object} request
         * @param {String} request.resource  The resource name
         * @param {String} request.operation The CRUD operation name: 'create|read|update|delete'.
         * @param {Object} request.params    The parameters identify the resource, and along with information
         *                           carried in query and matrix parameters in typical REST API
         * @param {Object} request.body      The JSON object that contains the resource data that is being updated. Not used
         *                           for read and delete operations.
         * @param {Object} request.config    The "config" object for per-request config data.
         * @param {Function} request.callback callback convention is the same as Node.js
         * @protected
         * @static
         */
        single : function (request) {
            if (!request) {
                return;
            }

            var config = request.config,
                callback = request.callback || _.noop,
                use_post,
                allow_retry_post,
                uri = config.uri || config.xhr || this.xhrPath,
                get_uri,
                requests,
                data;

            use_post = request.operation !== OP_READ || config.post_for_read;
            if (!use_post) {
                get_uri = this._constructGetUri(uri, request.resource, request.params, config);
                if (get_uri.length <= MAX_URI_LEN) {
                    uri = get_uri;
                } else {
                    use_post = true;
                }
            }

            if (!use_post) {
                REST.get(uri, {}, config, function (err, response) {
                    if (err) {
                        debug('Syncing ' + request.resource + ' failed: statusCode=' + err.statusCode, 'info', NAME);
                        return callback(err);
                    }
                    callback(null, parseResponse(response));
                });
                return;
            }

            // individual request is also normalized into a request hash to pass to api
            requests = {};
            requests[DEFAULT_GUID] = _.pick(request, CORE_REQUEST_FIELDS);
            if (!request.body) {
                delete requests[DEFAULT_GUID].body;
            }
            data = {
                requests: requests,
                context: this.context
            }; // TODO: remove. leave here for now for backward compatibility
            uri = this._constructGroupUri(uri);
            allow_retry_post = (request.operation === OP_READ);
            REST.post(uri, {}, data, _.merge({unsafeAllowRetry: allow_retry_post}, config), function (err, response) {
                if (err) {
                    debug('Syncing ' + request.resource + ' failed: statusCode=' + err.statusCode, 'info', NAME);
                    return callback(err);
                }
                var result = parseResponse(response);
                if (result) {
                    result = result[DEFAULT_GUID] || {};
                } else {
                    result = {};
                }
                callback(null, result.data);
            });
        },

        /**
         * batch the requests.
         * @method batch
         * @param {Array} requests Array of requests objects to be batched. Each request is an object with properties:
         *                             `resource`, `operation, `params`, `body`, `config`, `callback`.
         * @return {Array} the request batches.
         * @protected
         * @static
         */
        batch : /* istanbul ignore next */ function (requests) {
            if (!_.isArray(requests) || requests.length <= 1) {
                return requests;
            }

            var batched,
                groups = {};

            _.forEach(requests, function (request) {
                var uri, batch, group_id;
                if (request.config) {
                    uri = request.config.uri || request.config.xhr || '';
                    batch = request.config.batch;
                }
                group_id = 'uri:' + uri;
                if (batch) {
                    group_id += ';batch:' + batch;
                }
                if (!groups[group_id]) {
                    groups[group_id] = [];
                }
                groups[group_id].push(request);
            });
            batched = _.values(groups);

            if (batched.length < requests.length) {
                debug(requests.length + ' requests batched into ' + batched.length, 'info', NAME);
            }
            return batched;
        },

        /**
         * Execute multiple requests that have been batched together.
         * @method single
         * @param {Array} requests  The request batch.  Each item in this array is a request object with properties:
         *                             `resource`, `operation, `params`, `body`, `config`, `callback`.
         * @protected
         * @static
         */
        multi : /* istanbul ignore next */ function (requests) {
            var uri,
                data,
                count = 0,
                config,
                allow_retry_post = true,
                request_map = {};

            _.some(requests, function (request) {
                if (request.config) {
                    config = request.config;
                    return true;
                }
                return false;
            }, this);

            uri = config.uri || config.xhr || this.xhrPath;

            data = {
                requests: {},
                context: this.context
            }; // TODO: remove. leave here for now for backward compatibility

            _.forEach(requests, function (request) {
                var guid = 'g' + (count++);
                data.requests[guid] = _.pick(request, CORE_REQUEST_FIELDS);
                request_map[guid] = request;
                if (request.operation !== OP_READ) {
                    allow_retry_post = false;
                }
            });

            uri = this._constructGroupUri(uri);
            REST.post(uri, {}, data, _.merge({unsafeAllowRetry: allow_retry_post}, config), function (err, response) {
                if (err) {
                    _.forEach(requests, function (request) {
                        request.callback(err);
                    });
                    return;
                }
                var result = parseResponse(response);
                // split result for requests, so that each request gets back only the data that was originally requested
                _.forEach(request_map, function (request, guid) {
                    var res = (result && result[guid]) || {};
                    if (request.callback) {
                        request.callback(res.err || null, res.data || null);
                    }
                });
            });
        }
    };

    module.exports = Fetcher;

},{"./util/http.client":58,"debug":54,"lodash":92}],58:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
/*jslint nomen:true,plusplus:true*/
/**
 * @module rest-http
 */

/*
 * Default configurations:
 *   timeout: timeout (in ms) for each request
 *   retry: retry related settings, such as retry interval amount (in ms), max_retries.
 *          Note that only retry only applies on GET.
 */
var _ = require('lodash'),
    DEFAULT_CONFIG = {
        timeout: 3000,
        retry: {
            interval: 200,
            max_retries: 2
        }
    },
    CONTENT_TYPE = 'Content-Type',
    TYPE_JSON = 'application/json',
    TIMEOUT = 'timeout',
    METHOD_GET = 'GET',
    METHOD_PUT = 'PUT',
    METHOD_POST = 'POST',
    METHOD_DELETE = 'DELETE',
    NULL = null,
    xhr = require('xhr');

//trim polyfill, maybe pull from npm later
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^\s+|\s+$/g, '');
  };
}

function normalizeHeaders(headers) {
    var normalized = {};
    _.forEach(headers, function (v, field) {
        if (field.toLowerCase() === 'content-type') {
            normalized[CONTENT_TYPE] = v;
        } else {
            normalized[field] = v;
        }
    });
    return normalized;
}

function isContentTypeJSON(headers) {
    return _.some(headers[CONTENT_TYPE].split(';'), function (part) {
        return part.trim().toLowerCase() === TYPE_JSON;
    });
}

function shouldRetry(method, config, statusCode) {
    var isIdempotent = (method === METHOD_GET || method === METHOD_PUT || method === METHOD_DELETE);
    if (!isIdempotent && !config.unsafeAllowRetry) {
        return false;
    }
    if ((statusCode !== 0 && statusCode !== 408 && statusCode !== 999) || config.tmp.retry_counter >= config.retry.max_retries) {
        return false;
    }
    config.tmp.retry_counter++;
    config.retry.interval =  config.retry.interval * 2;
    return true;
}

function mergeConfig(config) {
    var cfg = {
            timeout: DEFAULT_CONFIG.timeout,
            unsafeAllowRetry: config.unsafeAllowRetry || false,
            retry: {
                interval: DEFAULT_CONFIG.retry.interval,
                max_retries: DEFAULT_CONFIG.retry.max_retries
            }
        }, // Performant-but-verbose way of cloning the default config as base
        timeout,
        interval,
        maxRetries;

    if (config) {
        timeout = parseInt(config.timeout, 10);
        if (_.isNumber(timeout) && timeout > 0) {
            cfg.timeout = timeout;
        }

        if (config.retry) {
            interval = parseInt(config.retry && config.retry.interval, 10);
            if (_.isNumber(interval) && interval > 0) {
                cfg.retry.interval = interval;
            }
            maxRetries = parseInt(config.retry && config.retry.max_retries, 10);
            if (_.isNumber(maxRetries) && maxRetries >= 0) {
                cfg.retry.max_retries = maxRetries;
            }
        }

        // tmp stores transient state data, such as retry count
        if (config.tmp) {
            cfg.tmp = config.tmp;
        }
    }

    return cfg;
}

function doXhr(method, url, headers, data, config, callback) {
    var options, timeout;

    config = mergeConfig(config);
    headers = normalizeHeaders(headers);
    headers[CONTENT_TYPE] = headers[CONTENT_TYPE] || TYPE_JSON;
    // use config.tmp to store temporary values
    config.tmp = config.tmp || {retry_counter: 0};

    timeout = config.timeout;
    options = {
        method : method,
        timeout : timeout,
        headers: headers,
        on : {
            success : function (err, response) {
                callback(NULL, response);
            },
            failure : function (err, response) {
                if (!shouldRetry(method, config, response.status)) {
                    callback(err);
                } else {
                    _.delay(
                        function retryXHR() { doXhr(method, url, headers, data, config, callback); },
                        config.retry.interval
                    );
                }
            }
        }
    };
    if (data !== undefined && data !== NULL) {
        options.data = isContentTypeJSON(headers) ? JSON.stringify(data) : data;
    }
    io(url, options);
}

function io(url, options) {
    xhr({
        url: url,
        method: options.method || METHOD_GET,
        timeout: options.timeout,
        headers: options.headers,
        body: options.data
    }, function (err, resp, body) {
        var status = resp.statusCode;
        var errMessage;

        if (!err && (status === 0 || (status >= 400 && status < 600))) {
            if (typeof body === 'string') {
                errMessage = body;
            } else {
                errMessage = status ? 'Error ' + status : 'Internal XMLHttpRequest Error';
            }

            err = new Error(errMessage);
            err.statusCode = status;
            if (408 === status || 0 === status) {
                err.timeout = options.timeout;
            }
        }

        resp.responseText = body;

        if (err) {
            options.on.failure.call(null, err, resp);
        } else {
            options.on.success.call(null, null, resp);
        }
    });
}

/**
 * @class REST.HTTP
 */
module.exports = {
    /**
     * @method get
     * @public
     * @param {String} url
     * @param {Object} headers
     * @param {Object} config  The config object.
     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request
     * @param {Object} config.retry   Retry config object.
     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).
     * @param {Number} [config.retry.max_retries=2]   Nmber of max retries.
     * @param {Function} callback The callback funciton, with two params (error, response)
     */
    get : function (url, headers, config, callback) {
        doXhr(METHOD_GET, url, headers, NULL, config, callback);
    },

    /**
     * @method put
     * @param {String} url
     * @param {Object} headers
     * @param {Mixed}  data
     * @param {Object} config  The config object. No retries for PUT.
     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request
     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).
     * @param {Number} [config.retry.max_retries=2]   Nmber of max retries.
     * @param {Function} callback The callback funciton, with two params (error, response)
     */
    put : function (url, headers, data, config, callback) {
        doXhr(METHOD_PUT, url, headers, data, config, callback);
    },

    /**
     * @method post
     * @param {String} url
     * @param {Object} headers
     * @param {Mixed}  data
     * @param {Object} config  The config object. No retries for POST.
     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request
     * @param {Boolean} [config.unsafeAllowRetry=false] Whether to allow retrying this post.
     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).
     * @param {Number} [config.retry.max_retries=2]   Nmber of max retries.
     * @param {Function} callback The callback funciton, with two params (error, response)
     */
    post : function (url, headers, data, config, callback) {
        doXhr(METHOD_POST, url, headers, data, config, callback);
    },

    /**
     * @method delete
     * @param {String} url
     * @param {Object} headers
     * @param {Object} config  The config object. No retries for DELETE.
     * @param {Number} [config.timeout=3000] Timeout (in ms) for each request
     * @param {Number} [config.retry.interval=200]  The start interval unit (in ms).
     * @param {Number} [config.retry.max_retries=2]   Nmber of max retries.
     * @param {Function} callback The callback funciton, with two params (error, response)
     */
    'delete' : function (url, headers, config, callback) {
        doXhr(METHOD_DELETE, url, headers, NULL, config, callback);
    }
};

},{"lodash":92,"xhr":59}],59:[function(require,module,exports){
"use strict";
var window = require("global/window")
var once = require("once")
var parseHeaders = require("parse-headers")


var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    function readystatechange() {
        if (xhr.readyState === 4) {
            loadFunc()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === "text" || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }
    
    var failureResponse = {
                body: undefined,
                headers: {},
                statusCode: 0,
                method: method,
                url: uri,
                rawRequest: xhr
            }
    
    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "unknown") )
        }
        evt.statusCode = 0
        callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        clearTimeout(timeoutTimer)
        
        var status = (xhr.status === 1223 ? 204 : xhr.status)
        var response = failureResponse
        var err = null
        
        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        callback(err, response, response.body)
        
    }
    
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    if(typeof callback === "undefined"){
        throw new Error("callback argument missing")
    }
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var key
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer

    if ("json" in options) {
        isJson = true
        headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync)
    //has to be after open
    xhr.withCredentials = !!options.withCredentials
    
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            xhr.abort("timeout");
        }, options.timeout+2 );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr


}


function noop() {}

},{"global/window":60,"once":61,"parse-headers":65}],60:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],61:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],62:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":63}],63:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],64:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],65:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
},{"for-each":62,"trim":64}],66:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
module.exports = require('./lib/routr-plugin');

},{"./lib/routr-plugin":67}],67:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';
var Router = require('routr');

module.exports = function routrPlugin(options) {
    options = options || {};
    var routes = options.routes;
    /**
     * @class RoutrPlugin
     */
    return {
        name: 'RoutrPlugin',
        /**
         * Called to plug the FluxContext
         * @method plugContext
         * @returns {Object}
         */
        plugContext: function plugContext() {
            var router = new Router(routes);
            return {
                /**
                 * Provides full access to the router in the action context
                 * @param {Object} actionContext
                 */
                plugActionContext: function plugActionContext(actionContext) {
                    actionContext.router = router;
                },
                /**
                 * Provides access to create paths by name
                 * @param {Object} componentContext
                 */
                plugComponentContext: function plugComponentContext(componentContext) {
                    componentContext.makePath = router.makePath.bind(router);
                }
            };
        },
        /**
         * @method getRoutes
         * @returns {Object}
         */
        getRoutes: function getRoutes() {
            return routes;
        }
    };
};

},{"routr":71}],68:[function(require,module,exports){
module.exports=require(42)
},{"./debug":69,"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/browser.js":42}],69:[function(require,module,exports){
module.exports=require(43)
},{"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/debug.js":43,"ms":70}],70:[function(require,module,exports){
module.exports=require(44)
},{"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/node_modules/ms/index.js":44}],71:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
module.exports = require('./lib/router');

},{"./lib/router":72}],72:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';
/*global process:true */

var debug = require('debug')('Routr:router');
var pathToRegexp = require('path-to-regexp');
var reverend = require('reverend');
var METHODS = {
    GET: 'get'
};

/**
 * @class Route
 * @param {String} name  The name of the route
 * @param {Object} config  The configuration for this route.
 * @param {String} config.path  The path of the route.
 * @constructor
 */
function Route(name, config) {
    this.name = name;
    this.config = config || {};
    this.keys = [];
    this.regexp = pathToRegexp(this.config.path, this.keys);
}

/**
 * Whether the given method is accepted by this route.
 * @method acceptMethod
 * @param {String} method  The HTTP VERB string.
 * @return true if the method is accepted; false otherwise.
 * @for Route
 */
Route.prototype.acceptMethod = function (method) {
    //TODO support array for method, ['get', 'post']
    return method === this.config.method;
};

/**
 * Checkes whether this route matches the given url, method (GET as default) and optional navigation related criteria.
 * @method match
 * @param {String} url   The relative url to be matched to this route.  Query strings and hash fragments
 *                       are **not** considered when performing the match.  E.g. /some_path?foo=bar#hashBaz
 *                       would match to the same route as /some_path
 * @param {Object} [options]
 * @param {String} [options.method=get] The case-insensitive HTTP method string.  Defaults to 'get'.
 * @param {Object} [options.navigate] The navigation info.
 * @param {Object} [options.navigate.type] The navigation type: 'pageload', 'click', 'popstate'.
 * @param {Object} [options.navigate.params] The navigation params (that are not part of the path).
 * @return {Object|null} The matched route params if path/method/navParams matches to this route; null otherwise.
 * @for Route
 */
Route.prototype.match = function (url, options) {
    if (!url) {
        return null;
    }

    options = options || {};

    var self = this;
    var i;
    var len;

    // 1. check method
    var method = (options.method && options.method.toLowerCase()) || METHODS.GET;
    if (!self.acceptMethod(method)) {
        return null;
    }

    // 2. check path
    // remove query string and hash fragment from url
    var pos = url.indexOf('?');
    var path;
    if (pos >= 0) {
        // remove query string
        path = url.substring(0, pos);
    } else {
        pos = url.indexOf('#');
        if (pos >= 0) {
            // hash fragment does not get sent to server.
            // But since routr can be used on both server and client,
            // we should remove hash fragment before matching the regex.
            path = url.substring(0, pos);
        } else {
            path = url;
        }
    }

    var pathMatches = self.regexp.exec(path);
    if (!pathMatches) {
        return null;
    }

    // 3. check navParams, if this route has match requirements defined for navParams
    var navParamsConfig = (self.config.navigate && self.config.navigate.params);
    if (navParamsConfig) {
        var navParamConfigKeys = Object.keys(navParamsConfig);
        var navParams = (options.navigate && options.navigate.params) || {};
        var navParamMatched;

        for (i = 0, len = navParamConfigKeys.length; i < len; i++) {
            // for each navParam defined in the route config, make sure
            // the param passed in matches the defined pattern
            var configKey = navParamConfigKeys[i];
            var pattern = navParamsConfig[configKey];
            if (pattern instanceof RegExp) {
                navParamMatched = navParams[configKey] !== undefined && pattern.test(navParams[configKey]);
            } else {
                navParamMatched = (navParams[configKey] === pattern);
            }
            if (!navParamMatched) {
                // found a non-matching navParam -> this route does not match
                return null;
            }
        }
    }

    // 4. method/path/navParams all matched, extract the matched path params
    var routeParams = {};
    for (i = 0, len = self.keys.length; i < len; i++) {
        routeParams[self.keys[i].name] = pathMatches[i+1];
    }

    return routeParams;
};

/**
 * Generates a path string with this route, using the specified params.
 * @method makePath
 * @param {Object} params  The route parameters to be used to create the path string
 * @return {String} The generated path string.
 * @for Route
 */
Route.prototype.makePath = function (params) {
    try {
        return reverend(this.config.path, params);
    } catch (e) {
        debug('Route.makePath failed, e = ', e);
        return null;
    }
};

/**
 * A Router class that provides route matching and route generation functionalities.
 * @class Router
 * @param {Object} routes  Route table, which is a name to router config map.
 * @constructor
 * @example
    var Router = require('routr'),
        router,
        route;

    var router = new Router({
        view_user: {
            path: '/user/:id',
            method: 'get',
            foo: {
                bar: 'baz'
            }
        }
    });

    route = router.getRoute('/user/garfield');
    if (route) {
        // this will output:
        //   - "view_user" for route.name
        //   - "/user/garfield" for route.url
        //   - {id: "garfield"} for route.params
        //   - {path: "/user/:id", method: "get", foo: { bar: "baz"}} for route.config
        console.log('[Route found]: name=', route.name, 'url=', route.url, 'params=', route.params, 'config=', route.config);
    }
 */
function Router(routes) {
    var self = this;
    self._routes = {};
    debug('new Router, routes = ', routes);
    if (routes) {
        Object.keys(routes).forEach(function createRoute(name) {
            self._routes[name] = new Route(name, routes[name]);
        });
    }
    if (process.env.NODE_ENV !== 'production') {
        if ('function' === typeof Object.freeze) {
            Object.keys(self._routes).forEach(function freezeRoute(name) {
                var route = self._routes[name];
                Object.freeze(route.config);
                Object.freeze(route.keys);
                Object.freeze(route);
            });
            Object.freeze(self._routes);
        }
    }
}

/**
 * @method getRoute
 * @param {String} url   The url to be used for route matching.  Query strings are **not** considered
 *                        when performing the match.  E.g. /some_path?foo=bar would match to the same route
 *                        as /some_path
 * @param {Object} [options]
 * @param {String} [options.method=get] The case-insensitive HTTP method string.
 * @param {Object} [options.navigate] The navigation info.
 * @param {Object} [options.navigate.type] The navigation type: 'pageload', 'click', 'popstate'.
 * @param {Object} [options.navigate.params] The navigation params (that are not part of the path).
 * @return {Object|null} The matched route info if path/method/navigate.params matches to a route; null otherwise.
 */
Router.prototype.getRoute = function (url, options) {
    var keys = Object.keys(this._routes);
    var route;
    var match;

    for (var i = 0, len = keys.length; i < len; i++) {
        route = this._routes[keys[i]];
        match = route.match(url, options);
        if (match) {
            return {
                name: keys[i],
                url: url,
                params: match,
                config: route.config,
                navigate: options && options.navigate
            };
        }
    }
    return null;
};

/**
 * Generates a path string with the route with the given name, using the specified params.
 * @method makePath
 * @param {String} name  The route name
 * @param {Object} params  The route parameters to be used to create the path string
 * @return {String} The generated path string, null if there is no route with the given name.
 */
Router.prototype.makePath = function (name, params) {
    return (name && this._routes[name] && this._routes[name].makePath(params)) || null;
};

module.exports = Router;
}).call(this,require('_process'))

},{"_process":38,"debug":68,"path-to-regexp":73,"reverend":75}],73:[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys) {
  var index = 0;

  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  return path.replace(PATH_REGEXP, replace);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

},{"isarray":74}],74:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],75:[function(require,module,exports){
/**\
   Copyright (C) 2014 eBay Software Foundation                               
                                                                             
   Licensed under the Apache License, Version 2.0 (the "License");           
   you may not use this file except in compliance with the License.          
   You may obtain a copy of the License at                                   
                                                                             
     http://www.apache.org/licenses/LICENSE-2.0                              
                                                                             
   Unless required by applicable law or agreed to in writing, software       
   distributed under the License is distributed on an "AS IS" BASIS,         
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
   See the License for the specific language governing permissions and       
   limitations under the License.                                            
 \**/
 // RegExp patterns used from: https://github.com/component/path-to-regexp (MIT)
'use strict';

var path2regex = require('path-to-regexp');


module.exports = function reverend(route, obj) {
    var keys, path, routeRegex;

    // Support `route` being an array (which path-to-regexp supports), and
    // prefer the first item because we want the best-fit URL.
    if (Array.isArray(route)) {
        route = route[0];
    }

    // Restrict `route` to Strings since a RegExp route can't be used to
    // generate a path (path-to-regexp supports RegExp route paths).
    if (typeof route !== 'string') {
        throw new TypeError('route must be a String path');
    }

    keys = [];
    path = route;
    routeRegex = path2regex(route, keys);

    keys.forEach(function (key) {
        var value, regex;

        value = obj[key.name];

        // Enforce required keys having a value.
        if (!key.optional && value === undefined) {
            throw new RangeError('A value must be provided for: ' + key.name);
        }

        // Pattern used in both unnamed (e.g., "/posts/(.*)") and custom match
        // parameters (e.g., "/posts/:id(\\d+)").
        regex = '\\(((?:\\\\.|[^)])*)\\)';

        // A key's `name` will be a String for named parameters, and a Number
        // for unnamed parameters. This prefixes the base regexp pattern with
        // the name, and makes the custom-matching part optional (which follows
        // what path-to-regexp does.)
        if (typeof key.name === 'string') {
            regex = '\\:' + key.name + '(?:' + regex + ')?';
        }

        // Append suffix pattern.
        regex += '([+*?])?';

        if (key.optional && value === undefined) {
            // No value so remove potential trailing '/'
            // since the path segment is optional.
            value = '';
            regex += '\\/?';
        }

        value = encodeURIComponent(value);
        path = path.replace(new RegExp(regex), value);
    });


    // Make sure the `path` produced will actually be matched by the `route`.
    if (!routeRegex.test(path)) {
        throw new RangeError('"' + path + '" will not match: "' + route + '"');
    }

    return path;
};

},{"path-to-regexp":76}],76:[function(require,module,exports){
/**
 * Expose `pathtoRegexp`.
 */
module.exports = pathtoRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match already escaped characters that would otherwise incorrectly appear
  // in future matches. This allows the user to escape special characters that
  // shouldn't be transformed.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that should always be escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
var attachKeys = function (re, keys) {
  re.keys = keys;

  return re;
};

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array should be passed in, which will contain the placeholder key
 * names. For example `/user/:id` will then contain `["id"]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 keys
 * @param  {Object}                options
 * @return {RegExp}
 */
function pathtoRegexp (path, keys, options) {
  if (keys && !Array.isArray(keys)) {
    options = keys;
    keys = null;
  }

  keys = keys || [];
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var index = 0;

  if (path instanceof RegExp) {
    // Match all capturing groups of a regexp.
    var groups = path.source.match(/\((?!\?)/g) || [];

    // Map all the matches to their numeric keys and push into the keys.
    keys.push.apply(keys, groups.map(function (match, index) {
      return {
        name:      index,
        delimiter: null,
        optional:  false,
        repeat:    false
      };
    }));

    // Return the source back to the user.
    return attachKeys(path, keys);
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    // Generate a new regexp instance by joining all the parts together.
    return attachKeys(new RegExp('(?:' + path.join('|') + ')', flags), keys);
  }

  // Alter the path string into a usable regexp.
  path = path.replace(PATH_REGEXP, function (match, escaped, prefix, key, capture, group, suffix, escape) {
    // Avoiding re-escaping escaped characters.
    if (escaped) {
      return escaped;
    }

    // Escape regexp special characters.
    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    // Escape the prefix character.
    prefix = prefix ? '\\' + prefix : '';

    // Match using the custom capturing group, or fallback to capturing
    // everything up to the next slash (or next period if the param was
    // prefixed with a period).
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    // Allow parameters to be repeated more than once.
    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    // Allow a parameter to be optional.
    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  });

  // Check whether the path ends in a slash as it alters some match behaviour.
  var endsWithSlash = path[path.length - 1] === '/';

  // In non-strict mode we allow an optional trailing slash in the match. If
  // the path to match already ended with a slash, we need to remove it for
  // consistency. The slash is only valid at the very end of a path match, not
  // anywhere in the middle. This is important for non-ending mode, otherwise
  // "/test/" will match "/test//route".
  if (!strict) {
    path = (endsWithSlash ? path.slice(0, -2) : path) + '(?:\\/(?=$))?';
  }

  // In non-ending mode, we need prompt the capturing groups to match as much
  // as possible by using a positive lookahead for the end or next path segment.
  if (!end) {
    path += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + path + (end ? '$' : ''), flags), keys);
};

},{}],77:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
module.exports = require('./lib/Fluxible');
module.exports.Mixin = require('./mixins/FluxibleMixin');
module.exports.FluxibleMixin = module.exports.Mixin;

},{"./lib/Fluxible":78,"./mixins/FluxibleMixin":80}],78:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var debug = require('debug')('Fluxible');
var async = require('async');
var FluxibleContext = require('./FluxibleContext');
var dispatcherClassFactory = require('dispatchr');

/**
 * Provides a structured way of registering an application's configuration and
 * resources.
 * @class Fluxible
 * @param {Object} [options]
 * @param {Object} [options.appComponent] The root application component
 * @param {String} [options.pathPrefix] The path used for application calls
 * @constructor
 *
 * @example
 *      var app = new Fluxible({
 *          appComponent: require('./components/App.jsx'),
 *          plugins: [
 *              require('./plugins/Foo')
 *          ]
 *      });
 */
function Fluxible(options) {
    debug('Fluxible instance instantiated', options);
    options = options || {};

    // Options
    this._appComponent = options.appComponent;
    this._plugins = [];

    // Initialize dependencies
    this._dispatcherClass = dispatcherClassFactory();
}

/**
 * Creates an isolated context for a request/session
 * @method createContext
 * @param {Object} [options]
 * @returns {FluxibleContext}
 */
Fluxible.prototype.createContext = function createContext(options) {
    var self = this;
    options = options || {};
    options.app = self;
    var context = new FluxibleContext(options);

    // Plug context with app plugins that implement plugContext method
    this._plugins.forEach(function eachPlugin(plugin) {
        if (plugin.plugContext) {
            var contextPlugin = plugin.plugContext(options, context, self);
            contextPlugin.name = contextPlugin.name || plugin.name;
            context.plug(contextPlugin);
        }
    });

    return context;
};

/**
 * Creates a new dispatcher instance using the application's dispatchr class. Used by
 * FluxibleContext to create new dispatcher instance
 * @method createDispatcherInstance
 * @param {Object} context The context object to be provided to each store instance
 * @returns {Dispatcher}
 */
Fluxible.prototype.createDispatcherInstance = function createDispatcherInstance(context) {
    return new (this._dispatcherClass)(context);
};

/**
 * Provides plugin mechanism for adding application level settings that are persisted
 * between server/client and also modification of the FluxibleContext
 * @method plug
 * @param {Object} plugin
 * @param {String} plugin.name Name of the plugin
 * @param {Function} plugin.plugContext Method called after context is created to allow
 *  dynamically plugging the context
 * @param {Object} [plugin.dehydrate] Method called to serialize the plugin settings to be persisted
 *  to the client
 * @param {Object} [plugin.rehydrate] Method called to rehydrate the plugin settings from the server
 */
Fluxible.prototype.plug = function (plugin) {
    if (!plugin.name) {
        throw new Error('Application plugin must have a name');
    }
    this._plugins.push(plugin);
};

/**
 * Provides access to a plugin instance by name
 * @method getPlugin
 * @param {String} pluginName The plugin name
 * @returns {Object}
 */
Fluxible.prototype.getPlugin = function (pluginName) {
    var plugin = null;
    this._plugins.forEach(function (p) {
        if (pluginName === p.name) {
            plugin = p;
        }
    });
    return plugin;
};

/**
 * Getter for the top level react component for the application
 * @method getAppComponent
 * @returns {Object}
 */
Fluxible.prototype.getAppComponent = function getAppComponent() {
    return this._appComponent;
};

/**
 * Registers a store to the dispatcher so it can listen for actions
 * @method registerStore
 */
Fluxible.prototype.registerStore = function registerStore() {
    debug(arguments[0].storeName + ' store registered');
    this._dispatcherClass.registerStore.apply(this._dispatcherClass, arguments);
};

/**
 * Creates a serializable state of the application and a given context for sending to the client
 * @method dehydrate
 * @param {FluxibleContext} context
 * @returns {Object} Dehydrated state object
 */
Fluxible.prototype.dehydrate = function dehydrate(context) {
    debug('dehydrate', context);
    var self = this;
    var state = {
        context: context.dehydrate(),
        plugins: {}
    };

    this._plugins.forEach(function (plugin) {
        if ('function' === typeof plugin.dehydrate) {
            // Use a namespace for storing plugin state and provide access to the application
            state.plugins[plugin.name] = plugin.dehydrate(self);
        }
    });

    return state;
};

/**
 * Rehydrates the application and creates a new context with the state from the server
 * @method rehydrate
 * @param {Object} obj Raw object of dehydrated state
 * @param {Object} obj.plugins Dehydrated app plugin state
 * @param {Object} obj.context Dehydrated context state
 * @param {Function} callback
 * @async Rehydration may require more asset loading or async IO calls
 */
Fluxible.prototype.rehydrate = function rehydrate(obj, callback) {
    debug('rehydrate', obj);
    var self = this;
    obj.plugins = obj.plugins || {};
    var pluginTasks = this._plugins.filter(function (plugin) {
        return 'function' === typeof plugin.rehydrate;
    }).map(function (plugin) {
        return function (asyncCallback) {
            if (2 === plugin.rehydrate.length) { // Async plugin
                plugin.rehydrate(obj.plugins[plugin.name], asyncCallback);
            } else { // Sync plugin
                try {
                    plugin.rehydrate(obj.plugins[plugin.name]);
                } catch (e) {
                    asyncCallback(e);
                    return;
                }
                asyncCallback();
            }
        };
    });

    async.parallel(pluginTasks, function rehydratePluginTasks(err) {
        if (err) {
            callback(err);
            return;
        }
        var context = self.createContext();
        context.rehydrate(obj.context);
        callback(null, context);
    });
};

module.exports = Fluxible;

},{"./FluxibleContext":79,"async":81,"debug":82,"dispatchr":85}],79:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var debug = require('debug')('Fluxible:Context');
var objectAssign = require('object-assign');
require('setimmediate');

/**
 * A request or browser-session context
 * @class FluxibleContext
 * @param {Object} options
 * @param {Fluxible} options.app The Fluxible instance used to create the context
 * @constructor
 */
function FluxContext(options) {
    options = options || {};

    // Options
    this._app = options.app;

    // To be created on demand
    this._dispatcher = null;

    // Plugins
    this._plugins = [];

    // Set up contexts
    this._actionContext = null;
    this._componentContext = null;
    this._storeContext = null;
}

/**
 * Creates an instance of the app level component with given props and a proper component
 * context.
 * @param {Object} props
 * @return {ReactElement}
 */
FluxContext.prototype.createElement = function createElement(props) {
    var Component = this._app.getAppComponent();
    if (!Component) {
        throw new Error('An appComponent was not specified.');
    }
    return Component(objectAssign({}, props, {
        context: this.getComponentContext()
    }));
};

/**
 * Provides plugin mechanism for adding application level settings that are persisted
 * between server/client and also modification of the FluxibleContext
 * @method plug
 * @param {Object} plugin
 * @param {String} plugin.name Name of the plugin
 * @param {Function} [plugin.plugActionContext] Method called after action context is created to allow
 *  dynamically modifying the action context
 * @param {Function} [plugin.plugComponentContext] Method called after component context is created to
 *  allow dynamically modifying the component context
 * @param {Function} [plugin.plugStoreContext] Method called after store context is created to allow
 *  dynamically modifying the store context
 * @param {Object} [plugin.dehydrate] Method called to serialize the plugin settings to be persisted
 *  to the client
 * @param {Object} [plugin.rehydrate] Method called to rehydrate the plugin settings from the server
 */
FluxContext.prototype.plug = function (plugin) {
    if (!plugin.name) {
        throw new Error('Context plugin must have a name');
    }
    this._plugins.push(plugin);
};

/**
 * Executes an action passing an action interface to as the first parameter
 * @param {Function} action An action creator function that receives actionContext, payload,
 *  and done as parameters
 * @param {Object} payload The action payload
 * @param {Function} done Method to be called once action execution has completed
 */
FluxContext.prototype.executeAction = function executeAction(action, payload, done) {
    var self = this;
    payload = payload || {};
    setImmediate(function executeActionImmediate() {
        debug('Executing action ' + (action.name) + ' with payload', payload);
        action(self.getActionContext(), payload, done);
    });
};

/**
 * Sets up the dispatcher with access to the store context
 * @method _initializeDispatcher
 * @private
 */
FluxContext.prototype._initializeDispatcher = function initializeDispatcher() {
    this._dispatcher = this._app.createDispatcherInstance(this.getStoreContext());
};

/**
 * Returns the context for action controllers
 * @method getActionContext
 * @return {Object} Action context information
 */
FluxContext.prototype.getActionContext = function getActionContext() {
    if (this._actionContext) {
        return this._actionContext;
    }
    var self = this;

    if (!self._dispatcher) {
        self._initializeDispatcher();
    }

    var actionContext = {
        dispatch: this._dispatcher.dispatch.bind(this._dispatcher),
        executeAction: this.executeAction.bind(this),
        getStore: this._dispatcher.getStore.bind(this._dispatcher)
    };

    self._plugins.forEach(function pluginsEach(plugin) {
        var actionContextPlugin = plugin.plugActionContext;
        if (actionContextPlugin) {
            actionContextPlugin(actionContext, self, self._app);
        }
    });

    self._actionContext = actionContext;

    return self._actionContext;
};

/**
 * Returns the context for action controllers
 * @method getComponentContext
 * @return {Object} Component context information
 */
FluxContext.prototype.getComponentContext = function getComponentContext() {
    if (this._componentContext) {
        return this._componentContext;
    }
    var self = this;
    if (!self._dispatcher) {
        self._initializeDispatcher();
    }

    var componentContext = {
        getStore: this._dispatcher.getStore.bind(this._dispatcher),
        // Disallows components from handling the callback for an action
        executeAction: function componentExecuteAction(action, payload) {
            self.executeAction(action, payload, function executeActionCallback(err) {
                // @TODO provide a way to configure component action error handler
                if (err) {
                    debug('Action returned error', err);
                    throw err;
                }
            });
        }
    };

    self._plugins.forEach(function pluginsEach(plugin) {
        var componentPlugin = plugin.plugComponentContext;
        if (componentPlugin) {
            componentPlugin(componentContext, self, self._app);
        }
    });

    self._componentContext = componentContext;
    return self._componentContext;
};

/**
 * Returns the context for stores
 * @method getStoreContext
 * @return {Object} Store context information
 */
FluxContext.prototype.getStoreContext = function getStoreContext() {
    if (this._storeContext) {
        return this._storeContext;
    }
    var self = this;
    var storeContext = {};

    self._plugins.forEach(function pluginsEach(plugin) {
        var storeContextPlugin = plugin.plugStoreContext;
        if (storeContextPlugin) {
            storeContextPlugin(storeContext, self, self._app);
        }
    });

    self._storeContext = storeContext;
    return self._storeContext;
};

/**
 * Returns a serializable context state
 * @method dehydrate
 * @return {Object} See rehydrate method for properties
 */
FluxContext.prototype.dehydrate = function dehydrate() {
    var self = this;
    var state = {
        dispatcher: (this._dispatcher && this._dispatcher.dehydrate()) || {},
        plugins: {}
    };

    self._plugins.forEach(function pluginsEach(plugin) {
        if ('function' === typeof plugin.dehydrate) {
            // Use a namespace for storing plugin state and provide access to the application
            state.plugins[plugin.name] = plugin.dehydrate(self);
        }
    });

    return state;
};

/**
 * Rehydrates the context state
 * @method rehydrate
 * @param {Object} obj Configuration
 * @param {Object} obj.plugins Dehydrated context plugin state
 * @param {Object} obj.dispatcher Dehydrated dispatcher state
 */
FluxContext.prototype.rehydrate = function rehydrate(obj) {
    var self = this;
    obj.plugins = obj.plugins || {};
    self._plugins.forEach(function pluginsEach(plugin) {
        if ('function' === typeof plugin.rehydrate) {
            // Send in the plugin namespace state and provide access to the application instance
            plugin.rehydrate(obj.plugins[plugin.name], self);
        }
    });

    self._dispatcher = this._app.createDispatcherInstance(self.getStoreContext());
    self._dispatcher.rehydrate(obj.dispatcher || {});
};

module.exports = FluxContext;

},{"debug":82,"object-assign":93,"setimmediate":90}],80:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

/**
 * React mixin for staticly declaring and add/remove-ing listeners for Store events.
 * @class FluxibleMixin
 * @example
 * // Register listener default handler function name
 * var Component = React.createClass({
 *     mixins: [FluxibleMixin],
 *     statics: {
 *         storeListeners: [MockStore]
 *     },
 *     onChange: function () {
 *         done();
 *     },
 *     ...
 * });
 * @example
 * // Register listener with custom named handler
 * var Component = React.createClass({
 *     mixins: [FluxibleMixin],
 *     statics: {
 *         storeListeners: {
 *             'onChange2': [MockStore]
 *         }
 *     },
 *     onChange2: function () {
 *         done();
 *     },
 *     ...
 * });
 */
var DEFAULT_CHANGE_HANDLER = 'onChange';
var React = require('react');

var FluxibleMixin = {
    contextTypes: {
        getStore: React.PropTypes.func,
        executeAction: React.PropTypes.func
    },
    /**
     * Registers staticly declared listeners
     * @method componentDidMount
     */
    componentDidMount: function componentDidMount() {
        this.listeners = [];
        var self = this;

        // Register static listeners
        this.getListeners().forEach(function(listener) {
            self._attachStoreListener(listener);
        });
    },

    /**
     * Calls an action
     * @method executeAction
     */
    executeAction: function executeAction() {
        var context = this.props.context || this.context;
        if (!context || !context.executeAction) {
            throw new Error('executeAction was called but no context was provided. Pass the fluxible' +
            'context via a `context` prop or via React\'s context.');
        }
        return context.executeAction.apply(context, arguments);
    },

    /**
     * Gets a store instance from the context
     * @param {Function|String} store The store to get
     * @returns {Object}
     * @method getStore
     */
    getStore: function (store) {
        var storeInstance = store;
        if ('object' !== typeof storeInstance) {
            var context = this.props.context || this.context;
            if (!context) {
                throw new Error('storeListener mixin was called but no context was provided for getting the store.' +
                'Pass the fluxible context via a `context` prop or via React\'s context.');
            }
            storeInstance = context.getStore(store);
        }
        return storeInstance;
    },

    /**
     * Gets from the context all store instances required by this component
     * @returns {Object}
     * @method getStores
     */
    getStores: function() {
        var storesByName = this.getListeners().reduce(function (accum, listener) {
            accum[listener.store.constructor.storeName] = listener.store;
            return accum;
        }, {});
        return Object.keys(storesByName).map(function(storeName) {
            return storesByName[storeName];
        });
    },

    /**
     * Gets a store-change handler from the component
     * @param {Function|String} handler The handler to get
     * @returns {Function}
     * @method getHandler
     */
    getHandler: function (handler) {
        if ('string' === typeof handler) {
            handler = this[handler];
        }

        if (!handler) {
            throw new Error('storeListener attempted to add undefined handler. Make sure handlers are actually exist.');
        }

        return handler;
    },

    /**
     * Gets a listener descriptor for a store and store-change handler
     * @param {Function|String} store Store
     * @param {Function|String} handler The handler function or method name
     * @returns {Object}
     * @method getListener
     */
    getListener: function(store, handler) {
        handler = this.getHandler(handler);
        var storeInstance = this.getStore(store);

        return {
            store: storeInstance,
            handler: handler
        };
    },

    /**
     * Gets all store-change listener descriptors from the component
     * @returns {Object}
     * @method getListeners
     */
    getListeners: function() {
        var self = this;
        var storeListeners = self.constructor.storeListeners; // Static property on component

        // get static listeners
        if (storeListeners) {
            if (Array.isArray(storeListeners)) {
                return storeListeners.map(function(store) {
                    return self.getListener(store, DEFAULT_CHANGE_HANDLER);
                });
            } else {
                return Object.keys(storeListeners).reduce(function (accum, handlerName) {
                    var stores = storeListeners[handlerName];
                    if (!Array.isArray(stores)) {
                        stores = [stores];
                    }
                    return accum.concat(stores.map(function (store) {
                        return self.getListener(store, handlerName);
                    }));
                }, []);
            }
        }

        return [];
    },

    /**
     * If provided with events, will attach listeners to events on EventEmitter objects(i.e. Stores)
     * If the component isn't mounted, events aren't attached.
     * @param {Object} listener
     * @param {Object} listener.store Store instance
     * @param {Object} listener.handler Handler function or method name
     * @method _attachStoreListener
     * @private
     */
    _attachStoreListener: function _attachStoreListener(listener) {
        if (this.isMounted && !this.isMounted()) {
            throw new Error('storeListener mixin called listen when component wasn\'t mounted.');
        }

        listener.store.addChangeListener(listener.handler);
        this.listeners.push(listener);
    },

    /**
     * Removes all listeners
     * @method componentWillUnmount
     */
    componentWillUnmount: function componentWillUnmount() {
        this.listeners.forEach(function (listener) {
            listener.store.removeChangeListener(listener.handler);
        });
        this.listeners = [];
    }
};

module.exports = FluxibleMixin;

},{"react":"react"}],81:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":38}],82:[function(require,module,exports){
module.exports=require(42)
},{"./debug":83,"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/browser.js":42}],83:[function(require,module,exports){
module.exports=require(43)
},{"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/debug.js":43,"ms":84}],84:[function(require,module,exports){
module.exports=require(44)
},{"/home/paul/Code/fundraiser/mydrive7/node_modules/debug/node_modules/ms/index.js":44}],85:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
module.exports = require('./lib/Dispatcher');

},{"./lib/Dispatcher":87}],86:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';
var debug = require('debug')('Dispatchr:Action');

function Action(name, payload) {
    this.name = name;
    this.payload = payload;
    this._handlers = null;
    this._isExecuting = false;
    this._isCompleted = null;
}

/**
 * Gets a name from a store
 * @method getStoreName
 * @param {String|Object} store The store name or class from which to extract
 *      the name
 * @returns {String}
 */
Action.prototype.getStoreName = function getStoreName(store) {
    if ('string' === typeof store) {
        return store;
    }
    return store.storeName;
};

/**
 * Executes all handlers for the action
 * @method execute
 * @param {Function[]} handlers A mapping of store names to handler function
 * @throws {Error} if action has already been executed
 */
Action.prototype.execute = function execute(handlers) {
    if (this._isExecuting) {
        throw new Error('Action is already dispatched');
    }
    var self = this;
    this._handlers = handlers;
    this._isExecuting = true;
    this._isCompleted = {};
    Object.keys(handlers).forEach(function handlersEach(storeName) {
        self._callHandler(storeName);
    });
};

/**
 * Calls an individual store's handler function
 * @method _callHandler
 * @param {String} storeName
 * @private
 * @throws {Error} if handler does not exist for storeName
 */
Action.prototype._callHandler = function callHandler(storeName) {
    var self = this,
        handlerFn = self._handlers[storeName];
    if (!handlerFn) {
        throw new Error(storeName + ' does not have a handler for action ' + self.name);
    }
    if (self._isCompleted[storeName]) {
        return;
    }
    self._isCompleted[storeName] = false;
    debug('executing handler for ' + storeName);
    handlerFn(self.payload, self.name);
    self._isCompleted[storeName] = true;
};

/**
 * Waits until all stores have finished handling an action and then calls
 * the callback
 * @method waitFor
 * @param {String|String[]|Constructor|Constructor[]} stores An array of stores as strings or constructors to wait for
 * @param {Function} callback Called after all stores have completed handling their actions
 * @throws {Error} if the action is not being executed
 */
Action.prototype.waitFor = function waitFor(stores, callback) {
    var self = this;
    if (!self._isExecuting) {
        throw new Error('waitFor called even though there is no action being executed!');
    }
    if (!Array.isArray(stores)) {
        stores = [stores];
    }

    debug('waiting on ' + stores.join(', '));
    stores.forEach(function storesEach(storeName) {
        storeName = self.getStoreName(storeName);
        self._callHandler(storeName);
    });

    callback();
};

module.exports = Action;

},{"debug":82}],87:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var Action = require('./Action'),
    DEFAULT = 'default';

module.exports = function () {
    var debug = require('debug')('Dispatchr:dispatcher');

    /**
     * @class Dispatcher
     * @param {Object} context The context to be used for store instances
     * @constructor
     */
    function Dispatcher (context) {
        this.storeInstances = {};
        this.currentAction = null;
        this.dispatcherInterface = {
            getContext: function getContext() { return context; },
            getStore: this.getStore.bind(this),
            waitFor: this.waitFor.bind(this)
        };
    }

    Dispatcher.stores = {};
    Dispatcher.handlers = {
        'default': []
    };

    /**
     * Registers a store so that it can handle actions.
     * @method registerStore
     * @static
     * @param {Object} store A store class to be registered. The store should have a static
     *      `name` property so that it can be loaded later.
     * @throws {Error} if store is invalid
     * @throws {Error} if store is already registered
     */
    Dispatcher.registerStore = function registerStore(store) {
        if ('function' !== typeof store) {
            throw new Error('registerStore requires a constructor as first parameter');
        }
        var storeName = Dispatcher.getStoreName(store);
        if (!storeName) {
            throw new Error('Store is required to have a `storeName` property.');
        }
        if (Dispatcher.stores[storeName]) {
            if (Dispatcher.stores[storeName] === store) {
                // Store is already registered, nothing to do
                return;
            }
            throw new Error('Store with name `' + storeName + '` has already been registered.');
        }
        Dispatcher.stores[storeName] = store;
        if (store.handlers) {
            Object.keys(store.handlers).forEach(function storeHandlersEach(action) {
                var handler = store.handlers[action];
                Dispatcher._registerHandler(action, storeName, handler);
            });
        }
    };

    /**
     * Method to discover if a storeName has been registered
     * @method isRegistered
     * @static
     * @param {Object|String} store The store to check
     * @returns {boolean}
     */
    Dispatcher.isRegistered = function isRegistered(store) {
        var storeName = Dispatcher.getStoreName(store),
            storeInstance = Dispatcher.stores[storeName];

        if (!storeInstance) {
            return false;
        }

        if ('function' === typeof store) {
            if (store !== storeInstance) {
                return false;
            }
        }
        return true;
    };

    /**
     * Gets a name from a store
     * @method getStoreName
     * @static
     * @param {String|Object} store The store name or class from which to extract
     *      the name
     * @returns {String}
     */
    Dispatcher.getStoreName = function getStoreName(store) {
        if ('string' === typeof store) {
            return store;
        }
        return store.storeName;
    };

    /**
     * Adds a handler function to be called for the given action
     * @method registerHandler
     * @private
     * @static
     * @param {String} action Name of the action
     * @param {String} name Name of the store that handles the action
     * @param {String|Function} handler The function or name of the method that handles the action
     * @returns {number}
     */
    Dispatcher._registerHandler = function registerHandler(action, name, handler) {
        Dispatcher.handlers[action] = Dispatcher.handlers[action] || [];
        Dispatcher.handlers[action].push({
            name: Dispatcher.getStoreName(name),
            handler: handler
        });
        return Dispatcher.handlers.length - 1;
    };

    /**
     * Returns a single store instance and creates one if it doesn't already exist
     * @method getStore
     * @param {String} name The name of the instance
     * @returns {Object} The store instance
     * @throws {Error} if store is not registered
     */
    Dispatcher.prototype.getStore = function getStore(name) {
        var storeName = Dispatcher.getStoreName(name);
        if (!this.storeInstances[storeName]) {
            var Store = Dispatcher.stores[storeName];
            if (!Store) {
                throw new Error('Store ' + storeName + ' was not registered.');
            }
            this.storeInstances[storeName] = new (Dispatcher.stores[storeName])(this.dispatcherInterface);
        }
        return this.storeInstances[storeName];
    };

    /**
     * Dispatches a new action or queues it up if one is already in progress
     * @method dispatch
     * @param {String} actionName Name of the action to be dispatched
     * @param {Object} payload Parameters to describe the action
     * @throws {Error} if store has handler registered that does not exist
     */
    Dispatcher.prototype.dispatch = function dispatch(actionName, payload) {
        if (this.currentAction) {
            throw new Error('Cannot call dispatch while another dispatch is executing. Attempted to execute \'' + actionName + '\' but \'' + this.currentAction.name + '\' is already executing.');
        }
        var actionHandlers = Dispatcher.handlers[actionName] || [],
            defaultHandlers = Dispatcher.handlers[DEFAULT] || [];
        if (!actionHandlers.length && !defaultHandlers.length) {
            debug(actionName + ' does not have any registered handlers');
            return;
        }
        debug('dispatching ' + actionName, payload);
        this.currentAction = new Action(actionName, payload);
        var self = this,
            allHandlers = actionHandlers.concat(defaultHandlers),
            handlerFns = {};

        try {
            allHandlers.forEach(function actionHandlersEach(store) {
                if (handlerFns[store.name]) {
                    // Don't call the default if the store has an explicit action handler
                    return;
                }
                var storeInstance = self.getStore(store.name);
                if ('function' === typeof store.handler) {
                    handlerFns[store.name] = store.handler.bind(storeInstance);
                } else {
                    if (!storeInstance[store.handler]) {
                        throw new Error(store.name + ' does not have a method called ' + store.handler);
                    }
                    handlerFns[store.name] = storeInstance[store.handler].bind(storeInstance);
                }
            });
            this.currentAction.execute(handlerFns);
        } catch (e) {
            throw e;
        } finally {
            debug('finished ' + actionName);
            this.currentAction = null;
        }
    };

    /**
     * Returns a raw data object representation of the current state of the
     * dispatcher and all store instances. If the store implements a shouldDehdyrate
     * function, then it will be called and only dehydrate if the method returns `true`
     * @method dehydrate
     * @returns {Object} dehydrated dispatcher data
     */
    Dispatcher.prototype.dehydrate = function dehydrate() {
        var self = this,
            stores = {};
        Object.keys(self.storeInstances).forEach(function storeInstancesEach(storeName) {
            var store = self.storeInstances[storeName];
            if (!store.dehydrate || (store.shouldDehydrate && !store.shouldDehydrate())) {
                return;
            }
            stores[storeName] = store.dehydrate();
        });
        return {
            stores: stores
        };
    };

    /**
     * Takes a raw data object and rehydrates the dispatcher and store instances
     * @method rehydrate
     * @param {Object} dispatcherState raw state typically retrieved from `dehydrate`
     *      method
     */
    Dispatcher.prototype.rehydrate = function rehydrate(dispatcherState) {
        var self = this;
        if (dispatcherState.stores) {
            Object.keys(dispatcherState.stores).forEach(function storeStateEach(storeName) {
                var state = dispatcherState.stores[storeName],
                    store = self.getStore(storeName);
                if (store.rehydrate) {
                    store.rehydrate(state);
                }
            });
        }
    };

    /**
     * Waits until all stores have finished handling an action and then calls
     * the callback
     * @method waitFor
     * @param {String|String[]} stores An array of stores as strings to wait for
     * @param {Function} callback Called after all stores have completed handling their actions
     * @throws {Error} if there is no action dispatching
     */
    Dispatcher.prototype.waitFor = function waitFor(stores, callback) {
        if (!this.currentAction) {
            throw new Error('waitFor called even though there is no action dispatching');
        }
        this.currentAction.waitFor(stores, callback);
    };

    return Dispatcher;
};

},{"./Action":86,"debug":82}],88:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var util = require('util');
var EventEmitter = require('events').EventEmitter;
var CHANGE_EVENT = 'change';

/**
 * @class BaseStore
 * @extends EventEmitter
 * @param dispatcher The dispatcher interface
 * @constructor
 */
function BaseStore(dispatcher) {
    this.dispatcher = dispatcher;
    this._hasChanged = false;
    if (this.initialize) {
        this.initialize();
    }
}

util.inherits(BaseStore, EventEmitter);

/**
 * Convenience method for getting the store context object.
 * @method getContext
 * @return {Object} Returns the store context object.
 */
BaseStore.prototype.getContext = function getContext() {
    return this.dispatcher.getContext();
};

/**
 * Convenience method for getting the store context object.
 * @method getContext
 * @return {Object} Returns the store context object.
 */
BaseStore.prototype.getContext = function getContext() {
    return this.dispatcher.getContext();
};

/**
 * Add a listener for the change event
 * @method addChangeListener
 * @param {Function} callback
 */
BaseStore.prototype.addChangeListener = function addChangeListener(callback) {
    this.on(CHANGE_EVENT, callback);
};

/**
 * Remove a listener for the change event
 * @method removeChangeListener
 * @param {Function} callback
 */
BaseStore.prototype.removeChangeListener = function removeChangeListener(callback) {
    this.removeListener(CHANGE_EVENT, callback);
};

/**
 * Determines whether the store should dehydrate or not. By default, only dehydrates
 * if the store has emitted an update event. If no update has been emitted, it is assumed
 * that the store is in its default state and therefore does not need to dehydrate.
 * @method shouldDehydrate
 * @returns {boolean}
 */
BaseStore.prototype.shouldDehydrate = function shouldDehydrate() {
    return this._hasChanged;
};

/**
 * Emit a change event
 * @method emitChange
 * @param {*} param=this
 */
BaseStore.prototype.emitChange = function emitChange(param) {
    this._hasChanged = true;
    this.emit(CHANGE_EVENT, param || this);
};

module.exports = BaseStore;

},{"events":36,"util":40}],89:[function(require,module,exports){
/**
 * Copyright 2014, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var util = require('util'),
    BaseStore = require('./BaseStore'),
    IGNORE_ON_PROTOTYPE = ['statics', 'storeName', 'handlers', 'mixins'];

function createChainedFunction(one, two) {
    return function chainedFunction() {
        one.apply(this, arguments);
        two.apply(this, arguments);
    };
}

function mixInto(dest, src) {
    Object.keys(src).forEach(function (prop) {
        if (-1 !== IGNORE_ON_PROTOTYPE.indexOf(prop)) {
            return;
        }
        if ('initialize' === prop) {
            if (!dest[prop]) {
                dest[prop] = src[prop];
            } else {
                dest[prop] = createChainedFunction(dest[prop], src[prop]);
            }
        } else {
            if (dest.hasOwnProperty(prop)) {
                throw new Error('Mixin property collision for property "' + prop + '"');
            }
            dest[prop] = src[prop];
        }
    });
}

/**
 * Helper for creating a store class
 * @method createStore
 * @param {Object} spec
 * @param {String} spec.storeName The name of the store
 * @param {Object} spec.handlers Hash of action name to method name of action handlers
 * @param {Function} spec.initialize Function called during construction for setting the default state
 * @param {Function} spec.dehydrate Function that returns serializable data to send to the client
 * @param {Function} spec.rehydrate Function that takes in serializable data to rehydrate the store
 */
module.exports = function createStore(spec) {
    spec.statics = spec.statics || {};
    if (!spec.storeName && !spec.statics.storeName) {
        throw new Error('createStore called without a storeName');
    }
    var Store = function (dispatcher) {
        BaseStore.call(this, dispatcher);
    };

    util.inherits(Store, BaseStore);

    Object.keys(spec.statics).forEach(function (prop) {
        Store[prop] = spec.statics[prop];
    });

    Store.storeName = spec.storeName || Store.storeName;
    Store.handlers = spec.handlers || Store.handlers;
    Store.mixins = spec.mixins || Store.mixins;

    if (Store.mixins) {
        Store.mixins.forEach(function(mixin) {
            mixInto(Store.prototype, mixin);
        });
    }
    mixInto(Store.prototype, spec);

    return Store;
};

},{"./BaseStore":88,"util":40}],90:[function(require,module,exports){
(function (process){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(new Function("return this")()));

}).call(this,require('_process'))

},{"_process":38}],91:[function(require,module,exports){
module.exports = require('dispatchr/utils/createStore');

},{"dispatchr/utils/createStore":89}],92:[function(require,module,exports){
(function (global){
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],93:[function(require,module,exports){
'use strict';

function ToObject(val) {
	if (val == null) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var keys;
	var to = ToObject(target);

	for (var s = 1; s < arguments.length; s++) {
		from = arguments[s];
		keys = Object.keys(Object(from));

		for (var i = 0; i < keys.length; i++) {
			to[keys[i]] = from[keys[i]];
		}
	}

	return to;
};

},{}],94:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ResponderEventPlugin
 */

"use strict";

var EventConstants = require('react/lib/EventConstants');
var EventPluginUtils = require('react/lib/EventPluginUtils');
var EventPropagators = require('react/lib/EventPropagators');
var SyntheticEvent = require('react/lib/SyntheticEvent');

var accumulateInto = require('react/lib/accumulateInto');
var keyOf = require('react/lib/keyOf');

var isStartish = EventPluginUtils.isStartish;
var isMoveish = EventPluginUtils.isMoveish;
var isEndish = EventPluginUtils.isEndish;
var executeDirectDispatch = EventPluginUtils.executeDirectDispatch;
var hasDispatches = EventPluginUtils.hasDispatches;
var executeDispatchesInOrderStopAtTrue =
  EventPluginUtils.executeDispatchesInOrderStopAtTrue;

/**
 * ID of element that should respond to touch/move types of interactions, as
 * indicated explicitly by relevant callbacks.
 */
var responderID = null;
var isPressing = false;

var eventTypes = {
  /**
   * On a `touchStart`/`mouseDown`, is it desired that this element become the
   * responder?
   */
  startShouldSetResponder: {
    phasedRegistrationNames: {
      bubbled: keyOf({onStartShouldSetResponder: null}),
      captured: keyOf({onStartShouldSetResponderCapture: null})
    }
  },

  /**
   * On a `scroll`, is it desired that this element become the responder? This
   * is usually not needed, but should be used to retroactively infer that a
   * `touchStart` had occured during momentum scroll. During a momentum scroll,
   * a touch start will be immediately followed by a scroll event if the view is
   * currently scrolling.
   */
  scrollShouldSetResponder: {
    phasedRegistrationNames: {
      bubbled: keyOf({onScrollShouldSetResponder: null}),
      captured: keyOf({onScrollShouldSetResponderCapture: null})
    }
  },

  /**
   * On a `touchMove`/`mouseMove`, is it desired that this element become the
   * responder?
   */
  moveShouldSetResponder: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMoveShouldSetResponder: null}),
      captured: keyOf({onMoveShouldSetResponderCapture: null})
    }
  },

  /**
   * Direct responder events dispatched directly to responder. Do not bubble.
   */
  responderMove: {registrationName: keyOf({onResponderMove: null})},
  responderRelease: {registrationName: keyOf({onResponderRelease: null})},
  responderTerminationRequest: {
    registrationName: keyOf({onResponderTerminationRequest: null})
  },
  responderGrant: {registrationName: keyOf({onResponderGrant: null})},
  responderReject: {registrationName: keyOf({onResponderReject: null})},
  responderTerminate: {registrationName: keyOf({onResponderTerminate: null})}
};

/**
 * Performs negotiation between any existing/current responder, checks to see if
 * any new entity is interested in becoming responder, performs that handshake
 * and returns any events that must be emitted to notify the relevant parties.
 *
 * A note about event ordering in the `EventPluginHub`.
 *
 * Suppose plugins are injected in the following order:
 *
 * `[R, S, C]`
 *
 * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for
 * `onClick` etc) and `R` is `ResponderEventPlugin`.
 *
 * "Deferred-Dispatched Events":
 *
 * - The current event plugin system will traverse the list of injected plugins,
 *   in order, and extract events by collecting the plugin's return value of
 *   `extractEvents()`.
 * - These events that are returned from `extractEvents` are "deferred
 *   dispatched events".
 * - When returned from `extractEvents`, deferred-dispatched events contain an
 *   "accumulation" of deferred dispatches.
 * - These deferred dispatches are accumulated/collected before they are
 *   returned, but processed at a later time by the `EventPluginHub` (hence the
 *   name deferred).
 *
 * In the process of returning their deferred-dispatched events, event plugins
 * themselves can dispatch events on-demand without returning them from
 * `extractEvents`. Plugins might want to do this, so that they can use event
 * dispatching as a tool that helps them decide which events should be extracted
 * in the first place.
 *
 * "On-Demand-Dispatched Events":
 *
 * - On-demand-dispatched events are not returned from `extractEvents`.
 * - On-demand-dispatched events are dispatched during the process of returning
 *   the deferred-dispatched events.
 * - They should not have side effects.
 * - They should be avoided, and/or eventually be replaced with another
 *   abstraction that allows event plugins to perform multiple "rounds" of event
 *   extraction.
 *
 * Therefore, the sequence of event dispatches becomes:
 *
 * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)
 * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)
 * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)
 * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)
 * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)
 * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)
 *
 * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`
 * on-demand dispatch returns `true` (and some other details are satisfied) the
 * `onResponderGrant` deferred dispatched event is returned from
 * `extractEvents`. The sequence of dispatch executions in this case
 * will appear as follows:
 *
 * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)
 * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)
 * - `touchStart`              (`EventPluginHub` dispatches as usual)
 * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {string} topLevelTargetID ID of deepest React rendered element.
 * @param {object} nativeEvent Native browser event.
 * @return {*} An accumulation of synthetic events.
 */
function setResponderAndExtractTransfer(
    topLevelType,
    topLevelTargetID,
    nativeEvent) {
  var shouldSetEventType =
    isStartish(topLevelType) ? eventTypes.startShouldSetResponder :
    isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder :
    eventTypes.scrollShouldSetResponder;

  var bubbleShouldSetFrom = responderID || topLevelTargetID;
  var shouldSetEvent = SyntheticEvent.getPooled(
    shouldSetEventType,
    bubbleShouldSetFrom,
    nativeEvent
  );
  EventPropagators.accumulateTwoPhaseDispatches(shouldSetEvent);
  var wantsResponderID = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
  if (!shouldSetEvent.isPersistent()) {
    shouldSetEvent.constructor.release(shouldSetEvent);
  }

  if (!wantsResponderID || wantsResponderID === responderID) {
    return null;
  }
  var extracted;
  var grantEvent = SyntheticEvent.getPooled(
    eventTypes.responderGrant,
    wantsResponderID,
    nativeEvent
  );

  EventPropagators.accumulateDirectDispatches(grantEvent);
  if (responderID) {
    var terminationRequestEvent = SyntheticEvent.getPooled(
      eventTypes.responderTerminationRequest,
      responderID,
      nativeEvent
    );
    EventPropagators.accumulateDirectDispatches(terminationRequestEvent);
    var shouldSwitch = !hasDispatches(terminationRequestEvent) ||
      executeDirectDispatch(terminationRequestEvent);
    if (!terminationRequestEvent.isPersistent()) {
      terminationRequestEvent.constructor.release(terminationRequestEvent);
    }

    if (shouldSwitch) {
      var terminateType = eventTypes.responderTerminate;
      var terminateEvent = SyntheticEvent.getPooled(
        terminateType,
        responderID,
        nativeEvent
      );
      EventPropagators.accumulateDirectDispatches(terminateEvent);
      extracted = accumulateInto(extracted, [grantEvent, terminateEvent]);
      responderID = wantsResponderID;
    } else {
      var rejectEvent = SyntheticEvent.getPooled(
        eventTypes.responderReject,
        wantsResponderID,
        nativeEvent
      );
      EventPropagators.accumulateDirectDispatches(rejectEvent);
      extracted = accumulateInto(extracted, rejectEvent);
    }
  } else {
    extracted = accumulateInto(extracted, grantEvent);
    responderID = wantsResponderID;
  }
  return extracted;
}

/**
 * A transfer is a negotiation between a currently set responder and the next
 * element to claim responder status. Any start event could trigger a transfer
 * of responderID. Any move event could trigger a transfer, so long as there is
 * currently a responder set (in other words as long as the user is pressing
 * down).
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @return {boolean} True if a transfer of responder could possibly occur.
 */
function canTriggerTransfer(topLevelType) {
  return topLevelType === EventConstants.topLevelTypes.topScroll ||
         isStartish(topLevelType) ||
         (isPressing && isMoveish(topLevelType));
}

/**
 * Event plugin for formalizing the negotiation between claiming locks on
 * receiving touches.
 */
var ResponderEventPlugin = {

  getResponderID: function() {
    return responderID;
  },

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var extracted;
    // Must have missed an end event - reset the state here.
    if (responderID && isStartish(topLevelType)) {
      responderID = null;
    }
    if (isStartish(topLevelType)) {
      isPressing = true;
    } else if (isEndish(topLevelType)) {
      isPressing = false;
    }
    if (canTriggerTransfer(topLevelType)) {
      var transfer = setResponderAndExtractTransfer(
        topLevelType,
        topLevelTargetID,
        nativeEvent
      );
      if (transfer) {
        extracted = accumulateInto(extracted, transfer);
      }
    }
    // Now that we know the responder is set correctly, we can dispatch
    // responder type events (directly to the responder).
    var type = isMoveish(topLevelType) ? eventTypes.responderMove :
      isEndish(topLevelType) ? eventTypes.responderRelease :
      isStartish(topLevelType) ? eventTypes.responderStart : null;
    if (type) {
      var gesture = SyntheticEvent.getPooled(
        type,
        responderID || '',
        nativeEvent
      );
      EventPropagators.accumulateDirectDispatches(gesture);
      extracted = accumulateInto(extracted, gesture);
    }
    if (type === eventTypes.responderRelease) {
      responderID = null;
    }
    return extracted;
  }

};

module.exports = ResponderEventPlugin;

},{"react/lib/EventConstants":98,"react/lib/EventPluginUtils":101,"react/lib/EventPropagators":102,"react/lib/SyntheticEvent":105,"react/lib/accumulateInto":108,"react/lib/keyOf":115}],95:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule TapEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require('react/lib/EventConstants');
var EventPluginUtils = require('react/lib/EventPluginUtils');
var EventPropagators = require('react/lib/EventPropagators');
var SyntheticUIEvent = require('react/lib/SyntheticUIEvent');
var TouchEventUtils = require('./TouchEventUtils');
var ViewportMetrics = require('react/lib/ViewportMetrics');

var keyOf = require('react/lib/keyOf');
var topLevelTypes = EventConstants.topLevelTypes;

var isStartish = EventPluginUtils.isStartish;
var isEndish = EventPluginUtils.isEndish;

var isTouch = function(topLevelType) {
  var touchTypes = [
    topLevelTypes.topTouchCancel,
    topLevelTypes.topTouchEnd,
    topLevelTypes.topTouchStart,
    topLevelTypes.topTouchMove
  ];
  return touchTypes.indexOf(topLevelType) >= 0;
}

/**
 * Number of pixels that are tolerated in between a `touchStart` and `touchEnd`
 * in order to still be considered a 'tap' event.
 */
var tapMoveThreshold = 10;
var ignoreMouseThreshold = 750;
var startCoords = {x: null, y: null};
var lastTouchEvent = null;

var Axis = {
  x: {page: 'pageX', client: 'clientX', envScroll: 'currentPageScrollLeft'},
  y: {page: 'pageY', client: 'clientY', envScroll: 'currentPageScrollTop'}
};

function getAxisCoordOfEvent(axis, nativeEvent) {
  var singleTouch = TouchEventUtils.extractSingleTouch(nativeEvent);
  if (singleTouch) {
    return singleTouch[axis.page];
  }
  return axis.page in nativeEvent ?
    nativeEvent[axis.page] :
    nativeEvent[axis.client] + ViewportMetrics[axis.envScroll];
}

function getDistance(coords, nativeEvent) {
  var pageX = getAxisCoordOfEvent(Axis.x, nativeEvent);
  var pageY = getAxisCoordOfEvent(Axis.y, nativeEvent);
  return Math.pow(
    Math.pow(pageX - coords.x, 2) + Math.pow(pageY - coords.y, 2),
    0.5
  );
}

var dependencies = [
  topLevelTypes.topMouseDown,
  topLevelTypes.topMouseMove,
  topLevelTypes.topMouseUp
];

if (EventPluginUtils.useTouchEvents) {
  dependencies.push(
    topLevelTypes.topTouchEnd,
    topLevelTypes.topTouchStart,
    topLevelTypes.topTouchMove
  );
}

var eventTypes = {
  touchTap: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchTap: null}),
      captured: keyOf({onTouchTapCapture: null})
    },
    dependencies: dependencies
  }
};

var TapEventPlugin = {

  tapMoveThreshold: tapMoveThreshold,

  ignoreMouseThreshold: ignoreMouseThreshold,

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    if (isTouch(topLevelType)) {
      lastTouchEvent = nativeEvent.timeStamp;
    } else {
      if (lastTouchEvent && (nativeEvent.timeStamp - lastTouchEvent) < ignoreMouseThreshold) {
        return null;
      }
    }

    if (!isStartish(topLevelType) && !isEndish(topLevelType)) {
      return null;
    }
    var event = null;
    var distance = getDistance(startCoords, nativeEvent);
    if (isEndish(topLevelType) && distance < tapMoveThreshold) {
      event = SyntheticUIEvent.getPooled(
        eventTypes.touchTap,
        topLevelTargetID,
        nativeEvent
      );
    }
    if (isStartish(topLevelType)) {
      startCoords.x = getAxisCoordOfEvent(Axis.x, nativeEvent);
      startCoords.y = getAxisCoordOfEvent(Axis.y, nativeEvent);
    } else if (isEndish(topLevelType)) {
      startCoords.x = 0;
      startCoords.y = 0;
    }
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }

};

module.exports = TapEventPlugin;
},{"./TouchEventUtils":96,"react/lib/EventConstants":98,"react/lib/EventPluginUtils":101,"react/lib/EventPropagators":102,"react/lib/SyntheticUIEvent":106,"react/lib/ViewportMetrics":107,"react/lib/keyOf":115}],96:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule TouchEventUtils
 */

var TouchEventUtils = {
  /**
   * Utility function for common case of extracting out the primary touch from a
   * touch event.
   * - `touchEnd` events usually do not have the `touches` property.
   *   http://stackoverflow.com/questions/3666929/
   *   mobile-sarai-touchend-event-not-firing-when-last-touch-is-removed
   *
   * @param {Event} nativeEvent Native event that may or may not be a touch.
   * @return {TouchesObject?} an object with pageX and pageY or null.
   */
  extractSingleTouch: function(nativeEvent) {
    var touches = nativeEvent.touches;
    var changedTouches = nativeEvent.changedTouches;
    var hasTouches = touches && touches.length > 0;
    var hasChangedTouches = changedTouches && changedTouches.length > 0;

    return !hasTouches && hasChangedTouches ? changedTouches[0] :
           hasTouches ? touches[0] :
           nativeEvent;
  }
};

module.exports = TouchEventUtils;

},{}],97:[function(require,module,exports){
module.exports = function injectTapEventPlugin () {
  var React = require("react");
  React.initializeTouchEvents(true);

  require('react/lib/EventPluginHub').injection.injectEventPluginsByName({
    "ResponderEventPlugin": require('./ResponderEventPlugin.js'),
    "TapEventPlugin":       require('./TapEventPlugin.js')
  });
};

},{"./ResponderEventPlugin.js":94,"./TapEventPlugin.js":95,"react":"react","react/lib/EventPluginHub":99}],98:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

"use strict";

var keyMirror = require("./keyMirror");

var PropagationPhases = keyMirror({bubbled: null, captured: null});

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topBlur: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topReset: null,
  topScroll: null,
  topSelectionChange: null,
  topSubmit: null,
  topTextInput: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;

},{"./keyMirror":114}],99:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

"use strict";

var EventPluginRegistry = require("./EventPluginRegistry");
var EventPluginUtils = require("./EventPluginUtils");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */
var executeDispatchesAndRelease = function(event) {
  if (event) {
    var executeDispatch = EventPluginUtils.executeDispatch;
    // Plugins can provide custom behavior when dispatching events.
    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
    if (PluginModule && PluginModule.executeDispatch) {
      executeDispatch = PluginModule.executeDispatch;
    }
    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var invalid = !InstanceHandle||
    !InstanceHandle.traverseTwoPhase ||
    !InstanceHandle.traverseEnterLeave;
  if (invalid) {
    throw new Error('InstanceHandle not injected before use!');
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function(InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function() {
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function(id, registrationName, listener) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !listener || typeof listener === 'function',
      'Expected %s listener to be a function, instead got type %s',
      registrationName, typeof listener
    ) : invariant(!listener || typeof listener === 'function'));

    var bankForRegistrationName =
      listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function(id) {
    for (var registrationName in listenerBank) {
      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0, l = plugins.length; i < l; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(
          topLevelType,
          topLevelTarget,
          topLevelTargetID,
          nativeEvent
        );
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function(events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function() {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
    ("production" !== process.env.NODE_ENV ? invariant(
      !eventQueue,
      'processEventQueue(): Additional events were enqueued while processing ' +
      'an event queue. Support for this has not yet been implemented.'
    ) : invariant(!eventQueue));
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function() {
    listenerBank = {};
  },

  __getListenerBank: function() {
    return listenerBank;
  }

};

module.exports = EventPluginHub;

}).call(this,require('_process'))

},{"./EventPluginRegistry":100,"./EventPluginUtils":101,"./accumulateInto":108,"./forEachAccumulated":110,"./invariant":113,"_process":38}],100:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    ("production" !== process.env.NODE_ENV ? invariant(
      pluginIndex > -1,
      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +
      'the plugin ordering, `%s`.',
      pluginName
    ) : invariant(pluginIndex > -1));
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      PluginModule.extractEvents,
      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +
      'method, but `%s` does not.',
      pluginName
    ) : invariant(PluginModule.extractEvents));
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      ("production" !== process.env.NODE_ENV ? invariant(
        publishEventForPlugin(
          publishedEvents[eventName],
          PluginModule,
          eventName
        ),
        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',
        eventName,
        pluginName
      ) : invariant(publishEventForPlugin(
        publishedEvents[eventName],
        PluginModule,
        eventName
      )));
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName),
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'event name, `%s`.',
    eventName
  ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(
          phasedRegistrationName,
          PluginModule,
          eventName
        );
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(
      dispatchConfig.registrationName,
      PluginModule,
      eventName
    );
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.registrationNameModules[registrationName],
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'registration name, `%s`.',
    registrationName
  ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] =
    PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function(InjectedEventPluginOrder) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !EventPluginOrder,
      'EventPluginRegistry: Cannot inject event plugin ordering more than ' +
      'once. You are likely trying to load more than one copy of React.'
    ) : invariant(!EventPluginOrder));
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function(injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) ||
          namesToPlugins[pluginName] !== PluginModule) {
        ("production" !== process.env.NODE_ENV ? invariant(
          !namesToPlugins[pluginName],
          'EventPluginRegistry: Cannot inject two different event plugins ' +
          'using the same name, `%s`.',
          pluginName
        ) : invariant(!namesToPlugins[pluginName]));
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function(event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[
        dispatchConfig.registrationName
      ] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[
        dispatchConfig.phasedRegistrationNames[phase]
      ];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function() {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;

}).call(this,require('_process'))

},{"./invariant":113,"_process":38}],101:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

"use strict";

var EventConstants = require("./EventConstants");

var invariant = require("./invariant");

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function(InjectedMount) {
    injection.Mount = InjectedMount;
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? invariant(
        InjectedMount && InjectedMount.getNode,
        'EventPluginUtils.injection.injectMount(...): Injected Mount module ' +
        'is missing getNode.'
      ) : invariant(InjectedMount && InjectedMount.getNode));
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp ||
         topLevelType === topLevelTypes.topTouchEnd ||
         topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove ||
         topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown ||
         topLevelType === topLevelTypes.topTouchStart;
}


var validateEventDispatches;
if ("production" !== process.env.NODE_ENV) {
  validateEventDispatches = function(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ?
      dispatchListeners.length :
      dispatchListeners ? 1 : 0;

    ("production" !== process.env.NODE_ENV ? invariant(
      idsIsArr === listenersIsArr && IDsLen === listenersLen,
      'EventPluginUtils: Invalid `event`.'
    ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
  };
}

/**
 * Invokes `cb(event, listener, id)`. Avoids using call if no scope is
 * provided. The `(listener,id)` pair effectively forms the "dispatch" but are
 * kept separate to conserve memory.
 */
function forEachEventDispatch(event, cb) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      cb(event, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    cb(event, dispatchListeners, dispatchIDs);
  }
}

/**
 * Default implementation of PluginModule.executeDispatch().
 * @param {SyntheticEvent} SyntheticEvent to handle
 * @param {function} Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, listener, domID) {
  event.currentTarget = injection.Mount.getNode(domID);
  var returnValue = listener(event, domID);
  event.currentTarget = null;
  return returnValue;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, executeDispatch) {
  forEachEventDispatch(event, executeDispatch);
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return id of the first dispatch execution who's listener returns true, or
 * null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  ("production" !== process.env.NODE_ENV ? invariant(
    !Array.isArray(dispatchListener),
    'executeDirectDispatch(...): Invalid `event`.'
  ) : invariant(!Array.isArray(dispatchListener)));
  var res = dispatchListener ?
    dispatchListener(event, dispatchID) :
    null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {bool} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatch: executeDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,
  injection: injection,
  useTouchEvents: false
};

module.exports = EventPluginUtils;

}).call(this,require('_process'))

},{"./EventConstants":98,"./invariant":113,"_process":38}],102:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName =
    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if ("production" !== process.env.NODE_ENV) {
    if (!domID) {
      throw new Error('Dispatching id must not be null');
    }
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners =
      accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We can not perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(
      event.dispatchMarker,
      accumulateDirectionalDispatches,
      event
    );
  }
}


/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners =
        accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(
    fromID,
    toID,
    accumulateDispatches,
    leave,
    enter
  );
}


function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}



/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;

}).call(this,require('_process'))

},{"./EventConstants":98,"./EventPluginHub":99,"./accumulateInto":108,"./forEachAccumulated":110,"_process":38}],103:[function(require,module,exports){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
};

module.exports = assign;

},{}],104:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

"use strict";

var invariant = require("./invariant");

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function(instance) {
  var Klass = this;
  ("production" !== process.env.NODE_ENV ? invariant(
    instance instanceof Klass,
    'Trying to release an instance into a pool of a different type.'
  ) : invariant(instance instanceof Klass));
  if (instance.destructor) {
    instance.destructor();
  }
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function(CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;

}).call(this,require('_process'))

},{"./invariant":113,"_process":38}],105:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

"use strict";

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var getEventTarget = require("./getEventTarget");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: getEventTarget,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ?
    nativeEvent.defaultPrevented :
    nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function() {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function() {
    var event = this.nativeEvent;
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function() {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function() {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function(Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);

module.exports = SyntheticEvent;

},{"./Object.assign":103,"./PooledClass":104,"./emptyFunction":109,"./getEventTarget":111}],106:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

var getEventTarget = require("./getEventTarget");

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function(event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function(event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

},{"./SyntheticEvent":105,"./getEventTarget":111}],107:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

"use strict";

var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function() {
    var scrollPosition = getUnboundedScrollPosition(window);
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;

},{"./getUnboundedScrollPosition":112}],108:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

"use strict";

var invariant = require("./invariant");

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  ("production" !== process.env.NODE_ENV ? invariant(
    next != null,
    'accumulateInto(...): Accumulated items must not be null or undefined.'
  ) : invariant(next != null));
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;

}).call(this,require('_process'))

},{"./invariant":113,"_process":38}],109:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

function makeEmptyFunction(arg) {
  return function() {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function() { return this; };
emptyFunction.thatReturnsArgument = function(arg) { return arg; };

module.exports = emptyFunction;

},{}],110:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

"use strict";

/**
 * @param {array} an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;

},{}],111:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

"use strict";

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

},{}],112:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

"use strict";

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

},{}],113:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))

},{"_process":38}],114:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  ("production" !== process.env.NODE_ENV ? invariant(
    obj instanceof Object && !Array.isArray(obj),
    'keyMirror(...): Argument must be an object.'
  ) : invariant(obj instanceof Object && !Array.isArray(obj)));
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

}).call(this,require('_process'))

},{"./invariant":113,"_process":38}],115:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without loosing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
var keyOf = function(oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};


module.exports = keyOf;

},{}],116:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['exports', './lib/animate', './lib/Scroller'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        factory(exports, require('./lib/animate'), require('./lib/Scroller'));
    }
}(this, function (exports, animate, Scroller) {
    exports.animate = animate;
    exports.Scroller = Scroller;
}));

},{"./lib/Scroller":117,"./lib/animate":118}],117:[function(require,module,exports){
/*
 * Scroller
 * http://github.com/zynga/scroller
 *
 * Copyright 2011, Zynga Inc.
 * Licensed under the MIT License.
 * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt
 *
 * Based on the work of: Unify Project (unify-project.org)
 * http://unify-project.org
 * Copyright 2011, Deutsche Telekom AG
 * License: MIT + Apache (V2)
 */

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['./animate'], factory);
    } else if (typeof module === 'object') {
        // CommonJS
        module.exports = factory(require('./animate'));
    } else {
        // Browser globals
        root.Scroller = factory(root.animate);
    }
}(this, function (animate) {
    var NOOP = function () {};

    /**
     * A pure logic 'component' for 'virtual' scrolling/zooming.
     */
    var Scroller = function (callback, options) {
        this.__callback = callback;

        this.options = {
            /** Enable scrolling on x-axis */
            scrollingX: true,

            /** Enable scrolling on y-axis */
            scrollingY: true,

            /** Enable animations for deceleration, snap back, zooming and scrolling */
            animating: true,

            /** duration for animations triggered by scrollTo/zoomTo */
            animationDuration: 250,

            /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */
            bouncing: true,

            /** Enable locking to the main axis if user moves only slightly on one of them at start */
            locking: true,

            /** Enable pagination mode (switching between full page content panes) */
            paging: false,

            /** Enable snapping of content to a configured pixel grid */
            snapping: false,

            /** Enable zooming of content via API, fingers and mouse wheel */
            zooming: false,

            /** Minimum zoom level */
            minZoom: 0.5,

            /** Maximum zoom level */
            maxZoom: 3,

            /** Multiply or decrease scrolling speed **/
            speedMultiplier: 1,

            /** Callback that is fired on the later of touch end or deceleration end,
                provided that another scrolling action has not begun. Used to know
                when to fade out a scrollbar. */
            scrollingComplete: NOOP,

            /** This configures the amount of change applied to deceleration when reaching boundaries  **/
            penetrationDeceleration : 0.03,

            /** This configures the amount of change applied to acceleration when reaching boundaries  **/
            penetrationAcceleration : 0.08
        };

        for (var key in options) {
            this.options[key] = options[key];
        }
    };


    // Easing Equations (c) 2003 Robert Penner, all rights reserved.
    // Open source under the BSD License.

    /**
     * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)
     **/
    var easeOutCubic = function (pos) {
        return (Math.pow((pos - 1), 3) + 1);
    };

    /**
     * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)
     **/
    var easeInOutCubic = function (pos) {
        if ((pos /= 0.5) < 1) {
            return 0.5 * Math.pow(pos, 3);
        }

        return 0.5 * (Math.pow((pos - 2), 3) + 2);
    };


    Scroller.prototype = {

        /*
          ---------------------------------------------------------------------------
          INTERNAL FIELDS :: STATUS
          ---------------------------------------------------------------------------
        */

        /** {Boolean} Whether only a single finger is used in touch handling */
        __isSingleTouch: false,

        /** {Boolean} Whether a touch event sequence is in progress */
        __isTracking: false,

        /** {Boolean} Whether a deceleration animation went to completion. */
        __didDecelerationComplete: false,

        /**
         * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when
         * a gesturestart event happens. This has higher priority than dragging.
         */
        __isGesturing: false,

        /**
         * {Boolean} Whether the user has moved by such a distance that we have enabled
         * dragging mode. Hint: It's only enabled after some pixels of movement to
         * not interrupt with clicks etc.
         */
        __isDragging: false,

        /**
         * {Boolean} Not touching and dragging anymore, and smoothly animating the
         * touch sequence using deceleration.
         */
        __isDecelerating: false,

        /**
         * {Boolean} Smoothly animating the currently configured change
         */
        __isAnimating: false,



        /*
          ---------------------------------------------------------------------------
          INTERNAL FIELDS :: DIMENSIONS
          ---------------------------------------------------------------------------
        */

        /** {Integer} Viewport left boundary */
        __clientLeft: 0,

        /** {Integer} Viewport right boundary */
        __clientTop: 0,

        /** {Integer} Viewport width */
        __clientWidth: 0,

        /** {Integer} Viewport height */
        __clientHeight: 0,

        /** {Integer} Full content's width */
        __contentWidth: 0,

        /** {Integer} Full content's height */
        __contentHeight: 0,

        /** {Integer} Snapping width for content */
        __snapWidth: 100,

        /** {Integer} Snapping height for content */
        __snapHeight: 100,

        /** {Number} Zoom level */
        __zoomLevel: 1,

        /** {Number} Scroll position on x-axis */
        __scrollLeft: 0,

        /** {Number} Scroll position on y-axis */
        __scrollTop: 0,

        /** {Integer} Maximum allowed scroll position on x-axis */
        __maxScrollLeft: 0,

        /** {Integer} Maximum allowed scroll position on y-axis */
        __maxScrollTop: 0,

        /* {Number} Scheduled left position (final position when animating) */
        __scheduledLeft: 0,

        /* {Number} Scheduled top position (final position when animating) */
        __scheduledTop: 0,

        /* {Number} Scheduled zoom level (final scale when animating) */
        __scheduledZoom: 0,



        /*
          ---------------------------------------------------------------------------
          INTERNAL FIELDS :: LAST POSITIONS
          ---------------------------------------------------------------------------
        */

        /** {Number} Left position of finger at start */
        __lastTouchLeft: null,

        /** {Number} Top position of finger at start */
        __lastTouchTop: null,

        /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */
        __lastTouchMove: null,

        /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */
        __positions: null,



        /*
          ---------------------------------------------------------------------------
          INTERNAL FIELDS :: DECELERATION SUPPORT
          ---------------------------------------------------------------------------
        */

        /** {Integer} Minimum left scroll position during deceleration */
        __minDecelerationScrollLeft: null,

        /** {Integer} Minimum top scroll position during deceleration */
        __minDecelerationScrollTop: null,

        /** {Integer} Maximum left scroll position during deceleration */
        __maxDecelerationScrollLeft: null,

        /** {Integer} Maximum top scroll position during deceleration */
        __maxDecelerationScrollTop: null,

        /** {Number} Current factor to modify horizontal scroll position with on every step */
        __decelerationVelocityX: null,

        /** {Number} Current factor to modify vertical scroll position with on every step */
        __decelerationVelocityY: null,



        /*
          ---------------------------------------------------------------------------
          PUBLIC API
          ---------------------------------------------------------------------------
        */

        /**
         * Configures the dimensions of the client (outer) and content (inner) elements.
         * Requires the available space for the outer element and the outer size of the inner element.
         * All values which are falsy (null or zero etc.) are ignored and the old value is kept.
         *
         * @param clientWidth {Integer ? null} Inner width of outer element
         * @param clientHeight {Integer ? null} Inner height of outer element
         * @param contentWidth {Integer ? null} Outer width of inner element
         * @param contentHeight {Integer ? null} Outer height of inner element
         */
        setDimensions : function (clientWidth, clientHeight, contentWidth, contentHeight) {
            // Only update values which are defined
            if (clientWidth !== null) {
                this.__clientWidth = clientWidth;
            }

            if (clientHeight !== null) {
                this.__clientHeight = clientHeight;
            }

            if (contentWidth !== null) {
                this.__contentWidth = contentWidth;
            }

            if (contentHeight !== null) {
                this.__contentHeight = contentHeight;
            }

            // Refresh maximums
            this.__computeScrollMax();

            // Refresh scroll position
            this.scrollTo(this.__scrollLeft, this.__scrollTop, true);
        },


        /**
         * Sets the client coordinates in relation to the document.
         *
         * @param left {Integer ? 0} Left position of outer element
         * @param top {Integer ? 0} Top position of outer element
         */
        setPosition : function (left, top) {
            this.__clientLeft = left || 0;
            this.__clientTop = top || 0;
        },


        /**
         * Configures the snapping (when snapping is active)
         *
         * @param width {Integer} Snapping width
         * @param height {Integer} Snapping height
         */
        setSnapSize : function (width, height) {
            this.__snapWidth = width;
            this.__snapHeight = height;
        },


        /**
         * Returns the scroll position and zooming values
         *
         * @return {Map} `left` and `top` scroll position and `zoom` level
         */
        getValues : function () {
            return {
                left: this.__scrollLeft,
                top: this.__scrollTop,
                right: this.__scrollLeft + this.__clientWidth/this.__zoomLevel,
                bottom: this.__scrollTop + this.__clientHeight/this.__zoomLevel,
                zoom: this.__zoomLevel
            };
        },


        /**
         * Get point in in content space from scroll coordinates.
         */
        getPoint : function (scrollLeft, scrollTop) {
            var values = this.getValues();

            return {
                left : scrollLeft / values.zoom,
                top : scrollTop / values.zoom
            };
        },


        /**
         * Returns the maximum scroll values
         *
         * @return {Map} `left` and `top` maximum scroll values
         */
        getScrollMax : function () {
            return {
                left: this.__maxScrollLeft,
                top: this.__maxScrollTop
            };
        },


        /**
         * Zooms to the given level. Supports optional animation. Zooms
         * the center when no coordinates are given.
         *
         * @param level {Number} Level to zoom to
         * @param isAnimated {Boolean ? false} Whether to use animation
         * @param fixedLeft {Number ? undefined} Stationary point's left coordinate (vector in client space)
         * @param fixedTop {Number ? undefined} Stationary point's top coordinate (vector in client space)
         * @param callback {Function ? null} A callback that gets fired when the zoom is complete.
         */
        zoomTo : function (level, isAnimated, fixedLeft, fixedTop, callback) {
            if (!this.options.zooming) {
                throw new Error("Zooming is not enabled!");
            }

            // Add callback if exists
            if(callback) {
                this.__zoomComplete = callback;
            }

            // Stop deceleration
            if (this.__isDecelerating) {
                animate.stop(this.__isDecelerating);
                this.__isDecelerating = false;
            }

            var oldLevel = this.__zoomLevel;

            // Normalize fixed point to center of viewport if not defined
            if (fixedLeft === undefined) {
                fixedLeft = this.__clientWidth / 2;
            }

            if (fixedTop === undefined) {
                fixedTop = this.__clientHeight / 2;
            }

            // Limit level according to configuration
            level = Math.max(Math.min(level, this.options.maxZoom), this.options.minZoom);

            // Recompute maximum values while temporary tweaking maximum scroll ranges
            this.__computeScrollMax(level);

            // Recompute left and top scroll positions based on new zoom level.
            // Choosing the new viewport so that the origin's position remains
            // fixed, we have central dilation about the origin.
            // * Fixed point, $F$, remains stationary in content space and in the
            // viewport.
            // * Initial scroll position, $S_i$, in content space.
            // * Final scroll position, $S_f$, in content space.
            // * Initial scaling factor, $k_i$.
            // * Final scaling factor, $k_f$.
            //
            // * $S_i \mapsto S_f$.
            // * $(S_i - F) k_i = (S_f - F) k_f$.
            // * $(S_i - F) k_i/k_f = (S_f - F)$.
            // * $S_f = F + (S_i - F) k_i/k_f$.
            //
            // Fixed point location, $\vector{f} = (F - S_i) k_i$.
            // * $F = S_i + \vector{f}/k_i$.
            // * $S_f = S_i + \vector{f}/k_i + (S_i - S_i - \vector{f}/k_i) k_i/k_f$.
            // * $S_f = S_i + \vector{f}/k_i - \vector{f}/k_f$.
            // * $S_f k_f = S_i k_f + (k_f/k_i - 1)\vector{f}$.
            // * $S_f k_f = (k_f/k_i)(S_i k_i) + (k_f/k_i - 1) \vector{f}$.
            var k = level / oldLevel;
            var left = k*(this.__scrollLeft + fixedLeft) - fixedLeft;
            var top = k*(this.__scrollTop + fixedTop) - fixedTop;

            // Limit x-axis
            if (left > this.__maxScrollLeft) {
                left = this.__maxScrollLeft;
            } else if (left < 0) {
                left = 0;
            }

            // Limit y-axis
            if (top > this.__maxScrollTop) {
                top = this.__maxScrollTop;
            } else if (top < 0) {
                top = 0;
            }

            // Push values out
            this.__publish(left, top, level, isAnimated);
        },


        /**
         * Zooms the content by the given factor.
         *
         * @param factor {Number} Zoom by given factor
         * @param isAnimated {Boolean ? false} Whether to use animation
         * @param originLeft {Number ? 0} Zoom in at given left coordinate
         * @param originTop {Number ? 0} Zoom in at given top coordinate
         * @param callback {Function ? null} A callback that gets fired when the zoom is complete.
         */
        zoomBy : function (factor, isAnimated, originLeft, originTop, callback) {
            this.zoomTo(this.__zoomLevel * factor, isAnimated, originLeft, originTop, callback);
        },


        /**
         * Scrolls to the given position. Respect limitations and snapping automatically.
         *
         * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>
         * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>
         * @param isAnimated {Boolean?false} Whether the scrolling should happen using an animation
         * @param zoom {Number} [1.0] Zoom level to go to
         */
        scrollTo : function (left, top, isAnimated, zoom) {
            // Stop deceleration
            if (this.__isDecelerating) {
                animate.stop(this.__isDecelerating);
                this.__isDecelerating = false;
            }

            // Correct coordinates based on new zoom level
            if (zoom !== undefined && zoom !== this.__zoomLevel) {
                if (!this.options.zooming) {
                    throw new Error("Zooming is not enabled!");
                }

                left *= zoom;
                top *= zoom;

                // Recompute maximum values while temporary tweaking maximum scroll ranges
                this.__computeScrollMax(zoom);
            } else {
                // Keep zoom when not defined
                zoom = this.__zoomLevel;
            }

            if (!this.options.scrollingX) {
                left = this.__scrollLeft;
            } else {
                if (this.options.paging) {
                    left = Math.round(left / this.__clientWidth) * this.__clientWidth;
                } else if (this.options.snapping) {
                    left = Math.round(left / this.__snapWidth) * this.__snapWidth;
                }
            }

            if (!this.options.scrollingY) {
                top = this.__scrollTop;
            } else {
                if (this.options.paging) {
                    top = Math.round(top / this.__clientHeight) * this.__clientHeight;
                } else if (this.options.snapping) {
                    top = Math.round(top / this.__snapHeight) * this.__snapHeight;
                }
            }

            // Limit for allowed ranges
            left = Math.max(Math.min(this.__maxScrollLeft, left), 0);
            top = Math.max(Math.min(this.__maxScrollTop, top), 0);

            // Don't animate when no change detected, still call publish to make sure
            // that rendered position is really in-sync with internal data
            if (left === this.__scrollLeft && top === this.__scrollTop) {
                isAnimated = false;
            }

            // Publish new values
            this.__publish(left, top, zoom, isAnimated);
        },


        /**
         * Scroll by the given offset
         *
         * @param left {Number ? 0} Scroll x-axis by given offset
         * @param top {Number ? 0} Scroll x-axis by given offset
         * @param isAnimated {Boolean ? false} Whether to animate the given change
         */
        scrollBy : function (left, top, isAnimated) {
            var startLeft = this.__isAnimating ? this.__scheduledLeft : this.__scrollLeft;
            var startTop = this.__isAnimating ? this.__scheduledTop : this.__scrollTop;

            this.scrollTo(startLeft + (left || 0), startTop + (top || 0), isAnimated);
        },


        /*
          ---------------------------------------------------------------------------
          EVENT CALLBACKS
          ---------------------------------------------------------------------------
        */

        /**
         * Mouse wheel handler for zooming support
         */
        doMouseZoom : function (wheelDelta, timeStamp, pageX, pageY) {
            var change = wheelDelta > 0 ? 0.97 : 1.03;

            return this.zoomTo(this.__zoomLevel * change, false, pageX - this.__clientLeft, pageY - this.__clientTop);
        },


        /**
         * Touch start handler for scrolling support
         */
        doTouchStart : function (touches, timeStamp) {
            // Array-like check is enough here
            if (touches.length === undefined) {
                throw new Error("Invalid touch list: " + touches);
            }

            if (timeStamp instanceof Date) {
                timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
                throw new Error("Invalid timestamp value: " + timeStamp);
            }

            // Reset interruptedAnimation flag
            this.__interruptedAnimation = true;

            // Stop deceleration
            if (this.__isDecelerating) {
                animate.stop(this.__isDecelerating);
                this.__isDecelerating = false;
                this.__interruptedAnimation = true;
            }

            // Stop animation
            if (this.__isAnimating) {
                animate.stop(this.__isAnimating);
                this.__isAnimating = false;
                this.__interruptedAnimation = true;
            }

            // Use center point when dealing with two fingers
            var currentTouchLeft, currentTouchTop;
            var isSingleTouch = touches.length === 1;
            if (isSingleTouch) {
                currentTouchLeft = touches[0].pageX;
                currentTouchTop = touches[0].pageY;
            } else {
                currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
                currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
            }

            // Store initial positions
            this.__initialTouchLeft = currentTouchLeft;
            this.__initialTouchTop = currentTouchTop;

            // Store current zoom level
            this.__zoomLevelStart = this.__zoomLevel;

            // Store initial touch positions
            this.__lastTouchLeft = currentTouchLeft;
            this.__lastTouchTop = currentTouchTop;

            // Store initial move time stamp
            this.__lastTouchMove = timeStamp;

            // Reset initial scale
            this.__lastScale = 1;

            // Reset locking flags
            this.__enableScrollX = !isSingleTouch && this.options.scrollingX;
            this.__enableScrollY = !isSingleTouch && this.options.scrollingY;

            // Reset tracking flag
            this.__isTracking = true;

            // Reset deceleration complete flag
            this.__didDecelerationComplete = false;

            // Dragging starts directly with two fingers, otherwise lazy with an offset
            this.__isDragging = !isSingleTouch;

            // Some features are disabled in multi touch scenarios
            this.__isSingleTouch = isSingleTouch;

            // Clearing data structure
            this.__positions = [];
        },


        /**
         * Touch move handler for scrolling support
         * @param {Number} [1.0] scale - ....
         */
        doTouchMove : function (touches, timeStamp, scale) {
            // Array-like check is enough here
            if (touches.length === undefined) {
                throw new Error("Invalid touch list: " + touches);
            }

            if (timeStamp instanceof Date) {
                timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
                throw new Error("Invalid timestamp value: " + timeStamp);
            }

            // Ignore event when tracking is not enabled (event might be outside of element)
            if (!this.__isTracking) {
                return;
            }

            var currentTouchLeft, currentTouchTop;

            // Compute move based around of center of fingers
            if (touches.length === 2) {
                currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
                currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
            } else {
                currentTouchLeft = touches[0].pageX;
                currentTouchTop = touches[0].pageY;
            }

            var positions = this.__positions;

            // Are we already is dragging mode?
            if (this.__isDragging) {
                // Compute move distance
                var moveX = currentTouchLeft - this.__lastTouchLeft;
                var moveY = currentTouchTop - this.__lastTouchTop;

                // Read previous scroll position and zooming
                var scrollLeft = this.__scrollLeft;
                var scrollTop = this.__scrollTop;
                var level = this.__zoomLevel;

                // Work with scaling
                if (scale !== undefined && this.options.zooming) {
                    var oldLevel = level;

                    // Recompute level based on previous scale and new scale
                    level = level / this.__lastScale * scale;

                    // Limit level according to configuration
                    level = Math.max(Math.min(level, this.options.maxZoom), this.options.minZoom);

                    // Only do further compution when change happened
                    if (oldLevel !== level) {
                        // Compute relative event position to container
                        var currentTouchLeftRel = currentTouchLeft - this.__clientLeft;
                        var currentTouchTopRel = currentTouchTop - this.__clientTop;

                        // Recompute left and top coordinates based on new zoom level
                        scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;
                        scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;

                        // Recompute max scroll values
                        this.__computeScrollMax(level);
                    }
                }

                if (this.__enableScrollX) {
                    scrollLeft -= moveX * this.options.speedMultiplier;
                    var maxScrollLeft = this.__maxScrollLeft;

                    if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
                        // Slow down on the edges
                        if (this.options.bouncing) {
                            scrollLeft += (moveX / 2  * this.options.speedMultiplier);
                        } else if (scrollLeft > maxScrollLeft) {
                            scrollLeft = maxScrollLeft;
                        } else {
                            scrollLeft = 0;
                        }
                    }
                }

                // Compute new vertical scroll position
                if (this.__enableScrollY) {
                    scrollTop -= moveY * this.options.speedMultiplier;
                    var maxScrollTop = this.__maxScrollTop;

                    if (scrollTop > maxScrollTop || scrollTop < 0) {
                        // Slow down on the edges
                        if (this.options.bouncing) {
                            scrollTop += (moveY / 2 * this.options.speedMultiplier);
                        } else if (scrollTop > maxScrollTop) {
                            scrollTop = maxScrollTop;
                        } else {
                            scrollTop = 0;
                        }
                    }
                }

                // Keep list from growing infinitely (holding min 10, max 20 measure points)
                if (positions.length > 60) {
                    positions.splice(0, 30);
                }

                // Track scroll movement for decleration
                positions.push(scrollLeft, scrollTop, timeStamp);

                // Sync scroll position
                this.__publish(scrollLeft, scrollTop, level);

                // Otherwise figure out whether we are switching into dragging mode now.
            } else {
                var minimumTrackingForScroll = this.options.locking ? 3 : 0;
                var minimumTrackingForDrag = 5;

                var distanceX = Math.abs(currentTouchLeft - this.__initialTouchLeft);
                var distanceY = Math.abs(currentTouchTop - this.__initialTouchTop);

                this.__enableScrollX = this.options.scrollingX && distanceX >= minimumTrackingForScroll;
                this.__enableScrollY = this.options.scrollingY && distanceY >= minimumTrackingForScroll;

                positions.push(this.__scrollLeft, this.__scrollTop, timeStamp);

                this.__isDragging = (this.__enableScrollX || this.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
                if (this.__isDragging) {
                    this.__interruptedAnimation = false;
                }
            }

            // Update last touch positions and time stamp for next event
            this.__lastTouchLeft = currentTouchLeft;
            this.__lastTouchTop = currentTouchTop;
            this.__lastTouchMove = timeStamp;
            this.__lastScale = scale;
        },


        /**
         * Touch end handler for scrolling support
         */
        doTouchEnd : function (timeStamp) {
            if (timeStamp instanceof Date) {
                timeStamp = timeStamp.valueOf();
            }
            if (typeof timeStamp !== "number") {
                throw new Error("Invalid timestamp value: " + timeStamp);
            }

            // Ignore event when tracking is not enabled (no touchstart event on element)
            // This is required as this listener ('touchmove') sits on the document and not on the element itself.
            if (!this.__isTracking) {
                return;
            }

            // Not touching anymore (when two finger hit the screen there are two touch end events)
            this.__isTracking = false;

            // Be sure to reset the dragging flag now. Here we also detect whether
            // the finger has moved fast enough to switch into a deceleration animation.
            if (this.__isDragging) {
                // Reset dragging flag
                this.__isDragging = false;

                // Start deceleration
                // Verify that the last move detected was in some relevant time frame
                if (this.__isSingleTouch && this.options.animating && (timeStamp - this.__lastTouchMove) <= 100) {
                    // Then figure out what the scroll position was about 100ms ago
                    var positions = this.__positions;
                    var endPos = positions.length - 1;
                    var startPos = endPos;

                    // Move pointer to position measured 100ms ago
                    for (var i = endPos; i > 0 && positions[i] > (this.__lastTouchMove - 100); i -= 3) {
                        startPos = i;
                    }

                    // If start and stop position is identical in a 100ms timeframe,
                    // we cannot compute any useful deceleration.
                    if (startPos !== endPos) {
                        // Compute relative movement between these two points
                        var timeOffset = positions[endPos] - positions[startPos];
                        var movedLeft = this.__scrollLeft - positions[startPos - 2];
                        var movedTop = this.__scrollTop - positions[startPos - 1];

                        // Based on 50ms compute the movement to apply for each render step
                        this.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
                        this.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);

                        // How much velocity is required to start the deceleration
                        var minVelocityToStartDeceleration = this.options.paging || this.options.snapping ? 4 : 1;

                        // Verify that we have enough velocity to start deceleration
                        if (Math.abs(this.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(this.__decelerationVelocityY) > minVelocityToStartDeceleration) {
                            this.__startDeceleration(timeStamp);
                        }
                    } else {
                        this.options.scrollingComplete();
                    }
                } else if ((timeStamp - this.__lastTouchMove) > 100) {
                    this.options.scrollingComplete();
                }
            }

            // If this was a slower move it is per default non decelerated, but this
            // still means that we want snap back to the bounds which is done here.
            // This is placed outside the condition above to improve edge case stability
            // e.g. touchend fired without enabled dragging. This should normally do not
            // have modified the scroll positions or even showed the scrollbars though.
            if (!this.__isDecelerating) {
                if (this.__interruptedAnimation || this.__isDragging) {
                    this.options.scrollingComplete();
                }
                this.scrollTo(this.__scrollLeft, this.__scrollTop, true, this.__zoomLevel);
            }

            // Fully cleanup list
            this.__positions.length = 0;
        },



        /*
          ---------------------------------------------------------------------------
          PRIVATE API
          ---------------------------------------------------------------------------
        */

        /**
         * Applies the scroll position to the content element
         *
         * @param left {Number} Left scroll position
         * @param top {Number} Top scroll position
         * @param isAnimated {Boolean?false} Whether animation should be used to move to the new coordinates
         */
        __publish : function (left, top, zoom, isAnimated) {
            // Remember whether we had an animation, then we try to continue
            // based on the current "drive" of the animation.
            var wasAnimating = this.__isAnimating;
            if (wasAnimating) {
                animate.stop(wasAnimating);
                this.__isAnimating = false;
            }

            if (isAnimated && this.options.animating) {
                // Keep scheduled positions for scrollBy/zoomBy functionality.
                this.__scheduledLeft = left;
                this.__scheduledTop = top;
                this.__scheduledZoom = zoom;

                var oldLeft = this.__scrollLeft;
                var oldTop = this.__scrollTop;
                var oldZoom = this.__zoomLevel;

                var diffLeft = left - oldLeft;
                var diffTop = top - oldTop;
                var diffZoom = zoom - oldZoom;

                var step = function (percent, now, render) {
                    if (render) {
                        this.__scrollLeft = oldLeft + (diffLeft * percent);
                        this.__scrollTop = oldTop + (diffTop * percent);
                        this.__zoomLevel = oldZoom + (diffZoom * percent);

                        // Push values out
                        if (this.__callback) {
                            this.__callback(this.__scrollLeft, this.__scrollTop, this.__zoomLevel);
                        }
                    }
                }.bind(this);

                var verify = function (id) {
                    return this.__isAnimating === id;
                }.bind(this);

                var completed = function (renderedFramesPerSecond, animationId, wasFinished) {
                    if (animationId === this.__isAnimating) {
                        this.__isAnimating = false;
                    }
                    if (this.__didDecelerationComplete || wasFinished) {
                        this.options.scrollingComplete();
                    }

                    if (this.options.zooming) {
                        this.__computeScrollMax();
                        if (this.__zoomComplete) {
                            this.__zoomComplete();
                            this.__zoomComplete = null;
                        }
                    }
                }.bind(this);

                // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out
                this.__isAnimating = animate.start(step, verify, completed, this.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);

            } else {
                this.__scheduledLeft = this.__scrollLeft = left;
                this.__scheduledTop = this.__scrollTop = top;
                this.__scheduledZoom = this.__zoomLevel = zoom;

                // Push values out
                if (this.__callback) {
                    this.__callback(left, top, zoom);
                }

                // Fix max scroll ranges
                if (this.options.zooming) {
                    this.__computeScrollMax();
                    if (this.__zoomComplete) {
                        this.__zoomComplete();
                        this.__zoomComplete = null;
                    }
                }
            }
        },


        /**
         * Recomputes scroll minimum values based on client dimensions and content dimensions.
         */
        __computeScrollMax : function (zoomLevel) {
            if (zoomLevel === undefined) {
                zoomLevel = this.__zoomLevel;
            }

            this.__maxScrollLeft = Math.max(this.__contentWidth*zoomLevel - this.__clientWidth, 0);
            this.__maxScrollTop = Math.max(this.__contentHeight*zoomLevel - this.__clientHeight, 0);
        },



        /*
          ---------------------------------------------------------------------------
          ANIMATION (DECELERATION) SUPPORT
          ---------------------------------------------------------------------------
        */

        /**
         * Called when a touch sequence end and the speed of the finger was high enough
         * to switch into deceleration mode.
         */
        __startDeceleration : function (timeStamp) {
            if (this.options.paging) {
                var scrollLeft = Math.max(Math.min(this.__scrollLeft, this.__maxScrollLeft), 0);
                var scrollTop = Math.max(Math.min(this.__scrollTop, this.__maxScrollTop), 0);
                var clientWidth = this.__clientWidth;
                var clientHeight = this.__clientHeight;

                // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.
                // Each page should have exactly the size of the client area.
                this.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
                this.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
                this.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
                this.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
            } else {
                this.__minDecelerationScrollLeft = 0;
                this.__minDecelerationScrollTop = 0;
                this.__maxDecelerationScrollLeft = this.__maxScrollLeft;
                this.__maxDecelerationScrollTop = this.__maxScrollTop;
            }

            // Wrap class method
            var step = function (percent, now, render) {
                this.__stepThroughDeceleration(render);
            }.bind(this);

            // How much velocity is required to keep the deceleration running
            var minVelocityToKeepDecelerating = this.options.snapping ? 4 : 0.1;

            // Detect whether it's still worth to continue animating steps
            // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.
            var verify = function () {
                var shouldContinue = Math.abs(this.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(this.__decelerationVelocityY) >= minVelocityToKeepDecelerating;
                if (!shouldContinue) {
                    this.__didDecelerationComplete = true;
                }
                return shouldContinue;
            }.bind(this);

            var completed = function (renderedFramesPerSecond, animationId, wasFinished) {
                this.__isDecelerating = false;
                if (this.__didDecelerationComplete) {
                    this.options.scrollingComplete();
                }

                // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions
                this.scrollTo(this.__scrollLeft, this.__scrollTop, this.options.snapping);
            }.bind(this);

            // Start animation and switch on flag
            this.__isDecelerating = animate.start(step, verify, completed);
        },


        /**
         * Called on every step of the animation
         *
         * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!
         */
        __stepThroughDeceleration : function (render) {

            //
            // COMPUTE NEXT SCROLL POSITION
            //

            // Add deceleration to scroll position
            var scrollLeft = this.__scrollLeft + this.__decelerationVelocityX;
            var scrollTop = this.__scrollTop + this.__decelerationVelocityY;


            //
            // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE
            //

            if (!this.options.bouncing) {
                var scrollLeftFixed = Math.max(Math.min(this.__maxDecelerationScrollLeft, scrollLeft), this.__minDecelerationScrollLeft);
                if (scrollLeftFixed !== scrollLeft) {
                    scrollLeft = scrollLeftFixed;
                    this.__decelerationVelocityX = 0;
                }

                var scrollTopFixed = Math.max(Math.min(this.__maxDecelerationScrollTop, scrollTop), this.__minDecelerationScrollTop);
                if (scrollTopFixed !== scrollTop) {
                    scrollTop = scrollTopFixed;
                    this.__decelerationVelocityY = 0;
                }
            }


            //
            // UPDATE SCROLL POSITION
            //

            if (render) {
                this.__publish(scrollLeft, scrollTop, this.__zoomLevel);
            } else {
                this.__scrollLeft = scrollLeft;
                this.__scrollTop = scrollTop;
            }


            //
            // SLOW DOWN
            //

            // Slow down velocity on every iteration
            if (!this.options.paging) {
                // This is the factor applied to every iteration of the animation
                // to slow down the process. This should emulate natural behavior where
                // objects slow down when the initiator of the movement is removed
                var frictionFactor = 0.95;

                this.__decelerationVelocityX *= frictionFactor;
                this.__decelerationVelocityY *= frictionFactor;
            }


            //
            // BOUNCING SUPPORT
            //

            if (this.options.bouncing) {
                var scrollOutsideX = 0;
                var scrollOutsideY = 0;

                // This configures the amount of change applied to deceleration/acceleration when reaching boundaries
                var penetrationDeceleration = this.options.penetrationDeceleration;
                var penetrationAcceleration = this.options.penetrationAcceleration;

                // Check limits
                if (scrollLeft < this.__minDecelerationScrollLeft) {
                    scrollOutsideX = this.__minDecelerationScrollLeft - scrollLeft;
                } else if (scrollLeft > this.__maxDecelerationScrollLeft) {
                    scrollOutsideX = this.__maxDecelerationScrollLeft - scrollLeft;
                }

                if (scrollTop < this.__minDecelerationScrollTop) {
                    scrollOutsideY = this.__minDecelerationScrollTop - scrollTop;
                } else if (scrollTop > this.__maxDecelerationScrollTop) {
                    scrollOutsideY = this.__maxDecelerationScrollTop - scrollTop;
                }

                // Slow down until slow enough, then flip back to snap position
                if (scrollOutsideX !== 0) {
                    if (scrollOutsideX * this.__decelerationVelocityX <= 0) {
                        this.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
                    } else {
                        this.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
                    }
                }

                if (scrollOutsideY !== 0) {
                    if (scrollOutsideY * this.__decelerationVelocityY <= 0) {
                        this.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
                    } else {
                        this.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
                    }
                }
            }
        }
    };

    return Scroller;
}));

},{"./animate":118}],118:[function(require,module,exports){
/*
 * Scroller
 * http://github.com/zynga/scroller
 *
 * Copyright 2011, Zynga Inc.
 * Licensed under the MIT License.
 * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt
 *
 * Based on the work of: Unify Project (unify-project.org)
 * http://unify-project.org
 * Copyright 2011, Deutsche Telekom AG
 * License: MIT + Apache (V2)
 */

/**
 * Generic animation class with support for dropped frames both optional easing and duration.
 *
 * Optional duration is useful when the lifetime is defined by another condition than time
 * e.g. speed of an animating object, etc.
 *
 * Dropped frame logic allows to keep using the same updater logic independent from the actual
 * rendering. This eases a lot of cases where it might be pretty complex to break down a state
 * based on the pure time difference.
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory((root.animate = {}));
    }
}(this, function (exports) {
    var global = this;
    var time = Date.now || function () {
        return +new Date();
    };
    var desiredFrames = 60;
    var millisecondsPerSecond = 1000;
    var running = {};
    var counter = 1;

    /**
     * A requestAnimationFrame wrapper / polyfill.
     *
     * @param callback {Function} The callback to be invoked before the next repaint.
     * @param root {HTMLElement} The root element for the repaint
     */
    exports.requestAnimationFrame = (function () {
        // Check for request animation Frame support
        var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
        var isNative = !!requestFrame;

        if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
            isNative = false;
        }

        if (isNative) {
            return function (callback, root) {
                requestFrame(callback, root);
            };
        }

        var TARGET_FPS = 60;
        var requests = {};
        var requestCount = 0;
        var rafHandle = 1;
        var intervalHandle = null;
        var lastActive = +new Date();

        return function (callback, root) {
            var callbackHandle = rafHandle++;

            // Store callback
            requests[callbackHandle] = callback;
            requestCount++;

            // Create timeout at first request
            if (intervalHandle === null) {

                intervalHandle = setInterval(function () {

                    var time = +new Date();
                    var currentRequests = requests;

                    // Reset data structure before executing callbacks
                    requests = {};
                    requestCount = 0;

                    for(var key in currentRequests) {
                        if (currentRequests.hasOwnProperty(key)) {
                            currentRequests[key](time);
                            lastActive = time;
                        }
                    }

                    // Disable the timeout when nothing happens for a certain
                    // period of time
                    if (time - lastActive > 2500) {
                        clearInterval(intervalHandle);
                        intervalHandle = null;
                    }

                }, 1000 / TARGET_FPS);
            }

            return callbackHandle;
        };

    })();

    /**
     * Stops the given animation.
     *
     * @param id {Integer} Unique animation ID
     * @return {Boolean} Whether the animation was stopped (aka, was running before)
     */
    exports.stop = function (id) {
        var cleared = (running[id] !== null);
        if (cleared) {
            running[id] = null;
        }

        return cleared;
    };


    /**
     * Whether the given animation is still running.
     *
     * @param id {Integer} Unique animation ID
     * @return {Boolean} Whether the animation is still running
     */
    exports.isRunning = function (id) {
        return running[id] !== null;
    };


    /**
     * Start the animation.
     *
     * @param stepCallback {Function} Pointer to function which is executed on every step.
     *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`
     * @param verifyCallback {Function} Executed before every animation step.
     *   Signature of the method should be `function() { return continueWithAnimation; }`
     * @param completedCallback {Function}
     *   Signature of the method should be `function(droppedFrames, finishedAnimation, optional wasFinished) {}`
     * @param duration {Integer} Milliseconds to run the animation
     * @param easingMethod {Function} Pointer to easing function
     *   Signature of the method should be `function(percent) { return modifiedValue; }`
     * @param root {Element} Render root. Used for internal usage of requestAnimationFrame.
     * @return {Integer} Identifier of animation. Can be used to stop it any time.
     */
    exports.start = function (stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
        var start = time();
        var lastFrame = start;
        var percent = 0;
        var dropCounter = 0;
        var id = counter++;

        // Compacting running db automatically every few new animations
        if (id % 20 === 0) {
            var newRunning = {};
            for (var usedId in running) {
                newRunning[usedId] = true;
            }
            running = newRunning;
        }

        // This is the internal step method which is called every few milliseconds
        var step = function (virtual) {

            // Normalize virtual value
            var render = virtual !== true;

            // Get current time
            var now = time();

            // Verification is executed before next animation step
            if (!running[id] || (verifyCallback && !verifyCallback(id))) {

                running[id] = null;
                completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);
                return;

            }

            // For the current rendering to apply let's update omitted steps in memory.
            // This is important to bring internal state variables up-to-date with progress in time.
            if (render) {

                var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
                for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
                    step(true);
                    dropCounter++;
                }

            }

            // Compute percent value
            if (duration) {
                percent = (now - start) / duration;
                if (percent > 1) {
                    percent = 1;
                }
            }

            // Execute step callback, then...
            var value = easingMethod ? easingMethod(percent) : percent;
            if ((stepCallback(value, now, render) === false || percent === 1) && render) {
                running[id] = null;
                completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration === undefined);
            } else if (render) {
                lastFrame = now;
                exports.requestAnimationFrame(step, root);
            }
        };

        // Mark as running
        running[id] = true;

        // Init first step
        exports.requestAnimationFrame(step, root);

        // Return unique animation ID
        return id;
    };
}));

},{}],119:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? this
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

function getXHR() {
  if (root.XMLHttpRequest
    && ('file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
}

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  this.text = this.req.method !='HEAD' 
     ? this.xhr.responseText 
     : null;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse && str && str.length
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status || 1223 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self); 
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
    }

    self.callback(err, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.field = function(name, val){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(name, val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(field, file, filename);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  if (2 == fn.length) return fn(err, res);
  if (err) return this.emit('error', err);
  fn(res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;
    if (0 == xhr.status) {
      if (self.aborted) return self.timeoutError();
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  if (xhr.upload) {
    xhr.upload.onprogress = function(e){
      e.percent = e.loaded / e.total * 100;
      self.emit('progress', e);
    };
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

},{"emitter":120,"reduce":121}],120:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],121:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuL2NsaWVudC9hcHAvY2xpZW50LmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvYWN0aW9ucy9NZXNzYWdlQWN0aW9ucy5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvYWN0aW9ucy9hdXRoZW50aWNhdGlvbi9Mb2dpbkFjdGlvbnMuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9jbGllbnQvYXBwL2FjdGlvbnMvYXV0aGVudGljYXRpb24vU2lnbnVwQWN0aW9uLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9hcHAuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL015RHJpdmUuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL2VsZW1lbnRzL3BvcEFycm93L1BvcEFycm93LmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9lbGVtZW50cy90b29sVGlwSG92ZXIuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL2Zvcm1zL2FkZHJlc3Mvc3RhdGVzLmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9pbnRlcmFjdGl2ZXMvaW1hZ2VDYXJkL0ltYWdlQ2FyZC5qc3giLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9jbGllbnQvYXBwL2NvbXBvbmVudHMvaW50ZXJhY3RpdmVzL2ltYWdlQ2FyZC9JbWFnZUNhcmRDb250YWluZXIuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL2ludGVyYWN0aXZlcy9pbWFnZUNhcmQvVmlld2VyLmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9pbnRlcmFjdGl2ZXMvbGVmdE5hdi9MZWZ0TmF2QmVoYXZpb3JzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL2ludGVyYWN0aXZlcy9sZWZ0TmF2L0xlZnROYXZDb250YWluZXIuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL2ludGVyYWN0aXZlcy9zaW1wbGVTY3JvbGxlci9TaW1wbGVTY3JvbGxlci5qc3giLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9jbGllbnQvYXBwL2NvbXBvbmVudHMvbGF5b3V0cy9TaWRlTmF2LmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9sYXlvdXRzL25hdmJhci9OYXZCYXIuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL3BhZ2VzL0dhbGxlcnlQYWdlLmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9wYWdlcy9Ib21lLmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9wYWdlcy9Mb2dpbi5qc3giLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9jbGllbnQvYXBwL2NvbXBvbmVudHMvcGFnZXMvU2lkZU5hdi5qc3giLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9jbGllbnQvYXBwL2NvbXBvbmVudHMvcGFnZXMvU2lnbnVwLmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9wYWdlcy9TaW1wbGVTY3JvbGwuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL3BhZ2VzL2FkbWluL2FkbWluLmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9wcmltaXRpdmVzL0FuaW1hdGFibGVDb250YWluZXIuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb21wb25lbnRzL3ByaW1pdGl2ZXMvU3RhdGljQ29udGFpbmVyLmpzeCIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvY29tcG9uZW50cy9wcmltaXRpdmVzL1RvdWNoYWJsZUFyZWEuanN4IiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9jb25zdGFudHMvQXBwQ29uc3RhbnRzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9lbnZpcm9ubWVudC9TY3JvbGxlci5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvZW52aXJvbm1lbnQvU3R5bGVLZXlzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9yb3V0ZXMvcm91dGVzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvY2xpZW50L2FwcC9zdG9yZXMvQXBwbGljYXRpb25TdG9yZS5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hcHAvc3RvcmVzL1Nlc3Npb25TdG9yZS5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L2NsaWVudC9hc3NldHMvSW1hZ2VzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbGliL21hdGgvZWFzaW5nLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvY29va2llcy1qcy9zcmMvY29va2llcy5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2RlYnVnL2RlYnVnLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2RlYnVnL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4LXJvdXRlci1jb21wb25lbnQvYWN0aW9ucy9uYXZpZ2F0ZS5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4LXJvdXRlci1jb21wb25lbnQvaW5kZXguanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eC1yb3V0ZXItY29tcG9uZW50L2xpYi9IaXN0b3J5LmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXgtcm91dGVyLWNvbXBvbmVudC9saWIvTmF2TGluay5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4LXJvdXRlci1jb21wb25lbnQvbGliL1JvdXRlck1peGluLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXgtcm91dGVyLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL3F1ZXJ5LXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9mbHV4LXJvdXRlci1jb21wb25lbnQvbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUtcGx1Z2luLWZldGNoci9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tZmV0Y2hyL2xpYi9mZXRjaHItcGx1Z2luLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXhpYmxlLXBsdWdpbi1mZXRjaHIvbm9kZV9tb2R1bGVzL2ZldGNoci9saWJzL2ZldGNoZXIuY2xpZW50LmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXhpYmxlLXBsdWdpbi1mZXRjaHIvbm9kZV9tb2R1bGVzL2ZldGNoci9saWJzL3V0aWwvaHR0cC5jbGllbnQuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUtcGx1Z2luLWZldGNoci9ub2RlX21vZHVsZXMvZmV0Y2hyL25vZGVfbW9kdWxlcy94aHIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZmx1eGlibGUtcGx1Z2luLWZldGNoci9ub2RlX21vZHVsZXMvZmV0Y2hyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUtcGx1Z2luLWZldGNoci9ub2RlX21vZHVsZXMvZmV0Y2hyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tZmV0Y2hyL25vZGVfbW9kdWxlcy9mZXRjaHIvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUtcGx1Z2luLWZldGNoci9ub2RlX21vZHVsZXMvZmV0Y2hyL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL25vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tZmV0Y2hyL25vZGVfbW9kdWxlcy9mZXRjaHIvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tZmV0Y2hyL25vZGVfbW9kdWxlcy9mZXRjaHIvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXhpYmxlLXBsdWdpbi1yb3V0ci9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tcm91dHIvbGliL3JvdXRyLXBsdWdpbi5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tcm91dHIvbm9kZV9tb2R1bGVzL3JvdXRyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ZsdXhpYmxlLXBsdWdpbi1yb3V0ci9ub2RlX21vZHVsZXMvcm91dHIvbGliL3JvdXRlci5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tcm91dHIvbm9kZV9tb2R1bGVzL3JvdXRyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tcm91dHIvbm9kZV9tb2R1bGVzL3JvdXRyL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tcm91dHIvbm9kZV9tb2R1bGVzL3JvdXRyL25vZGVfbW9kdWxlcy9yZXZlcmVuZC9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS1wbHVnaW4tcm91dHIvbm9kZV9tb2R1bGVzL3JvdXRyL25vZGVfbW9kdWxlcy9yZXZlcmVuZC9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUvaW5kZXguanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUvbGliL0ZsdXhpYmxlLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXhpYmxlL2xpYi9GbHV4aWJsZUNvbnRleHQuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUvbWl4aW5zL0ZsdXhpYmxlTWl4aW4uanMiLCJub2RlX21vZHVsZXMvZmx1eGlibGUvbm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS9ub2RlX21vZHVsZXMvZGlzcGF0Y2hyL2luZGV4LmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXhpYmxlL25vZGVfbW9kdWxlcy9kaXNwYXRjaHIvbGliL0FjdGlvbi5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9mbHV4aWJsZS9ub2RlX21vZHVsZXMvZGlzcGF0Y2hyL2xpYi9EaXNwYXRjaGVyLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXhpYmxlL25vZGVfbW9kdWxlcy9kaXNwYXRjaHIvdXRpbHMvQmFzZVN0b3JlLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL2ZsdXhpYmxlL25vZGVfbW9kdWxlcy9kaXNwYXRjaHIvdXRpbHMvY3JlYXRlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvZmx1eGlibGUvbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvZmx1eGlibGUvdXRpbHMvY3JlYXRlU3RvcmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2Rpc3QvbG9kYXNoLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvcmVhY3QtdGFwLWV2ZW50LXBsdWdpbi9zcmMvUmVzcG9uZGVyRXZlbnRQbHVnaW4uanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvcmVhY3QtdGFwLWV2ZW50LXBsdWdpbi9zcmMvVGFwRXZlbnRQbHVnaW4uanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvcmVhY3QtdGFwLWV2ZW50LXBsdWdpbi9zcmMvVG91Y2hFdmVudFV0aWxzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL3JlYWN0LXRhcC1ldmVudC1wbHVnaW4vc3JjL2luamVjdFRhcEV2ZW50UGx1Z2luLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIva2V5TWlycm9yLmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9rZXlPZi5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9zY3JvbGxlci9pbmRleC5qcyIsIi9ob21lL3BhdWwvQ29kZS9mdW5kcmFpc2VyL215ZHJpdmU3L25vZGVfbW9kdWxlcy9zY3JvbGxlci9saWIvU2Nyb2xsZXIuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvc2Nyb2xsZXIvbGliL2FuaW1hdGUuanMiLCIvaG9tZS9wYXVsL0NvZGUvZnVuZHJhaXNlci9teWRyaXZlNy9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvY2xpZW50LmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwiL2hvbWUvcGF1bC9Db2RlL2Z1bmRyYWlzZXIvbXlkcml2ZTcvbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbm9kZV9tb2R1bGVzL3JlZHVjZS1jb21wb25lbnQvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvS0E7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDam9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDempDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmpzaGludCBub2RlOnRydWUqL1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuLypnbG9iYWwgQXBwLCBkb2N1bWVudCwgd2luZG93ICovXG4ndXNlIHN0cmljdCc7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKTtcbnZhciBib290c3RyYXBEZWJ1ZyA9IGRlYnVnKCdteWRyaXZlJyk7XG52YXIgYXBwID0gcmVxdWlyZSgnLi9hcHAuanN4Jyk7XG52YXIgZGVoeWRyYXRlZFN0YXRlID0gd2luZG93LkFwcDsgLy8gU2VudCBmcm9tIHRoZSBzZXJ2ZXJcblxud2luZG93LlJlYWN0ID0gUmVhY3Q7IC8vIEZvciBjaHJvbWUgZGV2IHRvb2wgc3VwcG9ydFxuZGVidWcuZW5hYmxlKCcqJyk7XG5cbi8vIGJvb3RzdHJhcERlYnVnKCdyZWh5ZHJhdGluZyBhcHAnKTtcbmFwcC5yZWh5ZHJhdGUoZGVoeWRyYXRlZFN0YXRlLCBmdW5jdGlvbiAoZXJyLCBjb250ZXh0KSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHdpbmRvdy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB2YXIgbW91bnROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpO1xuXG4gICAgLy8gYm9vdHN0cmFwRGVidWcoJ1JlYWN0IFJlbmRlcmluZycpO1xuICAgIFJlYWN0LndpdGhDb250ZXh0KGNvbnRleHQuZ2V0Q29tcG9uZW50Q29udGV4dCgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFJlYWN0LnJlbmRlcihhcHAuZ2V0QXBwQ29tcG9uZW50KCkoKSwgbW91bnROb2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBib290c3RyYXBEZWJ1ZygnUmVhY3QgUmVuZGVyZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnRXhhbXBsZTpzaG93Q2hhdEFjdGlvbicpO1xuLy8gdmFyIE1lc3NhZ2VTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9NZXNzYWdlU3RvcmUnKTtcbi8vIHZhciBvcGVuVGhyZWFkID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9vcGVuVGhyZWFkJyk7XG5cbmZ1bmN0aW9uIGZldGNoTWVzc2FnZXMoY29udGV4dCwgcGF5bG9hZCwgZG9uZSkge1xuICAgIGRlYnVnKCdmZXRjaGluZyBtZXNzYWdlcycpO1xuICAgIGNvbnRleHQuc2VydmljZS5yZWFkKCdtZXNzYWdlJywge30sIHt9LCBmdW5jdGlvbiAoZXJyLCBtZXNzYWdlcykge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKCdSRUNFSVZFX01FU1NBR0VTJywgbWVzc2FnZXMpO1xuICAgICAgICAvLyBjb250ZXh0LmV4ZWN1dGVBY3Rpb24ob3BlblRocmVhZCwgcGF5bG9hZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBjb250ZXh0LmRpc3BhdGNoKCdTSE9XX0NIQVRfRU5EJyk7XG4gICAgICAgIC8vICAgICBkb25lKCk7XG4gICAgICAgIC8vIH0pOztcbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIHBheWxvYWQsIGRvbmUpIHtcbiAgICAvLyBjb250ZXh0LmRpc3BhdGNoKCdTSE9XX0NIQVRfU1RBUlQnKTtcbiAgICAvLyB2YXIgbWVzc2FnZVN0b3JlID0gY29udGV4dC5nZXRTdG9yZShNZXNzYWdlU3RvcmUpO1xuICAgIGZldGNoTWVzc2FnZXMoY29udGV4dCxwYXlsb2FkLGRvbmUpO1xuICAgIGRvbmUoKTtcbiAgICAvLyBpZiAoT2JqZWN0LmtleXMobWVzc2FnZVN0b3JlLmdldEFsbCgpKS5sZW5ndGggPT09IDApIHtcbiAgICAvLyAgICAgZmV0Y2hNZXNzYWdlcyhjb250ZXh0LCBwYXlsb2FkLCBkb25lKTtcbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgICBkZWJ1ZygnZGlzcGF0Y2hpbmcgU0hPV19DSEFUX0VORCcpO1xuICAgIC8vICAgICBjb250ZXh0LmRpc3BhdGNoKCdTSE9XX0NIQVRfRU5EJyk7XG4gICAgLy8gICAgIGRvbmUoKTtcbiAgICAvLyB9XG59OyIsIi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbXlkcml2ZTU6c2hvd0NoYXRBY3Rpb24nKTtcbi8vIHZhciBNZXNzYWdlU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvTWVzc2FnZVN0b3JlJyk7XG4vLyB2YXIgb3BlblRocmVhZCA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvb3BlblRocmVhZCcpO1xudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG4vLyB2YXIgY3NyZiA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQtY3NyZicpKHJlcXVlc3QpO1xudmFyIG5hdmlnYXRlQWN0aW9uID0gcmVxdWlyZSgnZmx1eC1yb3V0ZXItY29tcG9uZW50JykubmF2aWdhdGVBY3Rpb247XG5cblxuZnVuY3Rpb24gbG9naW4oY29udGV4dCwgcGF5bG9hZCwgZG9uZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKGNvbnRleHQpO1xuICAgIC8vIGNvbnNvbGUubG9nKHdpbmRvdy5BcHAuY29udGV4dC5wbHVnaW5zLkZldGNoclBsdWdpbi54aHJDb250ZXh0Ll9jc3JmKTtcbiAgICAvLyBjb25zb2xlLmxvZygncGF5bG9hZCcscGF5bG9hZCk7XG4gICAgLy8gdmFyIGNvb2tpZT1kb2N1bWVudC5jb29raWU7XG4gICAgLy8gdmFyIHRva2VuPWdldENvb2tpZSgnX2NzcmYnKTtcbiAgICBwYXlsb2FkLl9jc3JmPXdpbmRvdy5BcHAuY29udGV4dC5wbHVnaW5zLkZldGNoclBsdWdpbi54aHJDb250ZXh0Ll9jc3JmO1xuICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsdG9rZW4pO1xuICAgIHJlcXVlc3QucG9zdCgnL2F1dGgvbG9jYWwnKVxuICAgIC5zZW5kKHBheWxvYWQpXG4gICAgLmVuZChmdW5jdGlvbihlcnJvcixyZXMpe1xuICAgICAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICBpZihyZXMuYm9keS50b2tlbiAmJiByZXMuYm9keS51c2VyKXtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goJ1NFVF9UT0tFTicscmVzLmJvZHkudG9rZW4pO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCgnU0VUX1VTRVInLHJlcy5ib2R5LnVzZXIpO1xuICAgICAgICAgICAgY29udGV4dC5leGVjdXRlQWN0aW9uKG5hdmlnYXRlQWN0aW9uLCB7IHVybDogJy9hZG1pbicgfSwgZnVuY3Rpb24oKXt9KTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgfSk7XG4gICAgLy8gZGVidWcoJ2ZldGNoaW5nIG1lc3NhZ2VzJyk7XG4gICAgLy8gY29udGV4dC5zZXJ2aWNlLmNyZWF0ZSgnbWVzc2FnZScsIHt9LCB7fSwgZnVuY3Rpb24gKGVyciwgbWVzc2FnZXMpIHtcbiAgICAvLyAgICAgY29udGV4dC5kaXNwYXRjaCgnUkVDRUlWRV9NRVNTQUdFUycsIG1lc3NhZ2VzKTtcbiAgICAvLyAgICAgLy8gY29udGV4dC5leGVjdXRlQWN0aW9uKG9wZW5UaHJlYWQsIHBheWxvYWQsIGZ1bmN0aW9uKCkge1xuICAgIC8vICAgICAvLyAgICAgY29udGV4dC5kaXNwYXRjaCgnU0hPV19DSEFUX0VORCcpO1xuICAgIC8vICAgICAvLyAgICAgZG9uZSgpO1xuICAgIC8vICAgICAvLyB9KTs7XG4gICAgLy8gICAgIGRvbmUoKTtcbiAgICAvLyB9KTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBwYXlsb2FkLCBkb25lKSB7XG4gICAgLy8gY29udGV4dC5kaXNwYXRjaCgnU0hPV19DSEFUX1NUQVJUJyk7XG4gICAgLy8gdmFyIG1lc3NhZ2VTdG9yZSA9IGNvbnRleHQuZ2V0U3RvcmUoTWVzc2FnZVN0b3JlKTtcbiAgICBsb2dpbihjb250ZXh0LHBheWxvYWQsZG9uZSk7XG4gICAgZG9uZSgpO1xuICAgIC8vIGlmIChPYmplY3Qua2V5cyhtZXNzYWdlU3RvcmUuZ2V0QWxsKCkpLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vICAgICBmZXRjaE1lc3NhZ2VzKGNvbnRleHQsIHBheWxvYWQsIGRvbmUpO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICAgIGRlYnVnKCdkaXNwYXRjaGluZyBTSE9XX0NIQVRfRU5EJyk7XG4gICAgLy8gICAgIGNvbnRleHQuZGlzcGF0Y2goJ1NIT1dfQ0hBVF9FTkQnKTtcbiAgICAvLyAgICAgZG9uZSgpO1xuICAgIC8vIH1cbn07IiwiLypqc2hpbnQgbm9kZTp0cnVlICovXG4ndXNlIHN0cmljdCc7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdteWRyaXZlNTpzaG93Q2hhdEFjdGlvbicpO1xuLy8gdmFyIE1lc3NhZ2VTdG9yZSA9IHJlcXVpcmUoJy4uL3N0b3Jlcy9NZXNzYWdlU3RvcmUnKTtcbi8vIHZhciBvcGVuVGhyZWFkID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9vcGVuVGhyZWFkJyk7XG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQnKTtcbi8vIHZhciBjc3JmID0gcmVxdWlyZSgnc3VwZXJhZ2VudC1jc3JmJykocmVxdWVzdCk7XG52YXIgbmF2aWdhdGVBY3Rpb24gPSByZXF1aXJlKCdmbHV4LXJvdXRlci1jb21wb25lbnQnKS5uYXZpZ2F0ZUFjdGlvbjtcblxuXG5mdW5jdGlvbiBzaWdudXAoY29udGV4dCwgcGF5bG9hZCwgZG9uZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKGNvbnRleHQpO1xuICAgIC8vIGNvbnNvbGUubG9nKHdpbmRvdy5BcHAuY29udGV4dC5wbHVnaW5zLkZldGNoclBsdWdpbi54aHJDb250ZXh0Ll9jc3JmKTtcbiAgICAvLyBjb25zb2xlLmxvZygncGF5bG9hZCcscGF5bG9hZCk7XG4gICAgLy8gdmFyIGNvb2tpZT1kb2N1bWVudC5jb29raWU7XG4gICAgLy8gdmFyIHRva2VuPWdldENvb2tpZSgnX2NzcmYnKTtcbiAgICBwYXlsb2FkLl9jc3JmPXdpbmRvdy5BcHAuY29udGV4dC5wbHVnaW5zLkZldGNoclBsdWdpbi54aHJDb250ZXh0Ll9jc3JmO1xuICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsdG9rZW4pO1xuXG4gICAgdmFyIHVybD0nL2F1dGgvc3RyaXBlLz8nK2RlY29kZVVSSUNvbXBvbmVudCgkLnBhcmFtKHBheWxvYWQpKTtcbiAgICBjb25zb2xlLmxvZyh1cmwpO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmPXVybDtcblxuXG4gICAgLy8gZGVidWcoJ2ZldGNoaW5nIG1lc3NhZ2VzJyk7XG4gICAgLy8gY29udGV4dC5zZXJ2aWNlLmNyZWF0ZSgnbWVzc2FnZScsIHt9LCB7fSwgZnVuY3Rpb24gKGVyciwgbWVzc2FnZXMpIHtcbiAgICAvLyAgICAgY29udGV4dC5kaXNwYXRjaCgnUkVDRUlWRV9NRVNTQUdFUycsIG1lc3NhZ2VzKTtcbiAgICAvLyAgICAgLy8gY29udGV4dC5leGVjdXRlQWN0aW9uKG9wZW5UaHJlYWQsIHBheWxvYWQsIGZ1bmN0aW9uKCkge1xuICAgIC8vICAgICAvLyAgICAgY29udGV4dC5kaXNwYXRjaCgnU0hPV19DSEFUX0VORCcpO1xuICAgIC8vICAgICAvLyAgICAgZG9uZSgpO1xuICAgIC8vICAgICAvLyB9KTs7XG4gICAgLy8gICAgIGRvbmUoKTtcbiAgICAvLyB9KTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBwYXlsb2FkLCBkb25lKSB7XG4gICAgLy8gY29udGV4dC5kaXNwYXRjaCgnU0hPV19DSEFUX1NUQVJUJyk7XG4gICAgLy8gdmFyIG1lc3NhZ2VTdG9yZSA9IGNvbnRleHQuZ2V0U3RvcmUoTWVzc2FnZVN0b3JlKTtcbiAgICBzaWdudXAoY29udGV4dCxwYXlsb2FkLGRvbmUpO1xuICAgIGRvbmUoKTtcbiAgICAvLyBpZiAoT2JqZWN0LmtleXMobWVzc2FnZVN0b3JlLmdldEFsbCgpKS5sZW5ndGggPT09IDApIHtcbiAgICAvLyAgICAgZmV0Y2hNZXNzYWdlcyhjb250ZXh0LCBwYXlsb2FkLCBkb25lKTtcbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgICBkZWJ1ZygnZGlzcGF0Y2hpbmcgU0hPV19DSEFUX0VORCcpO1xuICAgIC8vICAgICBjb250ZXh0LmRpc3BhdGNoKCdTSE9XX0NIQVRfRU5EJyk7XG4gICAgLy8gICAgIGRvbmUoKTtcbiAgICAvLyB9XG59OyIsIi8qanNoaW50IG5vZGU6dHJ1ZSovXG5cbi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG4vKlJlYWRNZTpcbiAgQ29tcG9uZW50cyBhcmUgd2hlcmUgeW91IHdpbGwgYmUgZGVzaWduaW5nIHlvdXIgdmlldyBpbiB0aGVcbiAgcmVuZGVyIHNlY3Rpb24uICBUaGlzIGNvZGUgaXMgd3JpdHRlbiBpbiBqc3g7IDx0aGlzLnByb3BzLmFjdGl2ZVJvdXRlSGFuZGxlci8+XG4gIGlzIHVzZWQgYmVsb3cgZm9yIGNoYW5naW5nIHZpZXdzIGZvciByb3V0aW5nLiAgXG5cbiAgVG8gYWRkIGNvbXBvbmVudHMsIHlvdSBjYW4gcnVuIHJlYWN0LWZ1bGxzdGFjazpjb21wb25lbnQsIGFuZCBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBjb21wb25lbnQgZmlsZSBpbiB0aGUgZm9sZGVyLlxuKi9cblxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBGbHV4aWJsZSA9IHJlcXVpcmUoJ2ZsdXhpYmxlJyk7XG52YXIgZmV0Y2hyUGx1Z2luID0gcmVxdWlyZSgnZmx1eGlibGUtcGx1Z2luLWZldGNocicpO1xudmFyIHJvdXRyUGx1Z2luID0gcmVxdWlyZSgnZmx1eGlibGUtcGx1Z2luLXJvdXRyJyk7XG5cbnZhciBhcHAgPSBuZXcgRmx1eGlibGUoe1xuICAgIGFwcENvbXBvbmVudDogUmVhY3QuY3JlYXRlRmFjdG9yeShyZXF1aXJlKCcuL2NvbXBvbmVudHMvTXlEcml2ZS5qc3gnKSlcbn0pO1xuXG5hcHAucGx1ZyhmZXRjaHJQbHVnaW4oe1xuICAgIHhoclBhdGg6ICcvcmVzb3VyY2VzJ1xufSkpO1xuXG5hcHAucGx1Zyhyb3V0clBsdWdpbih7XG4gICAgcm91dGVzOiByZXF1aXJlKCcuL3JvdXRlcy9yb3V0ZXMnKVxufSkpO1xuXG5hcHAucmVnaXN0ZXJTdG9yZShyZXF1aXJlKCcuL3N0b3Jlcy9BcHBsaWNhdGlvblN0b3JlJykpO1xuYXBwLnJlZ2lzdGVyU3RvcmUocmVxdWlyZSgnLi9zdG9yZXMvU2Vzc2lvblN0b3JlJykpO1xuXG5cblxuLy8gdmFyIEFwcFJvdXRlcz1yZXF1aXJlKCcuL3JvdXRlcy5qc3gnKTtcbi8vIHZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcblxuXG52YXIgaW5qZWN0VGFwRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwicmVhY3QtdGFwLWV2ZW50LXBsdWdpblwiKTtcbmluamVjdFRhcEV2ZW50UGx1Z2luKCk7XG4vL05lZWRlZCBmb3Igb25Ub3VjaFRhcFxuLy9DYW4gZ28gYXdheSB3aGVuIHJlYWN0IDEuMCByZWxlYXNlXG4vL0NoZWNrIHRoaXMgcmVwbzpcbi8vaHR0cHM6Ly9naXRodWIuY29tL3ppbHZlcmxpbmUvcmVhY3QtdGFwLWV2ZW50LXBsdWdpblxuXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwO1xuXG5cblxuLy8gUm91dGVyXG4vLyAgIC8vIFJ1bnMgdGhlIHJvdXRlciwgc2ltaWxpYXIgdG8gdGhlIFJvdXRlci5ydW4gbWV0aG9kLiBZb3UgY2FuIHRoaW5rIG9mIGl0IGFzIGFuIFxuLy8gICAvLyBpbml0aWFsaXplci9jb25zdHJ1Y3RvciBtZXRob2QuXG4vLyAgIC5jcmVhdGUoe1xuLy8gICAgIHJvdXRlczogQXBwUm91dGVzLFxuLy8gICAgIHNjcm9sbEJlaGF2aW9yOiBSb3V0ZXIuU2Nyb2xsVG9Ub3BCZWhhdmlvclxuLy8gICB9KVxuLy8gICAvLyBUaGlzIGlzIG91ciBjYWxsYmFjayBmdW5jdGlvbiwgd2hlbmV2ZXIgdGhlIHVybCBjaGFuZ2VzIGl0IHdpbGwgYmUgY2FsbGVkIGFnYWluLiBcbi8vICAgLy8gSGFuZGxlcjogVGhlIFJlYWN0Q29tcG9uZW50IGNsYXNzIHRoYXQgd2lsbCBiZSByZW5kZXJlZCAgXG4vLyAgIC5ydW4oZnVuY3Rpb24gKEhhbmRsZXIpIHtcbi8vICAgICBSZWFjdC5yZW5kZXIoIDxIYW5kbGVyLz4sIGRvY3VtZW50LmJvZHkpO1xuLy8gICB9KTtcbi8vIC8vIG1vZHVsZS5leHBvcnRzID0gUmVhY3QucmVuZGVyKHJvdXRlcywgZG9jdW1lbnQuYm9keSk7XG5cbiIsIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4vKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIE5hdkJhciA9IHJlcXVpcmUoJy4vbGF5b3V0cy9uYXZiYXIvTmF2QmFyLmpzeCcpO1xudmFyIEhvbWUgPSByZXF1aXJlKCcuL3BhZ2VzL0hvbWUuanN4Jyk7XG52YXIgTG9naW4gPSByZXF1aXJlKCcuL3BhZ2VzL0xvZ2luLmpzeCcpO1xudmFyIFNpZ251cCA9IHJlcXVpcmUoJy4vcGFnZXMvU2lnbnVwLmpzeCcpO1xudmFyIFNpZGVOYXYgPSByZXF1aXJlKCcuL3BhZ2VzL1NpZGVOYXYuanN4Jyk7XG52YXIgQWRtaW4gPSByZXF1aXJlKCcuL3BhZ2VzL2FkbWluL2FkbWluLmpzeCcpO1xuLy8gdmFyIEFib3V0ID0gcmVxdWlyZSgnLi9BYm91dC5qc3gnKTtcbi8vIHZhciBQYWdlID0gcmVxdWlyZSgnLi9QYWdlLmpzeCcpO1xudmFyIEFwcGxpY2F0aW9uU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvQXBwbGljYXRpb25TdG9yZScpO1xudmFyIFJvdXRlck1peGluID0gcmVxdWlyZSgnZmx1eC1yb3V0ZXItY29tcG9uZW50JykuUm91dGVyTWl4aW47XG52YXIgRmx1eGlibGVNaXhpbiA9IHJlcXVpcmUoJ2ZsdXhpYmxlJykuTWl4aW47XG5cbnZhciBBcHBsaWNhdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJBcHBsaWNhdGlvblwiLFxuICAgIG1peGluczogW1JvdXRlck1peGluLCBGbHV4aWJsZU1peGluXSxcbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIHN0b3JlTGlzdGVuZXJzOiBbQXBwbGljYXRpb25TdG9yZV1cbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0b3JlKEFwcGxpY2F0aW9uU3RvcmUpLmdldFN0YXRlKCk7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFN0b3JlKEFwcGxpY2F0aW9uU3RvcmUpLmdldFN0YXRlKCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgLy9jaG9vc2UgdGhlIHJpZ2h0IHBhZ2UgYmFzZWQgb24gdGhlIHJvdXRlXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5jdXJyZW50UGFnZU5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hvbWUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoSG9tZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhYm91dCc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gUmVhY3QuY3JlYXRlRWxlbWVudChMb2dpbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2dpbic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gUmVhY3QuY3JlYXRlRWxlbWVudChMb2dpbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzaWdudXAnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lnbnVwLCBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NpZGVuYXYnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lkZU5hdiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhZG1pbic6XG4gICAgICAgICAgICAgICAgb3V0cHV0PVJlYWN0LmNyZWF0ZUVsZW1lbnQoQWRtaW4sIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KEhvbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVuZGVyIGNvbnRlbnRcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChOYXZCYXIsIHtzZWxlY3RlZDogdGhpcy5zdGF0ZS5jdXJyZW50UGFnZU5hbWUsIGxpbmtzOiB0aGlzLnN0YXRlLnBhZ2VzfSksIFxuICAgICAgICAgICAgICAgIG91dHB1dFxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChuZXdTdGF0ZS5wYWdlVGl0bGUgPT09IHByZXZTdGF0ZS5wYWdlVGl0bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC50aXRsZSA9IG5ld1N0YXRlLnBhZ2VUaXRsZTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcHBsaWNhdGlvbjtcbiIsIi8qIGpzaGludCBub2RlOnRydWUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBQb3BBcnJvdyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJQb3BBcnJvd1wiLFxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm5hdlwiLCB7Y2xhc3NOYW1lOiBcIm5hdi1jaXJjbGVwb3BcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBSZWFjdC5fX3NwcmVhZCh7fSwgIHRoaXMucHJvcHMpLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcImljb24td3JhcFwifVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvcEFycm93OyIsIi8qIGpzaGludCBub2RlOnRydWUgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBNdWkgPSByZXF1aXJlKCdtYXRlcmlhbC11aScpO1xudmFyIFRvb2x0aXAgPSBNdWkuVG9vbHRpcDtcblxudmFyIEhvdmVyVHJpZ2dlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJIb3ZlclRyaWdnZXJcIixcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge2hvdmVyaW5nOiBmYWxzZX07XG4gIH0sXG4gIHByb3BUeXBlczoge1xuICAgIGxhYmVsOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge29uTW91c2VFbnRlcjogdGhpcy5fb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmU6IHRoaXMuX29uTW91c2VMZWF2ZSwgY2xhc3NOYW1lOiBcInRvb2x0aXAtaG92ZXJcIn0sIFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwLCB7bGFiZWw6IHRoaXMucHJvcHMubGFiZWwsIHNob3c6IHRoaXMuc3RhdGUuaG92ZXJpbmcsIGNsYXNzTmFtZTogXCJ0b29sdGlwLXJpZ2h0XCJ9KVxuICAgICAgKVxuICAgICk7XG4gIH0sXG4gIF9vbk1vdXNlRW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe2hvdmVyaW5nOnRydWV9KTtcbiAgfSxcbiAgX29uTW91c2VMZWF2ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7aG92ZXJpbmc6ZmFsc2V9KTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSG92ZXJUcmlnZ2VyOyIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuLyoganNoaW50IG5vZGU6dHJ1ZSovXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHVzU3RhdGVzID0gW1xuICAgIHsgbmFtZTogJ0FMQUJBTUEnLCBhYmJyZXZpYXRpb246ICdBTCd9LFxuICAgIHsgbmFtZTogJ0FMQVNLQScsIGFiYnJldmlhdGlvbjogJ0FLJ30sXG4gICAgeyBuYW1lOiAnQU1FUklDQU4gU0FNT0EnLCBhYmJyZXZpYXRpb246ICdBUyd9LFxuICAgIHsgbmFtZTogJ0FSSVpPTkEnLCBhYmJyZXZpYXRpb246ICdBWid9LFxuICAgIHsgbmFtZTogJ0FSS0FOU0FTJywgYWJicmV2aWF0aW9uOiAnQVInfSxcbiAgICB7IG5hbWU6ICdDQUxJRk9STklBJywgYWJicmV2aWF0aW9uOiAnQ0EnfSxcbiAgICB7IG5hbWU6ICdDT0xPUkFETycsIGFiYnJldmlhdGlvbjogJ0NPJ30sXG4gICAgeyBuYW1lOiAnQ09OTkVDVElDVVQnLCBhYmJyZXZpYXRpb246ICdDVCd9LFxuICAgIHsgbmFtZTogJ0RFTEFXQVJFJywgYWJicmV2aWF0aW9uOiAnREUnfSxcbiAgICB7IG5hbWU6ICdESVNUUklDVCBPRiBDT0xVTUJJQScsIGFiYnJldmlhdGlvbjogJ0RDJ30sXG4gICAgeyBuYW1lOiAnRkVERVJBVEVEIFNUQVRFUyBPRiBNSUNST05FU0lBJywgYWJicmV2aWF0aW9uOiAnRk0nfSxcbiAgICB7IG5hbWU6ICdGTE9SSURBJywgYWJicmV2aWF0aW9uOiAnRkwnfSxcbiAgICB7IG5hbWU6ICdHRU9SR0lBJywgYWJicmV2aWF0aW9uOiAnR0EnfSxcbiAgICB7IG5hbWU6ICdHVUFNJywgYWJicmV2aWF0aW9uOiAnR1UnfSxcbiAgICB7IG5hbWU6ICdIQVdBSUknLCBhYmJyZXZpYXRpb246ICdISSd9LFxuICAgIHsgbmFtZTogJ0lEQUhPJywgYWJicmV2aWF0aW9uOiAnSUQnfSxcbiAgICB7IG5hbWU6ICdJTExJTk9JUycsIGFiYnJldmlhdGlvbjogJ0lMJ30sXG4gICAgeyBuYW1lOiAnSU5ESUFOQScsIGFiYnJldmlhdGlvbjogJ0lOJ30sXG4gICAgeyBuYW1lOiAnSU9XQScsIGFiYnJldmlhdGlvbjogJ0lBJ30sXG4gICAgeyBuYW1lOiAnS0FOU0FTJywgYWJicmV2aWF0aW9uOiAnS1MnfSxcbiAgICB7IG5hbWU6ICdLRU5UVUNLWScsIGFiYnJldmlhdGlvbjogJ0tZJ30sXG4gICAgeyBuYW1lOiAnTE9VSVNJQU5BJywgYWJicmV2aWF0aW9uOiAnTEEnfSxcbiAgICB7IG5hbWU6ICdNQUlORScsIGFiYnJldmlhdGlvbjogJ01FJ30sXG4gICAgeyBuYW1lOiAnTUFSU0hBTEwgSVNMQU5EUycsIGFiYnJldmlhdGlvbjogJ01IJ30sXG4gICAgeyBuYW1lOiAnTUFSWUxBTkQnLCBhYmJyZXZpYXRpb246ICdNRCd9LFxuICAgIHsgbmFtZTogJ01BU1NBQ0hVU0VUVFMnLCBhYmJyZXZpYXRpb246ICdNQSd9LFxuICAgIHsgbmFtZTogJ01JQ0hJR0FOJywgYWJicmV2aWF0aW9uOiAnTUknfSxcbiAgICB7IG5hbWU6ICdNSU5ORVNPVEEnLCBhYmJyZXZpYXRpb246ICdNTid9LFxuICAgIHsgbmFtZTogJ01JU1NJU1NJUFBJJywgYWJicmV2aWF0aW9uOiAnTVMnfSxcbiAgICB7IG5hbWU6ICdNSVNTT1VSSScsIGFiYnJldmlhdGlvbjogJ01PJ30sXG4gICAgeyBuYW1lOiAnTU9OVEFOQScsIGFiYnJldmlhdGlvbjogJ01UJ30sXG4gICAgeyBuYW1lOiAnTkVCUkFTS0EnLCBhYmJyZXZpYXRpb246ICdORSd9LFxuICAgIHsgbmFtZTogJ05FVkFEQScsIGFiYnJldmlhdGlvbjogJ05WJ30sXG4gICAgeyBuYW1lOiAnTkVXIEhBTVBTSElSRScsIGFiYnJldmlhdGlvbjogJ05IJ30sXG4gICAgeyBuYW1lOiAnTkVXIEpFUlNFWScsIGFiYnJldmlhdGlvbjogJ05KJ30sXG4gICAgeyBuYW1lOiAnTkVXIE1FWElDTycsIGFiYnJldmlhdGlvbjogJ05NJ30sXG4gICAgeyBuYW1lOiAnTkVXIFlPUksnLCBhYmJyZXZpYXRpb246ICdOWSd9LFxuICAgIHsgbmFtZTogJ05PUlRIIENBUk9MSU5BJywgYWJicmV2aWF0aW9uOiAnTkMnfSxcbiAgICB7IG5hbWU6ICdOT1JUSCBEQUtPVEEnLCBhYmJyZXZpYXRpb246ICdORCd9LFxuICAgIHsgbmFtZTogJ05PUlRIRVJOIE1BUklBTkEgSVNMQU5EUycsIGFiYnJldmlhdGlvbjogJ01QJ30sXG4gICAgeyBuYW1lOiAnT0hJTycsIGFiYnJldmlhdGlvbjogJ09IJ30sXG4gICAgeyBuYW1lOiAnT0tMQUhPTUEnLCBhYmJyZXZpYXRpb246ICdPSyd9LFxuICAgIHsgbmFtZTogJ09SRUdPTicsIGFiYnJldmlhdGlvbjogJ09SJ30sXG4gICAgeyBuYW1lOiAnUEFMQVUnLCBhYmJyZXZpYXRpb246ICdQVyd9LFxuICAgIHsgbmFtZTogJ1BFTk5TWUxWQU5JQScsIGFiYnJldmlhdGlvbjogJ1BBJ30sXG4gICAgeyBuYW1lOiAnUFVFUlRPIFJJQ08nLCBhYmJyZXZpYXRpb246ICdQUid9LFxuICAgIHsgbmFtZTogJ1JIT0RFIElTTEFORCcsIGFiYnJldmlhdGlvbjogJ1JJJ30sXG4gICAgeyBuYW1lOiAnU09VVEggQ0FST0xJTkEnLCBhYmJyZXZpYXRpb246ICdTQyd9LFxuICAgIHsgbmFtZTogJ1NPVVRIIERBS09UQScsIGFiYnJldmlhdGlvbjogJ1NEJ30sXG4gICAgeyBuYW1lOiAnVEVOTkVTU0VFJywgYWJicmV2aWF0aW9uOiAnVE4nfSxcbiAgICB7IG5hbWU6ICdURVhBUycsIGFiYnJldmlhdGlvbjogJ1RYJ30sXG4gICAgeyBuYW1lOiAnVVRBSCcsIGFiYnJldmlhdGlvbjogJ1VUJ30sXG4gICAgeyBuYW1lOiAnVkVSTU9OVCcsIGFiYnJldmlhdGlvbjogJ1ZUJ30sXG4gICAgeyBuYW1lOiAnVklSR0lOIElTTEFORFMnLCBhYmJyZXZpYXRpb246ICdWSSd9LFxuICAgIHsgbmFtZTogJ1ZJUkdJTklBJywgYWJicmV2aWF0aW9uOiAnVkEnfSxcbiAgICB7IG5hbWU6ICdXQVNISU5HVE9OJywgYWJicmV2aWF0aW9uOiAnV0EnfSxcbiAgICB7IG5hbWU6ICdXRVNUIFZJUkdJTklBJywgYWJicmV2aWF0aW9uOiAnV1YnfSxcbiAgICB7IG5hbWU6ICdXSVNDT05TSU4nLCBhYmJyZXZpYXRpb246ICdXSSd9LFxuICAgIHsgbmFtZTogJ1dZT01JTkcnLCBhYmJyZXZpYXRpb246ICdXWScgfVxuXTtcbnZhciBTVEFURVMgID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlNUQVRFU1wiLFxuICBnZXREZWZhdWx0UHJvcHM6ZnVuY3Rpb24oKXtcblxuICB9LFxuICBwcm9wVHlwZXM6e1xuICAgIHJlcXVpcmVkOlJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIG11bHRpcGxlOlJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHNlbGVjdGVkOlJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgdmFsdWU6UmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTpSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHN0YXRlcyA9IHVzU3RhdGVzLm1hcChmdW5jdGlvbihzdGF0ZSl7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCB7a2V5OiBzdGF0ZS5hYmJyZXZpYXRpb24sIHZhbHVlOiBzdGF0ZS5hYmJyZXZpYXRpb259LCBzdGF0ZS5uYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCBSZWFjdC5fX3NwcmVhZCh7fSwgIHRoaXMucHJvcHMpLCBcbiAgICAgICAgc3RhdGVzXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1RBVEVTOyIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgU1RZTEVfTE9BRElORyA9IHtcbiAgY29sb3I6ICdncmF5JyxcbiAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICBmb250U2l6ZTogJzEycHgnLFxuICBsZWZ0OiAwLFxuICBtYXJnaW5Ub3A6IC02LFxuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgcmlnaHQ6IDAsXG4gIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gIHRvcDogJzUwJScsXG59O1xuXG52YXIgU1RZTEVfQ0FQVElPTiA9IHtcbiAgYmFja2dyb3VuZDogJ3JnYmEoMTYsIDE2LCAxNiwgMC41KScsXG4gIGJvdHRvbTogMCxcbiAgY29sb3I6ICd3aGl0ZScsXG4gIGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcbiAgZm9udFNpemU6ICcxNnB4JyxcbiAgbGluZUhlaWdodDogJzQ4cHgnLFxuICBsZWZ0OiAwLFxuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgcmlnaHQ6IDAsXG4gIHRleHRBbGlnbjogJ2NlbnRlcidcbn07XG5cbnZhciBJbWFnZUNhcmQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiSW1hZ2VDYXJkXCIsXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGltZ1N0eWxlID0ge1xuICAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKCcgKyB0aGlzLnByb3BzLnVybCArICcpJyxcbiAgICAgIGJhY2tncm91bmRTaXplOiAnY29udGFpbicsXG4gICAgICBiYWNrZ3JvdW5kUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IHRoaXMucHJvcHMud2lkdGhcbiAgICB9O1xuXG4gICAgdmFyIG91dGVyU3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB3aWR0aDogdGhpcy5wcm9wcy53aWR0aFxuICAgIH07XG5cbiAgICAvLyBUaGUgbG9hZGluZyB0ZXh0IGlzIGNvbXBvc2l0ZWQgYmVoaW5kIHRoZSBpbWFnZSBzbyBpdCdzIGhpZGRlblxuICAgIC8vIHdoZW4gdGhlIGltYWdlIGlzIGxvYWRlZC4gTm9ybWFsbHkgeW91J2QgdXNlIEltYWdlLm9ubG9hZCwgYnV0XG4gICAgLy8gdGhhdCBvbmx5IHRlbGxzIHlvdSB3aGVuIHRoZSBieXRlcyBhcmUgcmVhZHksIG5vdCB3aGVuIHRoZSBwYWludFxuICAgIC8vIGlzIGRvbmUuXG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7c3R5bGU6IG91dGVyU3R5bGV9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7c3R5bGU6IFNUWUxFX0xPQURJTkd9LCBcIkxvYWRpbmcuLi5cIiksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtzdHlsZTogaW1nU3R5bGV9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7c3R5bGU6IFNUWUxFX0NBUFRJT059LCB0aGlzLnByb3BzLmNhcHRpb24pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUNhcmQ7IiwiXG4vKiogQGpzeCBSZWFjdC5ET00gKi9cblxudmFyIEFuaW1hdGFibGVDb250YWluZXIgPSByZXF1aXJlKCcuLi8uLi9wcmltaXRpdmVzL0FuaW1hdGFibGVDb250YWluZXIuanN4Jyk7XG52YXIgRWFzaW5nRnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vLi4vbGliL21hdGgvZWFzaW5nJyk7XG52YXIgSW1hZ2VDYXJkID0gcmVxdWlyZSgnLi9JbWFnZUNhcmQuanN4Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgSW1hZ2VDYXJkQ29udGFpbmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkltYWdlQ2FyZENvbnRhaW5lclwiLFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwY3QgPSAodGhpcy5wcm9wcy5sZWZ0IC0gKHRoaXMucHJvcHMuaW5kZXggKiB0aGlzLnByb3BzLndpZHRoKSkgLyB0aGlzLnByb3BzLndpZHRoO1xuICAgIHZhciB4ID0gdGhpcy5wcm9wcy5pbmRleCAqIHRoaXMucHJvcHMud2lkdGggLSB0aGlzLnByb3BzLmxlZnQ7XG4gICAgdmFyIHogPSBNYXRoLmFicyhwY3QgKiAyMDApICogLTE7XG4gICAgdmFyIHlBeGlzID0gdGhpcy5wcm9wcy5sZWZ0ID4gdGhpcy5wcm9wcy5pbmRleCAqIHRoaXMucHJvcHMud2lkdGggPyAxIDogLTE7XG4gICAgdmFyIGRlZyA9IE1hdGguYWJzKHBjdCAqIDY5KTtcblxuICAgIHZhciBjYXJkID0gUmVhY3QuY3JlYXRlRWxlbWVudChJbWFnZUNhcmQsIFJlYWN0Ll9fc3ByZWFkKHt9LCAgdGhpcy5wcm9wcykpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0YWJsZUNvbnRhaW5lciwge1xuICAgICAgICBjbGFzc05hbWU6IFwiSW1hZ2VDYXJkQ29udGFpbmVyXCIsIFxuICAgICAgICBvcGFjaXR5OiBFYXNpbmdGdW5jdGlvbnMuZWFzZU91dEN1YmljKDEgLSBNYXRoLmFicyhwY3QpKSwgXG4gICAgICAgIHJvdGF0ZToge3k6IHlBeGlzLCBkZWc6IGRlZ30sIFxuICAgICAgICB0cmFuc2xhdGU6IHt4OiB4LCB6OiB6fX0sIFxuICAgICAgICBjYXJkXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VDYXJkQ29udGFpbmVyOyIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG4vLyBJbXBsaWNpdCByZXF1aXJlIG9mIFNjcm9sbGVyIGZyb20gWnluZ2FcbnZhciBJbWFnZUNhcmRDb250YWluZXIgPSByZXF1aXJlKCcuL0ltYWdlQ2FyZENvbnRhaW5lci5qc3gnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBTY3JvbGxlciA9IHJlcXVpcmUoJ3Njcm9sbGVyJykuU2Nyb2xsZXI7XG5cbnZhciBUb3VjaGFibGVBcmVhID0gcmVxdWlyZSgnLi4vLi4vcHJpbWl0aXZlcy9Ub3VjaGFibGVBcmVhLmpzeCcpO1xuXG52YXIgUG9wQXJyb3cgPSByZXF1aXJlKCcuLi8uLi9lbGVtZW50cy9wb3BBcnJvdy9Qb3BBcnJvdy5qc3gnKTtcblxudmFyIFZpZXdlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJWaWV3ZXJcIixcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbGVyKHRoaXMuaGFuZGxlU2Nyb2xsLCB7XG4gICAgICBzbmFwcGluZzogdHJ1ZVxuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjcm9sbGVyLnNldERpbWVuc2lvbnMoXG4gICAgICB0aGlzLnByb3BzLndpZHRoLFxuICAgICAgdGhpcy5wcm9wcy5oZWlnaHQsXG4gICAgICB0aGlzLnByb3BzLndpZHRoICogdGhpcy5wcm9wcy5pbWFnZXMudXJscy5sZW5ndGgsXG4gICAgICB0aGlzLnByb3BzLmhlaWdodFxuICAgICk7XG4gICAgdGhpcy5zY3JvbGxlci5zZXRTbmFwU2l6ZSh0aGlzLnByb3BzLndpZHRoLCB0aGlzLnByb3BzLmhlaWdodCk7XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge2xlZnQ6IDB9O1xuICB9LFxuXG4gIC8vIGRpcmVjdGlvbi1pbnRlZ2VyXG4gIGhhbmRsZVRhcFJpZ2h0OmZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zY3JvbGxlci5zY3JvbGxCeSh0aGlzLnByb3BzLndpZHRoLDAsdHJ1ZSk7XG4gIH0sXG4gIGhhbmRsZVRhcExlZnQ6ZnVuY3Rpb24oKXtcbiAgICB0aGlzLnNjcm9sbGVyLnNjcm9sbEJ5KHRoaXMucHJvcHMud2lkdGgqLTEsMCx0cnVlKTtcbiAgfSxcblxuICBoYW5kbGVTY3JvbGw6IGZ1bmN0aW9uKGxlZnQsIHRvcCwgem9vbSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe2xlZnQ6IGxlZnR9KTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbWFnZXMgPSB0aGlzLnByb3BzLmltYWdlcy51cmxzLm1hcChmdW5jdGlvbih1cmwsIGkpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmxlZnQgPCAoaSAtIDEpICogdGhpcy5wcm9wcy53aWR0aCB8fCB0aGlzLnN0YXRlLmxlZnQgPiAoaSArIDEpICogdGhpcy5wcm9wcy53aWR0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCB0aGUgaGlnaGVzdCByZXNvbHV0aW9uIGltYWdlXG4gICAgICByZXR1cm4gKFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEltYWdlQ2FyZENvbnRhaW5lciwge1xuICAgICAgICAgIGxlZnQ6IHRoaXMuc3RhdGUubGVmdCwgXG4gICAgICAgICAga2V5OiBpLCBcbiAgICAgICAgICBpbmRleDogaSwgXG4gICAgICAgICAgdXJsOiB1cmwsIFxuICAgICAgICAgIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoLCBcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LCBcbiAgICAgICAgICBjYXB0aW9uOiAnTG9yZW1QaXhlbCBwaG90byAjJyArIChpICsgMSl9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChQb3BBcnJvdywge2NsYXNzTmFtZTogXCJuZXh0XCIsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlVGFwUmlnaHR9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUG9wQXJyb3csIHtjbGFzc05hbWU6IFwicHJldmlvdXNcIiwgb25DbGljazogdGhpcy5oYW5kbGVUYXBMZWZ0fSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRvdWNoYWJsZUFyZWEsIHtcbiAgICAgICAgICBjbGFzc05hbWU6IFwidmlld2VyXCIsIFxuICAgICAgICAgIHN0eWxlOiB7d2lkdGg6IHRoaXMucHJvcHMud2lkdGgsIGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHR9LCBcbiAgICAgICAgICBzY3JvbGxlcjogdGhpcy5zY3JvbGxlcn0sIFxuICAgICAgICAgIGltYWdlc1xuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld2VyOyIsIlxuLypqc2hpbnQgbm9kZTp0cnVlKi9cblxuJ3VzZSBzdHJpY3QnO1xudmFyIExlZnROYXZCZWhhdmlvcnMgPSB7XG4gIFBBUkFMTEFYX0ZBREU6IHtcbiAgICBzaWRlOiB7XG4gICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHNpZGVXaWR0aCwgc2Nyb2xsTGVmdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHNpZGVXaWR0aCAtIDAuNSAqIHNjcm9sbExlZnRcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICByb3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiBmdW5jdGlvbihzaWRlV2lkdGgsIHNjcm9sbExlZnQpIHtcbiAgICAgICAgcmV0dXJuIDAuNSArIDAuNSAqICgxIC0gc2Nyb2xsTGVmdCAvIHNpZGVXaWR0aCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b3A6IHtcbiAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oc2lkZVdpZHRoLCBzY3JvbGxMZWZ0KSB7XG4gICAgICAgIHJldHVybiB7eDogc2lkZVdpZHRoIC0gc2Nyb2xsTGVmdH07XG4gICAgICB9LFxuICAgICAgcm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgb3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29udGVudDoge1xuICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbihzaWRlV2lkdGgsIHNjcm9sbExlZnQpIHtcbiAgICAgICAgcmV0dXJuIHt4OiBzaWRlV2lkdGggLSBzY3JvbGxMZWZ0fTtcbiAgICAgIH0sXG4gICAgICByb3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlZnROYXZCZWhhdmlvcnM7IiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBBbmltYXRhYmxlQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vcHJpbWl0aXZlcy9BbmltYXRhYmxlQ29udGFpbmVyLmpzeCcpO1xudmFyIExlZnROYXZCZWhhdmlvcnMgPSByZXF1aXJlKCcuL0xlZnROYXZCZWhhdmlvcnMnKTtcbnZhciBUb3VjaGFibGVBcmVhID0gcmVxdWlyZSgnLi4vLi4vcHJpbWl0aXZlcy9Ub3VjaGFibGVBcmVhLmpzeCcpO1xudmFyIFNjcm9sbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vZW52aXJvbm1lbnQvU2Nyb2xsZXInKTtcbnZhciBTY3JvbGxlciA9IHJlcXVpcmUoJ3Njcm9sbGVyJykuU2Nyb2xsZXI7XG5cblxudmFyIExlZnROYXZDb250YWluZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTGVmdE5hdkNvbnRhaW5lclwiLFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXIodGhpcy5faGFuZGxlU2Nyb2xsLCB7XG4gICAgICBib3VuY2luZzogZmFsc2UsXG4gICAgICBzY3JvbGxpbmdYOiB0cnVlLFxuICAgICAgc2Nyb2xsaW5nWTogZmFsc2UsXG4gICAgICBzbmFwcGluZzogdHJ1ZVxuICAgIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9tZWFzdXJlKCk7XG4gIH0sXG5cbiAgX21lYXN1cmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgdGhpcy5zY3JvbGxlci5zZXREaW1lbnNpb25zKFxuICAgICAgbm9kZS5jbGllbnRXaWR0aCxcbiAgICAgIG5vZGUuY2xpZW50SGVpZ2h0LFxuICAgICAgbm9kZS5jbGllbnRXaWR0aCArIHRoaXMucHJvcHMuc2lkZVdpZHRoLFxuICAgICAgbm9kZS5jbGllbnRIZWlnaHRcbiAgICApO1xuICAgIHRoaXMuc2Nyb2xsZXIuc2V0U25hcFNpemUodGhpcy5wcm9wcy5zaWRlV2lkdGgsIG5vZGUuY2xpZW50SGVpZ2h0KTtcbiAgICB0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKHRoaXMucHJvcHMuc2lkZVdpZHRoLCAwKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLnNpZGVXaWR0aCAhPT0gcHJldlByb3BzLnNpZGVXaWR0aCkge1xuICAgICAgdGhpcy5fbWVhc3VyZSgpO1xuICAgIH1cbiAgfSxcblxuICBjbG9zZU5hdjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNOYXZPcGVuKCkpIHtcbiAgICAgIHRoaXMuc2Nyb2xsZXIuc2Nyb2xsVG8odGhpcy5wcm9wcy5zaWRlV2lkdGgsIDAsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlU2Nyb2xsOiBmdW5jdGlvbihsZWZ0LCB0b3AsIHpvb20pIHtcbiAgICB0aGlzLnNldFN0YXRlKHtzY3JvbGxMZWZ0OiBsZWZ0fSk7XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge3Njcm9sbExlZnQ6IDB9O1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJlaGF2aW9yOiBMZWZ0TmF2QmVoYXZpb3JzLlBBUkFMTEFYX0ZBREVcbiAgICB9O1xuICB9LFxuXG4gIF9oYW5kbGVUYXA6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdoYW5sZGUgdGFwJyk7XG4gICAgaWYgKHRoaXMuaXNOYXZPcGVuKCkpIHtcbiAgICAgIHRoaXMuc2Nyb2xsZXIuc2Nyb2xsVG8odGhpcy5wcm9wcy5zaWRlV2lkdGgsIDAsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjcm9sbGVyLnNjcm9sbFRvKDAsIDAsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ29udGVudFRvdWNoVGFwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzTmF2T3BlbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxlci5zY3JvbGxUbyh0aGlzLnByb3BzLnNpZGVXaWR0aCwgMCwgdHJ1ZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LFxuXG4gIGlzTmF2T3BlbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuc2Nyb2xsTGVmdCAhPT0gdGhpcy5wcm9wcy5zaWRlV2lkdGg7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBwcm9wczpcbiAgICAvLyBzaWRlV2lkdGhcbiAgICAvLyB0b3BIZWlnaHRcbiAgICAvLyB0b3BDb250ZW50XG4gICAgLy8gYnV0dG9uXG4gICAgLy8gc2lkZUNvbnRlbnRcbiAgICAvLyBjaGlsZHJlbiAoYmlnIGNvbnRlbnQgYXJlYSlcbiAgICB2YXIgc2lkZWJhclggPSAodGhpcy5wcm9wcy5zaWRlV2lkdGggLSB0aGlzLnN0YXRlLnNjcm9sbExlZnQpO1xuXG4gICAgdmFyIHNpZGUgPSBudWxsO1xuXG4gICAgLy8gVE9ETzogd2UgY291bGQgZG8gdGhpcyB3aXRoIHN0eWxlIGNhbGNcbiAgICB2YXIgc2lkZVN0eWxlID0ge1xuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogdGhpcy5wcm9wcy5zaWRlV2lkdGggKiAtMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IHRoaXMucHJvcHMuc2lkZVdpZHRoXG4gICAgfTtcblxuICAgIHZhciBiZWhhdmlvciA9IHRoaXMucHJvcHMuYmVoYXZpb3I7XG5cbiAgICBpZiAodGhpcy5pc05hdk9wZW4oKSkge1xuICAgICAgc2lkZSA9IChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBbmltYXRhYmxlQ29udGFpbmVyLCB7XG4gICAgICAgICAgc3R5bGU6IHNpZGVTdHlsZSwgXG4gICAgICAgICAgdHJhbnNsYXRlOiBiZWhhdmlvci5zaWRlLnRyYW5zbGF0ZSh0aGlzLnByb3BzLnNpZGVXaWR0aCwgdGhpcy5zdGF0ZS5zY3JvbGxMZWZ0KSwgXG4gICAgICAgICAgcm90YXRlOiBiZWhhdmlvci5zaWRlLnJvdGF0ZSh0aGlzLnByb3BzLnNpZGVXaWR0aCwgdGhpcy5zdGF0ZS5zY3JvbGxMZWZ0KSwgXG4gICAgICAgICAgb3BhY2l0eTogYmVoYXZpb3Iuc2lkZS5vcGFjaXR5KHRoaXMucHJvcHMuc2lkZVdpZHRoLCB0aGlzLnN0YXRlLnNjcm9sbExlZnQpfSwgXG4gICAgICAgICAgdGhpcy5wcm9wcy5zaWRlQ29udGVudFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50VG91Y2hhYmxlQXJlYVN0eWxlID0ge1xuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuXG4gICAgdmFyIHRvcFN0eWxlID0ge1xuICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLnRvcEhlaWdodCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcblxuICAgIHZhciBjb250ZW50U3R5bGUgPSB7XG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogdGhpcy5wcm9wcy50b3BIZWlnaHRcbiAgICB9O1xuXG4gICAgcmV0dXJuKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBSZWFjdC5fX3NwcmVhZCh7fSwgIHRoaXMucHJvcHMpLCBcbiAgICAgICAgc2lkZSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0YWJsZUNvbnRhaW5lciwge1xuICAgICAgICAgIHN0eWxlOiBjb250ZW50U3R5bGUsIFxuICAgICAgICAgIHRyYW5zbGF0ZTogYmVoYXZpb3IuY29udGVudC50cmFuc2xhdGUodGhpcy5wcm9wcy5zaWRlV2lkdGgsIHRoaXMuc3RhdGUuc2Nyb2xsTGVmdCksIFxuICAgICAgICAgIHJvdGF0ZTogYmVoYXZpb3IuY29udGVudC5yb3RhdGUodGhpcy5wcm9wcy5zaWRlV2lkdGgsIHRoaXMuc3RhdGUuc2Nyb2xsTGVmdCksIFxuICAgICAgICAgIG9wYWNpdHk6IGJlaGF2aW9yLmNvbnRlbnQub3BhY2l0eSh0aGlzLnByb3BzLnNpZGVXaWR0aCwgdGhpcy5zdGF0ZS5zY3JvbGxMZWZ0KX0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG91Y2hhYmxlQXJlYSwge1xuICAgICAgICAgICAgc3R5bGU6IGNvbnRlbnRUb3VjaGFibGVBcmVhU3R5bGUsIFxuICAgICAgICAgICAgc2Nyb2xsZXI6IHRoaXMuc2Nyb2xsZXIsIFxuICAgICAgICAgICAgdG91Y2hhYmxlOiB0aGlzLmlzTmF2T3BlbigpLCBcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX2hhbmRsZUNvbnRlbnRUb3VjaFRhcFxuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChBbmltYXRhYmxlQ29udGFpbmVyLCB7XG4gICAgICAgICAgc3R5bGU6IHRvcFN0eWxlLCBcbiAgICAgICAgICB0cmFuc2xhdGU6IGJlaGF2aW9yLnRvcC50cmFuc2xhdGUodGhpcy5wcm9wcy5zaWRlV2lkdGgsIHRoaXMuc3RhdGUuc2Nyb2xsTGVmdCksIFxuICAgICAgICAgIHJvdGF0ZTogYmVoYXZpb3IudG9wLnJvdGF0ZSh0aGlzLnByb3BzLnNpZGVXaWR0aCwgdGhpcy5zdGF0ZS5zY3JvbGxMZWZ0KSwgXG4gICAgICAgICAgb3BhY2l0eTogYmVoYXZpb3IudG9wLm9wYWNpdHkodGhpcy5wcm9wcy5zaWRlV2lkdGgsIHRoaXMuc3RhdGUuc2Nyb2xsTGVmdCl9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRvdWNoYWJsZUFyZWEsIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX2hhbmRsZVRhcCwgXG4gICAgICAgICAgICBzY3JvbGxlcjogdGhpcy5zY3JvbGxlciwgXG4gICAgICAgICAgICB0b3VjaGFibGU6IHRydWVcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5idXR0b25cbiAgICAgICAgICApLCBcbiAgICAgICAgICB0aGlzLnByb3BzLnRvcENvbnRlbnRcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlZnROYXZDb250YWluZXI7IiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBBbmltYXRhYmxlQ29udGFpbmVyID0gcmVxdWlyZSgnLi4vLi4vcHJpbWl0aXZlcy9BbmltYXRhYmxlQ29udGFpbmVyLmpzeCcpO1xudmFyIFRvdWNoYWJsZUFyZWEgPSByZXF1aXJlKCcuLi8uLi9wcmltaXRpdmVzL1RvdWNoYWJsZUFyZWEuanN4Jyk7XG52YXIgU2Nyb2xsZXIgPSByZXF1aXJlKCdzY3JvbGxlcicpLlNjcm9sbGVyO1xuXG52YXIgQU5JTUFUQUJMRV9DT05UQUlORVJfU1RZTEUgPSB7XG4gIGJvdHRvbTogMCxcbiAgbGVmdDogMCxcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHJpZ2h0OiAwLFxuICB0b3A6IDBcbn07XG5cbnZhciBTaW1wbGVTY3JvbGxlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJTaW1wbGVTY3JvbGxlclwiLFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7bGVmdDogMCwgdG9wOiAwfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXIodGhpcy5oYW5kbGVTY3JvbGwsIHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgdGhpcy5jb25maWd1cmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICB9LFxuXG4gIGNvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29uZmlndXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgIHZhciBub2RlID0gdGhpcy5yZWZzLmNvbnRlbnQuZ2V0RE9NTm9kZSgpO1xuICAgIHRoaXMuc2Nyb2xsZXIuc2V0RGltZW5zaW9ucyhcbiAgICAgIHRoaXMuZ2V0RE9NTm9kZSgpLmNsaWVudFdpZHRoLFxuICAgICAgdGhpcy5nZXRET01Ob2RlKCkuY2xpZW50SGVpZ2h0LFxuICAgICAgbm9kZS5jbGllbnRXaWR0aCxcbiAgICAgIG5vZGUuY2xpZW50SGVpZ2h0XG4gICAgKTtcbiAgfSxcblxuICBoYW5kbGVTY3JvbGw6IGZ1bmN0aW9uKGxlZnQsIHRvcCkge1xuICAgIC8vIFRPRE86IHpvb21cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcFxuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUb3VjaGFibGVBcmVhLCBSZWFjdC5fX3NwcmVhZCh7fSwgIHRoaXMucHJvcHMsIHtzY3JvbGxlcjogdGhpcy5zY3JvbGxlciwgc3R5bGU6IHtvdmVyZmxvdzogJ2hpZGRlbid9fSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEFuaW1hdGFibGVDb250YWluZXIsIHtcbiAgICAgICAgICB0cmFuc2xhdGU6IHt4OiAtMSAqIHRoaXMuc3RhdGUubGVmdCwgeTogLTEgKiB0aGlzLnN0YXRlLnRvcH0sIFxuICAgICAgICAgIHN0eWxlOiBBTklNQVRBQkxFX0NPTlRBSU5FUl9TVFlMRX0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge3JlZjogXCJjb250ZW50XCJ9LCB0aGlzLnByb3BzLmNoaWxkcmVuKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlU2Nyb2xsZXI7IiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIHZhciBBcHAgPSByZXF1aXJlKCdyZWFjdC10b3VjaC9saWIvcHJpbWl0aXZlcy9BcHAnKTtcbi8vIHZhciBSb3V0ZWRMaW5rID0gcmVxdWlyZSgncmVhY3QtdG91Y2gvbGliL3JvdXRpbmcvUm91dGVkTGluaycpO1xuLy8gdmFyIEhlYWRlciA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvSGVhZGVyJyk7XG52YXIgTGVmdE5hdkNvbnRhaW5lciA9IHJlcXVpcmUoJy4uL2ludGVyYWN0aXZlcy9sZWZ0TmF2L0xlZnROYXZDb250YWluZXIuanN4Jyk7XG5cblxuLy8gS2VlcCBpbiBzeW5jIHdpdGggTGF5b3V0LmNzc1xuLy8gVE9ETzogZGVwcmVjYXRlIHRoZSBDU1Mgc3RhbmRhcmRcbnZhciBTSURFQkFSX1dJRFRIID0gMTkyO1xudmFyIFRPUEJBUl9IRUlHSFQgPSA1MTsgLy8gKyAxIGZvciB0aGUgYm9yZGVyXG5cbnZhciBMYXlvdXQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTGF5b3V0XCIsXG4gIGhhbmRsZU5hdkNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlZnMuTGVmdE5hdkNvbnRhaW5lci5jbG9zZU5hdigpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIFNUWUxFID0ge1xuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIHZhciBidXR0b24gPSAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwiTGF5b3V0LWhhbWJ1cmdlciBmYSBmYS1iYXJzXCJ9KVxuICAgICk7XG5cbiAgICB2YXIgdG9wQ29udGVudCA9IChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7Y2xhc3NOYW1lOiBcIkxheW91dC10b3BCYXJcIn0sIFwiUmVhY3QgdG91Y2ggZGVtb3NcIilcbiAgICApO1xuXG4gICAgdmFyIHNpZGVDb250ZW50ID0gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIkxheW91dC1uYXZcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7Y2xhc3NOYW1lOiBcIkxheW91dC1uYXZMaW5rXCJ9LCBcImFzZGxma2pcIiksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7Y2xhc3NOYW1lOiBcIkxheW91dC1uYXZMaW5rXCJ9LCBcImFzZGxma2pcIiksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7Y2xhc3NOYW1lOiBcIkxheW91dC1uYXZMaW5rXCJ9LCBcImFzZGxma2pcIiksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7Y2xhc3NOYW1lOiBcIkxheW91dC1uYXZMaW5rXCJ9LCBcImFzZGxma2pcIiksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7Y2xhc3NOYW1lOiBcIkxheW91dC1uYXZMaW5rXCJ9LCBcImFzZGxma2pcIilcbiAgICAgIClcbiAgICApO1xuICAgICAgICAvLyA8Um91dGVkTGluayBocmVmPVwiL2hvbWVcIiBjbGFzc05hbWU9XCJMYXlvdXQtbmF2TGlua1wiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlTmF2Q2xpY2t9PkhvbWU8L1JvdXRlZExpbms+XG4gICAgICAgIC8vIDxSb3V0ZWRMaW5rIGhyZWY9XCIvc2Nyb2xsXCIgY2xhc3NOYW1lPVwiTGF5b3V0LW5hdkxpbmtcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZU5hdkNsaWNrfT5TaW1wbGUgc2Nyb2xsPC9Sb3V0ZWRMaW5rPlxuICAgICAgICAvLyA8Um91dGVkTGluayBocmVmPVwiL2dsYXNzXCIgY2xhc3NOYW1lPVwiTGF5b3V0LW5hdkxpbmtcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZU5hdkNsaWNrfT5Gcm9zdGVkIGdsYXNzPC9Sb3V0ZWRMaW5rPlxuICAgICAgICAvLyA8Um91dGVkTGluayBocmVmPVwiL3ZpZXdlclwiIGNsYXNzTmFtZT1cIkxheW91dC1sYXN0TmF2TGlua1wiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlTmF2Q2xpY2t9PlBob3RvIGdhbGxlcnk8L1JvdXRlZExpbms+XG5cbiAgICByZXR1cm4oXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtzdHlsZTogU1RZTEV9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChMZWZ0TmF2Q29udGFpbmVyLCB7XG4gICAgICAgICAgcmVmOiBcImxlZnROYXZDb250YWluZXJcIiwgXG4gICAgICAgICAgYnV0dG9uOiBidXR0b24sIFxuICAgICAgICAgIHRvcENvbnRlbnQ6IHRvcENvbnRlbnQsIFxuICAgICAgICAgIHNpZGVDb250ZW50OiBzaWRlQ29udGVudCwgXG4gICAgICAgICAgdG9wSGVpZ2h0OiBUT1BCQVJfSEVJR0hULCBcbiAgICAgICAgICBzaWRlV2lkdGg6IFNJREVCQVJfV0lEVEh9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwiTGF5b3V0LWNvbnRlbnRcIn0sIFxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5MYXlvdXQuVE9QQkFSX0hFSUdIVCA9IFRPUEJBUl9IRUlHSFQ7IC8vIGFjY291bnQgZm9yIGJvcmRlclxuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDsiLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbi8qIGpzaGludCBub2RlOnRydWUqL1xuXG4ndXNlIHN0cmljdCc7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIE5hdkxpbmsgPSByZXF1aXJlKCdmbHV4LXJvdXRlci1jb21wb25lbnQnKS5OYXZMaW5rO1xuXG52YXIgU2Vzc2lvblN0b3JlPXJlcXVpcmUoJy4uLy4uLy4uL3N0b3Jlcy9TZXNzaW9uU3RvcmUnKTtcbnZhciBBcHBsaWNhdGlvblN0b3JlPXJlcXVpcmUoJy4uLy4uLy4uL3N0b3Jlcy9BcHBsaWNhdGlvblN0b3JlJyk7XG5cbnZhciBtdWkgPSByZXF1aXJlKCdtYXRlcmlhbC11aScpO1xudmFyIFRvb2xiYXIgPSBtdWkuVG9vbGJhcjtcbnZhciBUb29sYmFyR3JvdXAgPSBtdWkuVG9vbGJhckdyb3VwO1xudmFyIEFwcEJhcj1tdWkuQXBwQmFyO1xudmFyIERyb3BEb3duSWNvbiA9IG11aS5Ecm9wRG93bkljb247XG5cbi8vIHZhciBCb290c3RyYXA9cmVxdWlyZSgncmVhY3QtYm9vdHN0cmFwJyk7XG5cbnZhciBGbHV4aWJsZU1peGluID0gcmVxdWlyZSgnZmx1eGlibGUnKS5NaXhpbjtcbi8vIHZhciBOYXY9Qm9vdHN0cmFwLk5hdjtcbi8vIHZhciBOYXZiYXIgPSBCb290c3RyYXAuTmF2YmFyO1xuLy8gdmFyIE5hdkl0ZW0gPSBCb290c3RyYXAuTmF2SXRlbTtcbi8vIHZhciBEcm9wZG93bkJ1dHRvbiA9IEJvb3RzdHJhcC5Ecm9wZG93bkJ1dHRvbjtcbi8vIHZhciBNZW51SXRlbSA9IEJvb3RzdHJhcC5NZW51SXRlbTtcblxudmFyIE5hdkxpbmsgPSByZXF1aXJlKCdmbHV4LXJvdXRlci1jb21wb25lbnQnKS5OYXZMaW5rO1xuXG52YXIgTmF2SW5zdGFuY2UgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTmF2SW5zdGFuY2VcIixcblxuICBtaXhpbnM6IFtGbHV4aWJsZU1peGluXSxcbiAgc3RhdGljczoge1xuICAgIHN0b3JlTGlzdGVuZXJzOiBbU2Vzc2lvblN0b3JlLEFwcGxpY2F0aW9uU3RvcmVdXG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlRnJvbVN0b3JlcygpO1xuICB9LFxuXG4gIGdldFN0YXRlRnJvbVN0b3JlczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50VXNlcjogdGhpcy5nZXRTdG9yZShTZXNzaW9uU3RvcmUpLmdldEN1cnJlbnRVc2VyKCksXG4gICAgICB0aXRsZTp0aGlzLmdldFN0b3JlKEFwcGxpY2F0aW9uU3RvcmUpLmdldFBhZ2VUaXRsZSgpXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yICdjaGFuZ2UnIGV2ZW50cyBjb21pbmcgZnJvbSB0aGUgc3RvcmVzXG4gICAqL1xuICBvbkNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlRnJvbVN0b3JlcygpKTtcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWQ6ICdob21lJyxcbiAgICAgIGxpbmtzOiB7fVxuICAgIH07XG4gIH0sXG4gIGlzQWN0aXZlOmZ1bmN0aW9uKG5hbWUpe1xuICAgIGlmKG5hbWU9PT10aGlzLnByb3BzLnNlbGVjdGVkKXtcbiAgICAgIHJldHVybiAnYWN0aXZlJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gdGhpcy5wcm9wcy5zZWxlY3RlZCxcbiAgICAgIGxpbmtzID0gdGhpcy5wcm9wcy5saW5rcyxcbiAgICAgIGNvbnRleHQgPSB0aGlzLnByb3BzLmNvbnRleDtcblxuICAgIHZhciBpY29uTWVudUl0ZW1zID0gW1xuICAgICAgeyBwYXlsb2FkOiAnMScsIHRleHQ6ICdEb3dubG9hZCcgfSxcbiAgICAgIHsgcGF5bG9hZDogJzInLCB0ZXh0OiAnTW9yZSBJbmZvJyB9XG4gICAgXTtcbiAgICB2YXIgTmF2YmFySGVhZGVyU3R5bGU9e1xuICAgICAgZmxvYXQ6J3JpZ2h0J1xuICAgIH07XG5cbiAgICB2YXIgbmF2YmFyUmlnaHQ9bnVsbDtcbiAgICBpZih0eXBlb2YgdGhpcy5zdGF0ZS5jdXJyZW50VXNlci5faWQgPT09J3VuZGVmaW5lZCcpe1xuICAgICAgbmF2YmFyUmlnaHQ9KFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwge2NsYXNzTmFtZTogXCJuYXYgbmF2YmFyLW5hdiBuYXZiYXItcmlnaHRcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7Y2xhc3NOYW1lOiB0aGlzLmlzQWN0aXZlKGxpbmtzLmxvZ2luLnBhZ2UpfSwgUmVhY3QuY3JlYXRlRWxlbWVudChOYXZMaW5rLCB7cm91dGVOYW1lOiBsaW5rcy5sb2dpbi5wYWdlLCBsYWJlbDogXCJsb2dpblwifSwgXCJMb2dpblwiKSksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7Y2xhc3NOYW1lOiB0aGlzLmlzQWN0aXZlKGxpbmtzLnNpZ251cC5wYWdlKX0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2TGluaywge3JvdXRlTmFtZTogbGlua3Muc2lnbnVwLnBhZ2UsIGxhYmVsOiBcImxvZ2luXCJ9LCBcIlNpZ251cFwiKSlcbiAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1lbHNle1xuICAgICAgbmF2YmFyUmlnaHQ9KFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwge2NsYXNzTmFtZTogXCJuYXYgbmF2YmFyLW5hdiBuYXZiYXItcmlnaHRcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcIm5hdmJhci10ZXh0XCJ9LCBcIldlbGNvbWUgXCIsIHRoaXMuc3RhdGUuY3VycmVudFVzZXIubmFtZSkpLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChOYXZMaW5rLCB7cm91dGVOYW1lOiBsaW5rcy5sb2dpbi5wYWdlLCBsYWJlbDogXCJsb2dvdXRcIn0sIFwiTG9nb3V0XCIpKVxuICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIE5hdmJhckhlYWRlcj0oXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwibmF2YmFyLWhlYWRlclwiLCBzdHlsZTogTmF2YmFySGVhZGVyU3R5bGV9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChOYXZMaW5rLCB7cm91dGVOYW1lOiBsaW5rcy5ob21lLnBhZ2UsIGNsYXNzTmFtZTogXCJuYXZiYXItYnJhbmQgbmF2YmFyLWJyYW5kLWxlZnRcIn0sIFxuICAgICAgICAgIFwiTXlEcml2ZTVcIlxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4oXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibmF2XCIsIHtjbGFzc05hbWU6IFwibmF2YmFyIG5hdmJhci1pbnZlcnNlIG5hdmJhci1zdGF0aWMtdG9wXCJ9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcImNvbnRhaW5lclwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIm5hdmJhci1oZWFkZXJcIn0sIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7dHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcIm5hdmJhci10b2dnbGUgY29sbGFwc2VkXCIsIFwiZGF0YS10b2dnbGVcIjogXCJjb2xsYXBzZVwiLCBcImRhdGEtdGFyZ2V0XCI6IFwiI25hdmJhclwiLCBcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiLCBcImFyaWEtY29udHJvbHNcIjogXCJuYXZiYXJcIn0sIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInNyLW9ubHlcIn0sIFwiVG9nZ2xlIG5hdmlnYXRpb25cIiksIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcImljb24tYmFyXCJ9KSwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwiaWNvbi1iYXJcIn0pLCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJpY29uLWJhclwifSlcbiAgICAgICAgICAgICksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChOYXZMaW5rLCB7Y2xhc3NOYW1lOiBcIm5hdmJhci1icmFuZFwiLCByb3V0ZU5hbWU6IGxpbmtzLmFkbWluLmhvbWUsIGhyZWY6IFwiL1wifSwgXCJNeURyaXZlNVwiKVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJuYXZiYXItdGl0bGVcIn0sIFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS50aXRsZVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2lkOiBcIm5hdmJhclwiLCBjbGFzc05hbWU6IFwibmF2YmFyLWNvbGxhcHNlIGNvbGxhcHNlXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7Y2xhc3NOYW1lOiBcIm5hdiBuYXZiYXItbmF2XCJ9LCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHtjbGFzc05hbWU6IHRoaXMuaXNBY3RpdmUobGlua3MuYWRtaW4ucGFnZSl9LCBSZWFjdC5jcmVhdGVFbGVtZW50KE5hdkxpbmssIHtyb3V0ZU5hbWU6IGxpbmtzLmFkbWluLnBhZ2V9LCBcIkFkbWluXCIpKVxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBuYXZiYXJSaWdodFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICApO1xuICAgIC8vIHJldHVybiAoXG4gICAgLy8gIDxOYXZiYXIgY2xhc3NOYW1lPVwibmF2YmFyLWludmVyc2UgbmF2YmFyLXN0YXRpYy10b3BcIj5cbiAgICAvLyAgICAge05hdmJhckhlYWRlcn1cbiAgICAvLyAgICAgPE5hdiBjbGFzc05hbWU9XCJuYXZiYXItcmlnaHRcIj5cbiAgICAvLyAgICAgICA8RHJvcGRvd25CdXR0b24gZXZlbnRLZXk9ezN9IHRpdGxlPXt1c2VySWNvbn0+XG4gICAgLy8gICAgICAgICA8TWVudUl0ZW0gZXZlbnRLZXk9XCIxXCI+QWN0aW9uPC9NZW51SXRlbT5cbiAgICAvLyAgICAgICAgIDxNZW51SXRlbSBldmVudEtleT1cIjJcIj5Bbm90aGVyIGFjdGlvbjwvTWVudUl0ZW0+XG4gICAgLy8gICAgICAgICA8TWVudUl0ZW0gZXZlbnRLZXk9XCIzXCI+U29tZXRoaW5nIGVsc2UgaGVyZTwvTWVudUl0ZW0+XG4gICAgLy8gICAgICAgICA8TWVudUl0ZW0gZGl2aWRlciAvPlxuICAgIC8vICAgICAgICAgPE1lbnVJdGVtIGV2ZW50S2V5PVwiNFwiPlNlcGFyYXRlZCBsaW5rPC9NZW51SXRlbT5cbiAgICAvLyAgICAgICA8L0Ryb3Bkb3duQnV0dG9uPlxuICAgIC8vICAgICAgIDxOYXZJdGVtIGV2ZW50S2V5PXsxfSBocmVmPXtsaW5rcy5sb2dpbi5wYXRofT5cbiAgICAvLyAgICAgICAgIExvZ2luXG4gICAgLy8gICAgICAgPC9OYXZJdGVtPlxuICAgIC8vICAgICAgIDxOYXZJdGVtIGV2ZW50S2V5PXsyfSBocmVmPVwiI1wiPlJlZ2lzdGVyPC9OYXZJdGVtPlxuICAgIC8vICAgICA8L05hdj5cbiAgICAvLyAgIDwvTmF2YmFyPlxuICAgIC8vICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdkluc3RhbmNlOyIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgSW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vLi4vYXNzZXRzL0ltYWdlcycpO1xudmFyIE5BVkJBUl9IRUlHSFQgPSByZXF1aXJlKCcuLi8uLi9jb25zdGFudHMvQXBwQ29uc3RhbnRzJykuTkFWQkFSX0hFSUdIVDtcbnZhciBWaWV3ZXIgPSByZXF1aXJlKCcuLi9pbnRlcmFjdGl2ZXMvaW1hZ2VDYXJkL1ZpZXdlci5qc3gnKTtcblxudmFyIE5VTV9JTUFHRVMgPSAxMDtcblxudmFyIFNUQVJUX0lOREVYID0gNTtcblxudmFyIEdhbGxlcnlQYWdlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkdhbGxlcnlQYWdlXCIsXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcbiAgfSxcblxuICBnZXRVc2VybmFtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMucm91dGVQYXJhbXNbMF0gfHwgJ0p1c3RpbkJpZWJlcic7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuc2V0RGltZW5zaW9ucyk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gIH0sXG5cbiAgc2V0RGltZW5zaW9uczpmdW5jdGlvbigpe1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgd2lkdGg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLndpZHRoIHx8ICF0aGlzLnN0YXRlLmhlaWdodCkge1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiTG9hZGluZy4uLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChWaWV3ZXIsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuc3RhdGUud2lkdGgsIFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0IC0gTkFWQkFSX0hFSUdIVCwgXG4gICAgICAgIGltYWdlczogSW1hZ2VzfVxuICAgICAgKVxuICAgICk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbGxlcnlQYWdlOyIsIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgSG9tZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJIb21lXCIsXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIldlbGNvbWUgdG8gdGhlIHNpdGUhXCIpXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSG9tZTsiLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbi8qIGpzaGludCBub2RlOnRydWUqL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gdmFyIEFwcFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL0FwcFN0b3JlJyk7XG52YXIgTG9naW5BY3Rpb24gPSByZXF1aXJlKCcuLi8uLi9hY3Rpb25zL2F1dGhlbnRpY2F0aW9uL0xvZ2luQWN0aW9ucycpO1xuXG52YXIgRmx1eGlibGVNaXhpbiA9IHJlcXVpcmUoJ2ZsdXhpYmxlJykuTWl4aW47XG5cbi8vIHZhciBOQVYgPSByZXF1aXJlKCcuL05hdkJhci5qc3gnKTtcbi8vIHZhciBCQU5ORVIgPSByZXF1aXJlKCcuL0Jhbm5lci5qc3gnKTtcblxudmFyIG11aT1yZXF1aXJlKCdtYXRlcmlhbC11aScpO1xudmFyIFJhaXNlZEJ1dHRvbj1tdWkuUmFpc2VkQnV0dG9uO1xudmFyIFRleHRGaWVsZD1tdWkuVGV4dEZpZWxkO1xuXG52YXIgVG9vbHRpcEhvdmVyID0gcmVxdWlyZSgnLi4vZWxlbWVudHMvdG9vbFRpcEhvdmVyLmpzeCcpO1xuXG5cbnZhciBMT0dJTiAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTE9HSU5cIixcbiAgbWl4aW5zOltGbHV4aWJsZU1peGluXSxcblxuICBnZXRJbml0aWFsU3RhdGU6ZnVuY3Rpb24oKXtcbiAgICByZXR1cm4ge2VtYWlsOicnLHBhc3N3b3JkOicnfTtcbiAgfSxcblxuICBoYW5kbGVTdWJtaXQ6IGZ1bmN0aW9uKGUpe1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmV4ZWN1dGVBY3Rpb24oTG9naW5BY3Rpb24sdGhpcy5zdGF0ZSk7XG4gIH0sXG5cbiAgaGFuZGxlSW5wdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zb2xlLmxvZyhcImF0IGhhbmRsZUlucHV0IGluIExvZ2luXCIpO1xuICB9LFxuXG4gIF9vblBhc3N3b3JkQ2hhbmdlOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICB0aGlzLnNldFN0YXRlKHtwYXNzd29yZDpldmVudC50YXJnZXQudmFsdWV9KTtcbiAgfSxcblxuICBfb25FbWFpbENoYW5nZTpmdW5jdGlvbihldmVudCl7XG4gICAgdGhpcy5zZXRTdGF0ZSh7ZW1haWw6ZXZlbnQudGFyZ2V0LnZhbHVlfSk7XG4gIH0sXG4gIFxuICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJsb2dpbi1wYWdlXCJ9LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgbnVsbCwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIGZsb2F0aW5nTGFiZWxUZXh0OiBcImVtYWlsXCIsIFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuZW1haWwsIFxuICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuX29uRW1haWxDaGFuZ2UsIFxuICAgICAgICAgICAgaGludFRleHQ6IFwiZW1haWxcIn0pLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZmxvYXRpbmdMYWJlbFRleHQ6IFwicGFzc3dvcmRcIiwgXG4gICAgICAgICAgICBoaW50VGV4dDogXCJwYXNzd29yZFwiLCBcbiAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLl9vblBhc3N3b3JkQ2hhbmdlLCBcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnBhc3N3b3JkLCBcbiAgICAgICAgICAgIHR5cGU6IFwicGFzc3dvcmRcIn0pLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJhaXNlZEJ1dHRvbiwge3NlY29uZGFyeTogdHJ1ZSwgbGFiZWw6IFwibG9naW5cIiwgb25DbGljazogdGhpcy5oYW5kbGVTdWJtaXR9KVxuICAgICAgICApXG4gICAgICApXG4gICAgICAvLyA8ZGl2PlxuICAgICAgLy8gICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgLy8gICAgIDxoMT5Mb2dpbjwvaDE+XG4gICAgICAvLyAgICAgICA8Zm9ybSBjbGFzc05hbWU9XCJmb3JtLWhvcml6b250YWxcIiByb2xlPVwiZm9ybVwiPlxuICAgICAgLy8gICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvcm0tZ3JvdXBcIj5cbiAgICAgIC8vICAgICAgICAgICA8bGFiZWwgZm9yPVwiaW5wdXRFbWFpbDNcIiBjbGFzc05hbWU9XCJjb250cm9sLWxhYmVsXCIgPkVtYWlsPC9sYWJlbD5cbiAgICAgIC8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgLy8gICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJlbWFpbFwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIGlkPVwiaW5wdXRFbWFpbDNcIiBwbGFjZWhvbGRlcj1cIkVtYWlsXCIgb25LZXlQcmVzcz17dGhpcy5oYW5kbGVJbnB1dH0vPlxuICAgICAgLy8gICAgICAgICAgIDwvZGl2PlxuICAgICAgLy8gICAgICAgICA8L2Rpdj5cbiAgICAgIC8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCI+XG4gICAgICAvLyAgICAgICAgICAgPGxhYmVsIGZvcj1cImlucHV0UGFzc3dvcmQzXCIgY2xhc3NOYW1lPVwiY29udHJvbC1sYWJlbFwiPlBhc3N3b3JkPC9sYWJlbD5cbiAgICAgIC8vICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgLy8gICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGNsYXNzTmFtZT1cImZvcm0tY29udHJvbFwiIGlkPVwiaW5wdXRQYXNzd29yZDNcIiBwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCIgb25LZXlQcmVzcz17dGhpcy5oYW5kbGVJbnB1dH0vPlxuICAgICAgLy8gICAgICAgICAgIDwvZGl2PlxuICAgICAgLy8gICAgICAgICA8L2Rpdj5cbiAgICAgIC8vICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb3JtLWdyb3VwXCI+XG4gICAgICAvLyAgICAgICAgICAgPGRpdj5cbiAgICAgIC8vICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hlY2tib3hcIj5cbiAgICAgIC8vICAgICAgICAgICAgICAgPGxhYmVsPlxuICAgICAgLy8gICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIi8+IFJlbWVtYmVyIG1lXG4gICAgICAvLyAgICAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAvLyAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgIC8vICAgICAgICAgICA8L2Rpdj5cbiAgICAgIC8vICAgICAgICAgPC9kaXY+XG4gICAgICAvLyAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybS1ncm91cFwiPlxuICAgICAgLy8gICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbC1idXR0b25cIj5cbiAgICAgIC8vICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzTmFtZT1cImJ0biBidG4tZGVmYXVsdFwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9ID5TaWduIGluPC9idXR0b24+XG4gICAgICAvLyAgICAgICAgICAgPC9kaXY+XG4gICAgICAvLyAgICAgICAgIDwvZGl2PlxuICAgICAgLy8gICAgICAgPC9mb3JtPlxuICAgICAgLy8gICA8L2Rpdj5cbiAgICAgIC8vIDwvZGl2PlxuICAgICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTE9HSU47XG4iLCIvLyAvKiogQGpzeCBSZWFjdC5ET00gKi9cbi8qanNoaW50IG5vZGU6dHJ1ZSovXG5cbi8vICd1c2Ugc3RyaWN0JztcblxuLy8gdmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gLy8gdmFyIEFwcFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL0FwcFN0b3JlJyk7XG4vLyAvLyB2YXIgQXBwQWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvQXBwQWN0aW9ucycpO1xuXG4vLyAvLyB2YXIgTkFWID0gcmVxdWlyZSgnLi9OYXZCYXIuanN4Jyk7XG4vLyAvLyB2YXIgQkFOTkVSID0gcmVxdWlyZSgnLi9CYW5uZXIuanN4Jyk7XG5cbid1c2Ugc3RyaWN0JztcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBTaWRlTmF2ID0gcmVxdWlyZSgnLi4vbGF5b3V0cy9TaWRlTmF2LmpzeCcpO1xudmFyIEltYWdlR2FsbGVyeSA9IHJlcXVpcmUoJy4vR2FsbGVyeVBhZ2UuanN4Jyk7XG52YXIgU2ltcGxlU2Nyb2xsID0gcmVxdWlyZSgnLi9TaW1wbGVTY3JvbGwuanN4Jyk7XG5cblxudmFyIFNpZ251cCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJTaWdudXBcIixcbiAgICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2lkZU5hdiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChJbWFnZUdhbGxlcnksIG51bGwpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ251cDsiLCIvLyAvKiogQGpzeCBSZWFjdC5ET00gKi9cbi8qanNoaW50IG5vZGU6dHJ1ZSovXG5cbi8vICd1c2Ugc3RyaWN0JztcblxuLy8gdmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gLy8gdmFyIEFwcFN0b3JlID0gcmVxdWlyZSgnLi4vc3RvcmVzL0FwcFN0b3JlJyk7XG4vLyAvLyB2YXIgQXBwQWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvQXBwQWN0aW9ucycpO1xuXG4vLyAvLyB2YXIgTkFWID0gcmVxdWlyZSgnLi9OYXZCYXIuanN4Jyk7XG4vLyAvLyB2YXIgQkFOTkVSID0gcmVxdWlyZSgnLi9CYW5uZXIuanN4Jyk7XG5cbid1c2Ugc3RyaWN0JztcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBtdWkgPSByZXF1aXJlKCdtYXRlcmlhbC11aScpO1xudmFyIFRleHRGaWVsZCA9IG11aS5UZXh0RmllbGQ7XG52YXIgVG9vbHRpcCA9IG11aS5Ub29sdGlwO1xudmFyIFJhaXNlZEJ1dHRvbiA9IG11aS5SYWlzZWRCdXR0b247XG52YXIgU3RhdGVzU2VsZWN0ID0gcmVxdWlyZSgnLi4vLi4vY29tcG9uZW50cy9mb3Jtcy9hZGRyZXNzL3N0YXRlcy5qc3gnKTtcbnZhciBGbHV4aWJsZU1peGluID0gcmVxdWlyZSgnZmx1eGlibGUnKS5NaXhpbjtcblxudmFyIFNpZ251cEFjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2FjdGlvbnMvYXV0aGVudGljYXRpb24vU2lnbnVwQWN0aW9uJyk7XG5cbnZhciBTaWdudXAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiU2lnbnVwXCIsXG4gIG1peGluczpbRmx1eGlibGVNaXhpbl0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVtYWlsOidwZ3J1ZW5iYWNoZXJAZ21haWwuY29tJyxcbiAgICAgIGZpcnN0TmFtZToncGF1bCcsXG4gICAgICBsYXN0TmFtZTonZ3J1ZW4nLFxuICAgICAgcGhvbmVOdW1iZXI6Jyg1MTMpIDMxOS04MjM4JyxcbiAgICAgIGRvYjogJzA1LzA4LzE5OTAnLFxuICAgICAgYnVzaW5lc3NOYW1lOidzb21ldGhpbmcgbmFtZScsXG4gICAgICBwcm9kdWN0RGVzY3JpcHRpb246J2Rlc2NyaXB0aW9uIGRlc2NyaXB0aW9uJyxcbiAgICAgIGJ1c2luZXNzVHlwZTonc29sZV9wcm9wJyxcbiAgICAgIHppcDo0NTAxNCxcbiAgICAgIHN0cmVldEFkZHJlc3M6JzE4NjcgSGFycm93Z2F0ZScsXG4gICAgICBzdGF0ZTonT0gnLFxuICAgICAgY2l0eTonZmFpcmZpZWxkJ1xuICAgIH07XG4gIH0sXG4gIGhhbmRsZUNoYW5nZTpmdW5jdGlvbih2YWx1ZSl7XG4gICAgdmFyIHNlbGY9dGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgdmFyIG9iaj17fTtcbiAgICAgIG9ialt2YWx1ZV09ZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgc2VsZi5zZXRTdGF0ZShvYmopO1xuICAgIH07XG4gIH0sXG4gIGhhbmRsZVN1Ym1pdDpmdW5jdGlvbihlKXtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIG9iaj10aGlzLnN0YXRlO1xuICAgIG9iai5waG9uZU51bWJlcj10aGlzLnN0YXRlLnBob25lTnVtYmVyLnJlcGxhY2UoL1xcRC9nLCcnKTtcblxuICAgIGNvbnNvbGUubG9nKHRoaXMuc3RhdGUuZG9iLnNwbGl0KCcvJykpO1xuICAgIHRoaXMuZXhlY3V0ZUFjdGlvbihTaWdudXBBY3Rpb24sb2JqKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgbnVsbCwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7c3R5bGU6IHt3aWR0aDonNDUwcHgnLG1hcmdpbjonNDBweCcsZGlzcGxheTonaW5saW5lLWJsb2NrJ319LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgIGZsb2F0aW5nTGFiZWxUZXh0OiBcImVtYWlsXCIsIFxuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5lbWFpbCwgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgnZW1haWwnKSwgXG4gICAgICAgICAgICAgIGhpbnRUZXh0OiBcImVtYWlsXCJ9KSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRGaWVsZCwge1xuICAgICAgICAgICAgICBmbG9hdGluZ0xhYmVsVGV4dDogXCJmaXJzdE5hbWVcIiwgXG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmZpcnN0TmFtZSwgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgnZmlyc3ROYW1lJyksIFxuICAgICAgICAgICAgICBoaW50VGV4dDogXCJmaXJzdE5hbWVcIn0pLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgIGZsb2F0aW5nTGFiZWxUZXh0OiBcImxhc3ROYW1lXCIsIFxuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5sYXN0TmFtZSwgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgnbGFzdE5hbWUnKSwgXG4gICAgICAgICAgICAgIGhpbnRUZXh0OiBcImxhc3ROYW1lXCJ9KSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRGaWVsZCwge1xuICAgICAgICAgICAgICBmbG9hdGluZ0xhYmVsVGV4dDogXCJwaG9uZU51bWJlclwiLCBcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUucGhvbmVOdW1iZXIsIFxuICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UoJ3Bob25lTnVtYmVyJyksIFxuICAgICAgICAgICAgICBoaW50VGV4dDogXCJwaG9uZU51bWJlclwifSksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgZmxvYXRpbmdMYWJlbFRleHQ6IFwiZG9iXCIsIFxuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5kb2IsIFxuICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UoJ2RvYicpLCBcbiAgICAgICAgICAgICAgaGludFRleHQ6IFwiZG9iXCJ9KVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge3N0eWxlOiB7d2lkdGg6JzQ1MHB4JyxtYXJnaW46JzQwcHgnLGRpc3BsYXk6J2lubGluZS1ibG9jayd9fSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRGaWVsZCwge1xuICAgICAgICAgICAgICBmbG9hdGluZ0xhYmVsVGV4dDogXCJidXNpbmVzc05hbWVcIiwgXG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLmJ1c2luZXNzTmFtZSwgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgnYnVzaW5lc3NOYW1lJyksIFxuICAgICAgICAgICAgICBoaW50VGV4dDogXCJidXNpbmVzc05hbWVcIn0pLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnByb2R1Y3REZXNjcmlwdGlvbiwgXG4gICAgICAgICAgICAgIG11bHRpTGluZTogdHJ1ZSwgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgncHJvZHVjdERlc2NyaXB0aW9uJyksIFxuICAgICAgICAgICAgICBoaW50VGV4dDogXCJwcm9kdWN0RGVzY3JpcHRpb25cIn0pLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dEZpZWxkLCB7XG4gICAgICAgICAgICAgIGZsb2F0aW5nTGFiZWxUZXh0OiBcImJ1c2luZXNzVHlwZVwiLCBcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuYnVzaW5lc3NUeXBlLCBcbiAgICAgICAgICAgICAgb25DaGFuZ2U6IHRoaXMuaGFuZGxlQ2hhbmdlKCdidXNpbmVzc1R5cGUnKSwgXG4gICAgICAgICAgICAgIGhpbnRUZXh0OiBcImJ1c2luZXNzVHlwZVwifSksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgZmxvYXRpbmdMYWJlbFRleHQ6IFwic3RyZWV0QWRkcmVzc1wiLCBcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuc3RyZWV0QWRkcmVzcywgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgnc3RyZWV0QWRkcmVzcycpLCBcbiAgICAgICAgICAgICAgaGludFRleHQ6IFwic3RyZWV0QWRkcmVzc1wifSksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgZmxvYXRpbmdMYWJlbFRleHQ6IFwiY2l0eVwiLCBcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuY2l0eSwgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgnY2l0eScpLCBcbiAgICAgICAgICAgICAgaGludFRleHQ6IFwiY2l0eVwifSksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0ZXNTZWxlY3QsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuc3RhdGUsIFxuICAgICAgICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UoJ3N0YXRlJyl9KSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRGaWVsZCwge1xuICAgICAgICAgICAgICBmbG9hdGluZ0xhYmVsVGV4dDogXCJ6aXBcIiwgXG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnN0YXRlLnppcCwgXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUNoYW5nZSgnemlwJyksIFxuICAgICAgICAgICAgICBoaW50VGV4dDogXCJ6aXBcIn0pXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSYWlzZWRCdXR0b24sIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlU3VibWl0LCBcbiAgICAgICAgICAgIHNlY29uZGFyeTogdHJ1ZSwgXG4gICAgICAgICAgICBsYWJlbDogXCJzdWJtaXRcIn0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWdudXA7IiwiLyoqIEBqc3ggUmVhY3QuRE9NICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBTaW1wbGVTY3JvbGxlciA9ICByZXF1aXJlKCcuLi9pbnRlcmFjdGl2ZXMvc2ltcGxlU2Nyb2xsZXIvU2ltcGxlU2Nyb2xsZXIuanN4Jyk7XG5cbnZhciBTY3JvbGxQYWdlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlNjcm9sbFBhZ2VcIixcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGVudCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgY29udGVudC5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtrZXk6IGl9LCBcIkl0ZW0gXCIsIGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaW1wbGVTY3JvbGxlciwge2NsYXNzTmFtZTogXCJTY3JvbGxQYWdlXCIsIG9wdGlvbnM6IHtzY3JvbGxpbmdYOiBmYWxzZX19LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIlNjcm9sbFBhZ2UtY29udGVudFwifSwgY29udGVudClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxQYWdlOyIsIi8vIC8qKiBAanN4IFJlYWN0LkRPTSAqL1xuLypqc2hpbnQgbm9kZTp0cnVlKi9cblxuLy8gJ3VzZSBzdHJpY3QnO1xuXG4vLyB2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyAvLyB2YXIgQXBwU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZXMvQXBwU3RvcmUnKTtcbi8vIC8vIHZhciBBcHBBY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9BcHBBY3Rpb25zJyk7XG5cbi8vIC8vIHZhciBOQVYgPSByZXF1aXJlKCcuL05hdkJhci5qc3gnKTtcbi8vIC8vIHZhciBCQU5ORVIgPSByZXF1aXJlKCcuL0Jhbm5lci5qc3gnKTtcblxuJ3VzZSBzdHJpY3QnO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIG11aSA9IHJlcXVpcmUoJ21hdGVyaWFsLXVpJyk7XG52YXIgVGV4dEZpZWxkID0gbXVpLlRleHRGaWVsZDtcbnZhciBUb29sdGlwID0gbXVpLlRvb2x0aXA7XG52YXIgUmFpc2VkQnV0dG9uID0gbXVpLlJhaXNlZEJ1dHRvbjtcbnZhciBGbHV4aWJsZU1peGluID0gcmVxdWlyZSgnZmx1eGlibGUnKS5NaXhpbjtcblxudmFyIEFkbWluUGFnZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJBZG1pblBhZ2VcIixcbiAgbWl4aW5zOltGbHV4aWJsZU1peGluXSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIGhhbmRsZUNoYW5nZTpmdW5jdGlvbihlKXtcbiAgfSxcbiAgaGFuZGxlU3VibWl0OmZ1bmN0aW9uKGUpe1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFxuICAgICAgICBcIkFkbWluIVwiXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRtaW5QYWdlOyIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgU3RhdGljQ29udGFpbmVyID0gcmVxdWlyZSgnLi9TdGF0aWNDb250YWluZXIuanN4Jyk7XG52YXIgU3R5bGVLZXlzID0gcmVxdWlyZSgnLi4vLi4vZW52aXJvbm1lbnQvU3R5bGVLZXlzJyk7XG5cbnZhciBQT0xMX0ZBQ1RPUiA9IDAuNTtcblxudmFyIEFuaW1hdGFibGVDb250YWluZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnQW5pbWF0YWJsZUNvbnRhaW5lcicsXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2tVcGRhdGVzOiB0cnVlLFxuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHJvdGF0ZTogbnVsbCxcbiAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgdGltZW91dDogMjAwLFxuICAgICAgdHJhbnNsYXRlOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMud2FzRXZlck9uR1BVID0gZmFsc2U7XG4gICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIHRoaXMubGFzdEFuaW1hdGlvblRpbWUgPSAwO1xuICAgIHRoaXMuYW5pbWF0aW9uSW50ZXJ2YWwgPSBudWxsO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JbnRlcnZhbCkge1xuICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5hbmltYXRpb25JbnRlcnZhbCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcykge1xuICAgIHZhciBwcmV2U3R5bGUgPSB0aGlzLmdldFN0eWxlKHRoaXMucHJvcHMpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0U3R5bGUobmV4dFByb3BzKTtcblxuICAgIHRoaXMuaXNBbmltYXRpbmcgPSAoXG4gICAgICBzdHlsZS5vcGFjaXR5ICE9PSBwcmV2U3R5bGUub3BhY2l0eSB8fFxuICAgICAgc3R5bGVbU3R5bGVLZXlzLlRSQU5TRk9STV0gIT09IHByZXZTdHlsZVtTdHlsZUtleXMuVFJBTlNGT1JNXVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5pc0FuaW1hdGluZykge1xuICAgICAgdGhpcy5sYXN0QW5pbWF0aW9uVGltZSA9IERhdGUubm93KCk7XG4gICAgICBpZiAodGhpcy5wcm9wcy50aW1lb3V0ICYmICF0aGlzLmFuaW1hdGlvbkludGVydmFsKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoXG4gICAgICAgICAgdGhpcy5jaGVja0FuaW1hdGlvbkVuZCxcbiAgICAgICAgICB0aGlzLnByb3BzLnRpbWVvdXQgKiBQT0xMX0ZBQ1RPUlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjaGVja0FuaW1hdGlvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKERhdGUubm93KCkgLSB0aGlzLmxhc3RBbmltYXRpb25UaW1lID4gdGhpcy5wcm9wcy50aW1lb3V0KSB7XG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmFuaW1hdGlvbkludGVydmFsKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgfSxcblxuICBnZXRTdHlsZTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcblxuICAgIGlmICh0aGlzLnByb3BzLnN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wcm9wcy5zdHlsZSkge1xuICAgICAgICBzdHlsZVtrZXldID0gdGhpcy5wcm9wcy5zdHlsZVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFuc2Zvcm1zID0gJyc7XG4gICAgaWYgKHByb3BzLm9wYWNpdHkgIT09IDEpIHtcbiAgICAgIHN0eWxlLm9wYWNpdHkgPSBwcm9wcy5vcGFjaXR5O1xuICAgIH1cblxuICAgIGlmIChwcm9wcy50cmFuc2xhdGUpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz0gKFxuICAgICAgICAndHJhbnNsYXRlM2QoJyArIChwcm9wcy50cmFuc2xhdGUueCB8fCAwKSArICdweCwgJyArXG4gICAgICAgIChwcm9wcy50cmFuc2xhdGUueSB8fCAwKSArICdweCwgJyArXG4gICAgICAgIChwcm9wcy50cmFuc2xhdGUueiB8fCAwKSArICdweCkgJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMucm90YXRlKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9IChcbiAgICAgICAgJ3JvdGF0ZTNkKCcgKyAocHJvcHMucm90YXRlLnggfHwgMCkgKyAnLCAnICtcbiAgICAgICAgKHByb3BzLnJvdGF0ZS55IHx8IDApICsgJywgJyArXG4gICAgICAgIChwcm9wcy5yb3RhdGUueiB8fCAwKSArICcsICcgK1xuICAgICAgICBwcm9wcy5yb3RhdGUuZGVnICsgJ2RlZykgJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuc2NhbGUpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz0gJ3NjYWxlKCcgKyBwcm9wcy5zY2FsZSArICcpICc7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgc3R5bGVbU3R5bGVLZXlzLlRSQU5TRk9STV0gPSB0cmFuc2Zvcm1zO1xuICAgICAgdGhpcy53YXNFdmVyT25HUFUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy53YXNFdmVyT25HUFUpIHtcbiAgICAgICAgLy8gb24gaU9TIHdoZW4geW91IGdvIGZyb20gdHJhbnNsYXRlM2QgdG8gbm9uLXRyYW5zbGF0ZTNkIHlvdSBnZXRcbiAgICAgICAgLy8gZmxpY2tlci4gTGV0J3MgYXZvaWQgaXRcbiAgICAgICAgc3R5bGVbU3R5bGVLZXlzLlRSQU5TRk9STV0gPSAndHJhbnNsYXRlM2QoMCwgMCwgMCknO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUsIHN0eWxlOiB0aGlzLmdldFN0eWxlKHRoaXMucHJvcHMpfSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdGljQ29udGFpbmVyLCB7c2hvdWxkVXBkYXRlOiAhdGhpcy5wcm9wcy5ibG9ja1VwZGF0ZXMgfHwgIXRoaXMuaXNBbmltYXRpbmd9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRhYmxlQ29udGFpbmVyOyIsIi8qKiBAanN4IFJlYWN0LkRPTSAqL1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgU3RhdGljQ29udGFpbmVyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlN0YXRpY0NvbnRhaW5lclwiLFxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7c2hvdWxkVXBkYXRlOiBmYWxzZX07XG4gIH0sXG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICByZXR1cm4gbmV4dFByb3BzLnNob3VsZFVwZGF0ZSB8fCAodGhpcy5wcm9wcy5zdGF0aWNLZXkgIT09IG5leHRQcm9wcy5zdGF0aWNLZXkpO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRpY0NvbnRhaW5lcjsiLCIvKiogQGpzeCBSZWFjdC5ET00gKi9cbi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5SZWFjdC5pbml0aWFsaXplVG91Y2hFdmVudHModHJ1ZSk7XG52YXIgVG91Y2hhYmxlQXJlYSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJUb3VjaGFibGVBcmVhXCIsXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdWNoYWJsZTogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgaGFuZGxlVG91Y2hTdGFydDogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5wcm9wcy5zY3JvbGxlciB8fCAhdGhpcy5wcm9wcy50b3VjaGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLnNjcm9sbGVyLmRvVG91Y2hTdGFydChlLnRvdWNoZXMsIGUudGltZVN0YW1wKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sXG5cblxuICBoYW5kbGVUb3VjaE1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMuc2Nyb2xsZXIgfHwgIXRoaXMucHJvcHMudG91Y2hhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvcHMuc2Nyb2xsZXIuZG9Ub3VjaE1vdmUoZS50b3VjaGVzLCBlLnRpbWVTdGFtcCwgZS5zY2FsZSk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9LFxuXG4gIGhhbmRsZVRvdWNoRW5kOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLnNjcm9sbGVyIHx8ICF0aGlzLnByb3BzLnRvdWNoYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb3BzLnNjcm9sbGVyLmRvVG91Y2hFbmQoZS50aW1lU3RhbXApO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybihcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgUmVhY3QuX19zcHJlYWQoe30sIFxuICAgICAgICB0aGlzLnByb3BzLCBcbiAgICAgICAge29uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCBcbiAgICAgICAgb25Ub3VjaE1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLCBcbiAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5oYW5kbGVUb3VjaEVuZCwgXG4gICAgICAgIG9uVG91Y2hDYW5jZWw6IHRoaXMuaGFuZGxlVG91Y2hFbmR9KSwgXG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb3VjaGFibGVBcmVhOyIsIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzPXtcbiAgTkFWQkFSX0hFSUdIVDo1MFxuXG59O1xuIiwiaWYodHlwZW9mIHdpbmRvdyA9PT0ndW5kZWZpbmVkJyl7XG4gIFNjcm9sbGVyID0ge307XG59ZWxzZXtcbiAgU2Nyb2xsZXIgPSB3aW5kb3cuU2Nyb2xsZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsZXI7IiwiaWYodHlwZW9mIGRvY3VtZW50ICE9PSd1bmRlZmluZWQnKXtcbiAgdmFyIFRSQU5TRk9STV9LRVkgPSB0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZS5Nb3pUcmFuc2Zvcm0gIT09ICd1bmRlZmluZWQnID8gJ01velRyYW5zZm9ybScgOiAnV2Via2l0VHJhbnNmb3JtJztcbiAgdmFyIEZJTFRFUl9LRVkgPSB0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZS5Nb3pGaWx0ZXIgIT09ICd1bmRlZmluZWQnID8gJ01vekZpbHRlcicgOiAnV2Via2l0RmlsdGVyJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRSQU5TRk9STTogVFJBTlNGT1JNX0tFWSxcbiAgRklMVEVSOiBGSUxURVJfS0VZXG59OyIsInZhciBzaG93Q2hhdCA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTWVzc2FnZUFjdGlvbnMnKTtcbi8vIHZhciBvcGVuVGhyZWFkID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9vcGVuVGhyZWFkJyk7XG4vLyB2YXIgTmF2QWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTmF2QWN0aW9ucy5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBob21lOiB7XG4gICAgICAgIHBhdGg6ICcvJyxcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgcGFnZTogJ2hvbWUnLFxuICAgICAgICBsYWJlbDogJ0hvbWUnLFxuXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKGNvbnRleHQsIHBheWxvYWQsIGRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goJ1VQREFURV9QQUdFX1RJVExFJywgeyBwYWdlVGl0bGU6ICdIb21lJyB9KTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWJvdXQ6IHtcbiAgICAgICAgcGF0aDogJy9hYm91dCcsXG4gICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgIHBhZ2U6ICdhYm91dCcsXG4gICAgICAgIGxhYmVsOiAnQWJvdXQnLFxuICAgICAgICBhY3Rpb246IGZ1bmN0aW9uIChjb250ZXh0LCBwYXlsb2FkLCBkb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKCdVUERBVEVfUEFHRV9USVRMRScsIHsgcGFnZVRpdGxlOiAnQWJvdXQnIH0pO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBsb2dpbjoge1xuICAgICAgICBwYXRoOiAnL2xvZ2luJyxcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgcGFnZTogJ2xvZ2luJyxcbiAgICAgICAgbGFiZWw6ICdMb2dpbicsXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKGNvbnRleHQsIHBheWxvYWQsIGRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goJ1VQREFURV9QQUdFX1RJVExFJywgeyBwYWdlVGl0bGU6ICdMb2dpbicgfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNpZ251cDp7XG4gICAgICAgIHBhdGg6Jy9zaWdudXAnLFxuICAgICAgICBtZXRob2Q6J2dldCcsXG4gICAgICAgIHBhZ2U6J3NpZ251cCcsXG4gICAgICAgIGxhYmVsOidTaWdudXAnLFxuICAgICAgICBhY3Rpb246ZnVuY3Rpb24oY29udGV4dCxwYXlsb2FkLGRvbmUpe1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCgnVVBEQVRFX1BBR0VfVElUTEUnLHtwYWdlVGl0bGU6J1NpZ251cCd9KTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2lkZW5hdjp7XG4gICAgICAgIHBhdGg6Jy9zaWRlbmF2JyxcbiAgICAgICAgbWV0aG9kOidnZXQnLFxuICAgICAgICBwYWdlOidzaWRlbmF2JyxcbiAgICAgICAgbGFiZWw6J1NpZGVOYXYnLFxuICAgICAgICBhY3Rpb246ZnVuY3Rpb24oY29udGV4dCxwYXlsb2FkLGRvbmUpe1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCgnVVBEQVRFX1BBR0VfVElUTEUnLHtwYWdlVEl0bGU6J1NpZGVOYXYnfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkbWluOntcbiAgICAgICAgcGF0aDonL2FkbWluJyxcbiAgICAgICAgbWV0aG9kOidnZXQnLFxuICAgICAgICBwYWdlOidhZG1pbicsXG4gICAgICAgIGxhYmVsOidBZG1pbicsXG4gICAgICAgIGF1dGg6e1xuICAgICAgICAgICAgcm9sZXM6WydhZG1pbiddXG4gICAgICAgIH0sXG4gICAgICAgIGFjdGlvbjpmdW5jdGlvbihjb250ZXh0LHBheWxvYWQsZG9uZSl7XG4gICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKCdVUERBVEVfUEFHRV9USVRMRScse3BhZ2VUaXRsZTonQWRtaW4nfSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZHluYW1pY3BhZ2U6IHtcbiAgICAvLyAgICAgcGF0aDogJy9wYWdlLzppZCcsXG4gICAgLy8gICAgIG1ldGhvZDogJ2dldCcsXG4gICAgLy8gICAgIHBhZ2U6ICdwYWdlJyxcbiAgICAvLyAgICAgYWN0aW9uOiBmdW5jdGlvbiAoY29udGV4dCwgcGF5bG9hZCwgZG9uZSkge1xuICAgIC8vICAgICAgICAgY29udGV4dC5kaXNwYXRjaCgnTE9BRF9QQUdFJywgeyBpZDogcGF5bG9hZC5wYXJhbXMuaWQgfSk7XG4gICAgLy8gICAgICAgICBjb250ZXh0LmRpc3BhdGNoKCdVUERBVEVfUEFHRV9USVRMRScsIHsgcGFnZVRpdGxlOiBwYXlsb2FkLnBhcmFtcy5pZCArICcgW0R5bmFtaWMgUGFnZV0gfCBmbHV4LWV4YW1wbGVzIHwgcm91dGluZycgfSk7XG4gICAgLy8gICAgICAgICBkb25lKCk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG59OyIsIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlU3RvcmUgPSByZXF1aXJlKCdmbHV4aWJsZS91dGlscy9jcmVhdGVTdG9yZScpO1xudmFyIFNlc3Npb25TdG9yZSA9IHJlcXVpcmUoJy4vU2Vzc2lvblN0b3JlJyk7XG5cbnZhciByb3V0ZXNDb25maWc9IHJlcXVpcmUoJy4uL3JvdXRlcy9yb3V0ZXMnKTtcblxudmFyIEFwcGxpY2F0aW9uU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgc3RvcmVOYW1lOiAnQXBwbGljYXRpb25TdG9yZScsXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgICAgJ1NFVF9VU0VSJyA6ICdoYW5kbGVVc2VyJyxcbiAgICAgICAgJ0NIQU5HRV9ST1VURV9TVUNDRVNTJyA6ICdoYW5kbGVOYXZpZ2F0ZScsXG4gICAgICAgICdVUERBVEVfUEFHRV9USVRMRScgICAgOiAndXBkYXRlUGFnZVRpdGxlJ1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZU5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Um91dGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhZ2VzID0gcm91dGVzQ29uZmlnO1xuICAgICAgICB0aGlzLnBhZ2VUaXRsZSA9ICcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyPSB7fTtcbiAgICB9LFxuICAgIGhhbmRsZVVzZXI6IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB9LFxuICAgIGNoZWNrUGVybWlzc2lvbjpmdW5jdGlvbihyb3V0ZSl7XG4gICAgICAgIHZhciBjb25maWcgPSByb3V0ZS5jb25maWc7XG4gICAgICAgIC8vIHZhciB1c2VyID0gU2Vzc2lvblN0b3JlLmdldEN1cnJlbnRVc2VyKCk7XG4gICAgICAgIGlmKHR5cGVvZiBjb25maWcuYXV0aCE9PSd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjb25maWcuYXV0aC5yb2xlcyE9PSd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5jdXJyZW50VXNlci5yb2xlPT09J3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoY29uZmlnLmF1dGgucm9sZXMuaW5kZXhPZih0aGlzLmN1cnJlbnRVc2VyLnJvbGUpID09PS0xKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhbmRsZU5hdmlnYXRlOiBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFJvdXRlICYmICh0aGlzLmN1cnJlbnRSb3V0ZS51cmwgPT09IHJvdXRlLnVybCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZighdGhpcy5jaGVja1Blcm1pc3Npb24ocm91dGUpKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFnZU5hbWUgPSByb3V0ZS5jb25maWcucGFnZTtcbiAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW3BhZ2VOYW1lXTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlTmFtZSA9IHBhZ2VOYW1lO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZTtcbiAgICAgICAgdGhpcy5jdXJyZW50Um91dGUgPSByb3V0ZTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcbiAgICB1cGRhdGVQYWdlVGl0bGU6IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgICAgICB0aGlzLnBhZ2VUaXRsZSA9IHRpdGxlLnBhZ2VUaXRsZTtcbiAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50UGFnZU5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBhZ2VOYW1lO1xuICAgIH0sXG4gICAgZ2V0UGFnZVRpdGxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VUaXRsZTtcbiAgICB9LFxuICAgIGdldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50UGFnZU5hbWU6IHRoaXMuY3VycmVudFBhZ2VOYW1lLFxuICAgICAgICAgICAgY3VycmVudFBhZ2U6IHRoaXMuY3VycmVudFBhZ2UsXG4gICAgICAgICAgICBwYWdlczogdGhpcy5wYWdlcyxcbiAgICAgICAgICAgIHJvdXRlOiB0aGlzLmN1cnJlbnRSb3V0ZSxcbiAgICAgICAgICAgIHBhZ2VUaXRsZTogdGhpcy5wYWdlVGl0bGVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRlaHlkcmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICAgIH0sXG4gICAgcmVoeWRyYXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZU5hbWUgPSBzdGF0ZS5jdXJyZW50UGFnZU5hbWU7XG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSBzdGF0ZS5jdXJyZW50UGFnZTtcbiAgICAgICAgdGhpcy5wYWdlcyA9IHN0YXRlLnBhZ2VzO1xuICAgICAgICB0aGlzLmN1cnJlbnRSb3V0ZSA9IHN0YXRlLnJvdXRlO1xuICAgICAgICB0aGlzLnBhZ2VUaXRsZSA9IHN0YXRlLnBhZ2VUaXRsZTtcbiAgICB9XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFwcGxpY2F0aW9uU3RvcmU7IiwiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGVTdG9yZSA9IHJlcXVpcmUoJ2ZsdXhpYmxlL3V0aWxzL2NyZWF0ZVN0b3JlJyk7XG52YXIgY29va2llID0gcmVxdWlyZSgnY29va2llcy1qcycpO1xuXG5cbnZhciBTZXNzaW9uU3RvcmUgPSBjcmVhdGVTdG9yZSh7XG4gICAgc3RvcmVOYW1lOiAnU2Vzc2lvblN0b3JlJyxcbiAgICBoYW5kbGVyczoge1xuICAgICAgICAnU0VUX1VTRVInIDogJ2hhbmRsZVVzZXInLFxuICAgICAgICAnU0VUX1RPS0VOJzonaGFuZGxlVG9rZW4nXG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAoZGlzcGF0Y2hlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyPXt9O1xuICAgICAgICBpZih0eXBlb2Ygd2luZG93ICE9PSd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIHRoaXMudG9rZW49Y29va2llLmdldCgndG9rZW4nKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLnRva2VuPW51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVVzZXI6IGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB9LFxuICAgIGhhbmRsZVRva2VuOmZ1bmN0aW9uKHRva2VuKXtcbiAgICAgICAgY29va2llKCd0b2tlbicsdG9rZW4pO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlUGFnZVRpdGxlOiBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICAgICAgdGhpcy5wYWdlVGl0bGUgPSB0aXRsZS5wYWdlVGl0bGU7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH0sXG4gICAgZ2V0Q3VycmVudFVzZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFVzZXI7XG4gICAgfSxcbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46dGhpcy50b2tlbixcbiAgICAgICAgICAgIGN1cmVudFVzZXI6dGhpcy5jdXJyZW50VXNlclxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZGVoeWRyYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gICAgfSxcbiAgICByZWh5ZHJhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0aGlzLnRva2VuID0gc3RhdGUudG9rZW47XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBzdGF0ZS5jdXJyZW50VXNlcjtcbiAgICB9XG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlc3Npb25TdG9yZTsiLCJtb2R1bGUuZXhwb3J0cy51cmxzID0gW1wiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvL2dBK1ExSkZRVlJQVWpvZ1oyUXRhbkJsWnlCMk1TNHdJQ2gxYzJsdVp5QkpTa2NnU2xCRlJ5QjJOaklwTENCa1pXWmhkV3gwSUhGMVlXeHBkSGtLLzlzQVF3QUlCZ1lIQmdVSUJ3Y0hDUWtJQ2d3VURRd0xDd3daRWhNUEZCMGFIeDRkR2h3Y0lDUXVKeUFpTENNY0hDZzNLU3d3TVRRME5COG5PVDA0TWp3dU16UXkvOXNBUXdFSkNRa01Dd3dZRFEwWU1pRWNJVEl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeS84QUFFUWdCbWdGQUF3RWlBQUlSQVFNUkFmL0VBQjhBQUFFRkFRRUJBUUVCQUFBQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVFBQUlCQXdNQ0JBTUZCUVFFQUFBQmZRRUNBd0FFRVFVU0lURkJCaE5SWVFjaWNSUXlnWkdoQ0NOQ3NjRVZVdEh3SkROaWNvSUpDaFlYR0JrYUpTWW5LQ2txTkRVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmc0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaDR1UGs1ZWJuNk9ucThmTHo5UFgyOS9qNSt2L0VBQjhCQUFNQkFRRUJBUUVCQVFFQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVJBQUlCQWdRRUF3UUhCUVFFQUFFQ2R3QUJBZ01SQkFVaE1RWVNRVkVIWVhFVElqS0JDQlJDa2FHeHdRa2pNMUx3RldKeTBRb1dKRFRoSmZFWEdCa2FKaWNvS1NvMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvS0RoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1TGo1T1htNStqcDZ2THo5UFgyOS9qNSt2L2FBQXdEQVFBQ0VRTVJBRDhBN0MvdnJ1ek1zT3IzRnMzbXJqWlk4T09NRnQvWG9PUU1aeCtlTHJHcVcrbDJLMmozTWQ5cDh4SU1wVXRMYkU0dzZ5SDd3NDZFRWpnRWtacWpCZUJ0UWw4NkZKUlBrQld3Zm1ZZFIrZFc1YkxUSk5OWVdsdGNlY2NaSWt6R3JaT1FENm5tdkUvdENVMUxsZnkxdWt2UC9NOU5VVXJYT08xand3WDhNeGVKUHRrTThqWEx4a0JTcnVnSlVzZWVlY2NEb0QzN2NmY0FUd1N3NzFRNEIzRStwL3BYWDMxNjFwb1Z4cFFpajhoNVBOVldYTHhOazhxM1VnZzhnLzhBMXE0VzlqWnJ3R05Ua2dCVDcxNk5HckdxazRhSTVLeXN5MXA4a1psakN5N3lXUE9PL1N1dzBhZVRUbFM0akFTSUt3YVIxNEI2THR6MU9UWEhXa0xyY2VVejVNYkRJQUdNOTY3bUxUTlJ2N0NGNW5WWUZBTVNqUDdzTU03K091UjljZld1WE1LcXB4V3R0U3FFVytoR25oKzdhemp2ZnRZTGtPWExIWTZ1U01aNS9pemtlM0hhdXA4TFJYTW1tWGFSVGd4aE44akdRa0VLZUEvUDVmaFdkOWlsZlJ2S2x0MWtOcy96bE1raFIvRVBianY2bnBScHNNbmxTVzhrVHdwUDh4a2ZnbnVGNDR4bFJ6NjlhOG1OZUUzZVczazdYK1oyV2EyUlpPbzMrbzY0OFZzWWhMQVhjTDVRQ0o1WUpQekhnOEEvbCtkKzc4U1RSMzE0K25UeHlKT1VrYTVpVUxuak9BTzNYSDFGUXpXOE1Wc2pXQjh4R1VCdm4yUGpqS05uNVdIY1ZoUkczdVk3bEJESkEwSTJQKzdLb2hPVGdkZU9EZzlxVThSQ1VMUTN2cS93OHU1Tm1ucWJObnJEM0tSeGJBWlJKODBwWURyZ0JoMlhHUGNWWTAyQzNtdDMzbEpibG84K1k0QnlPNTU2bk9CaXNnUldWdkFzYzIxQzZiUktybGxaKzJjZC93Qk9SV3pwQ0dLQ1NGekNPb0JaZmtWZStUK0o0OSsxZWRVU1YydERXSE05eU9UU05QdXJPZVNjVzhjY2NlNVdpVVpBNmdrOWM0NjF5Ylg5dEZCYXdxNjc1M0VnY3g3Vkl4akJidDNJNjlPMWJPdnlUNlZwT3EzaGxSZDZnd0JDUnRWd0IwejF5UmdkaCtkYzVjWGxrK2tXOG1veVJYVVYwREV6MnZ5dEc0QUlHRDF4a2srK1BhdTNEVWJxOTIxZjlES3MwblpHOTRlYisxYjdmRHRpV0ZTc3hWUVl5eTV4Zzl4M0pIYjZWMmN1STdVT3hnaUtCV0RTYmM5QjB5Ui9QdFhsbmcvWGI0YVUya2FkQUpydVNkcEZra1ZTc1NIanVNRG5KSlB0WFlXZWcybHpGSkpxbDlOY1hFU2t0QWgySXdIUUQrSTg4ZHVPMVpZdkM4dFY4enNsdDFkaDA1cmw5U2UrMTNTWUkvS3U5U1M0UE1iU0ZXSktzVG5nOGRoMzY4MGw3NDIwZ2EzWlhVYzhDd1JJMGJMZ2dZT3pBQTV4OTBuTmErbmVIOUp0NWxjNlpaTEhJUXpGNFZZb0FNQTg1NFBYakhYMDZha21tYU5ORS9rV05wSTdLRWRmTFhDOGRoOU9UOWFtbXFDaEtXdGw2ZmtEbHJhd21sYXhaYSt3R2szY0xTaGNtSm1BQkh0MzQrbGFPcVdNNHN0ODBwQlhnSXZKYm45TzljUWZDK2tYU21XR0o3UzdpZllKclZoRXdZZGVBTUgxeVJtaURTZkZ0dEt6NmJyVWQ5QXVBTGZVa3dXdzNLaHVRY0h2eHpXK0hyWVdwU2RGM3UrNys3eS9JbVVKUmtwSTNJN0NhNnZyR3lVTHQrZWZadEFLaGNnQSsyNDAyVFRyeTIxSVRYWkoyS3ZBUXNjNTY1OXgvV3NQVHZpQUxieE94MXUwZlRib1FDRGEzTVpiY1RrTjZIUFlucFhvMm5TVzE5YUplU1hFSkxET1JLR0FIZm5wNjFYMUdOU0NwUlh2ZDNhMW4rWVRxeWo3ejJPWHVaWnJlVmJXMm0yM01tWER5cmxZbzg0M01NOCt3enlmb2NRWEZsRzc0dUx1V1ZXQUxKdUM3c2tFRFBVNDdZSXhuM05JNDFUVjU3dHJHMGdndHJ1VUphM2tvSlpZbFViU0VHTUtTWGJKSTRmcDZyL3dqV3B3UUZwTlRZdG5BOHFJQmNaOURuOHZUaXZQcTBmWmU2cEpOZm45ek5JeTZzTktoa2VWcmJjd1FraEUySEFBNFBzTWtjWVBjMXQzMm5Yanh1a01pcGxzdHZBYmNPZUt3TERUTlpzNUZtdHRUM01KTUdON2RXUURPTThiU2ZYcitkYmdPcU50ODdWYkl2OEE5ZVpHQi8zOHBmdXRlYVd2OWVSVXIzMExpV2s4MXBCNXJKdFpBSkIwTlJyWkpFcnFxRUhuSXo5NEhybXFiM21zMjhUQXRaM2E3Z0FZZzBMZGV3SlllM1VmV29ZZkVFUUltdkZsdEViSlBucmxlT09YQklIUFlrVmxVakYybFQzOG1KS1JGcWtsK0xkb05QaWQyVHN1UnM0SFRIZmtWV1I3dFlSSE5PMzJzaks3TXZ5Uit2NW50VnViVnpkR05OT0lXQmxCYVJCMFAvNnNWSGR5K1drRElDMlFNdGc5ZW1jNHpraXNiMlhMYlV2bGJSbmFoWlNYanZFc3pSRi92cXlkQUIweDcrdlh0VjN6NDRvOXZreXJFeTdDUUR4amdlMVZ0VSsweld6UXh2SEdaQ0hhUjhFdGc5QmtlbFR6WE55bHJzVjRUYm1QT3c1WGpnQTk4anI2WTQ5SzJVWTFiS1VyRDVaTFU1N1d0S3ZyTzZ0NzZ6ajgyMXRuU2Q0VTRmZ0VaMjlPUVFQd3JPMVBSTHdhUGM2cmVPeHZrRE9GajVDY0FqY2ZVRTQ5T3dIZXVvZS91REpaNGxpYTMyZ0Evd0N3MkRuZHhuR2NnL3l6V2ZyRVU0dG4relRvaUJXZVdQeXc1bUJIT005T01qL0lycHA0aWNaUmhmNS9vOS8rQ05OZFNsYTNpaEVzekVzY1JqeUIxSko2bkp3U1NmNTFkczVMZUo1Rm40eUNWMnR1d2VoQnJHZTllR3lXSGF2MmphQXpCUmtISEkvWDlhaHNEY3UwbStKNFpsRzhSTVFTNE9PUnp3Q2FVNlBNbTlpbE9Ua3VVMW4xYU94dVRER0NubUVqRC9kYitvNyt0VmpjUlNKTk0rK0lxQm5ma3B5Y0FIditOVFNhYkpjYlRNc0xGR0RBTTJDVjdqUGIvd0RWVmZWYmMyMTVBd3M4eFNrRUk1SlZDRDFBSEdmeC9DbEJVN3BMY0pRbkdUYjJHcW4ycEMrOFNKR0EyOVFTY1pQSTl1UDVVOGFkTzZmYUpaUy9tSURsZWVjZDg0NmNqOEtuc01YbDFxSmx1L0lmYkcwZVk4SEF6bGZ4UHYwN1ZaVDdMYjJKbWttTERLNzhnbFhQWGdkaDJOVktUam9sMk00d1VwTFE1dUx4SkRaVzYyMTVJbVk1Tngzc3VGOTBQWG5yeDZEcGluM0hqeTh1WTdpMTA1Wjd5MWxiY1JIR1FEbkRmTWVnSUo1K25wVUowQzJXR0o3TjR6SkNwY041YWRjL2RZN1FlMWErbmVaZStZcVJFeVJwaGxPQVkyNmo1dXcvaTNkK3ZyWHF3ZEs3NUUyMzUyTTVYZTdzamtOMnJTejNFRTBFRnFoVm5kSmNsZ0FwT04yTWM4NDlTVjlpTUM4YVNCMG1WTW9NSGZub2NnMTJkMG1JYjZZc0RGc01ZNmtEYjBBOWllL1N1UjFHR1c3TnJhUS9LekVuNXZ5cjFNSlU1MWExckhGV2piWXUrWDVkMUlVVUJkeEovSG4vQUJyMGZRV3Y3elJvaEJiZVlJWTl1UXBKd01jbjh6K0dQeDgydHhPWk1TQUhLamN3OVJ4WG9YZ2JWSU5ac0pGRjdIRjlsaEJaVEd1NEFad1F4SStuNERPYzFqajZYdElKTlhScGg1OHJiT2t0SlBJblNTZEhpa0svTkpJbjMrQUNENzkrbnA2MW56cERPSDJJSFljQnR2RGZVOFl6Myt2V3BkVHY3Tm83aG1lTzlFVzFIZENBd3g5MXNqZ2psUnpuSFROWlVOK0Z1dGgydkpQdGFPSU1DU1NPQ1B5SCtUWHprOFBLTHZHOWp2ak9MV3BJMXZMQmNUbTFtQlcxVXRKR1VZTDM1R1J6MHhqUFlVTHR1b0pGa21qaUFpOHlYelgzb04yUngwNTRQZXJkdHJ0d1lpRnNudUVCTGhTY0VwN1k5OC80VmthNWVYMnFTckpwOWd0a2JoRmlsTEVzQW9Za01Eakk1M1o2bmppcXBRVTVQbmZMYTJ2OWZxWnlzbm9oYm5aSGNCYlZneVNMallzZnl4dU9jcTNiQTlUampIYk5iZW0yWkxadUkydVNWeGduQzd2dzY0OTZ1MjlqYVNXNGpqdDVFVk1BTWhKOWdldlRGTjAzYmNMTE5GSmxTZHNpT25La2Z3OEQvZDU5Q0QyckJ6ZFQzWWFXNzZmaVU0dUR1Y0w4UTd2L0FJa3J4eUkwY25tSU1BNVhPQ1NRZndISHZYbDlzZHpNVGs0VWtDdlhmaW9ycjRiZ2gyZ28xMkNDcW5nN1d3RCt0ZVR3NXRvTjhpbkxFcUZQR2NmL0FGLzVHdnBzcmtwWWE2WFU4N0VKcXBxZW8rRE5NVlBEa005c3g4eHlUSVZUdURqR2UvVDgvd0E2N25TNFlMbkRaTU55cTlUeVdPZTNQSEIvejI1Znd0YmVWNFhzYmQ1SCsxQk4wckFaVUF0a2ZqZzRJNzRyYmh1MWl1RlNKM1BsakdWVWR5UHh3VC9PdkV4VTNLckszZG04YktLTjZ4ajhtNG5oZTNhTGNvWGVUa3NBQUQ2RGpqOU9sTXZiQjNUTUVqUkt2TFJ4c0dQZkJVNHlPUWZ5eFZDZlduamFkSkN3VlYyc29VQmhqR0FmelBYMHgwcTlCZlcrd0dYekpaSkZCNU9TMlBwNlo2MXd1THZxaTR6Um5OYTNkbzBSaWxKL2Q1ZG1BeU1aenRYOERWdTQxQUMyWUMzYnlpbWZOakJJQXdEK05WMHU1WlNzRytNSXpBUnR0NkFjOEFubklIclVWeFphdGUzVXo2ZmJ0aUE0bE0veXFjNS9QSEI0OWF1Rk9WVjhxaGRtamttcjNMZHBaV1Z6WnpDZEZ1b1pvMXhFeTVIQUFJd2UvRlp3OEMrSDdxK2NSVzh5UXhFdkpDazdoR0pIQzR6eDFKT1BiM3BialVwdEptZ2pEeHpUemZ1OWdCQUIvdmZUdDM2aXVpc1ZqMHFBS0hCbWZNc3JOajd4Ni96cXFNcDB0NVdYOWZpRHQwTSs0c3J2UzcrT1hSYmVYeUZRR2UyYWJJbVhwOG03bzQ2OVJudjJOWHJUWDdLN2RRN1RXdS9LcEZjUnRFWFBmRzREbmpzYW1rbEVpTEw1amVTbVdBSHQxT08vL3dCZXM1N3MzTUUwVTFzTU5FOGlSeWNEQVhPMXZROEU4OXFMdXMxN3QzK1AvQkN5Nm15Sm5NVEZCaGdjZGVCV1RmQ1M5c1pvWUxoWWJuYTJ5UTRiYXc2RTVHQ1BYaXErazNUeTZmRXNSbWx0ekdDSlNDU2VPNS9yejA1Tk1YUjRMKzdsMjNNa084S1dWQ0FjNHgxL0QrZGM3aW96MWV4YTAxTC9BQXRuek5zbWpVc3hJd3U0ZFRqMHo3MVFhZnpvdnNwYnl3eEpYam5PT3ZZKy93Q0pxNUxhU1JXZ0VKTy9QUTlPL3dDTlk5dlBGcU1UUVR4aEdWQXU2UnNzTS94NUlQY0Q4dmFzMUM2azFzaW9TVjdsbXcwNkdLZHBrV05KT1ZNbTNHUjcrdjhBUDNwMFZ2TkhjenBMZ0VuekJ0SitaY2RRTWY1L21rQ0phaVJwNUVFQzRNYnlISkIyOFpKN2M5ZTNOYU5vRnVZVmpMRlpSSTJTSEdVS250amdlbitORFR1K1ozWGNxVTdhbzVpQVRURkp5SlBzMDVKVnBSZ2NFOGc5dlhucGltZWJjeXVGbGtlQ1ZQa1l1NkVsY1k1OVFjK25wMnJwSlpiVWdHV0padHJ1QXdYSjZFRWdlaDR6MTYxVWhzSWxqOHhJMFdFRm1YYVFRZmZwOHY1OXEybFZpdGJEWHZNd2pJTEs4MG0wOG1TUkE4aXJLLzd4bE9XSXhqcDIvbjYxRlBjdTF4S3J0NVBsU0ZHTEQ3eTQ0WVpBUHRpcmt6WEVWNHEzRXl3U01DMFlDZ2xkdU1uMzkvYW9wNWJDYVJqZFhFVHlGY0ZaY3BnWlBPVHhqcjZWdHpjMnJqZDkxZjhBNGIvaGh1bnJxWk1VNWt2QVlvbWEzZk81eVI4eDc4SHAwOWF0dzJhcmRyUEE4Y01yWkVrWStZNDZrZm1CMnBOUWgwdXdpdG9VZUszU1poSU41QUlQWHAzNmpyV3JEWlJNaTNCaldSWXg4ckFCZnh6MUZPcFZzbExYWFQxTk9YVFVDU1VKem55M0NNcmNFbjM3WXgrRlUzdjR4S1k3cG1pQnppVFlNZnA3a1UyRzlqYTVkdHNMcnYyaytZQWVNOGhhVVhKczdnWFBsemtxMlI1aW5ibjh5QWVNK21QcFVxbloya3RUTitUSVk3Q1M1bmxtU001RGNTU0RDNHgxQXoxSkJwYis5U1MyZ3RSQkVrY1dkekoxa3prL05SYTYzSnN4SmRTR0lvV1dQY0FjTXhJenp6OWZhcXNkdzBvWml1d000RzhOeHllZmZ0L090M3pLVFNXaG1wSnAzM0tJdjdLSlBLODh3eGROazZzcFhQT09SK3RWcDBuYVJKYmQ0TGdSSXhEaGdCSW5YREVlbmJQYzRyVXRuWjQ1WVZEZ0owSVRoZ2ZUMjZWVDFqVGJLV3hlOG1qV0c1aUl5K1ZReUhuS2tqazU0R2NjY2RlYTZxTW9xZHYrRC9rYzA0M1Z5T1dlMHUvQ1JieS9MdUFvWWxTTmpBdHo3NTZmclhMMjdQSnJNTGdZVll5TWRjREZUdmJ4cEJJcVRPSFZRUkRKR0N4M1l5ZDR3T0NlT09mMXF2T0pGdXBCQzdxcEdlTzR3Y2ZXdmF3c09STkxxYzFSdHRYTGtmTVR1ZTVKL1VuK3RYZExrYTB1ZHNDcEpMSmJtRisyTTg4ZWgrYjMvR3N5QTV0bmpIQlJzRCtkTzBPNHVyZWE1V1hLVDJreVNOTnZBUFB5OGZvUWM5cXVxdTcvQUtlaE1kenFkT2t2a1RFVmg5cWtMcktKQ001eGtFYmNqUFk4L3dCMnFhWGRsSmZ4dzNkczZSUm5kTXlSN0RHV0E2azlPM2IrdGJOcFpDNnVsUi9FZXF4b0YrK3VYQk83N3E3Um5rWndmOGlxZkIxczE0NTFEVjdrMjgyVlZWak8rYkk0SlpreG4xSFBjNTdWNUxxd1VMemxvdGxyZjdySFlvMzJOKy9zTGF5MCtDNXM3aWVkUW01UkxDVllnamphUm4zNTloMTRGVmRBaGw4dFNwRENRN2pDd0pIWE9XQjZjanA2WXJMaDhDVGFUSkhMNGMxUytzWm1ZZVlsNU1wVmhrYzRVRE9NanB1RmJVZmlQV2RFWVFlSUxCSUVCd0wyM2Jjajd2bDNkZnUrdkg1ZEt3clU0MVU1MFdtdkxSL2Q1K1JjZE5HdFRxTGUzWVc4QWNGUkNTaW9rbU1wa2NIK1ZWcDV3V1piWUlvMjhSUnJsbWJ2bmpwZzlmZXN5NjFTMGoxTTJweTk1R0N1ejVnZHJZK1lEQkdPT29QYkhYTlhyVkNKM2tXYklZNGJxdnAyNzlLOE9VT1gzcEcrclBOL2lOZk5jM3RqYU5HWVVkUFBmTEZzSGtkejJ3ZU9PYTRNcTEvZHFpS1Fnd2tZNjk4QWZYbk5lai9FUFJydlZyL3o3V01QOW5qQktBWWQxT09RUHlINGZqWEQ2WHA5M0RyR250Y1cwc1VienhsZk1RcUNvT1RnOSs5Zlg1ZlVnc05HejFTMlBNcnhsenZzZXdYVXpRMjRlS09KQ0ZFUStRNFBiT1BUR0taQ0pWdW8vd0RTQUZCSlVNT1B6NmsvNDFKZXNsMUNycVRrdmhFWTdpQWVjK3hPUDUrbFJ4eVFwbVE5VHh1SFJEbms0N2RxK2Z2ZGJHN2d6VnQ1YkM2Q3lJck93Qk9ISXdlT2M1R2FlMXE1WEJLeEpzTzBQMEkybkE3bnFjZlQ4S3BBM1ZwYnl4TW01V1k3V3lPbk9PNTlmNlZJWjU4R0tPVEcwSEtuR01rRTU1OWZXc25kZFI4cXRxT1dNVzF1RXV0cDg5VDVhaHZtUWtkc0E5T1RucHhWL1M3bVdIUzVKTGw3cVZKQjVJajJZZFZJKzl6MUl5YzhWRGFSeXl4TXNvUjVHVStXYzR5RG5BeitudU0weTNtUzJ1NHJaWUdWanVhU044OGxUeHRIZnFPbVB3b29WWnduZUNUWnBhTGpabE9QUjU1TGlHYVdQa25Nc3pMa2dFSFBHRDBKL0RKNlYwVUU4ZDhrSjhweDVZQi9lSU54eHhucDFOV3JTR1NiNWZMQXRpRG1RQWRBZW4wNHgrRlVMeHhhWEdZNDFYY1dHOVQ4dUFNOGtEajhhcXZUeENqckhUdjVmNWVaTVhDKzR6VlpKWXhHdHZNSUN6N1dmYnU3WkE2ajBQcitGVTJ2WlJvOE03ekNVcjgvbUtNSEgzVGxRZlRJL0NySW1aMEZ6SEFrcW5EZVlYeVI3Z1lJN2RxaVMrZ3RrVVhEdnVWUVFzdjNtR2MvNGZwV1VaVzBzWGREZE1uRU1Ud29ka2U3YkdvSzhrY2JpTTlUMS9LcDdXNWVTOGZaa3ptTUI0OG5CNmpnbnZ6MzU0cXJhQmxrblJZdjlVd2VOZ01iZ2YxNDR6OWFzdEZiVzg1bmpEQzVsd0N4WFB6RHJnOXU1UDByS3RLTG03bDIwMExEMzNrQTVqeHprNUhYT0R4bkhQOEFoV09ibFpOVjIyaXRLWTR5MnlNYmQ0SlB5OG5uMzQ2Z1ZZdWJ1NGFYYkVqQjUxOGphMlZ3UnVLa0h0MUp6N1ZaRm9rMDhublBFOEpDK2NTYzVJUlI2ZjNpNXlCMkhTdDZXSGdveWtwTDV2OEFyekk1K2pSbUMvOEF0WnhKTEo1Z0lQVGF1Y0RxZU9jNEJIRldGc0VZWmp2a2hNYS9ONXd5Qm4rNmM4SGs0Nmdlbk5VWjdXMHN0Um11TGRTOGdKQ1JmM01meGM4NFBQdnhucGswN1RkTnVadFJ1RGZLRlhJSzdaT0hYSEo2L3dBL3lvZE5SOTZMMC9yb0hNOWpVZ1ZZRndzZnlLdnl5dk9XVUx3Qno5UjNBSDg2YmV4eVlodDBVU0M0WUU5TnpMMVlZR0IwR01uMXJTaVczaXRpME1POExnSEM0R09nSnFsZHdEKzJMYTRTZFlrYUtYZEhKbFFmdTVJK3B4d08vcm1ra3FyWEpHenQxNmxSazFxem5QRWwzREhyZW1iWlFFWlpWbmZPZGk1VW44YXBTYVpMTDRnL2NLa0xwYjVrV1FqWXBZbmFHUHJoU1NlaDQ3VS9YMFMvOFc2WkRIa2JVTWp1bkhHYzljZGZsNHJwTkZqdEZzWlpaNGl6VHNqQWM1ZGNZeWVjL2RHUHhycm9OUmhDK2wxL24vWDNGeWNranpYeG5jSTNpS09LemhTNm1FS3RMKzdaUnZJT1FRRHdCamtqODY3bTZnczVyYUsxRUR4SVZWWkl4S1Nyc3VNa0hzcC9DdU92NEx0L0c3M1VOdVJHOG9CK1VINU1ZWVk1eGxkdytwcnNwNTdtU1ZWVUliV2VOU3Zsb3BKYkp5Q2VucDA2VjE0MnU1VTQ4dHRrL01tbkhYY29SMmF3emZadHF4QmR6SUQ5ekI3bjZFNXBMeDRiZUF6aDJDcWgyU0xneGxzY0hIWHJqRlc1VXVJWkdNa2FBNXhFY3RsbDQ2SGNjZGV1T2ZhczdVWW81amJ4QmlZY0NLTVBuSUhmZ2UyN24yL0d2Tmg3N1RreTVSZDlCVEVJMGp0SkNDaTRURVo0QjQvSC93RFhXYnFlbkMybEpqUmpFNDNDVjRobG05T1QxNi9wV2pKRWxvNXRnak5Hd1VwTXpBeHFDTWs5YzVHUC9yMC9GbEpaTTVrbWFIYXpBOGtMejdjNDUvU3RJemNIZmU1bkttcEl3UExuc1pZYk84S0x2RzZKOTV3NCt2cU9tUDUxQmV5clBMQnBjZ1BscTRsbkdUa0tNOGZsL091MzFLRFM5Y3NGTUxCb0psR3hrKzVucmtEcU92T01aUFd1SjhNV0U5MmJocGtkOXo3SGt3ZjRRTURPTzNwOUs3NlVvMUU2aTBhL1B1Yzg0eWk3ZHlwZDMwRzI2dG1oUXlTN1RHMndCa0lISkhwa2NFZTlaTVR0Y1hkeEtGSmlSUEtSaDBKNm1yVXVsekxKY2FnNkZkcEtzMlJnTXpjbnJ6V2ZHclc5OHR2SEkzbFJETExqZ3NkcC93QUs5bkRLUEswbmM1Wk9UZXBhaFFxc3JENWNuUFgyQnovUDhxNldKNUpMYTZXZXlMNzE4dHBZRkQ0SFVjWkJQUFBUdlhPQmppVlQxQ2ZxTTFlMFlMYlgwVi9GSE5KR3hLelFxd0dlcThlcEJISFBYMnJERlI1N2EyWnJCcEhVK0hiMjM4aXprbml1SkRBeDgySlVJT2VtUmdld3lEVzlOcldtNnRPd2dpYU5Ga1Rja2liV0EzREgxNkgrdGVmdmVQOEFhbnVvbk1Vcm5JUURHQ01kUjN6am4vOEFWVng5WFM2aVNUeUZndlIzWE9HTzdQZi9BQTdDdUN2aHVlTHNyWDErWnZDU2pKSG9qYmJ4bmpsWlRIRWpDRkpGQllranFvUGZQVHJVT3BEU0RZeExmUXFySzUvZXhzUW9HTWNCZW5CUFB2M3JpN1MvbWVMRDNleG8yeTBiTWZuR000emc0emoycm9yT1MzdjdhVkQ1ZnpJQ2hoUVo1STY1UDQ1L3hyekhUcTAvZHY4QTE2OVBrYmFiaEVkS3VyeUNlV0ZibVJGSzI5M0tuN3hoazVROXM5Y2ZqK0xyaVZyVzlIbkJHaE1oUVBFM1RIM2M4L2djWjZkY1V0enA5aHNpZnlYZGorN0t4Z25CSFJnT1A3dmJIYXFubVNKSXR0c2xhR2ZoWlpPb1BVQmlPcC8ydXA5TTlWSktXdS8rWGwvWFFxTjltYU1waG10SW5XQWVReEF3NHlTMjRISlAxcmpkY3VQdEhqYXhzbWhLVzBibDEzQmx6bE10ak9Cakk3Y2ZpVFd2YXhhbkJmVENHZU9heTNGdkxNbUdEWTRBSFR1Y2VvL01ZT3BhYnFxYS9hWG9uYTg4bjVXVW9FZU5DTURkanIzQkk5T2Ezd2ROUnF5dkpiTzN6L1V6bk50YkhWSVZGNm9tWjBLa2VXU2NoajNQQXlmNHZwK0ZTeldIa1R1alE1Y0RjeXErUU80N1lPY0U4Wi9DcVduM2kvWW1ieVk4dUZWWGNaZU1qcmpyenoyL0ROU202alE1YjdwTGJXSUkzRVovVE5aMmxCN0dVcWllNkxGb3ViY1FUU0VOSjhxL055T01lbkhVYy96cTdhMnNhMzhVVWpLaUJRL21idnZFL1hxY0U0eFZPSzlSTS91MExmTnV5K2NIMUdjZDhqdi9BQ3BMdlV3OXkwU3V4YllDckxqNVNSeDBBL0NwczNxVEdTV3FOeTFudFpMcVcyaGFOdHI3U3hPR0FEYmowNEI0Nll4VXAwOXA5UW1uaGxTNEp4bHlnWDVSamtIOGNmNU5Zc1VYMkFyOW11aTI4WWxhUkFOdVRnRGduUEE1NmR1dGJWaFBENGZrKzJYTU1zcVhLN0NRUGxVWlBRbms1Njg4OFk3VjJZZWtwemNaYkxWdGRtVEtvMHREc283Q0ZMT0lKQ21VajJxcEdSakhJeDcxNWxxbHkrbDNWeGF5ZVlyZWF6UmdET3c5aGtkUmpqMitsZW1hYnF0dnFLS2JjUGpHZVJ3UHhya3ZFMWphejZ2S2JtK2RWYnl3VlVmZHlTT1RuT1IxSDQrdGUxanFjYTlDUEk5UHVPZWhKeG03bkh3YTJidVlUdmNtT0ZGVGFWQkJmazQ2ZGUvK1R5UStJWmJtY1dVOFVjb21ZcUpBKzNHVDF6akk1cTFONFBTM2p2eklXdVoxL3dDUGNJQnRmSkp5VGtad2Z6SStsTGErRllvR2U3dUpFaWhVQm1DdGc1NXlNajdxOThmV3ZCcjA2TUl1VGxkOXVwMXBYc2tYM3VsczQ0NXJTVXl3cElzYzJDRGdIam4weDF6OUtrMUc1Q2FlV2R3NFVlYW5HMEhqa2J2VWpkMC93ckd2Tkx0THExRWxsT0V0blIySTNNZHpIN3B5TWtqMkZKcEdsTjRsZysycE5kczhaM2dpVFltTW5KSG9NcWV3SjcxejBjSEd0NzBidTIrbXZvYk9mS2pRaTFpTzZsbmk4bVlmWjVHVWx0ckRQUEl4bjh2d3FlR1dlWkdpaG1BaWJJMlNBZCsrT2ZiOEQyNlZSdXJnMmxyYVd5Umg1MGNSSkh1QzVRbklPZS9USDRIcldqY0tNbkQ1Q2tqTVpIVDAvcDAvclhQVjVGSzhGWk1wSjIxSTFNeGpkR0hrWFcvRFBFVkpJeUNEa2pqSzQ2OTZqTTYyNnEwRXNpVzUrUzVWdXJKOTRGY0RqSGNaNlp4MHdSSUo1MmxlSWxsNEFqSXdaRDNBUHIyNmV2TmFkdGEyOXRpU1hKY0x3V1hrRUU1NTZlM1duN1pVbTNEOENHbTl5N1kzVjljSVdraUV0b1R1THNNNEFQQjY4anY2ZmxRN1crcGEzcHlLcDhxVUZ6RmtCVjRVNEh2a2Y1NjFoenFscHFXTU95WERZMkhjRkFPV3lGUFRKR0QxSEkvSFg4bVZ0UzBtNmFOWXlMb1J0SUd4dURLMkJqOHE3c05WbE9VYWNGZFBlL1l6a3VXOHRqbmZGMTRscjRudWx0SUpFYUd4a3dFYmFCbGNjZ2VoWUhQc09PSzA5QzBraUtiVDF1RmgreXhEZHp1d29IYkgwRlpPcjJMNnY0cThVVFFUTkpGYkpIQ1VZL2VPVUJCT09uN3MvcCtMUEViVFRtNWowdUJrU1ZUR29aZW5xVG5qOGY2MTZWZWpSaFBscTZxK3c0eW0wdVU1Znd0cTQxUFhQc2x5aXBtTmlMbTYyWkJIM0ZCd0FPY2R6K0hXdTNzNGswcEwxL21WSkZLNTJaSVlNQ1QxeVB3OU05YTVleWhoZUdlMWlzdnM0VGFrclo4d2wrdnlrZENPRG5JNVBHT1JUOVBzM2E5WlV1R2U2TFliemp1UjhkQzQ5TVk3MXoxS2xIbjVvcmx0ODlEWDN0bTdtaks2U3JQNThzRDdUOGtTZHo2azV3QjBxaWl4WEYxQ1lIajJDQm1TTmczQjQ3bmpPQ2ZVVXR4QmMyTWd1SVBzZ3RacEFKSUlrS2drNEJBM2UvVEp4NzAyMlMxL3RHUXRMOWxkVVVyRXdCendjTGdjOVNCK0ZjdnM0M2ZzOXVuL0FBeHRlK3JKSTRiVm4yaVl1cUV1OFVoNFVIcG50eHovQUpGTlpiZVdVMmx3QXNBWU1QTFRHUWVldlA4QU1Db1pyT1kyUG5USys1NWQ4Z1RhVGpwaFR4MDRISEdSNzhUd3pYQmhraHRYRDQ1SU1aM0tEakpPY0VZNmNaSE5STk5mYS80QkRhYnNZSGgxWnJmV0xqUzlJYy9abzFMTVpRSDJPQ0ZQSGZJeDZjNTVyZjA2ZUhSNHRRV09hVnlMdHhOZ0FBRTR5TWM4QWpybnQrRlYvRGk2VWtkN0xZUXhydlVxaysxaHRrSFQ3dnl0anJnNEJ6elZhQU11bDZ5N0laNUhjRnBpUU1GdXVSM3pubkhldlRxMG8xYjY2dTNyOHpDTW5GR3hxR3NhYU5QVHpZYmVkSlJ3a2tZWEpPVDk3R0I5VGpwWG16QzNNbDFjMjBNaVJLNXlzclp3ZnI5Umo4UGZGZGRyWWNhUjlsYkRKSHMyTUZJTEtQOEFaK3B4K0ZjcGJ4cTFoTGJCZ1N6Zkt3WFBVOWNmNTZWMDVmaDFSaTJtOVRMRTFPZDJzT3NiV2ZVTFV2QXJPcERLemRCbnZ6MHJvdE8wNkpiUDdBand3dGs3VURkV0hINGs4OVBUTmMwYmN3MjgwSFJNZnU4c0NPYzVBR2FOSWx2N0tBUzNUbG84S29KR0dUQTlmOGZRVnBpNlU1eDkxN2RET25OUmVxTzJ1OUV1NzJ3aXVJb0dIbE1JbVpjblpqc1FPbnJ4V0JOYk5HOGlzV2psakxKTkM0NUJIYm5wZ0RwN0N1bHRMRDdUcHNjNVY1Mm5CQVdTVGR1empHM3R6MnptdWIxVzFiVHI5OExMRUdCWlRMd3dYcUNjZHpnMXg0YU40T0s2ZjB6V3FyYXBibDNTSnJtMWd1WVk0b0p6Y0ZkMjVmblRHZWhPQjBKR0NjZCt3cTdaM2tOdVZ1Q3NrY1FiYSs1VHRIVG9PeE9mL3Jtc0t5dVdtTWNSVVl3Rnl2WEJHUURqMHEwb2x1b1pJaWN3anN5NHdmcldWZUVwTzA5Z2hOUlZ6cVlMK0tkWlBzc2hXRWc3Z3E3aXVQZm9PK2FqMWFhSk5Ia004aDJqR0cyZmR6L0VNRHNSK2VLNXF6U2FGSkxocHNJbUN6RUU0VTlPZ3grSGJIZW80WnJuVW1TZVl6Q0pYRFJ4dXB3K0R3eEdQZjhBRHJYUEhDeGpQbVQwUnNxcmNWYmMxSDFHNHVKTFk2a2hzQXR1TjBpa2x5eDY1SDREM0hyMXJwdEpqaWEzWkliak84RXNRTU0yRHprNHlUajE1cm5ydTB1SlZ0L1BKTnRJMlFKOGJkdzdIR1A4OWhWMjF0ZnNHb0NaWGFVRWM1YkNsVDBKeG5rYzFoWDVKd3NuYjAyS2cybTdtdHAraFFyWnpyTE83c2tubUJ2YkhRajA0ckkxV1dPWFZGZ3RvbGhnVkFHS0hxd0h6WVBQWC9QV3RXQ3h1cGJKemJFdzNEdnRNaGxKRHFUMUl3YzhZK21LaWswcDNTMWcrWXNrVzExS2pHUWNkVCtKOSt0UlNxcjNuT2R3cTArWkpKRWRqSmJLY3JHclkzZk96QmM0Nmpuc2NmblZPZVpZQ3pScnNjTHZFckxuSTY5RDB3QUJVaDBpNVJwb2JpM1ZrTWdRT1RrTHgxNjVBOS84S21iU3JxTmZKV1FOQkVNa28zTEVqci90ZEFmeXFvMUtTZCtZeDVKdFdhSUxhUUV5U3ZPQXhCRE51TEtUMC9QbmpuMTlLNjdTZkVzdW92WndKNWFoVDVhVFBGa0VZNUgxNDYxeE1WdjVjaUdWTUtRUXBISng2K21QNlZ2V04zWlJXaVc4V2xySUxoOHlzWCtaRjQ0VEFHT01uQjR6WFpoS2thZFJ5Y3JMOHpDVVcxYTJwMWtFNjJjZ0oxWGRHR1pXZ2dHZHpjZ3FwSGNmaFZNYW0xOWZUQ0F2TGJrbGQrZm1BQk9RZXBIcC9rVm1KcDhjOTM5b2d0NXZzamgzYzV3UzIzc2NjRFBKNTlheWI2d3VaSnMyMHJJRjVKWTdVNEhiOE9POVJqc1Y3VzFLTHNyNzZtbEduWjNaMU85MnlZOW14ZXdIQ2lxa2c4K0lBa0hzVkNkY2tnbm5qdFZXeHNVdDVHazhrazR3d1FZVnNkRDFGV0k0RlJ5dTZPUERZWXF2SXh6ei93RFhyd3BSVVpQVzUxTFVyTGJXOXU4SzdTdmxIWW1EZ0RqZ1k5TzFLTm1tNnFCNVVTUjNlRkxLUUFHQUpQUGNFWk9PeEI5YVpjdW9tRE1oYUlIS3lodHhCOU52cnpSRVZ2Q1VhTVFnRldUTGdxMk9qTDZISSt2VDFyUlh0ZDdQY3JUb1FhN2EzdjhBYWxnOW9yaEJLVE1RbTRFQldaYzRIUUVuOHhXbkxwa2trU1FwTE1HSUlrZGNaMjk4OGRUbnFQVTBsZ2J4cFlpc3UxdDcrWjVneVdYa0FkZU8xUWFwckFzTG1PTlZaMGNiU3Fna3J6MUhxUFg2anBVT1ZTVGpUaHVoSVNWMWtpVVJSaUNHQm1YY3dJVWtZNUF4a2dmbFZxdzFHS1JXeEdGbFpBNTNPY2VuWCtuYm5OVUo3aVV3QzQ4cG9wUzVTUEh6a0UvS1d3RDBQSDA5TTFIcGRuZFEzbHdXa1laalZWaDZBcVNSeWZYT1Q3RDYxZnNsS20zSjdCZld4ZXU0b0wrTnhNcGpja0FTQVp3d0Iyc0Q2NXhUemZRM09qeFMzTWF1OXV3a01ha1paa09kdVQyTzNBOWlEVVF0cFd2bVl3cDVRaFVrb2NnTms1NUhIZnZXSnErZFBGMFM4bTI3amVWTjVBMmxVeDBISEtnZS9IcWEzdzBXbWtudHIvWDlkQ0pSRjhLNnRQcWw1cUFzWllyT3drdXZQdW0yZ3RJRDkySlNlZys4U2ZmM3FyNDF2TGJTZkp2WnBQUGdsWUtMZFdIT0NDVytnNEgxSTlLdC9EbUNLRFJ2S3lBWnBYbExnRWtZSVhKOXVQMHJqUGk3ZHd6YXRhMjBEbG80WXp0STZja2R2b0JYdHFOVEZZdEthOTFOcit2bVl6azZjVzF1ZEg0Rlo3eXd2citPQXcrZEx1ZzJ2L0FDUnpuSVkvTHlmcld3RkszVGVSTkdHUlZFbVUyQnVlM1BCeDAvcFhMZUZkTDFDSHc5QkMycFQyNE1hT0lsUUxoV0x1TU50Snh6NjlXK21OV0N4c1k1STdxWHpaSFNTTStaTElaTnB6MlVuQTlhNThSaC93Qi9KMzMyNjZHbEtiNVZjMExxNXNyaytWYzU0VXlUdjV4K1ZUZ2NqanFQUVk1QnFscDZTWHQ1dWFPQ2NCWEFNM3piMVJGVWR1Y2pKL0drMVl2cU5yS3NjY2JNNnFHM0xnUnRsUTJRRHg5M0l4K1ZVTk11VHBtck00TWs0bURnaU52bVJpd3hoaDFPQU92b2VPYUtWQ2svZHY1ZjhNYTg3dHNiZW82ZkxhUkcwbWpqaDNydmlXTUU0QkdlQ09NRHYyRlI2YnBjdDdDWjJBK3pPQ0RKSDhqTWMrbmNacGJ1L0VsbnZhOFZwOE1HMmtkLzRRY2pBSkhwNzFGQmZYTmxieVRLN0NKZ1I1WjVKK1lFRVp4MTNIcDdtc1pVMUp0VW5iWHFOSzJzdFdFVmlzVS9ueFhKYmNvd0UrVFlSbk9NZmo5UGV1WDFHMm5tMU1Xc1FUYThvWWJEeXc2dGs5Ui8rdjJybzdNSVZQN3lVaVFiVmtjRURQVGtucGptbzlGMDliSzRhVlM1dVFuTXVkK0NlblhHT24rZWxhNFdYSk84M29aeWltdERMMWxyTDdPMXN5eTJkOUV3U1MxbmtabWJuTzc1aWNnK285YTVrU3lSUlM3WnBOMjl1QWNESEhwWGU2N00rcVcxelBjTEhHOFNqQ3lqTE50SEFVNU9jYy9qWEJJcStXV1VGdzdNV3dlVkhQOEE5Yjg2OW5DdUxpK1YzUngxRTA5U3BOcWNNTXlUTXUyUXRrbFZBT09oR2NkT2FxUTZsSS9tUkxJVW1RbFFaQVdVajZqcCtWUDFPMmlZSVZoWmx4Z3M3aU1maG52K1A0VlNrc1JjeUFiTGtGZ1dCREIxSGZnWUdjK3hydFNpMWRtTGNrOUQxbnd2ZHk2NW9nMDlMQkpyaU5GRDNFUldJS1N3d0ZJeG5kMHoxNzgxRjRsaGprMVdVU0phK1V5Q0NNUnFHS3NBTWdja25uT01rKzNBeFZUNGZRbXloa2ltQmt0N1p5Ym1XTWxXanhuREE4SGFNODl1aFBIWG92RWxuWlE2bEpiYVhlaTZJWVhNSWJheWtIR1ZVajczZmozSDQ4OVNQTEQzTkZmVTZGSnRybU9ITysybFdaSkdUWXczWTZydEcwOWYvcmRlOVRXMXhPVExheFRveU1wa1FNNnFwSGZ0eU1BNXdSOVJTK0tKN2VlOGl1cksyTm5ES21YaVJ0M1Rodnd6amcvM3MxQm8wc1dyTk5MUGNGV3RsVC9SbUEyU3FpaklKNm5vRGc5L1UxelNwYzBidlVyVytoTHBWaGRYMXVsMDRLMis0Qkl3R0c5Z01xeEdPZ0JHUFhQNDFxeHdSeXJMOXBnSlpzbCtTQ1RuakRBK25ZOGNIOGR1T2RacnFTYVRZdHpJekdXTkZ3RW1UY1Y0OUNNZysyQldWYlNCa1c1UzZFa3NtNG1KV0xiTXNkdkk0L1BtdktyVGxKdVMyTm94U1JjbUtHQzNoVjNLeVpZZ2pkdlA4SkhPT1BZOU92b0tRbk1PcE03RUZrWDVrakp5UmpybjA3WTdZTlN4M2VkdHZPNks3TVdWbitUR0JrOUIwNFBTbjNFWWVWTnFpRm95V0M4N2dNWndPbkI5RDlhNWxwZFNORzFhNk5pMG5Fc2NrVHJKSEpnRWd1dzJuUEE1NTc5NlgrMEd0N2xjS3NpTVFneXdCempPT2ZyVkxUTCtlV1JQdEVUc09RSm40eGpIZlBVZWxXMDFBdmN6L1puU1VLdTFrYjdwUE9UanNlbGNjNmRtMDBhUms3WFErOG5ubldOMzNRU29Udkt0MVg2bkgrZlNuSXhraFlSd3l5QWZ2RWRaTUIrblFaOU8xWkY4MHNjaWdNc081bGtSMkpBOHZQY1o5eitsYVZuZjJMS2tjMDhZa0RmS1dZcWk5eG5HVCtIdU9POVdxRHNsRmYxL1htT012dFhNVmwrdzNza2x6dUJNbVVFaTh1Q2VtUjNycFk5SXM5UmRMcUs4aWpralFTZVFBTnc3SGtIQkgrUE5SWE9tUTMyb1Iyc2x5c3pCa2QwRGJjRE9SalBiSXhXL3AyblF6V0VzZHRJeWxpV0RFbkE1d09md3grRmQ5TG1mTkd5djEvNEJ6VktVWXJtSzhWMUhFVldIQ1J0a0FNUHZaNzRIdlVWMy9aYXpSWE0wSUU3QW9yK1pnSEhVSEhjSCtkTXVMUDdOYTdXRHlESkR5SVFIWG5BS2c5dVJYTnk2UEpEYmJHRFJ1R09KQzVPd0U5U2VCeVNXeFhGR2o3MTdoMDFOeUtXeHVVUUkvd0JuUjJFYUkrZm1ZOVFNOCtoei9oVWtzTnhOYm0yKzB6SUJoV0NjQWduMTYva2ZhbzlLbGc4N3kxaVo1MCtWN2tyd1Rqa1o1Nm5QR2V4clRtdFpKQmxkaWhpV1lMZ0J2NjF5VlpLTS93RE0wanF0VG0zMFYxdmwzVzF6SUd3aVlrSkdjZENEd01DdWdndG83YUpZTVJOT21JMlZTWHdNNU9TVGtjZjU3VnBJN3BIZ2JNNVlsUXVBTS9qV1hmMmRySXpHVmNLNEpMa2NudjEvd29sWDUvZGJIR05pdmNmdTNlZmRHWVB2UmduRCtZTWNjZ25IWHBnOGRLcDNBMUc1VWlPT0lSa2h2TlFrc3ZBeGpJNjU5UWVnOWVMbjJaelBieUkwWXQwUm9uVmY0MTR4ejJQK05XSGUweXNNaFZZejhxNWJhQ1NlQVAxK2xOU3MxeXEvOWZtVmErNDhTeVNiSW9jUUtoSDhJWU1PNFBwelU4MjJkZDhzaGpsSkhJWUhQUEFQNTRxcy9sd3h1c1g3dHhsU1ErQm44K085WmR4ZVJYVnpBampjeGNHVHl3Q1FWSElHZmw2Z1pIdlJDbTZqOGc1ZE5DNUlsNEp5b3hKR1JsbFg3eWdZSEhHT2NkRG52eldUNGlTSzY4TzNZbUVHNHd0TEJJeGJLZE9UL3dBQ1BRY2RLdlNhamNOZktJTU1GWUh5MGx5ekE4SFBCQXdNSHIxcm12R090VHBvMXhCTkVrY2N6S0NWZkxEQkJ3UmprOU9mMU5kK0dvVk9lTGozUXBXdHFhL2hOSllQRHVsdWx5STVSdVpsMmdISllrSE9NL2dmZXZPdkYxMWRYL2l1NWpqWUZCS0l4SkdBcGR1QVFDUG1ZNXlPdjVWMEduelhNdW0ySWtsbWpSWXNva2NUS2NNT0NXQTZuMjk2NDNRNFRjK01MTzR1Q2RnbTgxaTA0YkdNc005K3Rldmc0U2hVcVZKU3ZhK2h6Vm5kS01VZHpaWEY4NnVzUmxYTzFVVjN3RjRIT01Fa2M5UHdyUnU3alVudEdqa2tpMmVVNFFCQnU5MXpnOFpQY0Q2K2hERWkzVXJXUmlsUjVPWGpaWElJSEFJNkFESHQzOUtxYXZGOWhmZE5JUUdjQ1ZRZHJqSU9TUFhudU0rK2NpdVQya3ZhV2lyWE5sRmN1cG5KQkxCQk1semN4dVpZdjNTeTduT2NxVDhtUGw2dGdrZXZIZXJGcGVOYjI4MjZJdzNNZHN3Q3h4OFp5TUJ1ZlFkODgrdE5jeFM2S3JYVHhlZXNiQmZwa2tISFhyNmR6VFlkeG11REczMmlNUktXWm5JTGNuMUo1eWVPdjUxdTVwNjlnYXNkSGNXME56RVpXdGpJVy9lRWhRQnlQUVorbnIvT3NxODAxYjI0WmJDMnRGd0NDeDQrYjBQUFA0Q283QzV2NXJHMmdpZFlWUWZKSVZCejI1STc0OVJWdU5ZMnVEYWZhUEtXUlhSMjhyTDcrT3hHUjNIdG11R05LcEdmS25kL2dhZTY0dHNtOFRtRFJaN0d5bmcyWE56Ym1hWlV5NFViaUJuYjE0QjU1Nm5IVE5aM2h5NmlFMXpEY3lxSGhmWXBJSkREbkl5Ty93QmEwTGJUTlBWalBxT2kzRTBjTWY3KzV0NUhBUk80TzFsSUh2akdDYzFnYWZwZW5OcU9zN3RZbnNiRzNjb2pSYldFaWt2Z0VNZWVGNis5ZTFLalJxd1Vsb245eXNjaWxLTDEzT3MxTzFnUGcvVU5TSVpKMmprTnVrUkczYVVMWVlESjRCVTl1dUs4anNyaHByb3N3T1dPNEVqSDhJSEg0cWE2TysxU1lGOU1oMVdmeUZWa1VYa0FRektWNllJN2c0NjU2WTdWemRtckdhU1pqdzNRZHh6L0FQWE5kbEtuR0NhU3NZVkpOdFhaYjFhMVc1MDU1Q1R2ak9WUHNlTVZqV0dwWGxySThOdThhd29wbGJ6Q1FwK1VmNEQvQVBWWFZSamRaT3BHY3FTZnlyTDBLeGh1SXRRbkhscklseHRWbVFNUU9lbWVPdU90S3BVakNtM0phRThyY3REdVBoUHFGemZ5WHBqaGQ3bDAyRTdka1NBZzVMTm5uQS9tUFN1b2dzYldLV0xUTDZGN2UxYktob0lsV2FLVU0yR1Z1V0l5U005dUFlOWNENGF1N1d3bmpXYXlMd3lvekdKSE1aT1NNWkk2SDFBQkdPM1N0eFpMVy8xU2E4TjlOYVhHVHZnRWUxR0cwWkJQMUJCeU1kL1lZKzJTUzVkTmZ3TGpIdVlmamJTQnA4Y2Q3YXRjM0ZxWkhKbG1oQ01qREc0WkJ3M3IyNmRLb2FmYVkwUk5RaURsWXQ1dVNrWkpLbHNsZ2ZZYzRQb2ExZkZGM2VMNGZpaW1pVkd0WnhtSW9FM3F3WUhJL0wxcXRwY1ZsZGVGbWdzN3p5YmlTV1JaTjMzRmpLQTRZajNCQVBxZnBTY2xPbTNzWEM2ZXBESmRQQmNGWTVqTWpxSGpjbmxTTVpYL0FHdW8vd0FpdENLVVEyaldxUXlpTzJoSm1LWk9QN3VPM0p3VGpISFRyVE5SU0JmQzFrWXlmdE85VmROcFlJL1hIdHdUeDN5ZmFwTk5oa2VDR2FZaEJJaXl0R092STlENzQvOEFyNXllT1Z1WG03Zm9kQzFkaXByOTh3bHRYQ3h2SGt6QVN1ZDQraHlDT00vbDI2MVNzdkVWKzB2bjNTcWQ4Z1g1aVRoVHhnRTlTQlduNHF3STdNZ3NWZU9SQXl0d3k3VjdaejFIZnBtc0NDVnhqYkN2bEo4enVSa3NmWDlNWlA2VnRTb3dsUlNjUmZhWjNOOUxMSHBjUXRtQ1NiKzU3Zmx6MUhKOUt0YWZjd3l3UEhPcUc0WWd5eUtTQVd4N2Y1TlpVZDJ0MUFyUmdKYjRHMlJ1ZStjNVBZZmx4MXJWc3ZLalpETVlsWkJ0Vnl3NllBR1ByL2s5SzhldEZRalpyVTFnMWExeUc3dklybFk0RUNndnZ6S3h3VVBzRDJINW1ydGpvME4vTWJlMmxWeVFwUUs0Mlo1Qjc4NC94cUc2bXRyMjRuSmtDSmJ4QXNpS01uSnhnRWpybWwwdDdxR2Y3RWpScWtvUDd3UjdUZ2NnWlhuci9XcWdyMmRyTHNUS3pWalgwNkZyQTNBanVZMFJTRkVnK1pnb3dRQWZyajIrYnYwclJ0TDdWTEdIQ3lySUNHVXhoUUN5amtzRjYrNTduUGZ2U2wwdVNhRlpCYk1vUHlGZGk0SkFPZXBIR0Y0d085T3NtbWtsaldFeXViZG44MVdMS0ZKeU1Zd01kZjUvV2xHVWxKOHBqSko2TVo5cXUybDh5S0FrYy9LVkFLNEhwalBUMXBpMnFTMmtvQlFkR0tnRGtBWjRHT3Y1ZWxUWEZ6TjlvT0FBeXVVVUszemNjSEdPZjg5S2ZiVzlrQ0ZrWUt6SFlOeHhuMC9wNjF6T29vUFZNY1lsYUJMbUV1OEc3eWNnS1U0SDQ5c25JclFrdlpMYTJTTzRhM2FWUVN4KzZHUHRrY24yelQyZHhDcFNHTUFEL1ZzQVFSNi9yVlpTYlpuWkkwRE5JQ3JSdUNEeDJ6bmordGNNcEtwSzlqWkt4TkhyY01rencvT3FBRGwxNUxIdGo4YW8zK3J2Yk1HaVZHWmlBcXFwSkp6NmVnSFA0R3E5M3FFRVYwMGNnQWxNWWZhZ0paaVMzRzdzZmxQT0R4VlNGNTdXOGtrYnlwRE1OZ2tVSDVQb1JuT1RqOHEwaFFpdmVhLzRKYTBXcGVzTmJpbUNzckFTc3EvS0dVOEU4Y1pIdlUzRWw2a24yU0o1U1NBNnQ4cWdqR0NCbm5qcjlhNTYvbmllOGllSm8wYmI1YU9pNVl5ZFNQbUh5OThkeGsxcnk2elBCWVFHR09JYjhHUnd1MGtyMTduanIxOURYU3FDNWswckppbEpKRnY3QzExRy93QnRuYUNBSXhUYkdDUzNQUWtZSFh0VUUxbGFXbXBpSVc5c0NBUExLc011QnlRd1k5ZU92LzE2b3g2emN5V2tkckpPWkVSQU54K1FLYzdsWFBUc1BmQjlUaXE4NU0wMXFXaWI3U2pTSEJCTFN0c0ozY2dBRGp2NzE2S3BwUlNYOWYxNWtKNjM2R3ZiNmpheVcxeDluS3JPVHVNYkRhVkp6anIwSElHUFVuam11SDhkenJlYnZKbGlkbVlGbGlYR0J5UmsvZ1NQcitXbnB3dVpKbFdkMWhSMmRaR01xNTNIblBZQTkrcHJPOFhORGI2Y3R2RGd0RmNxTi9RNXcvUHZ3UnllZnhyU2tveHJxeE1sZEUxeHFMd2FITkpCWklCSEJ0Vm9TV0lKQVVFNVAwNlovV3NEd1pHWWRabG1hVXh5SkVTb3h5TXNvL2x1NDlxMS9GK3BPMmhNZ2dTQkpQTEkyamx1QWM1L0QrWTlhelBCZHFzbGxkWGNySXBMaUpXWWNkQmtaOTl3cldMU3cwNXRic3htL3dCNGwyT3RzYldTU09kRVNObjgyUUsrTndYNTJ5TWQrU0R3ZS80MDdVV0VWbGcyc1NGTUxsTUw4dzY5czQ0UCtlYXIyMHBhQndIVlZFN3QwM0Q3eHhrWVA2YzFQTklMbTdYejVkc1NweHVZNEhIemJ2VW44ZWVuYXVCeTExNkd5bGJZeDdLMk54TEtrNnh4d0ltMmJMRWhEbHUzWHAvTVZ2V1dudzNkMWN3UlNRSXFRR1ZFRFpKUFBYbjM0em52eDJvdDR0UG1pSnNuTGhsMnVyTHlwWnNrNDZkaDE2WUhyVmkzMUtXd3VabWdWRWx1MDhvbnJ3T1NlT1B5Tkh0VktvbkphZGpUbGJpMHR6bkxaN2hyQkxVQmpLOGhoWEtrRlNTUXVUMjYxdFdXZ1MzVmpMSkhjb2tjTGJIVmpra3FHK283Wnlhck5xQzNlcEcybGlXY3ZLcmVZY3FjaE1Edno5MDlhMzdmWElOSTBzMi9sL0pMS0dWaWZ1RWJoa0RvT25QWGtmbDBVYWxGVHRVaSsvOEFWaUhDUzFpZEphWEdqSzl5OXpJMW0yM2JMR3lrTzRJN2dEQUJ6MDR4eFhqUWl0aDRrdmJlempEdTEyUHNNWlhjcC9lNENrWkhZKy9UdFhjU2VLTHk0dFk3S1JJNDBNRzBoVlU3d3VDQ2QyZWpBbXVOT2xpVFhvNXcyMjNqa1Y5eEdjWkFQR09lQ2ZyWHB1dlN2ZGJmZHVjeVVydTUwZmlWYjY3dC9NRnRHalFxc0RqenQrTVk1Q25ub3JkeU9ldGVjV2JxOEJZWkx2SXlxQVBjbitsZDlxV29Xa2x1enkzVFNTTEd5UXN6L2VWUmpvM1BmajZWNS9wMGJNaXNCeXBmajhUL0FJMWVHcXFwRnRLeEZTUEswalNhZFlyZG5aL2wyRVlIcWNZL3JXRm9rY3NsNHlyTThFTzkybFlES3lEKzZmMS9PcitvUm4reG9GaUkzeXk5TSt4cWxiWGQ3cGNUWFZ0YkxOQ1gzekl5NUFBT0JuMnozK2xielRkTnFPNW45clU2VFJkUGp0N1d6bnViOHE4cy9sSWhjamNwSlVFRHBqSEk2WS9LdlMxaWgxU08rYVNLYUxVNFkxV0s5aFFiM2ZKQVpnZUR3UUdKNjRyeUxTN29YdDVIcWQydm5UeHNHMktTcUtkbzJnRFA0L1VHdlRJcDROVHRJcFlYaXRJMWpJQjJuekhKQlA4QUQvQ1NPdlhKL0x6WE9jSjh1N2ZlMXZSZW05em9qR0VvbUQ0MXZ0V3U5SmxqMTYyamxtdDVWLzAyRElRakJHMHFBUUNUbnVCeDlLeU5DdEZodExrVER5NVlTckt3SHlsU3JiaGdkUWNiYytwNjhWNktiVzcwN05sZHh5UnRNcGtqSjVaZ2NnS3dIZk9PcDdkNjV6VDVOTGxzbzFhSU5QNVpSeU0vZEo1SjQ2ZmhXTmJGVktjYlNqMTF0K3E2ZjhFMmhUaTlVekMxVzVoZVNGMlUyNnFBQ0hQVkFQbHlHNS9FQTRCNzFhTjJrdWpRcGRzMFpXTlYyYmRoVW5vRG5xT0IySEE5YzQzTHA0ZDhaYVZXbVJQM1pFWnlHNEdWeHdlTTVIK1JYZFgxS0tVenhoYnBEMFZpQ3E5Z29QYlBmcldLeFNsRk8ybjlmZ2FLT3VwenQ5WTNyV2NGMklTNkJUSXFNNHlxbkJKQzkvenovS3NDYUxVTGd6MnFSWFVzOEtobUF0OXdRWTY0SGJGZHcxNWM2ZXRyWlFYRVlqalg1RktBa0xnakxEUFA1MU05eFp3TzB0eGNTeHllWGhwVVpWd0QwQkp5Ums1d1B3NTRyZUdMbERkSjloeW84eXZGbUo0ZXU3aVBRaktKc3pMTTBhQmh0N0RzZnhGYlZwSXBndTduQ21PSGFBeTRJT2NBaml1Rm52NEpVaTA4S0VSenlGQlBVNXowSEdNVjJHaTZkREZwTTJtN1dlM2sydjVrWERLd3p3Yzl1dlBhcXhITEJPYyt2NUVSZW5LaUJMK1dPZEg4dU1Uc3Fzbm5aSzhqQ2s0OUZPY1YybWg2ZENsbEtkVXVaTGk0dWdCdHdBZ0J5eTlpQWNIMXp5ZWVlZVR1dE9kM2VVQ1JvbzBBT1FPZ1BBUGZPQmo4YTJKYitTOGMvYVdFVWUwbFZVZS9RRHQyOVA2MXpUckwyZnVmOE1aTlA1SGFTUE04U3cyNG1HRjVLZ1k0L3VqSkovbFN3RzFFVTU4MXk4dTBzQVNOM1hCSTZIakhQVGp0V1RvMnJXOGl4K2V2bTdWNEpiYVNPT0IxL0hQcjFwK3JhcmJYTXVRb2lsQ0FEQWI1TUgyUFRIOC9wWE1xYVVPYUVyUzdCZld6UlN2YjJTZThhWm9HTXhJVkRzNUlHZWY2OXZ5cUczdUpwcEpKamJyRkVyWXkvSU9Cd2NmV3FTYXNUY0JodGpLbitGdnBqNi9yVEpKYnE5UlVmRWNaeVR1T0FSeHhudjcxbEtEazd6Tkl4ZXhkdU5XdUlyaHZLdHZQQVVsQXhWVkk0R1J6akJQZW9IdWI2TlpqSXBYZVF3R0ZPMGJlZ3dQYnQ2azFRKzJySW4zak50R0NrYTRIcms4Y2pHYWVKZnRGdVBQalZRbzJvVkJKYnRqMy93QTlLUFp4aDBMV3V4ZXQ3aG5LcWtBeVJnRWtNZm9lL2MrbE52SlpiZTRacFYrUUQ1RllBWlBIR09CN2o4YVo1Y3F4Zk5NRWxPMVFEeGdBK3Y4QSt2bjhhei9GR29YV25XMEt4UkdWM1B6U3M1SXo3ZS9VOGVoNHBVNmJuUGxqcmN0T3kxRmFaWTVXWnhLRVJ0NWx3U09jRGc5QUtCY1dodlBMbHR5WldsK1pRcDU0TG5EZEFjNHlQek5UYWJkZ2FlZDdiNDdsZHBFcDVBNmpIR2NkZWYxckwweVdhOTFPL3VtWmxYNW9VOHNxV0xaUldZanQ4cFBJNS9TdXVsUjFibHBiekpsSkxZNm0wZ2pONGs1Mm00TGpra3R0UFB6ZXVjZ2pyNjFGcjBicFBieXhTT0Nrdk0rUVdBS014Qjc0ejA5UDVvTGdwSzkxRmNlWGxpekRISElPQ3g3K240RHJTNmxmUVQ2ZGFOZFR1WkZuL2ViTTdnUEtmT0Q5Y0N0SXBieElHWHNrZW9pSDdOR3NVcTVkbmpCSmZnQWtuME9mcjA5NjQzeFZheTIxdkZieUlJeVpWa0p6eVQ4dy9USDY1NzEyMEZ0Qytxd3d4VHNZMmlrVkhWZ3BHY05zSHIzL0FKZGhYRitNc3hhcFl3UjNNVTJTTjRVcWNET09jRTRQWDh2ZXJvWDlxa2hTdFlvK0xycWIreE5QdHBtK2NndVZ6bkdNQWZwelYvd3JaeHA0WWlsZG16TVhmYU1Eb2NaL0lWek91UlQzR28zUlpnb1hKaWp6dTRISkdlMk9UZytvOWE2K3dna3R0TXRZbUxGb2xFYkkyZUNGRzdqakhyLytxdDhUSGt3OFlwOWJuT3RhamJMVmtzVWNqcTVaU0pKRmsrWGFVTzQ4Yy95OXFrQkRibzVDR0hxdzc1UC9BTmFxY1RQT1dPMHRtUmpsR0FKN25qbmpyemlwWm1qalpHMjVYL25vRkJVRUhqcjE2anIvQVBxODZVYnlOclBmb1NKTk5hQ1R5MkQ0akkrV1RCRGVuVDd2QTlQMHFsWlRYRjVLODhubHJJSkJJeXNjWitYQndQWGovd0RYVFlyb1JXdHhNc243MDdsOHZjQ1dYMXdja2MraEg1ZERRN2RydTVpaGhSNW1aVVVxcmtIazg1NzlzKzJLMVZPeWZmWUUydGgxNWdTUnlvQzZJSFp0eE9RbnFQeDVBK3RkRnBkall5YUpHOTNIRzhUdkd4ZFVKZU5WNjRJNEdlUjFQU3N5YWMybHhQSWs4TENFR0NQWWNnbkJ6ajhINms0NHFTeDF2VTlNMHVXeWdrUTJ6cXJwRXpjc2pudHp5QmtqR09BYzk2N0tTVUp4aSttNE4zUm12TFB0YmUwVWNDNTNGSkNYNXdRcGJIVEJ4M1BCNXBpWGEybXNXMXNqUnJBMHNaRWtoSkM1STVQNTgxWmt0b1k3cUtPTjkvbkttQ3d3T1FNOEgzNyszcFdacnRqTFplSUlyTzJraWVWRmpkU01vb0hYdVBhdEtQSk9welNXaU1wYWFJOU4xYlFOTzF1emFlM3QydFpKNWxqa1lSc3l0bGdybGUzRE4weitWZU94Z3c3MkIrWERmbVcveUs3cVR4SHJ0aHBBV1c4YWRiY200TzdraVRPUmtudGtaeDdtdURoSWtnWUp3U25Ucnljbit0ZGtLbEthYnByL0FJSms0dU5reXRkWENpM3RGSTRNckZjZW1DUDYxQ1EwbW5YVnVOalJyYXE3ZGlUdlU4SFB1YW5lM1FKRktTZmxBVUtmN3pBMC9Tb0htMWp5RWpNaTNWc1lBb3puSmp3TVlCOWYwN1ZzOW41RUxjNXVNeXhibHQzWW8zREhkZ1k5eFh1L2c2M3RwZkFHbWF5a2tuMnUzenUrWUZUc2tJWlNPNUtjZ0U5elhoOW5INU4wanRFOGtJUHpyR3d5UjBJN2l2WGZBTjNwOXBhYXJDalN6MmNlRkVTUVBnaDhIQks1QUlJYkdSejcwVkpRanJLTit0KzF2MUhUVW5zenNmRjBQOWlUeHltOWFXYTliSVljU0FxTWV2M2NISDZkNjRIN1hKRzg4R1EvNzBzcXN2eUFFL3k2bXRtSnpKc2p0UzBzKzdHWGI3cEI1Yk9SdDV4V2JmNlpkdzNycnRFVWdRbDVHR1RJYzlNajAvOEFyRE5mUDE2OGE4M0pxeDIwcVRpclhIL3V4ODZ4S1dCSVpnUU1uUEpVZEFQOEtMcWFXOUt1Z2pNbTRvaW43emNqSXordEpiL2FMeXdXQzJCdUpGQlZqTGdKR1RqcUI4MlIycWJ6NGdrU0pBUmNSSjVaTzRnTVZISngyeWNtdVp3YWxmZG9xWG1aY2dhNHRwQTBrYnF2N3o5NmdESEhZY2NuK1ZVcFRwMXhKSERQSE1yeXA1YU1JM1lEcjB4NmYxcXpkWFAycTVjbUpZajBPRzRQOTcrUi9QM05OdWJoTE9HTzRpZGVDUTN6Z0VFY0hIdjE0cnFpcFJ0eTlUUFZQUXZhaDRUczU0SkxrM01zNHlTMXd1R0M4Tjk0RHJ5VVAvQWUxV3JrWGtYbHpTTEM2NVdPT2FEK01EampuMDljVWxsZVhNdWt0SkpBaGpqWElkQVNWOVIrQS9UTlpsNWNTUTJJaWdsRERmdXdUeUIyNDdmaC9Xc2txczJvVGQ3TTBrNDdtNWJ5K2RhWElhTUpIdGJCa3lBV3oweUJ6MzQ5cWhTM2ljU1J3U0NXUU11MU1Fc0R6bkFIVDhSV1pwRi9MNThjY0U2aUlzUklwSitiQTlCMnp3ZVJ3ZnJYb09rSWtaZTRubnRyYVIyLzFldzdGSjZBWTRIQXowNzUrbWxQRE5PUkU2a2V4ekkweTlRQlBLSzdnQ1pDQ3hVRWtBNEhIcjN4K1hGbSswK0M1Z0VabGJQa21NdHQyODlzZ2NBODljbnZYVVhSdFB0TWZtT3hFWitWK09BZUQ5T24xNHF0cm1tUGU2YjVzZHRIRUFyQVNqQmFYMHh6MHJHbTV6NXVYUzN6RTNGV3NjWFpvdWtTaTR1MGprd296Z0JqMDQ2ZSs3SitsTmhqdXRXajgrTjJpV1JpUmtqSDgrT1JXakJFWkk4eUlzajdDaFJ4d0dCeHg3ZGpVVU4zUGNSTUVpUUlXWnZrTzFVR1RqNWZZZWxTNXRyYlZHalRsTFhZeklOT210eVdaSnBKTUZXQ1BubnJrZHMvVUVmMEJMTEVyS3dlT2RXd3FramorWlAvQU92RlRQZUFMY0xEdWFWTUVjL2VQMS9LbjNMa1dWMGdRQW5PV0p5U1FPRGpuOERWUG1iOTVGcEpMUXYyOGFXeXJJOGhCR1I5NFlidm5xZU90Vk5VMUMzRmlKaEZMY0hxcXhyd0RqR2VlT2g3OGNWbnhhaklaN3paQVZGdEdaMFVrRUl2UjFHZWNESXgxUEJ4MnF2ZDJVejMwTVhteUl1eEVXU05nQU53eUZVZXdJNXhqQXdNR2lPSHRQMzJKenN0RWRObVZORXRiZTZ0VVNiN0pHZG9iaHRvWGc4NHlEenh4emlzTHcwYndXQ2dreG1SaTIxa0Eyb2pyNjR6d2V2YzRyUmtudDRyQ0JwRjN0c1ZkNXlONUF4d08zUThkc1ZVc29JeFpib2VQSzNnN2o2a00zWC9BRHo3YzJxdnV5VnV2WWhwbzJJYmMzQjh1S1Jpak1DRlpzWXdNSHVjZE92dlZlOVNTYU9PTlNSR0dmQTZrQUl4eHlPdWNlbnQ3VTUxazAzVUlabWtYeUF5WVVJdzNISXgvRjE2OXZYcjFyU2d2STJ1N1ZuVVIvTVRHb1hPV0lQSi9wbjgrS2xTbEcwbnF1Z1I5NWFGaTEwOXAvc0xTdTVrZVFjVEU0VUJHeGpPTTlCblBmMklyaVBGOFlQakMxUkZWWFZWM3VnQUdkMmNqSGJITmRUZTMxeEwvd0FlY0VrN3d5SW8rZmFpdHV4dHp3Yzg5c2ozcmpOVmt1cFBFTTgxOUVrVElQdVpKVTRYcHo2ZDYzd3FuS2ZQTHQzL0FFSE5LMWpGQ3RkYTVFb2tlV2U4blZGWm0zTUk5MkNjK3BBeDlNK3RlalhXbXN5c0k3cVJFODFTWk1uQ29SeW9CeUIxeVA4QTlWZWMrRnQwL2lxS2VUSjhwWGxPQjB3dUIrR1NLOUExWHpYdEpweE00Z2xFTGJncEs1RGNqR00vaFd1WWN6cXhnbjAvVXh3OW1telBGcEVwRXNkeElKUktZM2RreVNDNUFHQ091QVB4Tk5nZ2hsaUlFZnpxU0NXWW5EQStoNDdjMHB2V01jbHJjelJySkV5QkR0S2xqd0FSeitKeDcvaXFmYUxhVzZobmdNTXprUzhuZ1pBempIK1BmNjFnMUt6MS9yK21iU3QyTVowQ1J1eStYRGdFc1NlcTU2ZjU5YXM2U3h1YnVPT01ScUpBRjJodU04akpLbkl4bi82MVZMTnJXNHViMFhja2tFSXlTNnJ2Ny94ZC93Q2Y0VkZwajJFTThvdUpDSTE1VjBBQTI5aVIyNjEwdU9qM3VpRkhzYVZ3OEt3eU9qQm5OdzNscXJIZ0RBTEgwR01mNXhuVWswTFZuMEtiVUdNS3ZhdHVNU2hRNEdjTVRuNWlPUU1jZHNkS3oyaXRGMDVmS2phV1luQVpNaDVHQjVKNU9CMDllOWExNjkwdWxYRFE3Vmd3clliK0JnVjQ0UDA5ZXBxUGFRVWw3dlV2a2ExdVdrdml0MURESHZzYmN6S2tweGdCUzRCSmIyNVBXcVB4TmgwKzU4V3hwcHFCaVlvNDVmS1RHNlFFZ1lIZkkyMUcwYzhzcVJUdnZhNFlna0RlK0QwSXgxNUo3OXF5N3BSTHJrSmtkbEluVVB0QXl1R0djZW95VGoyeFhWaEkremp5MnRmYzVxajVyUHNkUHJYaEc2Ynd1MnBHVWJKQXV3S1FRd2JPZVF3d1JqQkJCSFBxSzg2aWRnWDI0MjdSamFPTTRGZC9jNmpCYVdjOW0xM05MRzhDN1VQeXFyY0VncVNlT09EOUs0aytTa1lqMmpnZ0RqT09EL2grbGI0ZHg1ZVdLMFJuSjNkMlpNazBqelN3L3dETEpRZS9UR2NWSmFYRDJ6dzNFdUNnSXl2VW5CNUg1VlNFVHh2SzdFbjVtWGovQUQ3MHVvTlBMZHhSUkk3RXF4Q2daUDMySDlLN2JKNkdTYjNLTjNjcW1wVCtVcXNpeU5zYkgzaG5nODEzL3dBTzdxNXNiKzh0NFlRYmk3Z0RlUVRrL0t3d1cvNzZQSFhtdVNGdmJXRG1aM2o4NTF5aGM4THpqdGsrdlB0Z2VvditEYm55dkd0aHN1RTNTdDVSTWFrRDV1T3JZT2VRZnFCV09KanowWlJYWXFuN3MxYzllczdkNTJ2UWhSNW5VVEZwdHF1YzU1QjVBd1FSalAxTmN2NDhNMHNkc3VuM3MwOHl4RkZjSEJWU0ZQVURQNStsZE5lV05yQnFrRTdwTXlCU3JvWkMvd0F4eGhzNTlqMjllSzV6eERheEt6bWVDYTZ0MlFLU3dDcTdFOXU0T2Zmdlh6MUNwR05TUFU5Q1N2Y2JwTnZCUDRldC9KdUxwYjJMNVNRZjNnUEpJTFlJT2VldnAyNXF0SmVGYndJbDVMTTZrWmpRaDJmMXpnZHU0ck5zYlc4dDVIczdmeWtzYmpFcG1WMkd3WTV5dVJrOXV3clMwKzJWWlpQTURiZmxQbW5jQ0V6Z0hIZjlQcjY5YmhEbWV0MS9tUkc5a2pQMVBYWnJhVkdrdGtua0s0V0pGSU9OeHlUNkFEajZqanZWZUw3SERiaGZMUnp2M2dFRFp0S2c0STdkdW5Cem4yckQ4VlRYRnRxMHNaY01wQStaT0F3N2ZwaW5TeXVOSmh1SXp0bFErVmtFakpYcDM5R0dLN29VSVJoSGw2bWFsN3pUNkhlVytvUXBvMGZuRWlWa0tlV01MZytoSXhrVmszVi9hUlRTU3cyYXRHNjh3dW1WSUE2NTllZW9JL09tYVZCZVhrSG1neG9vZGtCbGlKd0FTT285eDZIRlVHa1dPYlpJdU5yakEyZmU2Y1pHTy9xTzlZVThQR01talNVdVpHL29Nc3Y5b0JyZTNTTllrYzR0enljODlTZlVqNlY2YkJQWndXejJsdEswMXdSODhUNExLTW5HeHVNSEdPVG45YThvMGVFeTNIbXdEQ01NamNNOU1Ea24rZkg1VjJtbjJ5M2NJbWx2Z2t5dVZLZ2dFSU9BTWpqbkg2MWpWazZVdWFKTHBwcXpOaTVzemJNTGZ6RlNFWlVxcjdtempCR2NIUDVkcXF4emFqRkV0cEV6U1I3Y3BqSjJEa242OURqRmFsbmYyVU1Dd21GSlgzRldKWEo1Snh1SjQvWHRVbHhITEJ4SkRGdExINWxZYmhubkhBNHpYazFXNE44dXR5bzI2bUJPbDE5cWtZV3JxM1Z4dEc0REFKSngyK2J0NjFrVzd2SkN6em82MnpGZ3hZYmVNbmFRQjI0K3ZQNTlDNGtlL2J5WkNxb3E1K1hjZDJEeU9jOU8xWUZwYnp2Y3l3U21TS3lReVJ0KzhKRW1RUTNUb0Fmdy9Pcmh5eVQ2YkdxZmNyYWxZM2NNSWo4c1MrWnVqWEFDa1pIR0FmcFUwOWhkZjJaZHdrT2hJT05zT1dPU0Y3TmdnWTY5YXVhaGRXOGRybXlrYVdhR01mTU4yU3VSbmdFOXNEa2QrMUpjWGd0N1JpN0lxeVNEYzQrNjJXOSt4L3JSR3BVc3JMcWFPS3NZY3RpMWpxaTNGcmVjeVJpQXBHcERFRlNEa1o3ZXZQZXFkdXpMcTF1ejZqZHhtM21od2traDJTbFNNcWNrWnpub0RnWit0ZE5xOW85M3BjelNNOGdCODNmSHd3SzllQVQ3K2xjaEZmdzNFenRNTFNkUGxZdW8vZS9MeGxjak9UZ2R2NVYxMFpTcVJjbjZkREdjRXREcGt0SHRaWjc3ZWpReVcwaktqS0ZNTXJaSTJqdG5QMTVyTTB1RzZtdFlvVllzN1FGaVEyU3Z6U0FrZFJramIvbk5XcGJ0VXNydWR5MGJOSHZLRnYzaURid3ZQUThmcDNyUHNyMldQVGJNbVFLOHNjbVVWYzRHZVJudnc1Tk9uenVMMDFHMHJtMXFFYitkR1pDMjZPZEhZaGNoajJISEhROVBwNzAzVTBkcGdxbzhleEFxS1crWWs1NmtkQUJrL1E5ZTFXVENxd09pVE5JeFQ1bmtBQlhqcmo4dW5wbjNyUGdtay90eTRNYXRuQ3hEYU9NZGNuUFhPZjhBSXJGU2IyZXdXVWR6UXM1SllORHVkc2pJSVFDcURCVmlxcWZybklQOC9ldU84Yk83YXROSzRVTzBHU0FTY2RSem52WFl2REwvQUdWY0dhUUxNMFRydFlESXlDT01lM1d1SDhaWGd1Ny9BTXdkQmJLdWM1ejEvd0FmMXJiQnlVcXVuOWJFVGtuRm1kNEtLSnJNOGtnWTRnT0F2ZmtFajhsTmQxcVd0WjBaYkl3cVV1YmQyU1RuY0NvM1p4bnFOcDc5YTVUNGZ6eDI5NWVUU3NpSUdpK1pzNVhrcnhnZGZtNzRGZEJyUG5YMmpRdkJkeXhxdDA2eXhDTEc0TUd3NUhYK0lEdU9oclhGUVU4VDd5MnQ5OWpPaDd0TzZLdHpGYnk3SkZDTk5JOGJScVZJR1FmUWRPT3A5dlduVzMybTZuZGlnbTh1TkR0d2Q0SFFnWjdjZjU0RkpZYTVlNmZwK2xlUWtNazBwUG5tVExIWUcyL0tCOG9PTWM5em5Qdk5wOXJOTkpldDV1MG1IZVpRUXUxbUpQdGc1Qk9Uam9mWGxjalNhZnlObEpHRytqZVRCZVBMZW9yVG8zeUlOK1BtQkJKNmRSajg2ejdDQ0UzWXRzTXdqUUdaeGdra0RMY2NnNEdUeC9TbGx2SnJXN2FPT1ZzUnlTS1RHNVhxZU1IMEJBSXJROE5Yc2gxVzJhNm1hVzNBZUh5cEd6bFhWZ2NaUFg4cTZyVkl3YmJ1WjNpMnJHcFl4U3dXMFVGdklZMmVhS09SdzRJMk16anAxNENuL0NyT3VtV0hScGdxeVNvanBzYnpNNERZRzAvOEM1ejIvblMweEhsMVNIN1NDc2huaS9kWXp1MnJJekFkT3ZiNml0clhUaDlQdFVDT3k3NVdWZU55S2lNTng2OWVmYkJyam5aVlk5OXpXTDBzWnI2c2x6ZWFkSmJFQzBpbHpFcXQ4eXB1REFFKzJTTSsxWnVvM0VjbmlxVnRnRWYya01JeVNNTHU2Y2MvbFdwNG1uc2RMalN5dGJaVmpra004VThaSjVKeVFNblBjZGE1bVNGSmtOd1FRd2NaazlDZVQvVDg2N2NQSlRncFdzdFRtcUpxVmowbHRHZHZEOHR4RGFLTjBIblNGTUZVWFp4eVQxNE9lLzUxNXZPaS9hSkNnTzFpMkZQUHIvalhxMWtaclR3eGNlWmRDU0I0d2ZtSVhqMTkvd0FmL3JWNVZHZGpSdndmbUlKK3VLendTdEthQ3JHMWpQbEtYR3Bxall3UzY0QjZzT244aFZIV05Va0xDM2dZSWhYYzVVWVlrc1RnbjA1NmU5YkY1YU16eHpvcWdSdnZMWndTU3c3ZjFyTHViVlB0anU4QWtETWR6YnVnN2RPbjQ1cjFZMlp6TzQyK3RKRjhONlJlZVNYRW5teHNXQkkrVnpqdjducGpwV2RhU20ydTRyaUdGMWtqY09wM2NBZzVIYjJydTdqU283djRZTlBBQ2ZzamVhdVpPVnpJd0lJK2h6eDlhODhHOWNFNTIrdldzcUZUMmlrdXphSXFwd2tqNkZ1Yk1QbzhWNUFUY0daUmRSbVJ1UmpEQnR2UWNZemdEcHpYTDNNajM5bHFFWmtab0pKakhHdTdQS3JuZ2VuSVBIdFdwNEg4UzNjL2dtS3prczFlYTJSb2c4NHdpeFlHQ2VPZXdBSFhGWlViSS9odVJaa2pnbWl1b3ZNMnJnNFkvSWNqK0hIdjFCcnc0d2RPYmpKWHMvMVBRVXVhTis1aWFIUEpCcUduMmJ4ZjZNeFpjT0EzbW5uazlRU1NjOXZ4cnNmT2prbU1GekZKazdkcFFwbFJ3Y1lISkdRTzJLNXA3K3owcldqYVQzY1N5aHVXNmpPZUNTZU05ZjhBSnJWbFpCY1hPWEc1Rnl4SEdlZXVldlkvbFR4TVhPYW1sYTYvVVZPckpLeHhmaldTSTY4UzR6SEtpdXZIVEF4ZysvR1A4YXJUd3gzR25UMmR1N1NQdVdWQU9kMlFNNEhxUDZrMWMrSU5xSWJpeW14Z3RHVllGY0hnQWM5dld1WnRaSDhtUWJtM09tQWZwMHIyY09sUER3a3Voek9vMVVsRnJjOUM4UHlTeCtINHpKdVpJbUtzQ01ZSkJ4MjZjL3pyQ3Y4QVpEcWp4K2E1ZnoyenVVRW5rOXNnZEIrWHBVM2hxYVcrMFdVeXptU1NPWmZsa3l3YmpJQkJPTWZJYXo3dUZJYnlZZ25IbUZNanB3ZTNwV2NZOHRTUnZ6YzBVMGRicENXLzJhN2tBM1kyQUxJTUVrNXdBQjN3RlAwNTdWdmFaYWJrTUNsUklEdERISUNlaElCNTdZL3hySThEK1FicTR1cC9Ma2FNQlZWeHdEenlPTUQ3dUs2V3puVWFqUDhBSWMvS3daVUhUN3YwNi81OWZQcnpTYlJ0ZEcxcGRsYnJwMFZ5MEVydHR6dUtINWlUZ0FEOFRVbjlrWFZ6c3VabkNrZmR0MElJQTlHemdaOWdQeHArbVhrODluRXFINVVHQU5vejZFMW9UbUtUYXJQR1dIWlpDSzhpdk51ZGtySW16T1l2Wm83ZWRDa0d4czdSdGJQSWJJNjlPTTgrL1k5TWUrMVNXeTA1NTFqM3JOY3l4bzBmM2xZa25CNDVIK0dhNlBWWXJlR0VUd2lPUUl3RXBWQXVCbm5PUFFaL00xaDMxdEJlNkxxMXBjbExPSlptWUU0ekVkcXQwOVBueG5qcjcxdFFqQkpjeTYvMStaZG5iUTVlTytSbG1ndkM1dVZYTWtxT0JuYVJuc2M1Skg1VmRtdVU4blM3ZElXVi93QzFBck1PaEc0OFo0OVA1MWhMNVZyWnp4UnpTdTduS2wxWGF5azkyejFCQjQ5alZxM1p4cmRsdERPaTNET3E4bm5ucCtYYjhhOVNkSkxWZXY0Q2N0RHRicG1oaWtlTWJKZHAzQWtiVG5qM0gvMTY4eTBRRzQxU0Y3MXl6SzBqY3RsZ1FqRlQrRERQNFY2RnFTdGMyTjY0QlIwaFp4c0dBY0x4bjA5Zld1RnN0TS9zMlNLOWRsQ0lWazRCSkNkODlNREJQYlBYMHJEQXRLbks3MVlwcHRwblorSlpyYWJRVkt4Z3ljQU80QklCSTV5Qnp4ejJxdGIyNldseGF3VzF4RVF4OGtHVlFEalpuajBIQSt0VWRYbFJyS3lTMnVDalR5cVpJdDJYSUl3VHp6alBwVis0amVKN2FmeTVnOGNpQkNHM0RrT0FUZ0FBWndLaFJhZ292ekx1eTlaeVQvWm9ZMFovUFdUeTJET0ZCdzJEZzhnOEE5OCsxVk5Kalc1dTVwQ3JPd2pSQ1RqQU8wYzR6MTRxdzFrdHhaWFVpaVJsYVVPUTRKREg3L0l4enlTS3liZTJ1SXIyOUNTR05GbmJkR1Z6ZzdRMk1FZyt2VDI3VktVWktWblppYnVhMDB0dm85cS8yMjdoODJNSEpRSHAyeU1ZUGJvY25KcnpQVWJocEk5L0pCd3VmYi9JcnJkYlpvZEh1aExESUFWMi9NeFpUendCbm9SK2xjZnFLckZZV0lUSU1pUE1mWWxpdi9zbGR1Q2drN3ZlNWhWbGFMTkR3cE04Wm5QbHJOdTNyNVpKVUU0RzA1SCswQU90ZEhya2p3NlJheXdKNU1ZdlkzQ28yN0labUJ3ZS9Yb1BiSEZZR2hSTEZad1RHU1ZYZUtSME1hQTdXRG5CUFBxdWZ3NzFyM04vYm81YTcxUVQ1Tzh4K2FDZXZDbnFNRDA0L09uWFNkVzZYVXFsRit6TXUydUVSN1g3VEdqcWwwcFVKOStOV3l4QVU1QjY4ZTlkS3R6STA5cGJ3bnlyZTRpSG5GbHo1YWxzdjI0MjRiUCs5OWE0OXJzUHFheVNnR0hQM1JnQmdNNEIvbG11OThEbTNsbWpNNEJra2hlM2ZJKzYyUXd4NjVCeWZmOEFWMUkyMXNPTFBOOWVsSTF1NUNoSTFNN0JRbklYNXVnOVJXallzb0dIQ0tGQ3lBa1p3UjArdlgrZjRZMTVic2RXNE8vYk1SaEJ4dzNiMnJYbGdraEN3dHloVThLY1o1N244UlhaS0s1VkV4dStaczNvTmN0STlYc3JtVnNSeHNITEl4TEErVWk4WnhrOEg5ZnJTeFgxcmNQcVppa1A3cTBsOGdQOTQ1YnArS2tEQTV4WE9qRWFLQ0ZBL3VnVkRObU4xYVBqZ0VqK2xjN3cwSHR1YUtxMDlUdnZHMm1yQnBOdkl3M3ZKS01TNXdEMEoyajZiZWU5YzNiWWo4TlhFWG15QXlrTXlGY0tTSElHRDNPQm44NjE5ZVNhNHRZSVlJR2RXYmNTcmJsVTQ5Y0Ruai9QZXRad2JiQzR0cjJDUVhIMk4yakFHN2I4KzduMC93RHIxejRYbGpRVVZMcmNKM2NyczdIVEpGMUx3Mk5rb2t0NUlCSE1JanVaSkNQdk1vNUI5dm9jWlBIbCsyUXdTeHVOckJ5R1BUQjNGYTlDMFdJeCtGN1M5c1lRYmhRNnpvckVlYW9aZ0FRQjE3Zysvb2E0cjVHdXJqSEtQSTUvOGV6L0FGcDROMnExRW5kQlYxU1pEZHdzTEIxVEpac0RMYytsVUxtTUMrTXU2WHNNQWpIM1IvbnBXaVpCNU1haHM5Q2NucU1ack0xQkpGdkorZUFWd01mN0lGZXBHNXpzNmJRMG4xSFFacktBcEZiT0hRaDF5V3oxK240SHYwcmk1cFpvYlNLV3c4ampjSkRESDh5RUgzR1FNWTVyMEQ0YmhKdE52b21sRVRyTmpKUEJHMEhuMjRQNTF3UGllME9tZUtyK0lNb1BtbVJUR3h4aHZtR0QxNzF5WWVhK3NUcHYxS3JOcUNrZEw0TDFXUlBDbXVscmhqY3d1c2k3bUpKM2pibjN4ajlSWFhlSTlNbDArMHNQdEFWb3JnTERMaGNZY1laUUFPdklQSjk2OHg4T1g4a21zdzJraFdSTHFSSTNKVWJqOHdQWHJYc1BqU0dkL0IxMm5taVR5TnM4WVVBRWJUazRQc00vaFhMaTRLR0pUL21mK1MvNEpkR1hOVDA2SGxYaTNSYnFYVy90RnBBcGltZ1NZQ01ZR05tQ2ZUK0VuQXJwN1dXVzR0RXVaWGRKcFlsemc0MnRnQWpHT2hJL2xXWDRrMVNhR3gwUFZZeTY3b25pQWpjakFCNmNnam94cHVqZUkya3NZbGJhZ2liYU5vQUlIR1B3N1Z0VWpWblJqYnBwL1gzSVZrcHRYRDRoVFIzZW4yc2l1eGtEZ0VISEF3Zno2SC9KcmhyYWN3T0NNNDdWNkI0MW1EYUpBOGF1amlSVDgzSVlZUFAxNUZjR3lCa0pZZ042NHJzd0RUdzZUUnoxVTFVdWpwZkI4VzU3aVBJakJYek40SE8wQnVPUHJpc2pWYnJaY0dOSExxc2h3ekhKWTlTZjFxLzRUWW1lOVNPUUtyUitYNWhIM1FjNVAxckd2SjJrMUpZdzBicHVBTEltME4rQS93QW1xU3ZXbGN0VDl4SkhjZUM3aVdGOVFYNXNxc1pJWHFUODJmNSszV3VraVZ2N1YwKzNSMUVra2NwTDQ0WUtWNUI2bm5uOERYTitFbWthVFVwWUdVcUZqVmdSeWM3aHdPNXJvckdPU1R4UmJtSUtTdHBJVmQvdW96U2M1L0FEa2orTDJyeThRL2VsNmZvZFhSSm5XMkQza1VNalc2c01UT0NBT1NOeHJTaHZESkVjcSs4SEQ0NEdmNjFtV002UVJNOGtrYS92WEdUMVBKei9BSTlxdHg2dHBkeFBzam1NczRPUDNmSFBvUjByeFp6dTJwTDdpN3BhRU9xTTAxblBodmxhRnNCT1NRUnowL3lLNDdYU2srbWF2RGNUK1NkOFpabU9BTUlvUDErNXdNNU5kWGV6K1ZHWVdpM0IxSlB6YjJPZnA2ODhWeCtzRkErMW9IdUdsaWprZUYxT0hjZkxqOC81VjI0S04zYnQvbWdic2puMnRHZzBtTzZ0Mk54QUVPNlJsOHQ5dU1ZS2tuczJRZmZnOFZkdExKNC9FT2x3RVpIN3dxK3dOZ0RkampQUFRwVzljUXpXWGhhNWd1VUZ1d2hEQ05Db1VqZ2Zkd0NlZnJ6OVRXTnB0NFQ0NmhDeDVWWVpDTVlJVU03SGpqcHlCWGM2c3B4azEwditRYkd2cXU2MjA2N2psZHBWTUx0Z0FLQWNFOURuZ1k3bXVNZ3NyK1NLL1JwVXVvMWhFYXNqQThIb2M5KytNODlhOUM4VkF0bzg4eWdvZkthTnMrNDljOFo5dld1QjB6VHB0TWd2MisxeDdtVGxVbCtWMUFMY1o2ODQvR293Y2w3TnRiaEp0dEZ6VXBacHZEV2d5RlNTamtPUWNrSElCK2c0OTYxcnErZ2h1SW95aERtVlNKUzVZcjg2TmpQK0h2WExUWG9pVVJ5RjB0WTlTa2VNcjE4a2tIQUgwRFlIRmFXb2EvcGR4WWsrVkw1cUtyUnNGNmNER2Nuc2Y1VnRPaTdwVzB1L3hGR1M2bTArcXd0RmZTUk0rMVdnY2JzSDV2TUlPZWVPdlgwTlpBbDJYc2swekdPTjJNbnpaK1k0WUhnbjJINTFqeTYvRVlVaUt0RnVCUjJHU0NGR1Y2SG4rbmFxc1dvU3pMR2trVzZGbmJPQjkwOWNqOC8wRlZERE9LWW5ORzNyT3JXcjZLYlNHT1F5TklIWm1iakhiQUg2MXpOMis2TzNYWW9Ld2pPQjF5UzJUNzhqOHEwN3UwdkZqRHl4eHFnWUx3MlNlZW94MjYxblhhamZ1QjY0QXlPZUJXOUNNWXJRNThRM3N5WjVKRjB5M2dtWTdESDhxNUhDa2svek5VdnMwYWpDdXhKSTI1d1IrUHBYUVc5bFpQYTJraXMwc3JSRGVpWjYvd0RmT0FldlUxYmpodExHMjIzUnlHYjVZUWQzNW51ZW5TbkdvbGV5QjBaV1RiT1Fqa0lmRzhFazRLRnVhMG85VTFlMHZVVlhsdEkzSUxOQ201Z1FPdnNjRFBhdGthZlp5cURGYlF3SEp4SUVEdGozREFqK1IvQ25YZW1SMmxpSllkU21sQUI4d2JSRU92UUZNSDg2MGRTRGV3MUJwZkVZMEZtSkpoUDlvbE9EdkJjWjV5ZU8yZTM2MXFHT09TM0piNWlDU0pEL0FBdC9uakgvQU91cWl5RnJhUGdpTnM3U1hKNDlTZnJTMzl3WUlqYWlSU3lZa1lESndjZ0QrZlNzMjNLUTBsdU11SmxsUkpHVUprdHlEMHdjVkZjeGd4aDFLN1NldnZnVWw2anlXTnNWSkRCbjNOMjY1NS96MnFleGgrM20xamtPeUJ5TUhvT0NlTSs5YWFSaHpNaEp6bnlvNkM5dlpWQXVZWkk5eXlzbTFEa2pHT1dCNkRuZy9XckZuTGVYbHRCTW9FdVlwNDBBWEdNanZ4NnJWbnpkRTBXTjBXemhMeUUvTXNReVBVWnh4MTlhMWZ0RUloVkxVeHdSSUNUOHUzUDAvT3ZBbldqQkxraDgyZDBZOHkzTXJ3ZnFNeTZMUGJ6QmlqeXNGQk9Bb3dEampyMU5jN0pCNWQ3ZFJXd3pHa2pLcEhRREF4ajZWdjhBaHRvRTArWU5HenlDUm0ycUNUamFPbnZYTHpYK3lJU29nV1NhYmhDY1l5VC9BSVYzNFZYeEZTeXRzYzlTTm9SYktPb1R2YlNRQk9yTGxTZW1SbFNQMEZQbmJlanNWNTh0V3o5Ui93RFhxcmR1MHpRRWtLRlltTlQxQXlPZjAvU3JGNHdWRUFYNVRFZ3ozeml2VmEwT1pQVTZ2NGQzSXQ3ZTdEdDhzelA4bzUyRkFuT1BmZC80NmFtOFdmMkZKZlJMTnB5ZVpQRnVOMHprUHVUbmFxbmdrOEFkdWNuZ2N4L0Q1L0kwVzZkRDgvMmh1QURramF0YWZpZlRiWFYxc0cxTXhwSGJzV2ZlZkxWd1FCamNPbklHYThHcFVoSEdOdTY5UFE3NHdib3F5T1poOEpTUytKTFcvUXhXOW9jVHFVVlV5QVFRb0E2dHlBVGdEanZYbzl6Q0x1eG10SlkvTWlrUXFZbFlrQUVZeGovQTE1VEpwK3VXa0V0dmJSYWcybnBJY0NDVVNvZmZLZzg4RDZWNmRwV29RMytpMmw4R2pTV1JGWWdwbkJ4ODJDVDE2MHNkN1pLTWxOTmJhZmdLakdDYlZySEhhNTRhdXB2QjR0b3JkWkxpM3VQa1ZDUVVVNUhmdGpISFVldFZ2Qy9neTdYUzlRYThieUxsQ0dpaE8zTFk2bFR1K285T090ZGZwbHpjeWFuTEROZks2RXN3UkZ4amtFQSt2SHA3MXlpM1AyWHh6SkpjdGNwRTdQRWp6QmdnM1pPM25zVHlDT09SMDdPaFhyeVU2VjFmNHV2M0ZUcFFUVS9rZFBxT2pXVjlwVVduM3NTelhFS01zYUFCWFpzY0FISkdmeHhYamQvcGw1cDdpRzdna2lkdWNNT3YwUGV2VWRmOFI2ZHBlbjJzc3NjODEyNCtRSzNDc0FNNVAvQXZlcnVpYW5vdmlMUS90SjhtMG1qYjk5NStKRmpja2dIbkJHUmprWUhKNTROUENZaXZob2M4NHR4Yi9IeTh2a1JWb3dxU3NucWVkYVBHYlRUZFNCZ2ZFa1R0a29jOExnRWZpeHJuVWpmN2FHQU95TTR5ZW1RT2xkcmZTM0Y1ZmFoRFl6eVhWcWt6SkNQT01pNGJyZ2s5RGpQdGpucFVkbm9HbndUQmIyZTdsdUpRQ3FvQW94bnR3ZVBZQ3ZXaFZWbktXN09aMHRiUjZGendqT2JhSzd4a2llU0U0VVo2YnZ6NXp4V3o0YXU0b29yNmVSMlM1Tng1UitUZ29xcnRBNDkyTlpteUhTNGZMaGxlQlZZUmtlWnVLa0ZtR2NER01sdW1lb3FEdy9GZFhMQzBoRWFLcGFTV2FUQnp6MFZUbkxjZGVnNC9Ia3EwK2Zta3V0alpjeWFPMTBxNWp1NFA5S1p3N2NrREJ3U1MyZW52MzZaL0dvRVNFYWhzZ2FhM0VKNHd3MkhQT0NEd0t1NmVrRzFvR0R4WXdXTEVkV0hHRCtHTWUxV2JqU0VjRHpabEM4OVR6K1lyeUp5Y1p0ZHpaMDVUUXJva2pCNDNRWUEzYnlPdVBYSHZXUnFja2R0Y1JlVGRHTnR6UDVpeW5HRk84NXlPT0pDUHF0UlhGeWxnU293cWtuWnZia24zUFRIVDY4K2xaZDNjV2sycFdaVUZoSnk2SzJSdDJzQ0J3RHptdXJEMHByM3QwUktLTG1wU2gvRDkyMGNvWlRHd0dlb3cyUVN3UFBBSEJGY3BOcnR2WitLSnAxaWQzalVReGovYVdRTnljLzdPUHhyYjFBK2ZhcWtJa3QwR0RsWEM4cmtZQlgxR2V2cCtOYzlkYVphUzNadVZLSnN3emxHSUNuMzY1ejZERmR0Q0VVbXA5U1p0cEV0eDR6MUhVRzhoR2ppakp4c3h2Qnp3TTV5T3VLdzB1dFFtVUMzV1VxcThiUWR1TWsvNDEwT21hZHBFRENXT09SNUltUE1pNVhQb1NPby96M3A5NkxVeXBGSTd3ZVdTalMrVXdCQjZEUEkvblhUQjBvdmxoRXhuR280M2IrNHdiZ1hGeXlwZFJtT1pUbGlEbmVUL0FIdXZQSDZjOWMxUERwclRSRHpWMnR0MkRCL2h6MXhpdGdRMjF0QXJ2SDVnNUNvVHVZZlgwSDYxTzhjZ2pXT09FaVRCWnRxay9ManYrdllVNVZiYUpFeGk1YnNvV0VWcFlISEVraThZWTdXeU1jMWZ0MGE1dTk4c1FKUjgrWGpHN2pveDdjWi9LcXR0NXR0WlNUTVVabko2bkFYR01aejBIUHYwcHM2YXRQTXNvamQ1U09xdXZsa0hzVndNbm5QWC9HdWFiNW05Zm1kc0lTakZPWDNHbHJTVExvOGJlWHRpREtGYlBVOWVQODlxNWlWWkxobzQ3WkdrbHlRUW5MSDhCOURXNWYyTjFCNGNsa3ZMaHBiZ1NLeXhBc0Z4bkhRanJrK3RXZENlUzAwMk9NUXA5cmw1Ull3MjVseWM3OEQvQUNLVUoreXB0clhVVldtNjlWSjZhR2ZtSFQ5T3pKSVJIR0NONVhhekgwSDQ1cVN3TWVvMmNOek5GdExzU29Za2dBWkg1LzhBMXF2dHBPbFRzcXRERkk0Y0YxTHNTeHhrZ2R1MlB4cGtzc0ZyY2xBcVFSUkRDaGVxRDZWY0tpbm9rN2luU2ROY3plbXcvd0F0WVBsVk5xay9lVnNrZXZYSXJOMVcwZHBMYTNpbVpsbURGblBDL2w5UDhpcmduTjJ1NkpabVQ3dS9hZG85dDJNWnFEN1hMYjNVUjJPa0p5cGRnU3ZHTzRCOXFwS1NlaGp6UTJZaGtrczR4REVaRlZRQW8zZFB5cVdIV05SU1lzN1J2c3cwWWFOVGtuSEpPT1Q5ZW5iRlY3aThqbDViZDh3NEcwMUhic1pFNFVuWmxDT3VRUVNNZmpuODZ2MmQ0M2tnalVzN1JaYmx1amVzN3p5S3JrOVN4SHYxUHZqcldIZmFoY1cwb0MvdklXaUxNNUFHVHQ0NkRqT08xV3JxTHl4SkVGS0habGVjQWM1UFA0bXBiT01YU09nSHpvMjRqYnovQUxJenoxR1QrQnB0UmdsSnJRMGc1VlBjVHMrNTAyc3gyVmc5dWwxUHVXUm1lUldIM2V3SEE0NjhtckVHbzJXcTJWNUlOa1NXNzRUWjNVRUVISE9lbjVacXA0d01FdGpFVkpXU0g1VlVyMTNNU2VheC9EYU9ZcjZJU2xFbFhZY25Bemc0L2sxZWRTdzBLbEZUYmQxL21EcVNoT3hyK0hwdHNkeElKdGdXWE9PY0hQVHA5SzQyL2FYN1pjcGppR1lGUUJ3RzNkdmJHYTZMUWJxR015eGdJZDVYbDJ4Z0E4K3ZZOWhXRk1XYWVXU1VsNUpabUdUN2ZMei9BTjlDdTJqU1VLc3BMcll5blBtaWtOa3NpejNNMHVDNlJxSWx6d0FXeG1tVGxKVlZDeDNERzA0Qnp4OWFzeTNVYm8vbHQ1Z2NmUDNJQUlQK1A1VmxIQURoY2dSbkF6OVA4YTdGc1k2WE8zOEl6V2Rqb1VpeVRBekdmSUErVTg4WUpQMC9DbitMbWEvMEs1Ulp0a2FSQnhBTXlNelpIVWdkdlgzTllkcHNpMGFHUVlaOFBudmdvMlIrbGRhK2x4YW5vdDVCSEx1YVNFK1hrL2VZcG5QcjFidlhsMXFNS1ZaVit0enBqVXZUY1BJNExROWN2dEN0WTQ1cHpCYk1HYUlyQXNwTEhzVGtFWUlIR2M4OUs3blFOUnVaTkFFWnZJTGxBekFwRndFTEVrakJBT2VlbGVTZmFMaVBqelpBT2dBY2pGZFg0STFWb0x1NXRwU3NrYzBlZjNoSjJZNmtjSEhyMDdWMDR2Q3hsQnpTMTMyTUtXSXUxRG9kVk8zMlBYSUFzUGxtVkNkd1VqWmpnRE9lZXRZZmlmeERxRnpwcjZaZTJNYVMyOXlrc2Q1dkh6ZmUybkI3a0Q5RDZWc2FyclRiYkpGQVpVWDk0VlREQVk0T1AvcmQ2b2VJNzNTdjdPdElKb1pMano0MmJiRkdxeWIrTnB6akhISVBjMXcwSWUvQ1U0WGY0NmYxc2RFbjdyU2VoekhpR1dPNWF6RU9EdWg4dzRPZVdQOEE5WVZrU0tZb0NpdXdSc0VqUERIc2NmaWEzOU04TzNOMUFrOXpLc0tJTWJYR0dLOWVLMnJqdy9iYVcwVTdRM0puR0NxcTZ0d2VCZ1lJejZWNlRyVTZUVUxrUnBTbXVhdy93eHAyM1NyYWFLVlFkcGtsMy9LRjY4bmc1SFRnOFordGExdE5lM0Z0TkxEYytjZ2NBOEJCZ2NkOEFkZU8zRlJhZHFVTWNHUHN6TkRqWXczQUZSN2tEQTlPQitWQmt0dnRMMjEycStWUER0aVczR0NvR01rZ2pCNDlEK1dSWEhXY3BQbXNkTkt5MEliMmU1ajBnaGc4c0xzTjBaZGZtSGNEdmpJUElQNVp6V0xhYWpjMmRySkJiVExEZzVWV2ZqUEdPVHdUL1BQRlg5U21tc1JaMjhWMmpXci9BQ3RIdXd3WHRrZlhQTlQyK2t5SkFKMnM1SVdWU1dFWTNjREk2anRqcDZnbjBxb3pqQ0h2ZFNuVDVwMldsanVOQmw4elRyZWFRQ1NWWTFaMllESU9PUWYxK21hMVdlVEdFakRNeUhhVUF4WENRYXhmeHduYXkvSVF2ejQ0R2VEN1U1Tll2U1ZrZVZRQmpkOHY4c25qbjhhOHlyUmxPVGtkSEpaV1ROTFdwYmUzbGUzTUJhUmNPeFU1NTU2aXVKdS9PZTdnZUpOaGpreTNHMWhuOWE2U2Evbm1RUEZ0Wm42QUprajY0NS9QMnJKL3NwSlpKSlV5a29POWk0UFR2OWZ3Nkd1bkRmdTArWXhxVVpTK0ZtWk8vd0M5ZHBUOHJjWklKeHdCeWZwViswV0MrYjdMR3pXOEVXSmNsTnFNZmZ2ajhmU256NlM3Ump5M1Azdm1ZdGxTT3VBRHgrV0taUEJISEJDYmlZSkNlb0NnZ2dIMzlmMXhYU3BxV2lPZVZHY0hyc1RTV1lkNVlJcmlIendja0JETCtYVEgxSnF4WXd0YmVmSzRtZTZqYkFlZGxWQjlCazl1NDcwNk82cy92NmNzY0NTS0MveWxWWXFTU2VUem5JemdqcDlLaWdXU2FNM0wza2FSQnRyS3BJQTZFRUhyakdSK0hlb2JsWnJvYnhqQzZsMU10ZFFmVGRRYTN1VmdNazhtVmtTUTdVWFBRL2wvT3I2Nmw5dGljVzY3SVY1ZVVJTU1PNStZam44RDlLanU0N1Q3YkhlaTlqTzFQTHhuREdUUElBNS9RbW54VHZPZyt6NlVrODhaWWxIVWlJQTQrWm1HRG5qUFhvUHp0cFNpcFcxSmpMMmNtazlCODA1dVFubExHK3hpVTh3WjdZeVJqamoyOVBTcFJmd3Nuelhra2txcms1d0N3eDJQUGZOVlo3bUthVzZqdTlVZ3NsVGJoSTQ4SFBQQUhYZy9sNlZCYXcyOE1yWHl3dEpCSU5za2pIbHdSeHdSMytsSHMxeTY3LzExL3dBaVhVazVYV3hmTS8yaU5JNFpaU0NGK1VvV1VFZFRrY25BNSt2dFZhOHVyMkswZWFmYk5GdjJ4dUUrWlNUakpBNmVncXFKclpKWTdnS1pKbFg1ZUNxeFo3cUFlT3Y1ODFMTGZTU2hwSFlzN0hleFloOHR6ZzRQZms4MWNNTTIwN2FFMU1URmJQVVRTNXJ1QmhOYlhrYURLbGxDNyt2SGNiUWYxNXF5WXRKdUxvRnJaMDhvN1M4aCtWejZFZE9QNjFRZlVYbHRtaERNWkdQUlRqUHB4V21tbmlHMVUzRXZsM1p3ZHlzQ2h5VGpkajEvbUtkVlFwelVtOSszNmhTY3FrSEdLKzhzelgwTWtLUnl5Q09JTGt5SU1LQjZjZlhqaXNORGMzay9sWEVaalNOZHl5SytWWWRNQTUrbkhXb3JpKzFFTTltdGl3dUkyT1RGemxTT2VPZXVldFhOT2UzanRvMW5MUnEyU1YzRTdUbm9LcU9qMk1wd1RWbVdZNG83Sm9uaE1ZeG5uR2Y1MHlWNUdrODJNdDgvVVp6VEo3aUFNY0hJemhUVkpMdUpjNWJrZWd3RFc5TzcxWmhVdEgzVVBuM0JYWE9FYklPZW51SzBOTWtnYmFrOW9GaWZQbXlEUHo4WTUveitGVWpjUnpES3EzSUJ6aXE4eTNrcU5GRk9GaSs5a2NINllwMWFTcUxsYkNuV2xTZk5FMzlVdjdTZXcyM01UeWhBT0l5QVdQUGZIdldCWXpvdDdJTGVGNDBrS3VxdTViYnhqcjMrOTZVc0VzbDFwUnVHWDVURnljOGNkZjFxQzNXWlpFYU1aQVRuSnpqa0grbFkwcVNnbWpSeWJzWDlIV0Jyb21YQksvNnZBNmovQURpcXVveWhtWjQwQlZwSk5xbnJqY1QwK2dxU3hobE4xc2pHWEN0a1lKT0t4OVJ2MnQ1SU5oeElqeWNBZXVCL01uOHF1RVc2bWdwV1VEUHRtbWpqdUZXUGVDbVc0T1FQV3ByY0c0ZVJpVHQzREpKOWdLbytkSTVjYmlESWNNZlVaei9oVm1PN1ZZMVVnN3QrNDQvRC9DdXhvd2l6b3JHSmZzL2xra3FBWFVzZXYvNjhZcnBOUDFieUlJMFl0dFJGUldBN0RQWDMvd0FLeWRKdDdtN3NyVm83ZEhpWUZTem5xTW5wajBJL1N0M1Q3SjdYZUNrVWdKQkhPTUEvWGoycnk4VlVoSk9MNkhiUm95bHJZOG92by84QWlZejdTTnBja0NwTEM2YXd2WWJsTUV4SEpVL3hEdVB4RldMNnpubG5aNFlpeGVWazJyeWZVZnpyWnNkSDAvVFdTUzhRM2tvR1dYT0VVOXhqdjlmMHJ0YzF5SzV3S25MbjBOSjdlUzRzQjlpWm5RZ0ZIejFUSVA1WkhmOEFLdGZTOVBrOHJ6R3U0STNXSXV4WVl4MDVCK29xbkpxeGFOZnNNYVFXNmpiSER0eUZYdjArdWF2V040STVVbWxVTTY4cVl5VWJuMnh6MXJpbEdjcWJTMGJQUVVvcWE2cEVqK1JJY3VuelJBN25jOE1lNXFqcVYvTVpyRy9NQm1lTnZra1Z0b1FnNStiQXpqbjBQZW9OV25lMnRKWjRHWjRFYkR3eUorODU3Z2pyVE5MMStDNnQvTGFERWFJNG1MY1pHUmdqUEk2SDlLbFU3UXUxYzBVcjFMS1c0ekZ4SnFjbHdDbmszTVprWlkySnd3T0Rudm5vZTJjMGozWG0zY01LbFpvL3U1TFl5NHp5VDNQUWZTckVGbGN3d3RKWTNFYmwwS29VWmNuMDRjWS96NjFsalRiODN6VEhUNVh1SUFXS0luVVorOWp2L1NxamJxRTA3dXhmL3RLK2lXV3h2N0dDV0IyTDJqbUxCQ3FSbkJ4enhqUHA2akJCMU5QMU1ha0RiUk5HWkFRWkFwQU9BTWh1YytwejlPOVRXOERUV2tIeW1PVDV0cXR3SDNaSk9OcEdTTnZYUEdLdFd0dERaQXgyMFZ2dWxMRng1WVhZQ1R3TnB3Y2VtUnhYRldxeGttcmFvNklVM0RXNVlBNmtiWmtYNWZrRzF1NDVIOVAxNXFPYUhZN1NSUkZZaDhyU2taMjlCakE3ZGZwa1ZPSlpZYmhIV1JMaFJoWEd6QWJPT2QyTUQzQngzcEhoaisxZWRHcUpIa3VHUmN0azg1SkpKd1B5NXJqVHM3bW1wV1dKNXBDMjBwdGZhY0h0L0lucWVocHFCWkhJS2JuZ1lzeWx5Tnd6endPZngrbFQyMGNiVHVmS0xFQWpLWndTT1NTcHdUMzlhUllUY2x3UUEyM0NCWXhHRGc0N2s5T2VjOXFybXN3dUpEWmc0Q2lFQld5K1ZHNFpCNUdlUC9yVlh2WXZOS0VXNFJWWE82UWc0YjBHUi9JNTcxZmVhR0ErWEU3TXFnSTRaU1c0SDNzNElQSUE0L1BPYUpEY1hDdDVrYXN5aFdPVytZNUhUSjRBeDdVdWVWN3NMM1d1eHpNc1QzVjRzS3ozRWNPY2JGWExEakhKT0IxOWVtZXZXcTEzcHMrMDI0ZTZqZ0JERUkzekFucDIrYk9LNmFlRkpiVnJXVkVnWEF6dVBKUFFrTXZKSTlCeDZtaTJaOU5sOHN5SjVERUw1a3NtU01FOWlweCtCR2M5NjZvWWhwWGlaenBwNldNQ1BRMGgwbWN4Mk54NWpPcnh0TU9TUDlvZzV3ZlhqRlpUeGFza0F0WDFjeHdoeU5rVVprSzVQQUhUdVBYODY2R1M0V1NReHczMHAzdmw1OHNRVjU0QTRBNmZRVlN2YitPMGdOdTBvTVp6c1JRTUVrOHRsZXZIMTY5YTZxVldiZG5xMy9YVTVhaWlsMlJTWFROUG12bFZKRzNIRE5MS1FXSjR6aGVucjI5YTJsZ2ZTN2FlMWU0bWFCV0pkUk51ZGh4OGlrSEdTUFFad2Z4cm5qcVZsWTM4TXMwZ0F3UWpBa2hlYzVQL0FPcnBYUlcyc2FmcWlpMmE2UnBHK1ZjeUJRdzcvd0Q2aDIvS25YalZzbnEwT2k0TnRPMXpCZjhBZXEvSjNaKzZGSEgxUGM5ZjhhSDBmVlRaU1NSUlJ1cUVBTXJnbDg0N0N0Rzl0NHRQMUFwYm9KQWVkeThnKzRQNTFVdWJrWTJqZW5IVEdRUHBYYkJ1Y1ZLTCs4NDV4VUpPTDFHNmJwRi9DRGMzV3lNc05xN2lldmNaQVB0N1VsamJmYU5TVzRqRVVyak9Ga25LcmtmZ000Njlmd3A0dnJqeThwZnNWQUM3WExNdjBJK3RYdE91N0cyQ1R1MXQ5dFovblVpVGJqQTVCeHdlT2E1YTZxeFRkcjM3WE92RHVrN2EydDNJdnNjLzJ0NDVta253U0M4VW01ZDNQUUQ2NDZWVjEyQ0t4dThNbHhGYjRHMlNWQ1Zkc2M3U090YndTNVMxaWxzOU8vZE16U0xJemp1QU1FNEdjODg1UFFkS3FYdTlvWVliNmFCeUN4eEV2eXAwNHozK3RZVUtzbE8vWTZLOEl1RmtjMGw1YnlQOTROam9NMUZMTkFqa2dEcHh4V3BjM1ZyWnFTckwweUFPMzQxejh1cFNUN3ZLSVk5dU1WNjFOdXByYlE4bW91VFMrcFplL0RmSTVYSjZGT1FmclVjNWtpQWxqbVlZWG9PdWF6MmozRWx1dmNqclZock9jd282eXNneDNPZjUxMEtDaVlPVGtkQnBqZll0TU1kNUJjU0F5RUlFWWI1Qm5xUU03VjY4a2QrdEkwU1NheEdnMndLNVpSNW43d0psU0IxQXorWCtOVlJkTHAvaVNka0FFZHdQUWc0em5JOXV2NEdtWE1ra2tpVGNTTUdCTzBrNTlxODVSZDdycWVnNVIyNm8ySW8wajFSeE8zbnFGeUhpSVFNY0QyNC9Lc2tXbHZlNnJjWERvdXhISTJNU2NISi9waXJ6dGNQcUhtZVNGWWs3QmpHZXVQd3FwcDdTUm05ODlWRXBaaTdkbTkvNVU2YWNkZklVK1ZxeTduUFhRV09hVjQ1RlVwSVZVTDE5YzAyTkJLeEs5aHpVdW9Iejd5YVpFQ283SEI2Q21STUdCS2pHVkg1MTJwdmxPVHFkeDRWZHY3SFFQbFl4dVVIYnU0eVQyUDFHZldyMnBTWEVFSjh0WGtiQTJLQmtQejBPQngzNTR4V1RvUG1Mb3NNeUNMQ0YxK1pTV3p1N0h0d1IycmFGOUNWRWR5NlNUNUpJQndRT3VlTUErbjRWNDFSTjFtMHI2bnN4bkdGR045N0daQnB6enhMUGZNa0Y0ck15aTNRWUFiSHlzUDR1bmJIWHJTTnBNOGIrZUxabmhYZ3NCdDJuM3owTmJscmU2WmJNcG1qQ09yYnM3OFk2K3VjOWp3Qit0Yk4vZWpVY1JwdFV0dDNxR1BsOStSajcxWlN4VldFMUZSMEZIRHdxTG01amp6QUduUVEyN21kdVQ4cEl4NjQveUswclRTOVNjdklGajZkQy9UM3hTM3pOYkxtSmQ3QWs5UUNmVmllT2F1UGN5MmRnRXVZcGZNY0RjUkd4VmUvM2dNZENPSzZaVGx5NkxVNTR3anphdlE1YVY1SVhrU2VWanZ5ci9OMFByUmQyamlBUTZUYWk1aTJEelNEaVZ1U09WeGc1eDJKcmN1eWRXalNPV05HQXorOFpmdkhxQU80L3hxbGF4YXZGR0k0SXBtdDBKRWFTTVBtYjE0NkRvdWVuRktjdEZKOUNxY2J0eE15d3UwWUNHQVNCeU0rWGc1WDhQd3JxbXNidTNTTm80UUhjYkR1MmtESXpuSjcrNC9sWE9hZmJTUWVJTEtTK3NURGV1NFptajUzOXVRT0NTUjEvUHJYVFdiU1NGcDRHbkxOOGoyb2tLbENEazhIMXllL1U4Vnk0cWUzTHNkTkdEaTIyTEpMSGN0RUpTMDBpcU43ZEVYQUp6a2V2VEhYclRyZUszalZwWkd6S3grWElHNDVHMEVad08rUlRacGZ0VGdSUVN5cEY4MytzMktEbmtjOVNmZkZUV0VMU1RxV3RHZzIvTDg4ek9qbkpIQXo5Q01aL0ExeFBTSFkxZm1PdVdSajVTMmNqeVJZVTVDdVpBY0U1eHlEL0FFT2FyeDZnVEhQYnE4UWtISllLeWhUakczSjl3QmpwejFwN1N5d3pjeHpGUmxWS3JoQW1lY0FjOGM5ZWFhVEtWZU0yeGFCblVUS09DaDlRTWJnT3VWSTV6VGl0TlJXMHNMRE9zK29aYUJZM0pWZ0ZWR1ZqazVKenllU1A4NXFhM2tHb0xOdjNSc2NrYjVlQzNBd2VEZzlPZzdubWtjM1RYRHBKYm1NdmdZWGhtVTltNzRBQTl1dElsbkJhUkNXMmplU1FNNnI1Ylliamc4SFBIVFBKNHFaT0x0YmNRMThvZHNpVFJQZ0lWNEs1UEl6dXhrL1FWVmx6RlprcDVKU1JzTnVZQVpBOUZ4Z2pQY0hQSEdlYXZSWmt4UE94aUhLby9Ba3dlZzV6bkh2elZhM2l0emVHTjNWazNaTWJLQVRqZ0Rid0J6N1ZhbGIxR3JFc014dDR4UFB0WGFjaGl4TERJSDNsT005K25yVkNDOXVCTkpQRWtjaFpWeU5veTRQQis5emo4eFdoY1F0OXVTSXV2ejV3cnhlV2ZVZHNaQTlmMDd3Mzh6MnRxSkRIQzhuT0hDWUxqcm5PQno5T3VLVUxQWmFzSHNZN1hNcVludVZkVURiaEMwcXVxZzlBTWRNZW5lcWVwNmJZMzNsc0wvOEFlRDVVMnI5N29BTWR2OGF1QjRydUhiZEtneDBHV0hVZ244OFZTdDU0UmNzd3RBa1RBcVhYbmEzWWduNmZ6cjFsVGxUU24xOGppaktNL2RleFZ1UEJjazZNdm1OS3lBNDVDWVBZTm43djQvblZPMjBPZXk4MVVpaWU0eGx5SkIrN0FIVDNPYy9sNlYyOFVjaTJNS1JMQUhjWklFcTdSLzN5ZUJqR09NL05XSGJSU1dtcFhSa2FONXA1TXE4WTNiZXZBSit2T1BTblF4bFdYTkZ0RTFzUFNWbWtjN2NYYXdoU3BjS0ZCRE9PZWUrUHJWZTB2SmJ5UW9qN1l4dzBqRENqL3dDdjdkNjdUVVo3ZTdnVkxyWkpFcktWYVFaQklQT1FSMDk2aFMyVjRvTE95aHNtbXlmTW1BSmpDNDZaUEdNYzRGYnZGeGd0VVpRd3puZVY5akFpdDBGcjlvVzRhVGNkcXR0Mm9QWDNKNmVuMHF6WVhWaE9XazJtWldPeFVHUjgzR2NuNkhyaW0rTEpyaHJCQmJRSkhHZ0dmS2p3b3p3ZnBuaXMzdzNKYXJwc3NVeUdPNERrL01EeUNPUGZtdGwrOHBjejB1WXRxblV0SFU2M1U0emU2STF2YTNqeHlxZytReUZrNEdDQUJqakhwWE5IUzlhMC9USHVMbVR6clpEdDNDVC9BRlk5Z2VjSElyVjA2K2xsak5wQlpTelRBNVc0V1hiNVVYVnM4ZTU2bkF6K2VzTC9BRW1TME1FOXY1Ym1UQ1A1cDJTQWorSlIzejZBZGZibmhUblE5Mk9xdjh6MEY3UEVKWDBsYjVIQlBNWlV4bmVQVHBVRjBibUdCWkdnS1I5bUM4RDYxNlRINGQwNlNWV2p0b1BseElWREFGZmZrRWpvZW83VTJYdy9iMmNUMjg4ckhlUmhsVWtuSis3N0RIMHorbFdzMnBKOHFSbExLcHJXVWtlWFJ6VE1SSWtHNVFmdktDUVBlcmR6YmFocUVubDI5d0hVQW5hRGdBZTVyMEkyOW5aaVNTS05JMlZmbE8zeXdEeWVUMEE5OFV5TkpyTDdTTHl6VkpKRVZ2TVNNQXg0KzhTVDk0WTU1SXFwWm0zOE1mdktobGNkM08vZXhoM2VqUGVYa1Y2dHJPWlB2QlZmZHV5TThuT2Z5OTZsMUcyRVZ0QkpId3JLVUNrY2pCOWUvV3Q3UnI2QzlnVkRHWVdDaFdDRmlHN0E5U2UzcHhpb2ZFQlpyWm9HWXlDRWpheGJKQUk2SFBPVC9TdVNPSXFPcW9TV3gxVktFRlNsS083S2R4WngybGxZM1VLSkd6Z08yd2tuSkFJeVNUNkhwK2xObXQxaTFXUjQwT0dIT1czY2JReHlUN21yTHVseDRXandYY3h4cXk3cGQyQ3VBY0tPZ3dldE04SzJOMXJXcUdORTNLa2Y3emQwVGs0NTllQitWYjBXMm0zMHVjMWRKTkpMZXpNSFdyQlVnaVpWVlFWRzBBZmVKSnppckZwNFBlNWhTNGFScmFFeHJoV2p5eGJ2eHh4K05kZmM2V05QdkxLT2FHUnJwUnNqWUFGUS9yazkvVDZuaWwxZXl2STR4aG5NUTVieSttZmZ2K09LMGxqWVF0RytyTUZocFN2SkxReUxiU2xzckFXY003T3U3TE5qRE5udHhuSCtlYTJZdFA4QURsdGN3aGJKYnh5b1Z0OXdEZzRHU3BVNEkrcDV4MnJFWmloTGtZVWo1Z0NSa2UvU3VoZncvTzFyNTFxalJ6amFRSTVEdGo2ZHo3ZGE1cThvUzNkcjlqYW5DYjA3ZHl4YzZQNGF1WW51SCsxeCtWd1k0a1pzSDA1NHozKzkyclB0YlN3bFh5UkZPRVhPMVVtRE5uUDAvblQ5UXNOU2hqaWxqMU0zTHF4UjQxazI3VzdnWk5MWTJ0OXRsU1pvNEhCQVVPRmZQcjBPSzU2YzQwNmJjcE5yN3pXVk9UbFpJZTBrVFd0eFovWjdocHNxZk5qWHpHMmprRTR3UDA3ZDZzMkY1SGRSVzBHSkZqakFYelpJMkFIVEdmd3JqZFQxZWExMTlMYTNua2p1STIzTzZqR1g3ZFBiK2RhbG5xdHhKSk52QWpYYWNzSGI1dTVPTTRINVZxNmNrcnhlajFFcEpxejNSMXQwcytuU2lHYWRaYlNUak8za1k1eGpQY0Q5YXliOWpGYXE4TXFCWGJCWFlNNHgxK25QU3N5YlZab3RLa21lMnRibTNWbFV5RjJMcVNldTBFQWNrYy9oaW5YUGlKYjJDTzJHUkN3eUdJUDNnUFFlK1IvK3FsU1UrUzAxeldmOWFEY1ZmM1hZczJ1ck9rOEVaU1I1Z3dVRWdNU1NlcThZQng5YXY2amJwTGJadDdCTHE0dWhoaTBJajR6MU9UOHh4eDFIT0RYSnl1RWsyVE5KR1J3SS93Q0lISFgvQUQ3VjBPamFpc0xRMjl4YTdwTUtXUllTWGozY2drNUJYcDE2ZTFSaklyU3BGYW9NT203akpvcmlPWXdTeXN6dmh5cXFHTUo1ejBIZkp5UFFIbXBGQ0lseXFuSVk4bVJjaHR4UEtzcE9lL1RnWjdjMDZTeHQydnJpNmhqRUxUSGZ2Q2ZNQWNBTDhwem5QYjhmVE01c2Jhd2lqTmxBenVtN3paemx6azVHQ04yQjI3ZmwwcmtjNDhxVjlUb2N0U1ZiQ2VRTFBiNGVQYUlwSVFNbE04REEzRHVmUThWSTFtOXJPeXgya2UvSjgwRzRJY2pIM3VNN1NmWVZKQlpKYTJVYklKRnZaU2YzZ2I1bUdmbUl6eDI2SEI0emoxbzZwYjZsY1JGa3V5ZHFBZVg1VzFsem5xZm1HY2NaR0RXS2ZOSzE5UE1oTnQ3amdJYnZjMXphTVpRU2thR1RPTTVIek54empHUFQwRlJXOEZ5c3U4SkdJSFlLb2x5c2k5T0JsaGtleDk2bGhzWjdxelMzaThqWklBWjNoQWpLWTVPT2NIdDI0OUthelc3V01kczByb1ZKVnBSTUNSanVSemoyK25TcXZiUlAvZ0ZlU0l5NVJwWmRzMGV4bDNtT0ZYU1E4NEdRd0l6N1ZidjVOUnVzeGlJMjdGUXZtNVVxcSttZDM2RE5OdTN6WnFKNzZWRjUyRWtnUDJ5TWRTZmZITlJFR1cxQ3lyYzJqekZkeDgzSGJxeWdmcGowNmRoU3ZacEM4eU83aGFTemc4dStYR1BtVkVaU294aklBUFg2NC9XcUVVOEZ4dGhXVkpYWU1vazVkZ0JuakhZblBRK3A1cTlQRUxUVFJkSENoSDNiWlFWVTVBQjZrK25RZi9YcFoyaWdhUnRQdHNBc1g4eUpXS2c5K21PZW5IMStsYVFkMVl0T3lNQjlEczJ1STJkQVpVT0dkbU8xdTQ0NmRNY1o2VmV0bzBrUzZnZUI4S1dWWTJVb0dCd05vSlAxNUhZSGlyYlRQSGN6SmZSQnBVYmVXSUxaNHlmazNFZ0FERkZuR0g4b01wQUJaa3ltT004SGFNRDhTYzlQcFcwcTBuRzhpRkZSMGlpdmZhZkN1bm00dGpEOXBmNXRubU9OdVRua2NlblgycWxCcGFOS0pwSjQwZGxLQ0paZ1dUT1A4L2xWMjh1aXlpQ1Z3cmtzSCtVSmxoam9EeVJqMDZWUXQ1ck1Yb3VUYngrWWVDRHRKYk9NNHlBYzlDT1B4cTRUcUtHaG5LQ2w3MGlTNjBXNGtnZHN0TENwS3A1TC9NTURvVDBINi95ck9PK3dzVXRiYUUyNzhLd1ppUkpJZXA1NUF3UDg1clRzdGFnMUl2SElwS3ZJVURkY1pKNHozNTR6eitsUjNNS1hPdHE2UEJCYmFlTjIyV0xJZmdrZy9yeU1rWk5YQ2MxTGxxTGJVVXFTVWRHVVA3SHVkUSthNjFCbHlyQnZKaEdFR01kbCtiL1BQZXMyOTBwOUlzRk1NL2wyMFpJRVYwb0RzZXAybnJqOVB6elhVMjk5Tjlva1Jvdk9sbWozUm1OaVZBeWVueTVQVFBHQi9LbWFsSWJsUEt1RHV0a1hseU01SXp1K25mcjJyU0dKcXFhaTlqT3BSaEdITTFjd05KUmJqU2ttRTdSd3luSkFHTjNiazU5dnBUcnp3OU5xTnVKa3UxaVNMdkt1RnhuMUhVL1FDcGRMMG02bWpXQ0s2U0dQZWZMVmw1S1krOTN4MFBGVzc2OWkwZTE4blVibWFXQkc4cnk0QUdEZFNjZE1jbkhJL090blZmdEdvUFhzY2txTTFhVFdqNmxXMzBuVzlBdnBKZExNTnc1dC9rZjVXZHM4WlJTY2NIam44aldvOWdMU0cydTVyKzRWeWkrY2tyZ01XQnllUndUMi9yVlBVVjBQN1ZIcWp3M0VGeHR4SEhHd09DUmpCWEE1QTYvV3A5TG5pblozbGhpbXQ3ZU1TaFpDU3dPY0J0dnB3UjBybHFPY29LY2w2NmIrVzdPeWdvU2JqRjN2NTZHNTltc2RRZ1NlUGU0ZGY0cEFCRWNjQWdIUFB2V1ZjYWtKUHNzTjRKNDBaRGw0ejUyQ0NQdkZNNEhQVFBTc3Z4QmZ2YVdTQ3ptaldJa05jUm92RXA2NUF5UUFEbmdWay84QUNRK1Nkcm1UQzg0WDd5TVBRL1dwbzRPVFhNOVYwN29wMStSdU94clhkamZXZDhidXlielAzaFV4N01Fc2VOd0JKeUR4eG5tbXpheTJxV2M2WEgyV0NRTVZTT08zMkVoUmpxV0o0NmRPM1d1MHRrbHVaSGNTTDVKalVRc3hJWkd4eTNwMTkvVTk2WnEvaEhUcDVJbm1PNmJHNlh5dUE0endDVG45T2YweFZLdHpUakdwSFhvLzY2R2xleXZ5UytSeWVpM04vZDZJYktDeFc0aVIzUW56UXVOMlR6a0hnZGMvV3V2MGEvRm5wMXJwcTdJdkxqQU13T0FTZXA5eVRTV0NScGNDS3dnaVdQZmtRb295VDdEcTN1YTM5WXVacktFd1R4eHlPVUxiSTEzRlFQdy96N1ZyVnF3cDNTMGIxTUtkNmpTZlFhTkYxRzRnV1ZYZ3V6RVJJRXlCNWg2Z0tlbnB5YXlFbHVOU2E2K3pvOW5OYTh6cVQ1aklCemdEMStVajhhcytIZFR0N1NDVzNnbXR3Uy83eEk1Vko0QlBPV0pIR2ZiclZHNW50YmpVcng3Q1A5M000ZVpsYklsZFJnY2RPSzh1S2RhdGFhdTExLzRCMTNsUlRTZWhqejZSY2F6cUVidk5Jc0NsZDl3K0Vaam41aUJqQi9BZmpXbmQzT29UdGRXNG1heE1jakxGRXNvUXlnWitZaGwrYklIQUJIYm5tck1hTkpDN3MyV1k4RHYwN1VzM2lXOGcwbDVWbnNTbHVBaXd6Uk9aR2JQM2R3SXdNWTUvT3UrcEJ3aXVVeWpYY25xaWhGb21vbWN4M01yZ0JRZk8zRTdoajN4elVGenFHcFFJOXROWXZNc2YrcGFOY1pYUGNuR1RVOXJyY3Q2ckhlcFpSZ3B1NjQ5ejBxc2RWdUxlZHA1WS9PamJjTmhibGp6anQzeCtsRk9qVWpKODd2NUVUcnhrbFpIQzY1QmMvd0JxUlMyOXRJenlvU3lrL2NJUHFmVGo4cTZEU3JLMm5nVCswb2xhNlE1WGFXQU9lM0JxcStzM0dxengzRTlyRERHc2hqUkZYbkI1NVBVOUtjOTVOcHQ0c1VTbGxjN2wzY2pIcDlSWGROU2NWSHFjOFdrMjc3bHJXZGIwK0cvdk5OVzJtRW9oQzduRzlRU252MDRJckoweUc0bmppRVdvUldzZ0IvZVNEQXhuSnh3ZWFOVFZwTDd6TGh0bm5rbnpGR1Rqb0FQcHh6Vi9TTGV3MGw0aGViNXhNd1pYVVpBUWRlbmYvR3AwaEN5M0xTY25kN0hWejZOcGxscFM2bGNXNzNscUUzR2R6SWgzRDJ3Y2oySngrZFpPaTYzZGFqcWNubldhbE5tQXBPM2IzRzBBWjRYbkhQclhUYW5QRkRCSmEyRjV1MGc0a2tWK2NObmtEMjRIRlp2Z3d4WEVkL0ZhMjl1WUJjQ1JmTlhBKzZBY1lJSEdCeHpYbU9TVkdVNWErdlE2ZWVWMWZUOEJzLzJjd3d4R1ZveUc4czQ0ZkdlRkxjbkI5K1NCeWFrdnJWdE5naVlIem54OXlOeHNDOWkzSDE3ZmpXUmZTUGJhNUxDRVZYWmwyUndFc3VQWG5zZXYxTmI5cE81dHByWm9wSkVCVXNVais0U0J5RG4yejdkcXltbkhsbGU1cGQ5TmhxdXVvTEJOUGlQeXdHSmR2TFlIMTJrRUhnZzU2L2hVc054aUtTTkovdFlMa0NNSWlvaHdUbHpqSUhwNjl2ZklzcGJlK211RDVVc0NSTCsrL2QrWVpNY25KSzRIYnRtdFdDNWxudlcyeFJ3UW5JWWVWL3JCZ2JTRzZkc0gwcUtzSEJOTGIrdjYwSmFWOWhuK2tpeE4xRkJGSmFSZ2J6RVBLM2dqblB5OEVjYzlPdjFEcksrajFPTXhmWnZJamlYRFJ5RGVXanh4azlNZE8vU3F1b1F5YldOMExsTFVzU2JkRkJCUEdNRmhnL2h6OUttc3ROa2cxUDdlMzJpU09LTUJFaGZDcXpad0dVajd1TzVPZWxKcVBKNTlBbDNaUGMzOE5xWW9yZU9lNG0zbktRSDdnSFg1UUNCMUk2VlZzTCtHUzJtZGhPMEptM2JqKzdEWU9jSE9WWWtucHdmclYyM2l2NHA1MjFaQkl1ZGtJUXJuSlBISVBPQjM3WTdWalQyMGNtb2hoZVRLTWtOQTBiTWM0NEhKQUlvaEdDdkg4UnBKNkdtSnhQZnREdXN6NXY4QXowdWxVQWRTTnBISjZkUHlxK3R2SXNWdnNuVU9PSGpqdDFJSjUrOFNWNDc5TW5GWmNkN1BDVSt6YVZienJ2SUxiOE51SjZnTXVCMVA1L1dwcDdHOW1OdXNrUW1CSG1ZTW9TUEh0dFljOU94L25VdU51VkxUN24rcExXdXBCSkhFWlh2R3ZiYVJVM0xISEhoaVR5QUFGK2xSWDBGL2J2RzRtVUpPQWZMYUlzcEdNblBUR00rb3g3VmRXQzUwNlVYSWxoZ2l5ZjNma2xwdHg0SGI1UUFlL3B4U1hGeGRhMWROYlNpT2FJSzBaalljUGpITGJTTjNQdDFQV3JqZTkzc1ZkMzAyTXUwaFc5ZTZuS3hMdGl3SXlOeW5JT1NNTm5CejF6MnFocEZ6WmlKbGFJM0JDbG1rWGFvQUdQbUdUampQMTlxMnJXS09PNWlLU3hJeEFXU0FLelk5c0hnREk2LzQxYzhyRVJZUW1UeTEyRTRLbVFaeWVNQU1QODhWY3F5amRXdmNyVmFJNXUxdUk3aHJadk9NV3hmTkxaK1llZ3dHNTR4MkdNODFmMUpwYk8xTWx0WXhTU1NzQUN3RzFndzZrZzVQWHBWcUMzaTh0YnBWbHZwdnZKbUxsRUhRSG5wa2RTZWFxZVRkYS9PYmFTMmpnYTMrWmxKMkU5bEFPU0Q5UjZIMnB1U2MrYm92NjlSdXB5MDMzSTdPenVDL2tLelFGRkhtR01iVVgvZ1FBNXhVc2xoQll2NWNFL201RzVuVXNNTitQLzEvd3FLR080dHBCYjNVYy9rUjVLTzh2eUtjOVIyengrdFFTSll5VEtpWHM4eU9wSlZXR0VJd1NjNDdjZXRVdFpiNkdkYWRXdkRsU3N2TzEvdUczU1JYcUNFc1ZWamxTRjdqOHY4QTY5VlpOS2drL2R0dUt4cXBmSnprQTg1L0hGTE9zT3FFeFJhamhvMStkVTJvU2NjZEIvSVpPS3RTNklZSWxDWFVqRS9MallTR2JqaysyVDB4VzhaK3owVXJNODZ2VHF0S0xsekx0YnFjdHFkNVoyMDBNRWllYzhtN0k1Q2pJSTY5K3Z0akh0V1JaYW5LOTdiaVF0SmlSWW1jeWJTRlBCQjdkY2M0NjljMXJUK0c3ZUhXdk52TlVJMkRjUnR4dk9Ca0RHZlhyai82Kzlwa01UNW0wZ3BackNvVVNvbTRnK2pjWVBUT2ZldlFkYW5UcHEydDF2MENoaDUvQzNheHN4NmJwWVV3cnBueXNpbDk4aFlxU09HQnpqSEp5UngrVlkwdmhmVExlWGZjcXNpcXhNczd6YjJ4enpzWEdSeW96eldjdXNYMTVKNXNrakMyRGIvUUJRQU9CNllGYmRuRWw1cWRzWG1sU0JsNVdNRlhQR1FPUmpIdWZTdUYwNnRKTnluK1ozUW5HYnNvbTBaYmlFckpKYXorUmppWmNxQ1QwSCsxVmEydlpacnpidTN1QVhaU2NuQTY5dXZJOUswcnE0bDFUVFZ1SkxxTTJ5L2VFU0dNcVNjWjVKeWVjZFIxcUxTOUhqc0xxYTVudkE4MGlNcUtWMitXT01aNVBQSGVpV010QnQvRTlscVJHZzFKWFdpSWRGajh6WG95RmtVbHpzbHdTa1pHU04zSVBiSFhxUldaOFNkVXZyMnpDUWFiY1FNamhacFhWZHBYMERaNlovQ3JabmFXT09USlBra2JraWJxY2prMWQxQzVTUU5ITWpQQzBYbHNqZGR1T2Z6eld6dzZsVlZaNnRHS3FKUmNPNTUxb0ZvOXFodkhENFlCVmNrWU9ldUFNbnQxUFd1eDB5eGx2TE5wTE8wZG15TmtnK1ZRY2V2UURQcWZUMXFzTkhzWUhqaXQzdUV0dVdFWktzM1gxeHhtdXQwelhZYlQ3RlpMRnRoS2lOTW5rYlJna1k2bkpHZnJWVlhLVFVtdHpTTVl4WExCM011NXZsMG1lM1c1Z25oYVJnRzNxQ0Y2Wk80Y01NK25hcVBpaTh0b3JOYmFVUWVaT2NoVDJ4MElJNmZXdTZtamp1WjNqTU1jbHBzK2Z6Qm44K3ZGY0Y0ditIMXZxOW5KcUdtenVseEREbU5ETm1NNDdjOGpQNVU2YmpkUmtaeVR0ZUtNaGRTaXM0RkU4OEdTQnR3Y3Nmd3hrajg2dFdXb2FmZTZlNk5NQklUdFVNZm1SdTM1NHJ6MngwVzdtT0cycStkbUpDUWM1K2xiOEdrUzZScGx4Y3lPa2w4U0JFaWpPekhmMytsZEU2Y0ZwekdTYmVyUjBmaVRSelkyTnRkRUtKSElXWjRsNis1SGM1NzFuMjFwZjYyVnRValZJY2JsbVZ2bS9EUFR2VG5ON2ZhTEhiM2tzek5JUzdTWis2QUFRQU8zL3dCYXRMd3hMSmFhZEpiU3VDOFFHMlE5Q29KNjFsSnVNTDdzdGNzcFdLVi9vazg5MUhwOFpMT05pUnlOMllkYy9xYWlNVTJsN212WlF6eHVVVk1ZVWxlT0JXNS93a3VtMnQ4a3d1QmNzSkFka1FCK2JvZVJ4K05VdGZuSGk3WHJDeWVHUzBXT05tUnBBVkpCR1c2ZGVRQjI2bXVaMUtuT3VkV2piVm5SR0M1YlIzdVo5NXF0OXJjQzJFRVlWUXdhWUtSdUNmVFBQUFlWdDZiWVM2TFlIemRSRnZic3BkMWlJWmM1NCtZc0FQb1JSb3ZoNUxMeklmc0luMVFwNWtBV1JWVlNHd1NISjNBOUNLdVFXOStESTE1RE0xak9XODZOclpDd2t6akRrTGxnTTljODRyR3ZVVW84c0xjdjUvbWFRanl1NzNLVnJyZXZ4emVUL29za1lHeU1YSVdPWFBkVkp5ckFqQjQ5YXZ5WG1zMm1wUkxHbmsyUlFCVTd4c1R6bnFUN1ZMYVdWNWIzWDJPMENpMElZaVNDUU11QVFUbGo5eGw5UDhUVVd0WGw5ZHl3QzJ1VnVMWkUyU3F6S0pONTZCa3p3TVordld1ZHBWSjZSVnJhanVvK1pWZ3V0WGVhUzJ1WW8ydHhoV2ljb0EyT0FjQTdpZVBjSEg1YnRsSmF5dzNIbFMzRXNzWkMvdlZLNWJhQ0NNWXdPUndlT3RZK25XOXRMZEdLZUtBM0JVYkEwbTBkemtlL3YvOEFxcnBZTnFyS1p3QkhJdURMT0I2OUc2NVA2K2xaWW1TV3l0NmJCTFJhR0phM0R6dGNSeXl4eitUdDN4dEdHYkJVSEkzRWNqMlVFZDYxSVZudmJDWHpWdW9ZWkN1OVpDR1ZsNDVMWjQ3OU1IK21UYTNqVE03MkZpalc4TWhSMzNaeTNJR0dQVUFrSEI3ZGdLclJIVS9zRTgrcVhzVTZvTWZNTmdDdDZEZ0UvZ1I2ZTF1UE5mVzNidURqcm9hK2syMm9RRHpHSm50aGtSU3lGZkxUbnJqN3dPRGpPQjM1cXZxa0VFZ3VMMFJYYlN4QTdybDNaMUNyeVI3RDM3VldqMUc3TmtUR1puQTRETTI5R1U5QmhlRGpwd0JqSUhQV29vUE8xYlQyc2JxZTNTSlN3S3Vza1JjY2tnbGY4S1hKSlBtbG92SXBKcDh5S3R2cjJuM01zdHY5cXZGbVdRSVFxN01FZHVweitKTmFVeGtsdWJXNDNReXdPekx1UWJqdXdUdFluMndSalBhcmwxYjI2Mi8ycHJPMDNCdHdlMWtSTnpZOU9BY2dZendlT2FraHQ3VkxTRzZ1WTVNU0F2aDBiQmJuZ2JXSlhub2UrZXRFcFUrYThWNWRCS2NrcnZjemJ5NXVHdDBraEVrUmlPNFpRbko3QWc1QTR6OWZ3cDBrbDFKby9ud1BJR2xQbVNGckpNUnRqcjA2WUE5dUt0UmE1TGQyY1Z0RklrY2JGWXBiaFZJQ3FlT2QzWEdjWnpTcnJWL29zbHhIZVI3TGRPSTNXTGx4bjcyTUVBSFBwUTd3YVVVTjNlalN1Y3dta3l0YWViY2FyRmxHM1BGQ3JCenpnanJqcG5yZ0RudFhUU3pXOE9tdjVjMGtiU01HWmtoWXVxNFBVNFBQUG9LeVpyRk5Sdko1WTBWWTQxNEVTSXVjak8wNEFHQitOUzZBWk5Namt0N3kxY1F0SVEzbHJ2WlI3ZTNIcFd0YVhORlN2ZHJvTnB0YWxyVDBrc0xTZTRXK2xCYy9OSkxHQ1dIWG5qMzk2eS90RXhhUyswclVZWnJrNVR5NCtrZklHM2xNOGRlUHg0RldWMHlIVzU3eExBeVFXeVBsMG1rdzhoOU5weVA1Q2l4czU3TzhpaWt1Rmx0a2t3c1FJK1JnY3FEMkJCUHVLVGNZM2IzN2FDOURNdjdoNEU4NjRraUZ3ekw1YUZtWno5Rk9Gd09lYXpCZTNVdDVENU1ZUXp1UXFSdGhlT3ZQUFRtdWd1VWkxTHhkbDdGWldWZkxSYmpiRmxqL0FIbE9EbnJWZlh0T2lzR3RaaFptSzRnZDlscDVaWVp4bmdBWTY4K2h4WFRDUzBUanExL1NNOWI3a2NhUlh1bFhOdkVwZEk4eWg0WVNTOHVRY2xnYzU1QTdIOGpVZHpINGhpbHQ3NlpvN1oxaUNnU2taeTNjQThrL1FIODZzSWJ5NnNZcitPNmxVTTQyeHdaTG5JK1pRTm9DNEk5ODFSazFDTmJ5T1hVRTFLMGZQeUY4dVZBUEpKYmtIMXh4ejJwUWkzSjZKL2o2bTNNMThKTTlpc3picm0zTThhQU1YODM3djBKT2NuT01WRERMZFI2dXM2V1MvSXF1MXRGSjVaZFdPQUNjZk1mcWVRUHdxN2E2NVlvZ2JUWnJscEZZa200VldCSno5TTllbUQxclRpMzZlb21udkpFdUp1R2hFSU8wL1RHTVovRGc4MW5LY29KeGtyOUZ2L1NDYXUxSk94bGpVNG9MK1MvRnBjUnlFNGUxWjk1R2VDUVIwT2M4WTR6MjdRbThtdjBsbnNJcEpJclU1ZHBGSlptQUJ4dFlja2NZNXg2QVZhMDdVTGRyNjh1bFo1YmlOU3J2UEdOejllQjZBSDB4VmE0OFVQWVhDd1cwUUVrN002U3UyZmw2ZHV2T2ZUZ2pnOWF0S2QzR0VOZE4yUTVSaWsyOUNTMHROUnNsa2plQ1NXUitUdGxYYURuc3FrY2pqR1JtbnJLNGhDekNRdm5nWkpJSi9RVnR4WGE2bksxcEhZcERGSmh6S0J3UDhPbnArZFZHczdPT1dNcmNrcWVIZE9SalBQOEFXdWkvdlhaeXo1bXJFTnVTa3BkSkZqa1VaNHdRZlRQNDFiVlk3bUZkKzM3dnpCVDM3RDgvNTFrNnZGL1pscGRTV1V3dTJRYnRtN3NmUTk2eG9ySHhUY1RRbGs4cDVCdVhMQXNSeGtZL0hHT0s2S2NvNzdHUEkyanJiR0JJbWN5bmJzWTg0empQcldlYmhMUzZTN0NHV09PVU9rY294dUFQY2VuK1RWR0hWN3N6dXMwNGxsKzduWVB4d0IwcXZkWDhOc00zOXpISDZienlmNm1ydnpYUXVXeDduSExiUzZhcW9QM08zcEdjY0Qwcnp2WGRRdHJ1NmUxMGRRUWh5N0JzcU81R0FCeFdmWitOb0VndGtzYjZYeTNpK1lTSUNWWmVCbjZqbmowcXFkYmhZVHlzVExkVHR0M0xHQW9BNC96MXJ5Y0xTcXFiNWtkVTR4aEc2ZTVpNnZvc3R3dHhlTkxISkhFNjdva2ZZNGZBK1ljL01NNTkvYXB0T3NvWWRGTHh0SWJoaUdjeU9XS0RydDU3WXJmMCtSSVlwWmxLQ1BBTEt5NHh6MUFybXRQdS90SDIxemNLdUxsdHJxZXE5UDVEdjYxM1JsTnBwN0lWVnhjVnlsOXJ5M2pGdEd3RHI1dzI3aDFQUC8xeFROUXM5UFoxYTZqTWx0Z2wxVEI0QTQ0SkFOWU9zenZhYWpEY1FoemJqSkhVSzdNZWMvaFd2cURSdHBsdk5GSnVNcTdDblhHUi93RFhyVnhzazExT2RhbFhTcmRWdVZleXRJVjh0L05XT1h1RjljWTU5dmFwNGZGVWE2OWQyMTlhRzNXNVVBR0Y5cFE3UnloL2g2SDI1TlQrQzBEYXBMdlFvOFVUTW9mcURrRC9BQnJVdk5MMGVTN2tobEVVVjYvelJxeUJkNHgwVWdFZ1p6MEhldU9wVmc2MHFjNDMwT3lGTit6VWsrcFpYVTlQbnUxYVBVNDdXZVJBR2VVZ0RBeHcyZU1IbnRqT2ExZnRDTGRUVHRDOXRkS1NvTVR5YkppQmhUOHBJL25YRDZ4NGNnamlqdUxkcEpJWThKTmJiOFN4TWR2M1QvRXZQY2NmalhSNmZaMnh0b25zWmRVaVluYjltRXFGWFB1UWNZNTdFWjVybHEwNmNJSndrKzMvQUFDcnViMVJyWGMrcDJ1a1I2a3J4UEt6QkpGdGw4MHFCeVd4blBxR0hiK1hOTC9aVi9PNHVZSjRiOVQ1cEJVcUpSMkJUQkhYSGJtdEhVcm0rMDVCRE5kdFpwRmtDWll4SUl3ZUIyNHdmNTB4TEhXcnU0VzR1N3kxMUtDUlF5Um1OWVd3Y1p3UngwNS8vWFVVbkNFT1pPMSszL0RXL0VybGNkSHFVdFBld2V6MUt5aHRyaTFrUTcxTDVHNGorWGZ0VzVhUVF5UVcxdElKTmpSZzdvM0c1VGorUG5HTzNROS94enIzVWJ1NHZiV3dnMC95MzM4TXk3OWpMenR3T2NkZlRyV3pmNnphWGx2Y1d6d1N3YWhBcFY1TnVRbWNjZ2VoOUdIZnZnVk5UMmtyTmFYMTN2YnBjYzI3MmU3TXdMZFcycGhMZnpmc3FzVVlpNVpSMEh6SEE2OEhKOXZlcjAycmZiakpETEo5bXdjTkpBNFliY25uN2dKSnhuQkJGT3NJL3RHak0xZzV0V0FNV1ZLbys3QXdRY1l4ejZldjFybW9OTW5zM2U5dmJtTzNPUkY1TFI1WjFKQlBESEI5YXVuRlR2ZDZyN3hOSyt4MFNTUVc4QzJzWkQ3MVBsTUUzSGVldWZtSDF3QUI5YXN5MzlycDFoSGNwTEhHOGdNWUR4NDh4c2RTRnpqb2UzZXN5MXZiSnBwQlpTMjhTUHVkaGdLSXN0OG9Zamp1T0Q2ZDY0dTZ0cFo5ZWtsMU9kdG04S0lNK1gvZEdTMk9BZWVSenhUcDRYMnN1V2JzbHI1c21TMFhLdFdkMUMwRytJWFN4eHF6Z3RJV1oxSUJHQ0VROUJ4eU1EMTcxVzFIWDRMWXU4YUxxTWNJeWlLcFh5eU9PUVJqSFFaeHhXQm9XcEhSL0VrTU1jclhOazUzSVpNNXdSeitJNSt2QjcxdkRUYlMzbm52dE5ubGxNYmhsTGdCOG43eFZzODV5ZStUNzFwVnBVNmR1ZlgrdnZRVTV4bkp4ZWpJcldlMW5QMjR3dnA4cU1YL0FIQXl2YmRuSFRQcjlhMlJkUGVlVkxZMzhGeGF1ZG9YSlZTZXBCWWhqLzQ3eHoxck92ck83dGtTL3RGKzBTSzRieWhIdmt5UFRKd1AwTlRXb3VMYThNeVJ4NmZOTU54eGpiTjB5R1RHUTM4ajdITmM3NUd1YjdyL0FKZHlwcm1mdWhFMWhjM2t0dkRwdWx2QUNSSk50REYrRHlBQ3Z6REdPZzYrMU1FMElpTmpqN0toQVpBek5oazlseGhRVG5ucGcxU250YkM5bm1aOUluZ2tsWWxKTUJDNUI1UEp6anJ4akgwelYyR3k4TVF5allJdnRheFlhU1RMc1RqT1RudmsrdmNWcW5GNk52MC9wc1Z1VkxRbWxNMWxKRnR0clZJc2ZLeXB5d0k0NVBYMTlLWTF4ZjMya3h4Mk16V2h5N1A1VU1pNVBYSjVKVWRUZ1krbE5FMWxiL1psbWx0cjYzWnhHNnhUTkc4WS92RG5CeDlSK2RYTlV1WW9FV1BUWTVJV2s0TFcyNE1RTUU1WG9UanZrVkVZY3JTYTFFMm5zdm1aVnJIckVKUzYvY2tpSUI3Z3V4VjJJNTR5cCtuVTFLOTdxOFFtRU9uczBDS1dlVnBBT004Z1piZDdkS3JEYkRLSkJZM3l5QUdPRkZRYnM5U3dENXdTZTRQYXJRdDcvVmJ0TGg1SkVaMEt2RW1VOHZCNm5zU2U1SDUxYzNCNnlTdC9YWmxMbTdtZkpxMTNxR2tmYXBTOEZxa3BRbTRnWlhaUVFjYitRZlQxck92NFpyblR4Y1E2WEkxdVdEN3kyNWlneGpra0EvOEExcTNwcjJORXViSzl0cm1TY2NxVHNFUVR0a2s4dCtWTTB6WGJxYSttdDVzeUltTmlSS3NhZ2VvSUpQcHh4ZzVxbEtjRnp3aWt0OStuK1k0dVZ1VXE2ZjRaamFkWjRacFZIVjNlTU1nYkpPUXVRY2o2K280cTNwVnJGTGVYRndxdk9pb1ZhU1dVUnNSamdxZ0FHM3IzcTVxTTBhaVc5c1ozWFU1b2xVSTBEc3NZSFZTUURqdnhtdWIwL1ZMZU4zdTlUdG9HWmh0WldUeXVyY3ZrQWtqR1R6MTR4bk9LY0ZWckp0dnk4ek55WFFsdS93Q3pFdkZhM3RVU0tIRzhKQ29WbUF5Q0FxODlmWG1zN1ZQRmtqeXNsNGl2Ym9GbFpOZytibjVRRDFIUFhIcDJxM3FlcFEzZ21nc2lzZG5DeWtScXZ6dDlBZXVLamh1YnJSb0Z2UnA0MzhsN21VTElOdlRsQW9JSTY1NDk2NklSV2twSzc2YTZsdnlSeThuamk1Q3JFWW9aTURCQzVPZng2Znpxdko0cDFpN2NKQXJ4d2pnUXhBODhqMDU2Z2UxZEZjNmZwZHRweG1tZ0NNd3dFUmNFMUg0WnVIdmJ1M3Q5dUkwVWpHY0FmVDlhNzFVcHFQTkdCd3VGUnV6a1VyYnhOcTBVOFAyclR4SGI3c1BJMEpIWDYxNlZKZjZmSm9rTjVDOGJCSTErNWxpbWNaSFk5dXByU1dEVEZ0MWhHR2pWY0V2MTlEa2Q2ejd2U2RHa3QzRVVDVzByREJlQTREZlVISVA0akZjT0lqR3JacFdhN0hWaHB1bGRTMVRPVThRYVplM0RMcVdpWE1NVnZjdWZNQ0RNaW5IUFVkOEgzeWF4cGZoMWMzbHNzdm5TU1N0eVdMRTU5ZXRYTk5ua3NaV2dnbndrc204ZHdjREE0T2VEeWVQYXV6ZTl1YmEzWGF1NUhUZHRiQklKSFVINjgvaFhWU2M0UXNudC9XcHoxNHdjbjJaNXhGNEptc3JXUnk4MzJnWUM4N1FCMzZWMEsyMGVuNkJickpHZU9Da1p5eE9QenJTYTVkdjNrcmJnQ1dJeGpyV1hyVnRNV056REt4ampVU0tnSklQYy9qZy9wV2pxT1MxSVZOTFJGSWFsL2JOakphMis4UVNERHQ5emQ3ZjQxSytnS3R1a1NKS3JwZ2hVQkFaZTQ5K21hWnBLSkl5K1NQM0s1eHQ1QTcxcFgydHJZVDJ6cTRMN3R2QjU2SCtWUzk5Qks3WTJTR0s3MHlhemsyaEdHRllEa0hzYTU2ekMyN1BOZG9KWlltS0NNbktBaitlYTNOVnVXVFM0OVdUNWxuY3ErMGNSeVlCd2ZxRCtPRFcxbzkxcE4zcEZySjloaWtuOHY1VmtqLzFyWU9UdXhnNVBZOU1WaFd4S2hUVWxGczJoUmx6dFBvWmxwRExxRnpGcVRHZUtIa2hZY0J1RGdrOEhDOWVPK0szSWZFZWpXTUVsbnJOdWpzdUYzelFid3dJemtIcUt5MzhSM2hnOHkydHpiUktPZHhETU9nMnFDTUFmV3B6YTJHcHdLOTdjR0s5YkEvZXdObDg5d3luQS9URmNNb0tXczlGMlc2TzZTVFhLMEsxMVlQSmNYVnZkMjl4cHNpNEZtU0EwZkdCc0o1UDQxYWcwZlVMUy9UVklMd1BwcGoyRzBrWUJtNEdBT09TZmZCNHFHUHd4cDFvMEt2TTFxWlcrVlhqd2pFbk9PbU1WVXVmRDB5TkxieHlXMDBNakY0MHRVTW9CNEJQQk8zakhiRktEcHp2WjNYbXVuK2ZtWnZvcjJOR1c1VFU1aEJwOXBhaVBIbDNJdjJaU2dIYjFIT1IvK3FvcHRNdmRIQmh0YnVLR1NSU3NFY2plWkNwN0t1VDk0RHVSM3FIUUxNMmJIVHJ1emhVczVmTXNhN2w0SkpMSEI1QXlSeU90U3JlV0YrYi9BRVRVcjlmc2dPWXR5S1dpT2VkcmRjWVBYOHFoeGNKT01QaFhsZS85ZmtGdXFMMW5KcU1GbEJMTGVtWGErR3QwVlN3SFE3VzNFZHM5Q2ZwVXNzOXNOTkYzYjN5UXRlU0ZXamVOVk1qZjNqbHVlM1BYMEhOY3haZUQxMUM2bVN6MU40NFk4N1doaytlUURqSTdZNmM0cXRiblY0dFJFUnZRc2NYemVkZFErWm4wejBJSEg0YzFwN0duT1RjSks2MWVsaEs2ZXFOUFVkUXZCYjIxdkRKWXhzaVphUlZkMWt6MzVHRGtZT0RuSDg2OTR5c3FvVWpScmpDeGlMYUdBNjVLSHRuSFVjNTZjVm5KY2F2cU1iV2trc2NRY2xWbFJRR2tVY2NLbkp6MCtianB6WFgrR3RNVFMyZWQ3eU9WZm1BV1NFR1pUakFPNGtiZ01kTUE5cTBxMnBSNlg3ZjhFZnRMYXE1VDAzVFFiTmdsMUcwakREUk5GdExkUUQ4M0s5QWNZNjU3VlFoMDY2dnBCQzF2WnprQUVyT29qa0dPdklVSHI3MXZMWlNYYTM3WGpHemp3V053d0tzUFRhQWNZT01qR2VmWEZadWphQTBNbHpKSjRpbEkrVXJJbnpsKzV6dUhCd0FQVG11ZUZSOHNwT1g0ZjVBNmo5VEZ1TkJtMHFPNk54QWtoUkI1THd1eDJsbkNrWkpHZmxZL2xVZW5hZE5OSlBaV0w2aXM2L3ZJbU14VkY2ZE9RQ1ByWFd5SnBlc3BIRE1KemZRU0RhaW9wTEx3T1Z3UjM2am5QZnRVK213NlpieVhFOExIVGxjY1prT1d3ZWNaUFg2VnRMRlNWSzcrTDAwTTJsemFvNG5TZkdWM1lYTnpCcVZzdzhodGpCeGtnbis4Y2Q4ZS93Q09jMTBGOTRpMG1Xd2l1N2UzU1M3ajVsdC9tRy8vQUhjWndlaDZDckY3cTluZHRQSkpwaVBZM2theHk0QURNeTg1ZkFES2VSOTMrNzE5ZWV1L0JscE5ETGRXU1NXTTIzOTNBakIwSFBYTzcrZU92TmJwMEp5VG11VitXeGtvMUthME9xMFpUZHd5WGtHWXpNbm5KRklvalpjNHlDY1p4MXdjZmpVc2VuK2RMTTk3YmcrZXBEb0dZeHVBY2J1ZWM4RG44eDF6eldsVzBsakVVV0c3V1loRElzMGU0Tmpvd1lIR0RqT09jWjYxYnViVFVyeTczeDM2UVlPeHJZTVFXSHFEa0hwL2sxd1RwcFZINzFsM090UmNvcVRMdDdZSnEwRXJ3bVVTeE50VVN5c2tZNi9NTWprWTl5ZnBUN1ZudTRUOWplMmdXRDVaYm14M0FnWkdSa2pCenp5UGZuTlpEcGN2bTRralVXanVka1h6TjVaQTdrNTUvRWRzQ3JjUzNXdVdyMkYxSGZMQkFqU3lUU1M0V05RU1EyZXVjRHAxL25XcmcrWFRXMzRFeWpiZGwyQjFTMWx0TG1kYm0zYklTVHppNWt6enRMS0FmYkhYaWpUOUt0YnkwanZsbmxpTWFnTENMa3BIQUFNRGR1UElKQTdFOCt4TlM2UGZ3V3RuTGJTM011NHNRTXFTTm9HTnpFRVpQQTV4ajY5YTVZMmR4TE95alVZcDR5eGFOSW9pejR6alp1d3FuZzBvUWNtN3V3cmROamMxdlR0T21qYStqdlFWaDVsa2lHOE9lbkEvaXdlS1l5NlYvWnJ3MjB6VHdYUUlEUnhneUtXQXlDT09tUjZmanpXVEhyYlc5ekZiVytoeXVnallPbHdwMm9CejkzMjY5amptdDdRV3VaWkpXamV4Z2FjaGRyZy9mOWZ2YzhkaFRsUmxDS1UyMHVnM0s2MGQ3RmpUdFA4QTdHVnplMzRrREx0aWtsUUtzWTR3TUFnS1B6ckUxQ096RjlJdHJFSkxtVUJua2drK1VBOUNBRHpuUFA1NHFYV2JCYmkzRUYzcjhFMDNtN21XT0FJckQwUGNubml0YTAwaHJUUnZLaSt5UXpYQzcwRWtUS3hYR01rSzRQVE5FZlpwODdsK0RTL0loeWxHeHcrbHd5MnVxeWk3VDdWTTBaVllHQkhsbGh3eHlQU3RqKzFJM3g5cmpNTnFIeEsva2s5UWNmcnhWK3greFdGL0c3NmtSTFpSYlZpTnNWUVpCSEI1TFl6MUI5ZmVxVjQxaHJ0L0k4OWkwNmx0MGQ4c2J4cXpkbExubkdTZVBZVnJLVWFrN3lUc3V2OEF3OXY2N2pWUjlOVEF2YmlJbVdReWVhbzZPVHpqcDBxcjRMajh4N3FaM0lJd2NNZHB4ejA1OTZ6YlRSYnpWYmRwVm5FYThEeTlyWk9mY0RBL0d0SmZERWxoOHcxR2NGQUYyeC9MZy9qbXZXOWl1Und2cXpnOXUrZFN0b2p1ZnNsbFBEa2N1Vkk4d3N6RWU0NXhXTGRXOXZIWnpMTE1ETW1UR1VKSG1Ec3pjL2hpc2Ird2RkdnJhU2VMVkpaVWo2cHZBYnQrZFlFMXkybTNja001bGxkVHh1WW1zWVlkM2FVcnN0MW8zVGFzZHJwOEl1SkxjWlh6Tm9VSEhURmRWcUNMTEluSXdpaGQyZVNBSzRidy9mbVc4aWthSXBHZzNBZzVMZTM1NHJvSmJxZWE0ODUyS2tIT0NNWUZOTGwwWXFqdnNWZGFjeGFiTUljZWMrRWpYUFVrK3YweitWTFlSVHo2UkpIY0RiS2pZSUI1OU80OTZqa3VaYnJWQkpaaGxXQW5nTmpkbnJqK2RNdmRTanNrZTVkeVgySEtiZVNUanArWXFaN2NxUnBIdWMvWjZwSm90ek5ibHQ4VzR4bHV4d1NNKzFUemhMNllOQ2Q4a1EzRUlRZHVjSEpCNmpqOVJXUGErR3RRdUZuZUtkcGlFODFGQjVtR2VTbzlmYnJYVmFFSXRKMHZ5NTlJbCsxVHN5YjR5ckVZQndXQk9SMVBQVDNxNjg0d2plT3JERHhrNSs4ckkyclcxZ204S3gyY0dxMi8yaU9aWm1nZUxheWNjcVd5YzVBT0RnVTdVZFl0NFpMZGRVc3JYK3poRUVDeFFFckcvd0RlNDZZN0RqclZQeW9yUC9TclNVaVZ6c0N6RlFXNDVBL21SL2pVbHRCWkZ4UFk2a0xQZktXa3RuUUxuaitESU9QcHg5Szh4OHJ1M3MvNjZIYzRXMTYva2F1amFwSkFKWWJtYTN2WS9LSjh5T0VNMjNIRzRzUjA2Y2p0MXFwZFdVSWxzaE50U3ppK2NiNWNuZ0FxTUwyN0hucG5uTlZ0VjFEVHJXMWJTMHNibDNtZk85SXprRnNad3dJeU1FOWMvU3JPbHorSHhwc2p5eXhsWE8xMWtqTzRuampiako2OXMxaEtMaWxVaEYyZlpDamE3dnVTRHhOUHJFRDIxbGFlYzYvTWNqQ3g0UDNodjdaNHo2VmdXbG5xd3ZWbWE5dGJkbFhCTUN0dUl6M3dRTzNhb2J5K1NhOWhtczRKWTdBbmF6RldDc2VvWTg0SnljZmlPbGFqWFVGdEFzc2hVN3Z1QUxrdDlLOUhEVUlVMTdxc245NXpWcE5hSTFyelJKYml3ajFDZlZHTzZSUkNnMmtLdzQzQlNwL3lhU3pqMDk5TVFUMnlYRjlEL3E5eXFCS1N4d1N1UURqT2M5cXhySy9pdTduUDJuWXh6aU9SY0VqMHorSFNrZVdHNW5rVzRVb1ZLK1NPT0Q3OGpqR1I2OCsxS3RRWHM3WHRic1JUbEp5c3k3WXV1a1hrZjlwYlZlWjIrenoyOG1XVnllVi9kL1hvQVJ6V3hGSHAycWFuY0Y3bVc0Q3BnTHRZcVhBenpoY25Idjc4Vm4rSGJPMm5acnlTMHRIdW9YWUpKSTVKSkhjZ0E0OVBYOGF2K0pOWjAyMVJJQkVKYnFiWUdhQ0hIbEFFSEpZanBuMC9UclhCVWNuVlVVbmZ5L3I5VG9iYWRrWDlKMDViYVg3WDVEV29SR2oyK1VOcWduMEgwQitocWkrcHozL2lXY1d0dGJEN0l1M3pwYmpaNWdKL2gzWUIvTDhhdzdYVUw2T1psMWFTNE1NbjNIdGIwSXUwOThFOC9ubmo2NXU2UG91bTM5OEpvOVV0a3VXY2VXaFFHUURHU1NRM1A5UHhxZllRVW5LcHJwL1g5TVVsWjNaWW0xUzRCbmkxR3pXNnRaVzh0NTlzcXhvdzV5bTdqR2NqS2prYzFEYTJoMDkxZTF1SHViU1Z5MHNURWZkNDRKNi9sMTlLdFhXblE2WGRYUDJkSkwyMWRTTGdTdjhBdTQrNUk2bnVPTWpIdWFvL2J0TnN3OTZscEdZRlFJb003a0hCSklJSjU5czlNZldxMGJVYWFkdmwvU0hIYTlpVHhCUFlwcHh1cmFDUzBlRmxXZTNDQURhRzRPVitWdXZRL1Rpc0ZidVhVZFZqTm1rRWNma2I5NWpWaXNoNFlIMFBmL0pyVGl2SmZFS1NUeVFUSnArMEtsdDVRVVNZOUR6eDEvS3BKOUJzVGVMRnBzN2xtVUlZWTVNbER6bGp3ZWZiMnJTTW8wdmRtdGRmTkx5RXVmWmJESWwreVhLcnFFdTZCejVoaWpWV1ZjSEFPMWxPT3ZWU1BwV2s5eGIzV3BKOWlzdnR5enNGeEpJQUlnQWZtSXhrQTQ5QU0vV29kTHNaTFNWVzBmVUptUlFXdUV1SURrRDBMTmdkUVJnRFB2VExEeHBkV2VvTVd0NFpZSGJCa1RhQkgvd0VuZGdkenozNHFYKzhrK1ZYMDlQd3N2ekM3dG93bHZUWWFqSkV0MDl1Q29WOHk3VlBCSGZqUEhCeU0xSGN3YWZxN1EvWjlmZTZsVk5vTXpIZjZnZ0Z2WEg0Vm5YbGpwcjZ4ZUMrdGxZM1B6RHk3aGo1UVA4QUY4M3MyUitsT21zTk8wcXlzbzdZeVRSeVNPOGZ5WllEakNnbjZkRGs4OFZxb1JqRldidjh1eFM1cFNUU3NUWDhPbzJrRVNwY1RtMGR5clNRekFLWXlBRkxJUnlBU2VCeU94cTZmdFVxeTJ5M2x2SEVZdjNGdUpRckU0TFp5eHpnbjE2MUhCcEpuZ2E1V1pwV2djTWJlVGtFS2NsQ2ZmNmNkNmgxeTUwalVidUpMYTBGay9TZGx0eUNuSEk0QkJyT00rZEtDMXQ1YmYxM1FTVjVOc3VhVG9semErZjlrbGpkMlFGc3Z3SEhVRTg1ems5UFE0UEhOMlM0dEhBMCtXMWt0MndmUEVVWTIrbTVzY244ZXZ2V1Y5cjFMVDFuU3lubE1XekpudVNRcXQ2aFB5N0hHT2xXN2VXMHVNM2Q5SjlsbGlUNXBSRzBubUgrOHB4dTI5TURwbnNhem5HYzVjN2YzQW5iUnJZemJsSXJSVWJUcmU5YTJKMkZJMlpGZkI1TEt1QUIxSFQ4RFUwVVU4eVM2Y2t0cEtOdVRNSk4vbGM5c0RQcHh4OWF6eGN6cFp5eVhNLzJtMG1CL2RHMUFDODhmZFhJSHVldnBWSFRyNlBTNWhlMk1jVThFaWtFSUh6alBwbkE1ejJIZXVoMDV1TFMxYTI5Zm1PK3Qzb09sdHByRFZGZVh5THkzUW5DUmJodDdjakhCL0U4MTBrTjJMZlQxdUl0SWFHMThzN3JoSnp2S2pnQUQxNDZaNDQ3MGwzb21sWGR3SncxbGJYakp0VmhjaVBPU1RrNHpubjgrUlhPMk5zVXZsc0UxQzVqdHlXRXNscUhFSjlTQ092STYwclJydzVyN2I3L0FLTW1VMm5abHJWUVBOZ2kxTzRXVVhQNzJCWmdZd3Fub3BJL2lHZS8vd0JhalZyUUNCUHRWdmMzTURMdUtwY2xTY2R3Y0hQWDBQMXFhYncvYTNlSjR0Y3VKN2VFRmJsSng1ak1PeEhRL3I2KzlaMzluM2tOL2JXVm85d2thWldJM0VXR0M1M0U0d2Uvcm5wVnhjWFp3bHR1ck5mOE1YR1hSb3VhZmhOTW51T1VMeS9JQVB1OGV2MEk5K0tqbmdhRllkc2lPR1RkejJ6MnFEU05VdDQ3T2FDNUNvUS9UZ3Rub1FmVDYwVDY3cElsQlM0UUVIN2pIQS9FOURYcUp1OWtlVTQ2WExVTUVoYmFwZENjREl4My9HcUxXVVRhZzZxaWs3Z3JMMkhBL3J6VlM4OFJRd0FmWlA4QVNMay9jd2ZrVTlqay93Q2VsVXJmVTdrUnR1VmpNZm0zSG5jYzg5QlJWVW1pb0pMYzN2SW10cFFrSWpMbGh0VWpnODgvaGlxZjlvemFqZWZaVkVrWURiWlMzVVk2Z1UyMXZ0UXVCc01UcnNVTms5Q0RuSFhrL3dEMXFodm9yclMzaDFPT0x6aEtXY2djSEk2NUdjMWtrMHJQYzFpa3pvVEU4ZmsvWnBQTGVNNHp0NC9MOHF3ZkVtbjZqZVhEM2kyaEFsQ29rYURJVjhjbkFIY2o5YXpaZkY5emVNWWJlTklkMmR4NU8wZCtUWFhhSjR5dUxhM3ViVzdNRnptTWVUNW9HRkl6MjcvL0FGcVU0VnFkcEpJS01vU2JScmFSb05ocHVqdGFuVm9wYitTUDVrbE96REVjS0ZiSkhKNjQ5T0s1UnJTNnRMUzJ1N20wYUo0bUJNcExBbFNlcWs5Q2NIak9ENlU3KzFyN1hIbGh1cjdkbHNJc2grVWRnRkpHNGNkczQ3MXI2ZGFhaW9YUzdqVUxtVlZ0RzI1T1V6L000eUJ5Y1Z3emNxVW5LVXIzMWY4QXdMSGZDTGlyVy80QkZleGVIN0ZtYVY1TlVpbVFQNVRNZmx5U040d1FGOVBhdGp3VnAyaWF1YnpVbWpWNDRuMndLWmQ1VVk1ei9UUDlhNUhVb0xiUjUzYVZKWlVRbE55cmdCUWZ2ZGNZNTdldmF0UHcvZUpwMzJ0ckt4SVc5Qy92RkJ3NTlCN25uOGFkU0w5aTNCdDM3N2YxWW1TYjBUWDZub0ZtVlVMTE5aTEJNQmlNZ0RKVUFZd1I5Y1lQTmNuNHp0YkR6N1hVN2llNWhtM2JHeHVZRmNNZVArK1RWVzkxTFVyKzB0MCt6WG5reU1WUm9aRGc0SXprS2V4NDU5RFhOek45dHVqYlh0L0pBOGVTZ24zYlZIOTNQUWZTdVhCWVNVS250SEw1SW1Tcy9NMzlKMVMxdXRQVFRtdTVCcHJXK0kxY0VCWk9UNmM4OWo2VkJINEx1NWJ0WVZ1bzRGWnd3a0xBNzhuQzdWNmpyeUNCL1dtZUY5UGhzOVJuMDNXTGRwYk82VkRCTkdEdEJYUGNIMy9IaXR5ZDlROFBtVHlwSTVMWEJTRXU3dHRBUEFHRHVISEhHZTlkRlNweVZuR2k3WDE4bjZlZmNTaXBSOTVhb3p0UThCYWpiVzZTeVhDZ0RBYVVISWpQcjFCOVBYcitOU1dFOTNZMjdXcVRJMlBsRXpwL0VCenhucjY1ckx2UEVYaUhXWjQ3V2E3MlFJVHZqaGxVTmsrcE8xdTU0LzhBMTFQUGIzOHJKWXJQTEpHVVhnUjVQcHhna3NUeDFPYTBuR2JTaFZhWTZjVWszWWRaWGx0cDk0OXplYVZKY2xteDVxVEdPTU1PaFlnWUg0akZidWkyZHhmd1hsNGtkdkRhM2JIekhpUk4zb2NNTWdqOEQxcUt5VjdQVGJteGU1ZjkwVDVrYnBzbDJzTTVBT2M5ZU9QL0FLOUJiYTEwaXhGM3BsM2N1VkM1U1NRa1lPYzhaQXozL0NzcDFHNHRSMGUxOS84QWhoOGw1YUJkblRkRDIyTGwzbktBczh1MWc0UFFnNHhuZ2UxWFk3YXg4UFd3YXdXRDdmZExsWm1jeVB0T09NS09PUjlNOTZaWVBQckZ6S0lWZDdpTWVabVpObzJnakFBejNPZnd4enpXanFjRXQ5cDBWalpNbm1YRWlGMEpPM1BVSEl5Y0RHVGpGWjFXN3hqVTY3LzEyRFMzb1pWenF6NkJjUVIzZGxHOXBEdFoxSDNwRC9lSkk2OWZyanJpalVialROU2hhYTJndGJhenlzdm1PcXR2SHAwOWVPdmJHTzFYcm5TZkZtbHhvcTNrTi9iTU1TSnQzRkIvd0xrZ2M5L1Rpc3g5RXVacGJsbFNVUlhFaFpuQ0VsR1BWc2JzNE9PZjVjWXJTbkttN050WDdwL294SnA2bE5KTlYxRzNrTm5ld2lERzEwRVlROThzdUR4Mjc1OXFUU05VMVd3YUJ0UWFaNFZ5U1RBRmxkZWNmT1RuR2UvNjFxNk40UTAyL2ltTjVJa2t1U3dDblk2NC9pSUJ5ZWNkZjYwNi93Qkk4dERacHJqS0l3cUNHV0liRkRaSXdNYy9sMzlxSllxbTVPaituNnIvQUlBNGF1N1JTdU5jMWJWdFdXeTBjU3hST3U2U01ybEdCNE81c0hCOS93QUtaTERxMEYwMGs4cHR2TXg1cnZJcnEzeWdBWTU1NkNyVitrbWtMRERwOTR6NFRkTkt4QzdtNkFCUjkwWjkrY21wZkMraFhOOURkM2cxeTZ0cG5ZbG9vZm1qSlBjcTJkM0dSMC9IaXFpNEtIT3JKZWwyL3dDdlJpbStYYTR5eDBDWFZvWnJxeGd6ZExIc2RHdUF5UG5uako0d1ByNmU5VW51a2Z5dEpXTzRQbVA1ZUhKSGx2MHdUamdmbUQ3MXJZMVpkUm10N0dTTzlnZHNybU9BRVlBNEk2OGoySDRVeit6clBRdFVsMUdWMlVrS0pGRURGRElRY01wQXdEZzlBZjFxSlRhdnphdnBhKzRSaytteEJORHFlaTNTNmZiK1FzVEF0RkpOeHV6MTV4NiszV3FqZmFwZHFpMzJuZG1YN0w5NE43cWVQeUFGYStyd0hYdEtnbDA2Q08ralFzSFl5aFRHQmpLalBjajNIVHIycWxwV254Nmd4aS9zNjVGNm9IbUxLbXh0Z1BEbHlmdThkT2VlS2lsVmp5YzBscjE3K3IxR3Q3ODFoa0ZzTGk3eE5ydHhBWTJWMTg2MzhzOEU4Y05qNml0YlhOZGdzV3REdkY3YlRFZ3VIUlFwQndBTWdnbko5UjBxWnJ1MDBwWkpUSkJkUnlNbzh1VG9SNlp3Y1k2NTZjKzFZV3JTV2NzYlEyandlY3dBV09OZHlNRzUyZ2duMjZHblpUbkdUV25wL3dBQVdzbTFmN3hkT1hWdFJhZTUwbVMwZUIyNXQ1bWpjRmdPZ0lJSTdjWnh6VjNUN3JVYitTVzExR3d0TlB0a1VCR1ZjNTZZQStZZS9iLzYvUDhBaFcraXNwcGJDN1RneVlXM2tPeEZjcms1T000SUE2ZmxYUjN1clhGaENTK2d4VDZmUDhubVdrV1dVa0FaeUR1ejcrL1dxclVuejhyUzEyZjlic1NsWlh1WExQUlk3bTFudDRaN1dhMHlNVHRiTE5KRTU0empJNmRCd2Y1MWttYTc4UDhBaU9ld2ttZlZMU09OZkwrVFl5dVRrRDd1TS9RNHJGZzBwNDFsbTAzVXJWSFRLbElid28wZnN4NHljK3ZvSzJ0TzhTYXJxVjlFbGliYzNpOVpsQXd3VWM3dXc0R01qLzhBVnBLQzVYSDRsMTZXOHlFbmZtSWRkMHU2RXJYZW5wTkhNNUxSd01qQXIzWmlXWURhZTNUdldMb1FtR3VQRHFkckVxa1pTUWdNcU56Z24xLytzSzE5UjFxNXM5Ym5ubWxlOHZYVGJLa0tzVWk5Tm81eit2ZnBXWGUzc3VweVBsRUVtOEtTRjJuY09uVHYycXFjcEtISTlZdGI5U293NW5kdlhzWk9yYUhiM2YycWVKVGwxRXFra1pKUFVuOGY2VnpsdnBEU011eU5nRC9Fd3pYVlhyeFIyY2NWdGRpUlM1REZUeVZQUVkrb3hVbHJBOEVPOW94ejZucFhvVTYwNHhQUG5DTGV4RHBlbUxiZ0RiajFPSzZiYmJySHRPMDVQUThFODFtSzRYNVRuSlBHUmorZFNDVjRtU1VEak9EamordFl6Yms3c3VOa1JhcHE4MWhmdEZGQ2hMMm9WRDF4ODdaQi9Tb0xPZWRycU43d3RKRzQyRlN2Q1o5UHlySzFLOVJkYkEzS3pLbnpxU2NEdUswN1MraFdJSVdWV1lqYXZZbXJsVC9kOHR0eXFWU1VaODhYc1psL29iNnBxVFBaU0k3RTduQmJhVnllNEo3ZnArTlpDaVZkWGpTYUZwUEtrMlNRNTJrcjBQUHYycnZOSjBiVEh2TCs5MUNGREd1QWp0THRCUDhBRmozeGo4elNlSjAwcElZSnRPK1pBV003d09DTUhqblBQWDJ4VXh4bkxVOWkwM3B2Ynk3M05KVUZQOTZ0R3pBdXRQbW51Zk10SVBJZ0NFc3BCMm9vNlpicG5HUHpydXZEZXR5M1dpV3BoUzVlSVpTUXJHcGJqMTJyNjlqK2RjY3RwSk9QTGxNYlBHTW5qcDY1SCtldGJsazk5NGUweHpvZXF5eXlGdDAwUmlYeTBQVWhkd0o3ZHV2NlZsaWFjSlFVWlA4QXJ6LzRKMFJuS1QrRU5WOFNhaDVFK294MmN4dDBkVk1qUjVpZHhsZWM4QThkdTJLdndlTXA5VmtPbDNsakZzZVBCTzRrQTg4WUhvZUtyTDQ5MUM2c3JpMDFHQ0g3SThSVmxoaitjazl3T0IvS3NXeTB5OGwxK1dLRzFraldTTVBISkl3WkhYKzlqZ0VrWTRyQ2VGcGN0NVJTdDF1RVpYZnZIb3o2amI2VHBLU1gwMGF5REcyTkUrYzU3N2V2MStsY1BxY3NVczhHb1czaDYrdVlWbEwzVDNLQnR3NUIyZ0U4RGs1OXFsbDhMcmJYQ1hEYXVZVHRPTWJRdmZnTC9obWt0cDlSc2RKa2hqZTdScHkzbGJWd3JQNmc0eUJnZXRjK0hvMDRKenBPN2UrNkNjWHR0OXhkZ2EyMUxXSW9VdDN0dEt3U3I3VUEzZFFRUmtiZW5UUFA2U2EvcGVwMjhzYlIza0F0eGdLOFp4SVZ6OTV1UG02K3VPS3FlRTlMdGJhVzVUVVZnZ1ZEdlF5cmtBWTVBQjRCem5vTy92V2pxTm5lNmxlSkpiM1VhUnQ4cTdsUElDNXp3T1BwU3FXaFdTaS9kUzYvMXVYRnkza1MrR1o1eUx5MHVJWVhtdHlBL2tSWVBJT01ZNFA0QUdzdThFV2gzOXRlck5QUGV4T0RQYmxUR1ZqUEs0SnlUakhPU2V2YXE4OHV1YUxjekxCUEFtODdaQUI4NElBNUJPTnd4anNRTS9qUkxyVTk4c2phbEM1S01ZMXVvMU9EL3NzUU1EcjB5SzNoUzVaT3JIVk5MWWxhdTJ4cTZ0cW1vZUpJWUpiclNzMmdJQ1hNSUlicUNOdzNmZEhYUE9LekYwcUs1MUJUTktpcktjbVRZU1RuOGVwcTIxMWVMWUlMa0l0dGdFWVJnQ296ajVpY2pqQTYrdFFhakxEZVdpMjlrbGpibEFTeUpjZ3lQbmpPMC9OeDdFOWFpTG5MUmFlbjlibTZqN09PcU5xMDA3UkYxaTNqbldXZENwaVBtTWR1VDA0R09PTWZsNlZnNnVxdDRnZTIwalRQSlNEOTRKUTdESjY1SFBIcHg3OWFORXVacExZd3lCMGxoUDM1cEZWMko2QUwvRjA2NS9uVisvOEF0TjJEQmEzRnJEZHBrek84bUVYQkdUajE2RUQwelMvZVVwcUxkLzYzTTVSaDhTWnB4YXZOQlpJYkFTelhKVVNTK2JJVzNuYnlGTGNBNTU0d0t4TDN4cmRXeFJqWTNjOGUvQ3VzZWNrZFFTQ2Z5NC9yV3hlNmg5aWxhd25XS2FCMDJPcEpKY2p2a0tGNis5Y2hmYVpwVW9samx1WllYVWZKRkt3R0Ixd0FPU0IrdFpZV2hUbGVWU0Y3L01QS09qTmpTdFprMUpYbHNkT204N3k4T1FtQ1Z6Z2pqMC9FajhNMW9hUDRha3VKWnJtZTh0L3NwKzRCTHZ4enlBdzVPRDJQZWkydTdiUmRKRjNhM1Y1RkZHQ1NxSEt0bnQwR1JucDlUVk0rSmx2N3BKbWtsTWJPQmdFTnp6eGpJSEdRZU9UVzA0U2ttNlViSWhjeWxadXhjMXlTKzA4VzhWcXpmdjVoSEp2WGVTUGIvSDZjVlRodjlUMFBXNHRodG5CUWJXWk5za3VUeXBPT2VCN0RnZEszazFCSnpIYnczQWFZYmpzTnVReUFkTWs1eG5QSEZWWjlLMHpXWklmdGpyRmNReU1XQmJCWTQ0T1IyeU9SL1N1YW5WOWkxR2EwL0ViVGtteXBmNm8xNXJrWmswV3puRGcvTkVWVWs4bkpiSXdmZkh0VTF0Y3d3NmZKYjNPanoyaXlyc0t3djVvYkJKK1VMMkdldU9jOVRVR2tTK0hiYlU1b2JpV0c1ZCtNQmkwZkdjRHBqUFB2K0ZSVGFqcGMxeXl3V3lXeFhyQ3VVS2tEa0FqL0FQVnhXdFM4K2o2ZC93RE8zNENqQzdzdGhCSzlsWnpRMnBhRlhBVXlRTGhsL3dCN25yejZWbkxxOXpaR1czMUs1dW1obloxanZFa1lTcDIya3IxQndPUDhpeHBmaHdhczh0MTUvd0F5azQ3NFBvMkQxNXE1TjRhdmhveVhTeld3ZHBHa2xMcVFkZ3dBQWNkZmx6ejB6VDlwUWhLMHBhL2RxWFpQM1hvUVh1aXd5MmNkN0ZyREtwS2lQeVlseStCbkRFOURqdVRnVm1XNjNFZGsyM1RKUXgrYjdSTkQ4eS9RNHdQNVU3VkxlZTd1WVd0Nzk0bUs1ODJBa3F3ejBKN0dyVmplNmhCZHhpV1NLYUNDUU13MzRjamdua0RCeU9PUVB4cmFpNUtGNU8vNGY4T0U0Y3I1VXk3cHZoR3gxeUg3UnFrb1NZWVlKR3dPRnh3V3lPOVVydTB1ZEQrVTNDVzhNWkxSUEUrNFl6akdBZWZvSzYzV1BFTmxDa0Z6cDhzQkxxUXlTd0hlRDF6bjhmZjhhODAxQzlnVy93RE9taG12YjJSc3NzS0FxeFBUbk9lT09NQ29wUXJWS2o1L2g2TCt2MUlwVGNGZHUxem92RGY5bXdXa3pSZ1RBdnVqYU1ISTU2SEp6bm1xVGVUOW9tbjh6N01Yd1d0WUVSY0VuYmhXUGZqbjFOWlVnV0tGcHBvTG0wMkhEUjcyQTY5RGoxOVRXaFozMXZQSWw0NlRpMmhQend4Z0FQOEFRbmtuK1g2MXQ3SzBwVkx2VXFUU3Nvb2svd0NFWDF1ZVdPNHNVdW1na1F1V251RTQrZ0hUMTYwdDdjM1ZuRVk5UXZURVJsQTNtWUpaZW4xL0hyWFhlSDljOE54V2NoZ3U1NHJpVG1TRzVZdTBmWHQweDlQV3VMMXZTTkt2TmQ4eVRWWjViWlFUSkc0Y0JlNHdYOVNlTzFLRGxPZkxVMlhrUXB5U2JzY1hzYlRvVmt1SW1DcXhBRGpoajJPZS9hdDNUZGEwOXJSRWx1a0RLQ1BuNCtsYmhpUzUweVN4dVFrbHEzUUVZeHo2L2pXTForR3RGc3RiRU44b2UybFhjaGR6KzdJNTV4MUJydmxXZzR0elR1dXh3Um96NTBsMUpUcWVtT3AvMHRNS0JnNXg5YWhHc3hUM0Jpc1c4d29OL21GVGhlM1R1ZmFzdlg3RFRvdFRkTEdGUmJieUk1VkoydjBKem5qalBiam1uNmZlWGVrQ1o3VzBZUm5hM2x5SnV5bzR6bkhyK3RWeUowK2VHNzc2RnhpbFY1WjdlUlV1dEt1WkprbGpEek5jSCtJYlNTV0kvRHArVk50SnZKWWg1VUJSc0VIbXUxbDFMVDd4NGJtWkdFVVdHT0FVUFRrRWQvekZZUGlTMXRaOVVlVzF0MjhxZGQ3SFp0d1NjazU3RG1sUXhNcWo1SnhzYTRyQ1JwZTlUZHlmKzJsanZ5VWdhNHRwU0NDbU1vY0RPZWVQeHJ0UENtdXd5YTJ0ckRCSVZsREtxbmJqR01zV3owQkF4L2tWNTNieHUwTVZ2YVJSU2JpVk1nYkJKNXhubkZhTjNDZEFMM1Z0cUV4VWhWOG9NeXR0eUNja2U0L1FkcTU4Umg2ZFI4dXpleHZDYlZMbGF1dnlPMzhXTnAxeHEwc291MXNiaFkxVjBNSWJ6anowWUhqZ2tjODFVdDlPKzIyTHoyOW0wOGNvWmR5a0tTQmo3dWVlMzlLODhPb1BlWDdUWEVzMHJwOGlSeVBsdU94SjU2KzFkWlphN3FGcGJMT3R3OEtQOHBSbEJCeHh3cFBINFlyR2VFcVU0SlJkMy9YekNuVVhMWmJIUGFwWXhUeW9MZGN0R0dWb21pMjdjSGtkU1cvSC9HdXZlSFZyVHcxWlBaVHdzUkdDeGY4QWdVbktqam5qakZKZnoyMnIyd2traGlodWYrZm0yVERFSGtncVdIdWZ2SDJxaFk2dkxBc2thTmNSeFJJVmpFOXNWSnovQUJZeVIzUFUxVlNkV3BUaWt0VTlVOVJRVVZKdDlSTGxwMFpXdW9aWk1FQ1FERVpZODVDNVBYODZrRjQxbEJDdHY1cXdLaFlTWFlET0FUeU1nREF5TTlNOGNWblhscnFHbzNwa3VSY3VwVlFEc1loV3h6akEyZ1orYmpIWHRWdXcxMjgwUzZTMzFDenQyaGM0ZVdQRzdwbitJOWNkaldrazNCSkpOOXJpamU5M29YZFBZNnZHOTFjUEpkcUMrMkMyaGNrNUdBYyt2VWVuU3V5dE5SMDZEU1VsbVdTemtSUnRpbUhsdGprRDVUNllOY3RiNmpwZHJxVFhPalBQYnpDUDk2TnBDNHgvZDZIdjI2K25GVXRTbGoxVytndUwyK2s4cU5HVEtxV1hCOVFQZitkY0ZXbDdlU2kwMUg4ZlN4cGFYTHF6ZjFMVTIxS0hLMnE3U0RoZUc1eGdISjdBWTZIbXVmdUlaTHlieVVtZU1zaThReWZLKzNwbGM0Tlg3blRiQzIwSlYwelVaWlhsMnMwY2o0UlVPVHlxakFPY2RzOGZqV0REY3ZEZE85dThZays2R2VFRVJrZjNRUi9TdHNOUjVZdHcyVjk5Q2xWaGJsdHFhTm5wczA5eVZobXVKZmwyZVdXSlFkUUJ6eFZPWjdqUmRVdVQ5a2F3OHVNN0o0UUNDRCtIcldpbW15eGFhbXMzMTJBVVpXd3FDTk1ad3ZUQTYvcGlqVVk1dFVPMVVsYTdjQ09KTm9LczNZTmdEQUJPYWFxSnl0bzQ3UDEvcnlFNWRYMEk1OUNtYjdKTGFYVXR6SzZlY255aEFCZ0hBOWM1SE9RQitsYTE3NGJ1TlF0M21qQlp5dVVSUW9KYjNQb1ByNjExV20ybDYvaFMwdGIyS0pkU3NyY3d4VDdGbEErVUtDUXc5aG4xeCtGY0ZjbTVqL2RYMTY4c2kvSnloK2JrOUIwck5UbFZtbEdhZHZuK1JsQ1dqU1ZqYjBEUk5UczRYdXI2UFQ3bFlkeGxpV2NQSXl0MDU2QTQ1NmpQNDF5bXUya0kxT0Z0SnNXamd1RU1wanVXSUJJR1NGNHl2Si9NK25GYW1xM1dtMjFpSWJUN1lKQ1YybVVsSThqT1NRTTU0T01FWTZldE8wN1c0UDdPaEM4ektOc2loUzM0Z25nWngwcmFNcHE5U0szNmJCR0RiMVpoSTk1Y21LMlM1YU9OZ0hDSXl1RlB2R1QwempPSzd1ejhON3RIaEZ6NU1WNnJNUzl1ZmxjYzRLbitFNFBVZXRjVjRrMHVjdkZjTGFwREVVS2xnd08vMEhYaXQ3UU5RbXN0RVcyV1JIdUNXYVA5NFdBNDZaSXdPbjUxbGl1ZDBsT2kxZjhBcnFWS29uS3pIM2d2dEoxS1NTMjFwVXQ4TnVodW1MbUhBQkNnRTViSnp6bnYzb1RXTE85MEJJNTcwVDNoWWw0eXZIWG93Q2tZL0Q4YXBYVWtGdmF5WDJxV1VrbHhjZkxJeXhrbHVlQXA2WTZkZjFwRjhSUlF3TGI2ZnBza3Q4MFcwR01obVBHY01vWHIyckpVWEtLOTI3WFhSYmVmWU9mUzdkaGw1Y1hGL2FQdFNLVXhjRmhBb2tqSHNjQThaNjlhenhQQmNRQ0s1MnlQR0NHSTRQT1RrbmdacmIwaTNuMDYxaTFHL3dCTnVMWkxoaXNzbTRxVkpiQTNwMjdESTR4ajFyV3ROQTBxN3VKTG55b0doOHN4N2NZdzNIT2ZvTzFkTHhWS2hGdVN1bDI3azJjbHpSWkY0QXVMT2JUSmtudmtqa2ozS1ZMcHlvd1EzQjl6bjYxWEV0cDlxdko0TG1lOHQ5MjZhUDdTRmhmQXgwWW5QMEhIVDJwcWVEZExHczhMUE5ia2IyWkpnUEpibkE5V0J4amprY2V0VWRmMEJMSzA4dDdqemxlWGRBODJISzhnYmVmd0g0MXpSZUhxMXZjZXNoSnRMVWtpdk5NdHJodk4wZ3kyTnd1Nk5pZ3pFMlA3KzdkZy9UOEtoMDJ4dWZFa1VzTnVxV1VlN0JrUUg1ZllBNEovK3Y3MWZzckhXTDloWlJTMjF0QUVJWjFzNHdxSHNPZWVmVWMwNngweldFMUdDd2tzYlNTNCtaNDU0OEtWVWJmbU8wZjdXQjB6M3JXYnNuR0RYTjYzMjYyTDUxZTdJZGN0TG5Sb29iZXowWjdrU0lZM3VaQVpRdjhBdEZWSEI1NFBIMDRxVFR2QkZoSnBzRjVjNnNIWUVCcEkwSURIUFFqcU9PRDcxb2FscGV0V2wydHhMTklRQjhyUms3U09ldUR6V1ZOUDRnRU56YTJ0eVpZNW90b2RoamFTT1FEZy9ULzY5WlU2czFEa1VyUHErLzMzQ1ZIbVhOdWRucWVsMkY0aHVZTG0yaWpaU1pQM1FmZWV4NmdaK29PZlN1UXY5RnZySzQ4L3kwZG8xQVM2dGs1ZmpuY3BKd2V1ZTNJcklzcnpVTlBsanNvNXBQSnRteEo1c2diUFE0SDUxb1QrSXRRdHBWaWdXR1JDY1IrWVNwQi91OEU4MEtqVWc3UmFhSERiYzQrKyswM1Z4TkpjeXZISXBBWHpQbVlEdHgvaFcvcGwzcXVrYVVMYzNOcGRSTVJ0aWtRczJHUGNjY2RhTkplWFV0WG1OMWJ4amNHbFNSR0xBWi9oeDA2ZnlyU2J3emQzRmpNL0NRTVNCNWhEYmdBZWNEbnJqaXVxdlhwSktuVXNyVzgvdUl0SnZjemZ0eXdRQU1vSUo1ckUxS1ozMTIwZVNOc1B1K1JoMUdEV25FU2J5M0dUanpsNHF4NHRIL0V4MHB2NHZONi9sVzBhbkxWVUxicC9rS05MbWp6WDJhL013SmZEYmxwSnZQWnJlRnNDTmp3Z1BZRWRTQmpQcWF0TGZSSFM5TWhodWZMbGdhVElKR1FwWTR5RDBISFQ2ZEsySUNWaG5VRWhWVWtBZEFjWi9uWG5zc2puVjFZdXhiZWVTZWV0ZFNqN1hTVDJPYm45bk54aXRHZWlXczhsMnNxUzJ0bk1wUXRHWXBDQTJDT3ZVZzg5ampGTWs4VzJOdmFlWFlXaGprY2Y2eGxCTFlQT2M4a1YxTGdmWW1HQmdrZzE1ZHFZQXZvUUFBTmg2ZmhYbllOUXhFcFhWcmVaMVlpVG94VFIxV24zZW5YRmdzczBseEErOHNYUlFFUHFEamtuOGFudTlNdDc5cmIrenBFbHU1bjh5STNURmM3ZmJHVHdQZm9PbE44RlcwRTlqZENhR09RZmFZbHc2QThFOGptdWNzV01XcldEeGtvNGtrQVplQ0FNNEZhT2sxS1RpOXY4aFFyTndUdHVXOVF0NzE1ak5jMm14bXlKRUpIek4zT0IxTlowRmxkM0VjRU1FcEdXWnR3VFlFeHhqZDBJNUZleTJrRVUzZ0Z6TEVraE1jamZNb1BPNDgvV3VHOE8vdlBDVUxTZk94ZHdTM0pJQU9LaW5pbW9OMjJkalZwVk5OckVBMFRVN1V3L2I0WTFDRldhVHBHNmtkeUFjWkdlbWVhMExoYkhVckdTSnZMZWUyT1lkaCtaUFRhUjI2Zm5VMTljVERTM2o4NlR5L01BMjdqakgwcmx2dE00R3BuejVNb2dDL09mbDY5UFNzWVZKVjF6UzBhN0Z3aW9YNm1oZWE3cmJSblRJR2l0cFk0d3U2TURya2RTU2UyZW1lOVpWL1pDSzVqZTd1WnJ2ekVNanp5TjA5Rjl1MlByVnZ3T1BNMVdKWCtaV1pTd2JuSnozcTFmd3hQcUYrSGpSZ2tVcktDb08wakdDUFN1Nmx5d3E4a1lwZnFjOG9QazUyeS80ZXZOSnVwNGJkTEJ2dE14SmphWmNxRkFKeU01NTRQYXN2eElJN1hYSlVlRmJSVmlEUmVVU1JLYzk4OVNlbjRkNnZLQkhiUnlJQXJxWVNHWGdnNTlhb2VKR2FUVTdKbllzMzJOVGxqazUrZXNLTW04U2t0bW4rQmRkY3NYTHFJK3QyMGxzdHJEb3NkcmNaeEhMRkprRTlzNHhubnRVRXhqbnNua1czUDJqY0VJQ2s3bVBRajFKNHJUOE13eGZid3ZscHQyRTQyakdhNmpWb1lsdjdTUlkwRHZGdlpnb3l6REhKUGMrOUZlb3FkVGtTODl3dzg5bmJVejlCMTNSZFAwQVdIaUcxdW93Q2RtK1Bjclo1Nk4wd2Mvbldqb09uQ3hjWDlsZEUyODBUQUxKQ29DaitFaFIrZkhIdHpUWkxlQzR0aUo0WTVSMXc2aHVjKzlZSHhCdkxxRjdOWXJtWkZaWExCWkNBY0RqTmNjL2VrbzAvZGMyNzlmd0trdmVhT3VYeEE3SVlMY202Y0g5NHpGWWZMR09UakFKNTl1OWNVYm1PMzFTZDNtYVZ5UTBaYVZYWm5QWWtmMXJsdEVubGV3RWpTdTBrbDVzZGl4SlpkaE9DZTR6MnJwYjFGT21idG96NXZYSDBycitxcWhLeWU0VVpKcTZRbzBpWFYzdUxxN3ZqR1NNcEhERUdDYzhudGpxUjByb05MOE54ZVp3Sld0M0h6Z2dSWjQ2akg0ZnJYRXgzZHltdVd5cmNTcXYyb2pBY2dZQVhGZXA2bkk2YUZPNk95dUVQekE0UGV1UEgxcWtPV0NlNDdMbWJRMjYwT09YVFh6YnBkWFFJMlBLZnAxK2xWcnJ3d2wxYUdXM3ZKNDdpRmNoSWtSaVNPdzNkS2s4Q3lQUDRiMHVhWjJrbFpDR2R6bGp5ZXBOY3JxZDFjRHhGYy92NWVMcDBIem43bzZENmUxWjBhYzlYemZEZm9acS93clM1b2VIZER0NVBKdmRUdkxocnlGQ29nbGtVTEV1ZmxPQjM0NmsxVi80Um16UGlDOTFBM0xSWGJTQ1dPUzNrWGFNc2NZUE9XeDFHTzRyQjFLV1NLK0UwY2pKTHdONm5EZm5VZmh0bW0xbTJhVWx5SHlDeHp5Q2NHdXBVcXo1cWlxYnJhMzRBNHh2Wm82dnhUcWV0MkR4dkJGTk5wN1IvTVZoVmxEOU1OeGtBanVlS1o0YjFMVUxyVDc2T1BUa3Nwb0pTSEJoSkJZOTlvNXp4anYxNzEyMEpKUUVuSjNkYXBMOHVzVDdlTjFzcGJIY2htQXpYQmhLc0swZnE3Z3ROYi9BUEFGSnRPL1E4N2ZYZFcwcStXN3Y5c3R2S1J1ZTNrM0ljZHRwQXdjZlQ2R3VrdDdxMDhXUUI1a2N3eEUvS2hVNTZkUVJ1SDVmeUZSNnZid3lhaGY3NFkyL3dCRmpiNWxCNXcvUDE0SDVWVTFlQ0xUZmlCYlIyTVNXcUdPUEt3S0VISTU0RmVoWG9RY09lS3RKTGRFS2RwY3ZRMm9yZjhBc2pUSEdtMms1SVVzMll1WkcvaEhQUWRxemJiU3RYdm1rMU80c1pyYTViQTJQUDhBTUJ6d29QMDlzMHZnbVJ6ZjZuSHZiWUhEYmM4WjNEbkZlbHBGR3JZRWFnQUVnQWREbnJVVTZNYnl2djNMbFVsQjNSNVphNkhmeTM3MjdtOGdqQzRpQVBRRTVPTnVlTTVwK282UGQyajJ0cmJYNXRsbEpERS9LQ0FDVHlUeDBBOWE5U2RWTEVsUVRrY2tWeG5pN20vc2dlUnNmaXBxcVVaM3ZwMnNWVHF1cEt6T01HaFFXS3hYUnQ3Y1RybFpYVnk2RWduRERQcm1xdHBCL3dBVHNxMXhKSHN5eDgyTWJYSjdER01DdHJRQ1d2N21Fbk1RR1FoKzZENjRxWFZZMGZWN0JXUldVbHdRUmtIcFFxMG5VZE45Ym03Z294dWpNdkxSTkxCdnJZZkpzNWNZMnEvdDY4MXpkeDR2OFRXOXhDcXp0OW5HTnlSeGdnNTY5Yzg4MTN2aXVLTkxHQkZqVlZFcTRVREE2VnkvaWlOSW9yYnkwVk14NU8wWXlmV3VqQzhrcmUwaXBYdnVZVnBUbkhSMnNmL1pcIiwgXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8vZ0ErUTFKRlFWUlBVam9nWjJRdGFuQmxaeUIyTVM0d0lDaDFjMmx1WnlCSlNrY2dTbEJGUnlCMk5qSXBMQ0JrWldaaGRXeDBJSEYxWVd4cGRIa0svOXNBUXdBSUJnWUhCZ1VJQndjSENRa0lDZ3dVRFF3TEN3d1pFaE1QRkIwYUh4NGRHaHdjSUNRdUp5QWlMQ01jSENnM0tTd3dNVFEwTkI4bk9UMDRNand1TXpReS85c0FRd0VKQ1FrTUN3d1lEUTBZTWlFY0lUSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5LzhBQUVRZ0JtZ0ZBQXdFaUFBSVJBUU1SQWYvRUFCOEFBQUVGQVFFQkFRRUJBQUFBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUUFBSUJBd01DQkFNRkJRUUVBQUFCZlFFQ0F3QUVFUVVTSVRGQkJoTlJZUWNpY1JReWdaR2hDQ05Dc2NFVlV0SHdKRE5pY29JSkNoWVhHQmthSlNZbktDa3FORFUyTnpnNU9rTkVSVVpIU0VsS1UxUlZWbGRZV1ZwalpHVm1aMmhwYW5OMGRYWjNlSGw2ZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJoNHVQazVlYm42T25xOGZMejlQWDI5L2o1K3YvRUFCOEJBQU1CQVFFQkFRRUJBUUVBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUkFBSUJBZ1FFQXdRSEJRUUVBQUVDZHdBQkFnTVJCQVVoTVFZU1FWRUhZWEVUSWpLQkNCUkNrYUd4d1Frak0xTHdGV0p5MFFvV0pEVGhKZkVYR0JrYUppY29LU28xTmpjNE9UcERSRVZHUjBoSlNsTlVWVlpYV0ZsYVkyUmxabWRvYVdwemRIVjJkM2g1ZW9LRGhJV0doNGlKaXBLVGxKV1dsNWlabXFLanBLV21wNmlwcXJLenRMVzJ0N2k1dXNMRHhNWEd4OGpKeXRMVDFOWFcxOWpaMnVMajVPWG01K2pwNnZMejlQWDI5L2o1K3YvYUFBd0RBUUFDRVFNUkFEOEE0VFo2ZWxHT1BlbjlCUzkvYXZCNWozaG9IZWxBeDBQZW5BZmxRQU91S2x5QWJpbkFHbjR5TTlhQngyUFNvNWhqY2UzYWdESjcwL2FQU2xBemlwNWdHNDlSUzRwMkJUZ3ZiSEZKeUdOeHppbDI4RElwK1AxRk8yMUxrSWp4eFR0dkdLZnRwZHZOVGNCbUFhZHRwd1hGTzIwcmlJOXVSaWxDOGRLbEM0N1V1M2ozcGN3eUxiMjcwYmNWTnQ5alM3ZmJwU3VJaTJZbzIrMVRCVHh3YVhZZXRMbUFoMjU5cVVKbm1wdHVLTnRITUJEdHdLTnZ0VTIzTkcyam1HUTdmLzFVbXpyVSt6a2NVYktPWUNEYmo2VW0zL0pxZmJnY1VtM2lqbUFoMm5GSVY0NjFPVjZVaFh0M3A4d0ZjcnhUZHY0WnF4czYwaFRqTk80RUczMHBDdFQ3S0FtZnBUNWgySzIwNXBDaExWYTJnYzBoWDJvNXdzVkN0R3ppckRKM3BBQjZWWE1GaWtCd0tjQU9SMnAyUFg4S0F2ZXRia2pRTTl1YWNCaW5BQ2xBNHFYSUJOdnVLT2MwL0hOTGdrVk53R2hlYVhISEZQQUJOT0FwT1F5TUx4VGdNVThMVGdoSTU2Vk53dU1DMG9IdCtOUFZNVTlWL3dBNXBOZ01DKzlLRnpVZ1hGT0MrdFR6Q0l3dlBGT0NuTlNCZTlPQzQrdFM1REk5bWVlS1haK2xTQmZiUDBwY0E5amlwNWhFWVdsQ1lGUzdhWGIrbExtQ3hFRXBRbU8xUzdhWGJTNWgySXR2ODZObVQ3Vk50NHBRbnRTNWdJQW5IU2paeGp1YXNGS2FVbzVnSWRuSW9LK2xUK1h4UVl5S09ZQ3Z0NzBtMnJHempwU0VjOFUrWVpBVjcwM2IzeFZqWnhTRlQ2VStZQ3VVNjgwYlQ2Vk50NHBOdFBtQWkyWU5OS1ZOdHp6U0duY1pDUjJQV203YzFNUitkTklQQk5PNEVETDc1cHVPS2wyMG0zbXJURVVjZE9NVTdIZkZLQnpTZ2UxYTNFQUZMZzA0RDJwUXBCcWJpRzdhY0U5cWVCL0tsQXpVdGdKamlsQ2VocCtLWEZLNHhvWGlsQTRwK01VcWpJcWJoWVFMK05LRk9hY0I3VTRMd0tUWURRT2xPQXA0WEZPQ252MnFHd0doYzlhY0Y0N1U5VTVwNFRQYmlwYkdSQmFjRXFYYjhwOWFjRXFYSUNJSitWS0U2Vk5zOWhUZ25GVHpBUWhlL0ZMc0hTcHRtQlRnbnRVOHc3RUlqNHBmTHlhbTJISEFwZG5PUUtYTU94RHM0NlViT0tuMjgwYmVhWE1GaXZzL09rS1ZaMjk2YVV5S2ZNS3hCc3hUZG1hczdPYWFWOXFmTUZpc1Y2MG16akZXZGd4elRDbWFwU0FyYmFRcjZWWUsrMU1LMVZ3SUN2T0thVjVxZGg3VTByVFRBZ0lwcEZURURPRFRTS3RNUkFSMXBwSE5Ua0QwcGhGVW1CbmdmblR3Qm1sQ2tkS2NGNUp4azFzMklRRHJ4eFRzQ2xBTk9VWVBOU0FtRDlhY0FmU25BYzhVNExVM0FZRk9hY0YrbE9DNE5QQzlhbHNCb1gxNlU0TFR3dURUc2MxTGtNWnQ1SEZQQ0Q4S2RUZ0tsc0JvWDJwNEdlMUtGcDZqcFVOanNJRnhUd3VNY1VvQUFGUFVWRFlXRUNVNEo2MDlmY0duaFQ2VkRrRmlNSlRnbnJVbTNudlR0blROUzVGSkVXM29LZHM0NzFNRTV5S2RzeWFubUw1U0haN2RhWFo3VllFZkZLSXhpcDV3NVNEeThVaGpxMFVwZkx6MTYwdWNmS1ZESGdkS1R5L1RwVnZ5eDNwREhpam5FNGxUWmcwMHgrMVd6SCtOTk1ZejA1cWxNWEtVeWxOWlRtclpTbzJYanB6VktZckZVcjYxR1Y1cTBWOVJUQ3RhS1JOaXNSVEN1S3NNdWFqWmF0TUxFQlhrMHdpcG1YQnBtT0swVEVRbW1FVktSMXpTRWR6VlhGWW83ZTJhY0V4UUIzcDlhM0VJRnB3SHRRQlRzSFBXa0FvSFEwN0dCVFIrZE9xV093NWZwU2dVZzZVN1BGU3gyRkF6VHVvcEZISXB3RlN4MkZBOUtkam1rQzA4THpVbFdBRDYxSUJRQjdjVTlWNXFHeDJBTFVvWE9PK0tWUjZpbkt2STlLemJCSUVVMUtxOXFGVTFNcVZtMlVvalFsUEVlZUtlcVU4SWF6Y2lyV0l4SDZVL1o3MUxzelM3RDNGUnpBUjdldkZHeXAvTHlLY0VxZVlYTVFCVGlsMlZQczlxWGJTNWlibGZiK2ROSTRxeHM1cE5tS2ZNRnl1Vk9lUlRDdnRWa2crbE1aVHg2VTB5a3lzeWpGUnN1S3NsT2FZVjRxMHgyUlZaYWlaS3RsT3VhaVplMWFxUW5FcXNwOUJVVEFpclJXbzJYLzY5YUtSTFJXSy9qVVpYajJxeVY1Tk1aYTBUSmFLeFhCcGpEdmlweUthVkdlZXRXbUpvemg2VUgrVklNNTc1SnB3SEI5NjZDYkNnVTdudlNBR25kNlE3QzdlMmFjQnpRb3llYWZpb2JDd20zbnBUMUdPbEdPS2Z0N0NwYktzSUZIYnBUd0tYYlRsWHJVdGpzSXE4ZEtlRnBRUHBpbmhmU291VWtDclVpZ1VneU1IRlNLRHhtczJ5bEVWVk9hbEM5QUtSUnpVcXJqcldiWlNpS3E5K3RUS1BwVFVYQTZmcFVvWFBGWk5sV3NJQm50MXFWVjdVQmNkS2xDWjlhemJJYkVWU2UxU0JQU3BFVHBrVk1zZnRXVXBHTXBXSzRqOXFlSWpqb2F1SkJudFV5Mi90V1RxMk1aVlVpZ3NSOUtYN09UMnJURnQ3VTc3T0tqMnhtNnhrbUU5TVUweDQ0clgrejFBOXYyeFFxdHhxcmN5bVQycU5rclJlSDJxdTZZR01WdEdkemVNN2xKbHgycU5scTJ5OTZoY2MxdEdScW1WbVhOUnN2V3JMS0tqWWZoV2lab2lvVjVxSjF6VnRsNTZjVkN5OThWcW1EamNyTXZOTUsxWUsvd0QxcWlZVnFtUTBRTW94VENvcVpoMXFKczU5cXRFMk1vWUJ4ajZVN0F6NlV3RG5OUEE5YTYyS3c0RFAwcHc3VTBEa2RjMDRBZCt0U3dTSGdZNTVwNEhGTVhzZjVVOEUvaFVNZktQQS9TbmdVMVR4VHhpb1krVVVMVGdPYVFkZWxTS1B5cVdWeWdFR2NVOExqcUtVRG5wVWlqbW9iTFVSRlgxcVVMNlVBZER4VXFqTlpObHFJcUw3VklGeHhRb3hpcEFDUitQU3NteDJGVWZoVW9VZXROVmNpcGtUajNyTnNoaWhlZnJVeXhrMEt2cjFxeEdtVG1zWlNNSlNDT01rMWJqaDlxV0tMbnBWNk9JS09hNWFsUTVLa3lOSWNEbXBOdFNiYU50WVh1Y3oxSTl0R0treFJpa0lqeFNGUWUxU1lveFJjQ3RKQ0RWT1dIbmdWcVlxS1NNRVZwR2RqU0U3TXhKSThWWEs5YTA1VXdlbFU1RTY4REZka0puYkNWeW00UEdSVUpIWTlxdE1NR29IeFc2WjBSSUdIZnVhaFphc1A5S2hPYTFpYXBGZDFxSmdDYW5ZWU9ldFJOOUsyUW1pRmdLalllZ3FWc2pOUkVaNXJSRU5HUjY4VXVCVVFrR0tlR0dNWjVydGFaS2lTY1V1VFROdytsT1Y4ZGFWaXVVa0djZHpUMUo3MUdDTTQ0cDQrN25JcUdPeElHSFNuZzhWRU1kVCtGUFU4OGtWRFE3RXFrY0VETlNBaW9sNEgxcDZuR2FobGNwTXVUVXFua2NWQXBBUEZUS3lqcG1zMmkxRW1YcGlwVnozcUZENlZJRG4xckpscEU2OEdwRjY5NmdWdWhxUUhjT08xWnRDY1N3cHhVeTg0eC9PcXFzY0FHcDBPVnJLU001UkxTQW4zcTVDT21CeFZHTTl4MHEvYitvcm1xSExVall2d0p4MTVxMEJVVnVBUURtck9LNEp2VTg2ZTR6RkdLa3hSdHFia0VlS01WSnRwTVVBUjRveFVtMmt4UmNDUEZJUm5pcENLVEZPNEZDNFRyV2RNQjJOYXR5QldWS1J6N1YxMG5jN0tPcUtUOWVsVjM5K0t0T1I5S3F1Y3Q3VjJ4TzZNU0p1RnFGdW5UOWFrWTl2NVZFV0dhMmlqZFJHTVNCMDYxRXg0NlZJWDcxQ3pZUEZhcERjU051dkZNYmcwclBqaW9HYjBGYlJSbTBjMmwxRklvWkhWbFBRcWVEVWlUTDZpdkxOeEhRbXBZN21hTTdrbGRXOVZZZzE5TzhzWFNSNUN6TmRZbnFRa0hyMHB5VEtlUXd4OWE4dU4vZGtNUHRVM3pmZStjOC9Xb3hjU3FOcXl1QWV3UFdwL3N2KzkrQS83VGovQUNucXozS1JydmtjSXZjazR4U3gzYVNxSklwRmRUL0VwQkg1MTVVOTNjU29Fa25rZFIwRE1TS2FrMGtaREk3S1IwS25GTCt5bGI0dGZRZjlxSy93Nkhybm01NC9XbnJKakdTQm5wWGtZdVp3MjhUT0d6bk80NW9rdTVwbjNTelNTSDFaaWFuK3lmNzM0RmYybkgrVTloODRJT1dBQUdha1NVWTY4MTQyTHk0Vml5enlBa2JTUXg2ZW4wcVFhcGZoOS8yMjQzRG9mTU9hbDVPK2tpdjdWaC9LZXpMSjA1NHFVU1lBTmVPeGVJTlZpVXF0L09RZjd6YnY1MUxING4xaUpnVnZYUDhBdkFIK1lyR1dUVk9ra2FMTktYVk05alNUanFLa1dYT1IrRmVPcDR2MXBNLzZablByR3Y4QWhWdUR4M3EwV04va3k0L3ZwalA1WXJHV1MxdWpSckhOS0hXNTY2SDRwNnZYbEVYeEQxRkpNdmIyN3BrOGNnL3pxd254SnZRd3paUUZNY2pjY2svV3NKWk5pZXkrODFXWllWOWZ3UFZGT2FuUW5wMXgzcnltUDRtWFlCMzJFQlA4T0dJcWQvaWpjaEI1T253aHNjbDNMRDM5S3llVFl2WlIvRVR4MkhhMGtlcnhOM3o3MWZ0MkdhOFVqK0tHcUxjYnpiV3BqNCtUREQ5YzF2YWI4V0xZZy9icktXSnNINW9XM0EvZ2NWelZza3hhVjFHL296S1ZlalBabnMxc3dJQXEyQlhoNCtNRGk5U1dPemRJRmhjR0lzRHVrL2dPZU1EMSt0UTZsOFlkV3VoYi9Zb2hhc2tlSmVRd2RzcWNnRWNEZ2o4YTVQOEFWM0d5bHNsOHpobFRVbm96MlNmWGROczU1WXJ5OWd0MlNRUmdTUHQzWlZXLzltNjFvNzFNYXVwREsyTUVISUlOZk1WNXIxMXJXcXphaGVQdW5tYkp3TUFEb0FQWURpdTg4TWVPcnZUN05MS1RiUENwR3pmMVhuT00rbGFZcmgrVk9tcFFkMzFYK1I2TU1xZGFselVYZVhWZjVIdFZyRXNrbnpjNEdjVmVhRkdHMHFNZlN1UzBUeFRiWHdERXJGSjZic2l1akdvS1l6OXpQWWc4VnRsbU13dUVvT2ppWTJscjB2YzhiRTRhdFRuYVNzVlhUYTdEUFEwM0ZOKzEyem5QMmlQSlBRdU0xVHY5ZDByVGNDN3ZvWWllMjdKL0lWOHp5U25OcUVXYVJwVGs3Sk5zdWtVeHlGR1QwcXBiNjdwRnpFc2tPcFdySzV3UDNvQlA0SG1xMnE2dmFXY0t5ejNFY2NiTUVWbWJna25BRlZHaFVjdVhsZjNEalNrNWNyUWwxT0RuTlpVODNVMGx4Y2pPTWpOWjBrM3FjY1Y2RktqWTllamhySW1rbUI2OFZBMG9KUFBXcXNrNHoxejZWQTl4Nm5qM3J0alNPMk5BdHMvTlF0SjgzT1BXcVQzWUhRamozcXBMZll5YzhEOUszalJiTDVMR2xKS085UVBPb3JNYThKNy9BRTVxQjdybk9Selc4YURNMmpUYWI1ajYxRzB1T3ZTc3Ryekhlb3pkSHJrRE5iS2d6Tm84cHBhT2xGZlpIeFFabzcwbEtjWjRPUlNHRkdhS0tZWERORkZGQVhEUEZLTWQ2U2xwQW1LYVFtaWlnT1ppNXBNMFVVQmRpMHVjVTJqakhXZ2R4MmFkVE0wb1BHS1Jha1BCUEZQelRGTk95QlVzMWl5UlRVaWtHb0ExUFUrOVMwYndtVzRwTnA0TmExbmViY1pOWVN1Y1ZLc3VEd2F3cVUrWTlYQjQyVkdWMHp1TFBXcElBQWttQjZWcy93RENVM1BrN2ZOWWZRMTV2SGVNcEdUVmthZ2NkYTgycGw4SlBWSDBFTTB3OVZYcVJWenFyN1Y1TGdFNzhINjFpVDZneHlDeFA0MW10ZkgxcXJMT1Q4MmEycFlWUjBzWllqTm9xTnFXaGFudXQzZk5WcEx5ZGtFWm1jeGc1Q0ZqalAwcXFaU2FhWHoxcnVqVFNQbjYyTWRSM2JPcnRmSCt0UW5FMGtkeU1BRHpFd1JqMHhqOWM5S3R5L0VPNGFaeWxuR0lpUGxVc2NnKzVyaHlhWVdyQjVmaDVPN2dqT09QcXdWa3pyYmp4enFFckF4SkZFTVlJeHVKcVQvaE9KQ0NIc3dUN1NmL0FGcTR3dlNlWmcxWDFDaGEzS0wrMUt5ZnhIWnQ0d1JsWE51NDQ1K1lWU1h4SzNtek0rOWxmTzFlUGxybXQrZTlOM2MxU3dWSmJJVHpPcjNPcS80U1pDb0hsdHdQV21ueEVtZnVNZlQ1c1Z5KzRldEJZVWZVNmZZWDlwMVRwbThRS2VBaDU5NlE2N0dmNEd6M3JtdDFKdXAvVktmWVA3VHFCY2JmTStVZHFpL0N0cGRJZ2JPWnBXYlBiRlRMb2x0M2FVbjA0RmEvV0lKV09XV0JyU2xleSs4NS9qMG94elhUalJiTEIzRGFmK3VsS05LMDFWenViUHB6VS9Xb2VaU3k2cDNSeTlHSzZqK3p0TUlPVmtQMHhUNDdUVG8rUEtKUHVCUjliajJaU3l1cDFaeTZ3eU9Nckc3RDFBelQvc2x4L3dBOEpQOEF2ZzExNlNRUW9GaVhiOU1BZnlxYnpYZFRoU2M5cXllTWt2c215eXVOdFdjWjlpdWM0OGlUL3Ztayt4M0o2UVNmOTgxMm02Uk1sb3h5ZjRqVVFtYlBEUUtUNkEwbGpKUG9WL1pWUCtabklmWTdqL25qSitWSDJPNS81NFNmbFhiUnF6Lzh0b1FjL3dCMnJheFNNQmk0aHlQOW4vNjlTOGUxMEQreXFmOEFNenovQU94WEovNVlQK1ZLTlB1ei93QXNIL0t2UUhoa1ZlWGo1L3VnNS9uVGxqZFY1ZE53OVFUVS93Qm9Qc1AreTZYZG5uNTAyOEgvQUM3dlIvWnQ0Um43Ty81VjZKczM1RENOc0RuclRIc1VrQlpjQTllaC93QWFTekY5VU5aVlM3djhEejRhZGVmOCs4bjVVRFRycy84QUx1LzVWNkJIcHR3dVBMblFjOURuUDZtbTNwdWJDRXpUWEZ1RnlCMEhGTlpnNVBsaWtONVhSU3U1TTRUK3pyd2Y4dTcvQUlETk9HblhaSUgyZVFIM1d0Vi9FZDdKSmxKRVZBY2hkb3JvSUx1ZTlpVjRwSUpPekVjZHEwcVY2dE5KeVNJbzRMRDFHMUdUT1BYUjc0OUlELzMwS2VOSDFBRFAyVmorVmQ3QlBLc1laL0pEQVkzRnV0YWF4Yllpek5BQjBHWmNZRmNjOHhuSDdLT3BaYlNYVm5tQjBxL0gvTHMvNlVmMlpmcjF0WC9LdlRWdUxHTi8zdDFhaGVtQklUVjhYK2lSUmhqZW9Sd1FGVnNmbWF5bG1sUmZZL012K3o0THF6eVVhYmZIcGF5bjZMVGpwMStCL3dBZWR4LzM3TmV1cHJtbmtsWXdTMk9NeWRSK1pwVHJDUktmM2VWQjQzU1ZIOXExci93L3hMV0JoM1o0OGJDL0l6OWp1TWV2bG1tZllyMDhHMW4vQU8vWnIyQjlVbGxHN2V5QWRWUUEvd0F6VERxSlZXSiswT09uTEFjZmdhcFpwVS9rWDNpbGw4ZjVtZVBOYVhLbjVvWlYrcUdvekJMeis3Y2Y4Qk5lc1hONGtpbmJGSVNlUWQyNzljMVFrdXA5cTR0MVlLZWpEcCt0Ynh6R1RXc1B4TW5sMEg5bzgxOGg4RE9lZlkwM3lHeWVjWUhvYTlITjFMZ2h0UGpaZU1FSGorZE9OeWhIT2tnRWVrZzZWZjhBYUV2NWZ4UkR5MlBjODBNUjJnN2dNMDB3NEpIbUljQ3ZTWGtoTEV0cGJnZW9jVkc4VnE3QWl5bUdmOTA0L3dBYXBaZytzZnhSbkxMWS93QXg1eUlTUm56RS9PcEZ0QzRiRXNmQXoxcnZqYTJtZitQUnozKzRLYjlsc1NNL1pINDYvdWhWL3dCb2VSS3kyQ2VyUFAzZ0NEUG5JZm9hYUlnWEFFaTg5Njc2U3lzRGovUm41LzZaVkdiSFR1YzI1OVA5VUtwWTlkbVE4czEwWnhpV1JkSFlUSmhSbnJVUnQyQkkzcjZkYTdZMkduN1A5U3lrL3dEVEljL3JVVGFicHA2UkgzL2M5S0ZqVjJHOHVWbGI5VEhET09qTVBwVHZNbU9DWGFrTEVISWM1L0tqY2R1TUU5K3RGajBodzN1ZnZQbi9BSGFBanNjSy93Q2RSSDA1RklPcEg5S2RndVhFaVlqbCtSeGphUDhBR25yYm9WNW13ZTNTcVlCNHhUaGtWRGkrNVNKM2hVRElteWZRQ29mbUJBTEgyb0dQeHAyeFc3WTllZXRHMjR4UThxOUpQNjA5WjUxKzZWT2ZWUlRBaTUrWXNCOUtrVkk5dVRMaWs3RHNQODRsZm5oNVBJWUVEK2xDejVKeEcyUjZFZjRVaDJaQURmNS9PbjRqQk83QnlPUG1xZE94VmhETytRUWh6MHlTQ1A1VThOY0VqNVJuMkhOTkVzYUtRRllrSDE0b2E0ZjdvQkg0MG12SXJRa1dXNEhTSmg2OFU4M013d1NxbzMwN1ZDTGwySVVrajZHcDJ1R0dVNXh4eVd6Z1ZMWGRBU0xQTnZ5V1VnOStNVXk1aisweEZKaXdCNjdPUHI5YWorOFdWZzJSK2xEeU00SlpYQUdSa0h2U1ViTzZLY1UxWmxGdEd0ZzJkemdWY1cxdDRJc1J4NVBxTS80KzFDenNpbGdTVG5rRWRLZkRNcFB6akI5ZDJCVnlsTnJWa1FvMDRPOFlwQ0k4TWcybERqcHlQL3IwNk82anRTVkNvVlBQeklNajhhbmp1RlVqY2lTZHpsZTMxcFhqaW5EU0NPTUQ3b3d3SDlhemJXeldocTBVTlExbGxaVmhpdDFia3R2WHJ4VE5IMXlhUzdTSzRkUkdRY2JWNXpXQmVQdnVwQ01BQTQ0T2VuRk10NXZJdUk1TVoyTURqT09ocnVXR2c2ZHJIejg4ZlAyOTc2Sm5yZW5RTGMzSUV5U3g1L2k4b25ISEhBcm93STdlTXZFd2tiaGRnUmczMTVPZS9yWEUrRXZHclQ2M2IyQTBwbSswTVVZeHpPN2NuSU9EeHdNLzU2K3F5WGQxYVNjYWZkU0s1NEtkZ01qSklCSTZEclh5dVBqVnBWRkdTMzgwZW9zYkdYOFBWSEFYdDBvbWFKQUE2amNWWjhIUG9PUDg1cm5kWHVyKy93Qk8yUnh4S0MzT1RrOGZoWFo2cktodlhrTnBORSsvN3pSdU41L0xuakhPUC9yWWR6SkROUEp2aU1MRGhzUlAxOUI4dGRlSGx5Mmx5blU3Vkk2NlhNTzJ1N3Eyc0lvYmdvektNRERFY2R1TVlxVVg4amtLc1RZN3NId0QrbFNGclZIK1lLRlBvalpINWluT0xKd1dDT3dITE1ZMjUvS3V0dUxkM0VJcFJTUlhlOW1pYmMyQ3BPTUI4L2xVME9wT3EvSkhuc1BtRlZ6RGJsbU9HTVJPUU9oSDUxVmtFTWJIaFhPT0I1aThmWG1xVUlTMHNEU05UKzBib3J1Nmc5Y0tLRHJUbzNsbCtUN0FmMHJPZ2lJK1lybmNjYlZicFVyMm8rWmdoWWp2NW82VlBzNmQ3TkVOSVU2dkgvRmhtNzhjVXdhbkdUOXhBRHlPVFNQYklNYm9VNXljK1puajhLck9zYU5rSWg3WTVQNllyU01JUFpFMlJiL3RyYmtiSXZiSUpwaDFoMkpRSkNjLzdKcXEyMEhDeGhtNjRLWXhVYnFvSUt4ams4QTRGV3FVT3dta1hCZlpKRFFRbHZYa1pwclh5eWZMNUVJSjl6L2pWWVBiZzRlRWRPb2JOTy8wVTVPd2RmOEFhbzVJMzJGWkdZRjQ3MGJXeG5KSTlSbXJBZkoyN09nOWFYYmdBbFdIMUlycHVaRUtwdTZIOWFkNUhYdDNPYWxEYjF3TTQ5cWNpc1VJMmdudnU1cVhKbEVLVzVJWWpvUGVsTUhiY1BwdXA1REtjTGdIODZZVzNIYVY1OXpSZHNwK1lpeGdIR1FCNjVxUmtqRWVkeDNlbWFqd09oSUZOYkFPQ3dwMnVEYVEvalpnWUJIclQwSUh6Ynp1OWFxbWVCR3c3b1QvQUNwaHZvMFlLaWxoM0lXcTVKUFpHYnIwNHZXU0xxdUNSakdCNm5pbnBrTWY5V2NIRlUwdUZia0t4LzRCU21lVEl4RWYrQllGVHlNdjI4TzVkRE1jL0tjZE9ocHlaS0hQVnZ4TlVOOXlYNGdYR1ByVThTM2hJUHlBRHZzSnBPSG1OVmI3Si9kL21XVjN4bkdBUWZZMHJPUzRZd0ZUbnBnMUM4RjRkclBjYkFPaENZcHoyenhvdTYra3l3eUNPZjZWTmwzSzlwTGZsL0lzYjRoeWlzVG5Kb015Z01qcU9jNDNEQkZVeGJ4eU1CSkpjU0U5Y2tZelRIdFlWYkcwSVIzZHMvMG81STl3OXBQdCtKYW11b0V3V2VFYzlGWUVuNmlvVjFDQUVxcU81SnlDcUQrdFFnSWtaYk1UNE9NQmYvclV3TkpJUUZFYUVIZ0VZL3BWcUVUT1ZXYTZseHI1L0xETmF6ZCtlQldicVdwczhZaWlVb0Q5NzU4bXJUMjB4RzlwbFBHTUE5UDBxcUxGSGI1bng3QVpxNmFnbmN3eEh0NXc1WXQ2bU9DYzVPYVU1cS9KYXRHeFVDa2p0Q3pBRTRycTlvclhQSCtwMUwyTC9oUFZuMFBYWWI1YlJMb29DUEtkaXVjajFIZXZSZjhBaFowY0pFa25oU0R6U3AzeXBJUVRuOFByM3JrUEMybnlIVmtXTzFGekpqS29KbFE5UjBadi93QmRlZ1cxOVBZWEdmUDFaSjBPVnRaYmlLNWpPT294L0QxeHdSWGg1aXFGU3BlVWVaMjd0Zmwva2VsU3cwcWNPVjduUFA0MjA3VkxvcmM2VmFXTWFyaENZMmJCOXlDUGVxRjdMRmZTdTl0SmJzTUFqeTA2ajZialdscld1d2FreEZ4b2pva21RcmVVQnlBUmtjWjk4Wk5jOWNXbW1mdlkvc3NzTXlzUWlNckx1R2ZRanJSUXB4U1RVWEg1M1BRcDgwVmE1Tk5HeUlnZUJNTU01RVlYMDZldE1MSVFHRUt4Z2c0TzBBbXFEMjgwTFloZTR4akcwZ24wNDVxdEpjM2NaR1lsYlBZcVJYWEdsZlpqbFg1ZmlScm9rMkN4d1Fld1gvUEZORVZ0dVVTRUFZeWNkaldkSHFNYUovcEVNZ2t6a0ZPZ3A1dmJKeWZuSzU2QXNlS1hzNUI3ZW0rdjNseVVXM1ZaQXE1NStTcTVsUld3RHY4QWM1RlBXS0YvbTg1ZmYvT2V0UnZBTi9JUDE1b1NXekxidnNTTGNwSmtNaWdnY0hQU21zdzh6Z3V1ZXh4U05DRlVqT1Q2QVpwandiY2ZNcDU1R0RUU1hRUXZEaktENXVoNUZPZUVGZ09NNEIrWWlvQ0NwUFhQcUtRcGhzWlkrNE5WWVRKeENHd3UwQTQ3bm1tRkVWanp4bm5wVVJWUUFjQTg5QWVhVDVTZnU4Zldta1NWVnZGSEJUUDVVZmJXZmp5MlAxcUpVZFNUaHgrRlBYY2NzQzM0MXU0eE9DTTZqM2Y0RW5uVERrUkVlbVdIK0ZTTExkdGxkaTVIT01tbUlHWWZNWDlCakZTN2RwK1ozNjV4VU8zWTJVWExXN0lRTHZmdWVVSVBaT2FlREtSemRFakg5ek5UK2FWQUpZalBITk5FaENrS0NEM3ovd0RXcFhiNkZleml1cis5aWlQS2xqUEtjOStSL0txajJNVHVEdmtZL25WNVhKWEFiQkhyVGQvQS93QkkyRWRjVWxLU0hPakNTMVZ5a0xXMXp5cit3UEZUYmJJZktxSG5zVFV3S2h0NGJkOWFidXdmNFI3OTZweWJDTkdNZGt2dUdDTlF3MnhxUWZyeFVqQWZkSTU2WU5KNWlqcTRIT1FUUUpWMjhPaHllYWwzTkVvN0NqYWd4dkg1MUtKTGRUdVp5elk5RC9qVmNoMkJPRkg0VTRRUzdRZXZiSFFVTkxxeGN6N0VqWEZ2dTNZQlBYMTVwalRidm1FWSt2cFV5Mk1oUXMxdU1Edm4vQ3Bsc1ZES1NnNUhDaGdlZmVvNW9JMFNxTkZVT0h4OHBKNzVIV3BHdGczS0w4M3NwR0swNFV0WGJDMmpBZ0hPMGpKOThVaklnTEFMZEFIc0NCVWUxMTBSYWhwcVo4VUU4V0R0SzgvZUM1cTZKN3FWd1gyeUJRRnlRdVNLbmd0Z0pQbDNraitCeVNTZndyU1ZXalZGRndJbUhKL2RIajhheXFWVjJMVWJiRkFXczBzTzlWem5nZ09DQjdZQXFhMDBxM2VCeVkyWEFPZDBaQjZmNzFSelhGdEhMODk1TVN6Y2xGT1QrdFY3aTZqREVyY1N6S09CNWlzbjhqVTJtMXBvRHNaVjFBcXlzWXh4bmcwa2RsZEdJVExieUdJbmI1Z0IyNTlNOUtta1dPYVFuZUNTZlUxMVdpYUJxQWpTRzNGc1hrS3VreDh6NVMyUmpqdjc0N0RubXRxbFpVb1hiTWFrVW5lMmhXOEsyRW9sYTRqTjdDL0NyTEhjQ0ZUejh3TEUrbllWNkFQRDBWOGRyYXZjem9CdVhONUZNVWZIQStidG4zN2ZqU1czaDd4VmFiSkxLTFE3Y2pPNHhLeTcxOUR1SGZyK05hZmwrTWJkQ1A3SDBpNVlZWWt6SEpJUEJHZWxmTzR2RyswbnpVNXhYelg2bkxPb3BheGErOHg3blFubFo3UmRaYTRnaitabFd4aVlxY0VjRTlUK0JybExud1FzVS9tMitvN1ptTEFpVkZUOGlNL2hpdGp4THFYamVLWko3cXpzd3JrS3NVRW04RWovQUdkMzYxeWs5ejRrZDVIbHRQdi9BREhISUJQZmtuL0pyc3dxcjh2TXFrZGZUL0pHMUs5dGRmVC9BSUJWdU5JdTdhMzV1NWQyL2I4MFlkUCsrajcxWGtzTHVGd3NveVFPV2pSV0hYMk5XbHQ5V01aTDZXWHlCbjk2VnlQcDZjMHlXSzdndGk0MEc2aDNINUdobElBUHVNVjZTbTlycC9kL21YZExYWDhTazBBVmZtS003SE94NGl1UHhwaDA4eUFZeGs5aDIvV283azNkeE9vazArZmVUdzI5aTJQeTVxeXR0cWlSN2tqbjh2M1BUODYyZDQ5UlJsR2Q5Q25Mb3BpK2NYQUhPQnREZjRVcWk3c3dNM1dCNkZDZjVpclRKY0VBM1F1Rko3NEJINkdvNTFsM3FwU1lMeGduL3dDdWFhbTNwSjNKVkdDMWpvVTMxQzk4MEh6VWNEamtBY2ZsVTBPcXdvR1NWVGx2VG9EK2RPVzNFay9MRDYrVUQrZ3BzMW11eGc2d2pIZnl5dFgrN2VqUkhMVlYrVi9lU3JjVzhxbFkvbjR3UU8vNDRwMHZrbFYyb1I2a05tc28yc0VEYmhjUnFUM0JQOUtiOXFsWEFTWlpCMytZZjFwK3lUK0VqNnhLUDhUOEdhWjhwaXZKd2VNRmNVR01BampJN1lHYXFIVUxiQTh4WlZmMUFVajh4U2ZhN2Z2TXArdVJpbHlTN0dpeEZOcmNhRjNBQWxsL0tneGhNRVpQcmltRUVrRXlBZmpUY2dIL0FGZ3gzclN4bnpXNkV5b1NNYmlQeHhTbE1EazlQZW9zQm16di9IRktGUUU4YzBtaHBvZXl1V0dDQ1BYdlRTc2dQM2MrNEZDNTVCS2c5c2MwdTRJZVhRaysrS05SNlh1TndldTNuNlVNR3huYU0rbE84N0I2NCtsT0RidjR5UGJGUFlkaytwR0ZiZzdSK1ZOTWJFL052eDZBVk1mTXlQM2hQUGVwVlhhQUNTYVhOWUZUNXRDa0kxemtsbFBvUmlyQ1JMemhqLzN4L3dEWHF3RjNNTXV1UitkR0loOTVHem5nNU5TNXRsUm9xSXFKQUZDaEdMZXhJcWN3cXlCZ2pMNjQ1LzhBcjFDR2gzWkhtREI0d1JWaUNXVkhCU1NTUWRHVUFtczVYM1JzckxZdjIxckJOR3FyZU1TT1N1ei9BQ2FjOW9rVXVSTkY3YlFjL3dBcXBHN2lqSkQyOGUvME1lRG1vUE9qYVR2ZzljcUNCOUt3NUpON21pZlM1b1BiM0s0WlhESVJuT3cvbDBxRVR4UmtxNm91ZXVXeG45YWRINWJPcXd4YmhqNWhqT2Z3elQ1Z3p3L0xBSW14end2OHFGMlk3MkZqdXJSUUZEcUNQNDBrUDhxWHpMRmg1cnRNR0hmWmpQNlZWMlhqQnR3aE8zcm5HUDVWSEpOY1p6NVlVSGpDTHdhcjJhYjBmNGlVaTlKY0ZoaUhUb3l2WE93YnNmWC9BQXFLVVNOQUJOWlFManVTZDJQZkZWRnVKTnUwU3NyQWRRQ0QwcUpXYmNBVEp0NmdrNEdhcFU3Q2NrWE5PMHhyN1VZcmVDQUZwVGhWM1k1OUs3aFBEdXB4MndtMHVHNG5oWUZaTFY1UXV3NHdUa0hua2ZwWEZXQ2FtckpKYldrcnEzeW93WElKeDI0NjlhN0cxOGIzTElwMUN4ekVwVlZkb0ZBWC9nUlAwT09PcDlLNDhXcTdhOW5aK1JsVWxKZkFqUUE4WDdDYmJRV0M4RFAyaVE3Z005Y3R6MXJRajF6eDVEQno0ZExzaEh6c3g2RHJ4bjBxUzI4VzZXMDBCVVgxeVVHNUlvRkdXQkE2NEdEejJ6L0t0Qzk4ZjJkcWdWTkYxUjNaU0ZqY0JBZmJxZjVWNGxWMTVOUmRCUDhBcjFPU1hPM2JrdVljL2l6eExjRWk2OE1QNWlLUTBzS0VsUm4zT1B6L0FDckx2TlMxSmxVUjZMY1FJQ1M2dXFLeFRkbnI2OWZiSDFyb3o0KzFDNmRHdC9DR29TeHNBWTl6bGZtSHB4akZjM05yZXBXOC9IaGhvTnprRkpHUWxYUGZsT3VPNTdWMFllbkphZXlVZiszbC9tYVVtMC9oc1pPcGVJTlRXNGRvTEx5VkpLcWpNRHQ1NkhIdFdmYk5xcXFKZnNjQ2djc3o1d2ZxQzM2VmRtdXRidkxzaUsxMUNCd0FyckdkdkdBdU1oUUFQcjYxbFgxcnFJbGxqZFoxS25EeGgxNFBZSEhldldwd2lsYXlYNG5ZbVN6THFLQm11SmRyU1k1RWhRa2RSZ0FkS3FmWm5paS9leHpZUEphT2NFTjdFVkc2M2lJUUxhYko3cys0NDl2U29QTm15Z1dHNHg2QisvNFlyb2pCMjB0L1h6SWNsMUxMQ0IxTExGTUZHQnQ4eENmMXF1OE5zdk1obmliZGpkak9SK0ZNQW1BQlZKWXQvSExkYWVFdU1yeXg0emdxRGlxU3QxRTBtVjVZWkZBZUthWmhuR0EzUDg2QUZrVWJwbjNIcnVVOGZ6cXlWbVQ5NUs3UmtER1ZYZHgvU2hvbXdNb2MrNmtIODZ2bUo1RmZRYTBNYWc0bGpMRGdjNS9URlFDMWN1VzNxUGNZcWVOV0NNVVE3U2NaSnpqOHFheVRzdTZORWJIVURnaitWSk45d2FXN1JGUFp5T3AvZVJrRG43dUQrTlVIc09jRW9jL3lxNmJpWkppb3RRZU9TRFNHNGx4aDRYUGJDNE5heGM0bUU0VXA3b3BiUVRqb0tYYm5nOENxNjdnMkhLblBjVThGd0RqZGl0Yk01NHpUM1JKdEF5TjUvT2pHQVR1WWoyTk5YQis4UWVPT0tYeXM1Slpmb0RSNmo5RUlTVzVLcU1ldWFWSXcyZmxUUHNLZWtJQkc0akhyMXB6UVE1NFp0M29DTVV1WkRVSHV4dmtFbjVjWnBWdDVnZmxDRDNQTk84Z0hscFBwak5POHBzRFprL1VtbHpHcXBwNjIvRWVJZHZMeUQzeGlwWTRZWlJ6S1Z4MzRxSUFJUG1kTStocCs5Vys3Sno5Q0t6ZDNzYkpSMlpiRUtSTXBqdUR1L3dCckdLa1pta0lkUkh4M1BIODZ6dk1sQUlFZ0lQWUNtK2RNbzJrNS93QjFxajJiWlhPb21rVEk2a0VEQi9pUVVpUUNOK2syZWVyTnlmYXM0eXlOM2xJSFpxa1ZKc2JqbFIyNG9jTExjYXFKOUM5S0UyZ2tic2RtSDlhWnNpbEEzVHJIa2ZLQTNBcUVYQng4MjF1TWNrVlhlZUlyZ3V3eWZUaWxHREtsT01VV1dTRldHYmxtQkg5NzlPdElzYXZ5Rm5ZRGpJYk9LcUI0eUFTTncrbURUaEpBeEh5c2gvblduS3pGVGo1RnNmdWlGTWNnSTdIci9PaHBjdjhBTEkyYzhobVBUMHFCcjZLTEgzbTdjam4rZFJOZVJ0eXFsVCtKbzVHK2czWGd0T1lzZWNkckRjVkI2L09SK3RPdHA0emtNY1lHUWZNL3hGUUxldy8zMkhicDAvQ3JObnJFRVVvYWUyanVJeHlRWXg2K3hIMFAxcE9MdHNMMjBiMzVqczlLdTlJWlUzU20xbFpReE1Gd2dETjBHUXdJN25JNC93QU4rOG5samtsMjYvREVrMlZhMXZJRU8zQjJsbHhrRTVCT2VNNXJ6NjAxVHc4MGtRdXRQdUlncUhkTEErNGxzNUIySHRqQXhtcnllSzdLM1dHM3RvSXpIRGtxOGxraEVnUFJaQVNUeDB5RCtkZVhWd2twU3ZGUDUyLzRKbk9wRnZjNy9UdE1XNERQcC9pZlNyaE0vUEhQWW9vVThuN294NkhyNlVOcHRrVW5OL3JHaUY0OW9UYmJ4SitZQUpJNTdFVnkxajhTWUEwdjJ6UzRIREFLc2NWdXFydEhPTzNmSFhOYnVsZU10RWE0KzBRV2NPbm93K2RsdHZuRGRqaGR3MjQ3N2E4K3BoOFhUYmJUK1NYNkw5Q0h6YXYvQUNNcS9zZkVNczBuOW42K2t0dXk1Mnd1NGpYSElBM2NCc0RJNXo3MWczdWplS0xaQUxuVTVZMHlzaXFMdk9TZWpBWjYrK085ZGpydmpMVGJHUUw5dWxsa2pjT3F3V3lyOU9TM29PNDlPSzVTNjhRK0c3dUVTUzI5NUpka3N6eVNRUi9PVDBCSUk0SFBiMHJ0d3JyMlRjTlBUWDlDN3hkbExUNy9BUGdHQkxwZW9TUEw1bDA4eFE1STNoaWM5T092cFVEV0Vxc3FOTElRL3dEdFozZmhXdGIzK2dRdSsreWFUY3d3eFFaUUE1NFhkam5rWU9meHp4SE5QcHJJN0xkUlJya0JWK3pMa2NkaC9PdlNVNTdOZmgva2FLTk5mOE9aSDJPUmNsUktNSEJibkZPOGh0Z0FsWWQ4S3hQNDFZZTZ0Y04vcHFaUHpCQkJnRSsvUURyNlVpc2trTzJPU09VdGdaTFp4K1ZhYzByYWppcWJkb2tMQ2VMQ21kZ0IwRGR2MHFNck5uekZ1RzNldk5UcDU2TmxaWVZBNEhKL1NqTTdQazNVWkpIUWRhTDJCcGJXZjlmTXB5UTNMdUhhVGpQM3R6QTA1a2xkY2JpMlBjbm1yRWtjdTRNMDVJSHAvd0RxcGtxNDVVblBmZ2orVlZ6WEY3Sks1Q3kzZUNXZHhuZ1pxTHpKNDhCSXczcWNacTBKZHFraktrZHhtbUZ6dEF5RG5zZURUVDhpWEJMWnNyck5MMVZwRVBzdE9TUzZVWStSaG5PY2MwanlJcllXVmczcGpJcE44cjVEQlhYMDZWZHZJeVQxM2Z5SysxUFhIMG9QbGxzYjJQc1RUVWQvNFJnSHRpcEEwbUNGMi9pTTFvY3lhZlFkdHdRUXhPT3h4U2hWSnkwWkh1YVFPTWZ2U21mYW5vWWlPR0pQdFVObThWRjdEZktVOGhzajBMVTlJWmlmazZEc0ZGUEt4anNNMG9jSDVTbjZWUE16UlVvM0VVVEQ1VHRIMU5QQ3NCbkNjSHR4L09sRzlSZ0VIOEtCNWhQUWZnS2xzMVVlOXhSSTUrOE9mOW5Cb2FVa1pNZi9BSDJLYVErY2J4ejJ4UVkxd01vQ2ZxYVdnL2VXd3g1NHcyWFFJVC9zOFVvbmpJdzBoNDlxZnNpSnljakhxYVRiRm5qUDRIRlZlSkZxaTZvRGVKZ2lNcTU3OWlLRXU5eCtaUm4weUtYWkRrRUtvUHF6VkxnS29JWTRISHlFRWZvYVQ1ZXhWNnQ5WkRmTmpiSUpqVS9Ray9yaWhraFpzcVFUN0pqK3RLU3BjQlNwSjdHbFNNWkxNMGFrYzRDOGZuU3V1aGRuZlhVWjVjYlpWaGh2VGJtbFdKV1VLMlZYb0R0NFA0MVpSUUFXRTJTVDkwai9BQXFOVVdSeUJJVUpQWEZMbUh5SzF5SVdjVEhBNUk5alVoc0ZreXUxc1lCR1FmNTlLYzBNNi82cTVsY2RpbzRJNDk2ZzhpNkJ5Mi9QYmR4VFRiNmtPTWR1UUYwNk5uK1Z6MXgyT2FmSHBVTnhITExHNElpd1dBSXpnbkdRT3VLUHNkNHlHWlltMnFjTXdqT0FUMEdlbk5UTERmeFdwbTZKa2pKNms5RGpQWHIyb2NuMGtaOGxOL1lOT0R3bGIzSmtXeHZrbVpZeklJMlZsWWdkVDBJNCt0YVVQZ1ZZbXhjM3NTS3JZTWdWaXVQKytlZnFPT1J6V0V0enJTN1hpdTdrbk8wTENDU3A5dU9NKzFkUDRiOFMrSTdWbWhaTHFlMmI1UXN0cVhIR0Y1SEhUanZ4anBYRmlQck1ZdHdtbi9Yb0xSYkt4cFIvREMwdXJaZkx2THhMa3JsQkxhTXF0ejEzWTZkOFpyTTFYNFhYdG0rRGZXekVSbVFxejdEdFhxUjF5Qi9XdW1TRFdKNWJaanFEcEZOODdOR0RHSElKQlhZY0FqSXoyclMxU3h1WjdLTmdxUlhNTXF5SkhicUVkZ0NQbUs3V3lBeEhBT0Qxcnlsak1SVHFKT29tbVJ6TnZkSGx0eDRMa2lqaGVHZEovT0FLR09RREo5T2NIdjZVNWZBbXB0YkdUeWdwVTRhTXNDNEhISkhweUs5TnZkVDFXMHZZRmFPNmVZcjhrYVdxbEZKeUFXS2pPRGc5RDZkSzR1Vzd1UERrRWsxMWYya3Q1Skt5bTNna1pKVkp4bG4yRUhzY0E5SzdLT014RlJhTlg2ZGIva1ZGeHRxa2N0Y2VHYjYxbEVUR01sdWNKS3B4ais5ZzhmalVCMGVac2doR1pUMFdVSC82MWE5eE51M0xMcWttRlVoTXZJTTllY01lK2MvalJDOTFjd3NuMnAwajNid0hiZ0FManEyQWNEdnowRmQ2cTFMWGIvQ3hzcWNFdFVjKzlpc1pJSVpjZGNkUlRQc2J0a0o1Z3gzSXhYUVR6V1VkekpicFBPMXNHQll4TGt5TUIxQnowejNxcElDdVNZeUVCQlp5cEFHUm4rTVp5T2Z5clZWWkI3S2tZaHRZMTRMRlQvdlVlU294KzgzSHRtdFFYQ3VYRytBQURxUnlmeXByRldYZ2grK0ZRZy95cS9hU012WVUraG43WnVmbkdCN1VvTTRVTDVvQVB1S3VTU1FnNFZYWC9aSjUvR2xSU2NNUS9BM2JqeWNmalJ6K1JTcGVaVDgyY0t3d3plK2NVenpwaVBtUUw2WnpuODZ2c0F6TU53STlTZVRVWWlUSUF3UGZOQ211dzNTbC9NVTFMRWpLdjlRMmFrTWlwOHBJSituTlR0QWhCQndUOWFSWWdPR3lvemprL3dDTkhNbVNxY29GTGVNZ2JjSDYwQ1BjMjdmK0d5cFBNWCtFalB0VGZ0R2VHQlBzS3ZVeGFqOXBqMVJtNmJTUFplYWY1SkhPV0g0VkNzcXFDRStVbjF5S1EzVWhHQkVXeDNCb3RKN0ZlMGdscVRnbFJqZUQ5UmlsTHB0emc1NzhWWFdWbUFFaWJmcURtbktZeDFjbGZRbWs0OXlvMWIvQ05McGtrSU0rdU9hUVhqREE2R3BHQzR5cmdqMzVwb01oN0E0L3VnR3FWbVp2blQwWTJTN216eVNQY2ltSmNTRWdtUUQvQUQ5YWVWTGNHSTQ5YzAxclRQS2wvb1JWZTcxTW1xdDd4ZHlmN1p1NGVUUHZnZjBxTXVtY3F6SHQ4cHFQN0dXL2hEZGpqZzBxV213N3NFZlhrMHJRWFVMMTVhTkNyY3BGZ2J5RDc4MG4ydFdiNzU5OXFjbW52YmphR3pJb1BjaklwcHRvbVhQbUhQc1FNMC9kRTFYV2lzUEVydWVHYkgrMHBwR0FWZ2NqQjc4LzRVZ3RVNEtNd1B1K1JTLzJkSnRMQThqKzYzU2xlSzZqdFZhK0c3SjRwTWZld2NjZEFPUHlxVHpZai96ekFKNEpZNS9yVUF0V2p4a1Nic2RBeHgrTk5hR1FuSGtBWjdqTlRhTDZteW5VaXJOZm1YSGtVTG5qam5wak5QRW9raVg5M3VPVGpISU5ad2dtQis2K1BkaFZoWTJpQlpRdWZxS2x3UnBDdE51N1ZqYTBpN2VGNVJHRUNtTTdsY2Nkc2NFalBQOEFuUE5kQmJ3WGNVVFdscmJ4RXQrOERoU0E2bGNFTW9HUU9TT3VPbzk2NFdPN0NxOGMxdUpkdzRLeVlJL0dyVU4zY1dpN3ZMbGpMWVlmT3dCQTQ0L3h6V0ZURHVUdWhlM1RPdGJYTlQwNmNEVTlOamtnSUlraVdQeWdnWUVZR0ZHRGpwakl4NjFOWmVLWXJ5NGl0UHNtb2xkNmhURGVZR2NiY2pjb0l5TURHUjBGWVdsZUlOVGpsa0NhWkZkUnNBQkhLanlCQjA0QVlkZTlhUDhBYmQ5WXhKS21paUMyY2dsSTAyRGR6bnFHSjZaQU9RTWZqWEpPZ3ZoY1ZmMXQrQTA3Nm83U0NmVVRwUmlzdERtRE1mS2E0L3RCakowR0N4VDVsYm5uOEFlZ3FTZlE3ZG85MTVlWHNMelBzazh1VjVYQXh3R2RrM0JjNC9MMXJsZitGaGF1bnpmYklVbFVzMytrMlcyUWNENVF5OEg5T25PQlZvMzF6NGhhSzQxWVhNMXZsUzBzTURLU3ZwZ0ZSa2NjNVBvTTE1encxYUR1N1JYazIzK0pDaks1dERRYjR3eUlOZmhXeGdHd0s3dktpZ2pHUG1ZY2pQZkFyS3NORC8weWExTjNhUVJMKzdtdUZuaUxNTjMzdm1CWUhyM0hiMDV6WjQ3R3pua3RyV1B4SjVna3pIR0pUQjhuVXQwYlBUT2VPdlNzUzRuMEs2V05MTFN0Vk53d1hNc2orWXlrSGtqSDN1M3BYUlNwVkduNzJqOGw5KzVWMnRQME82bDhNZUhMYVZwNzZaMmhtQit6eUQ1eklkdnpNVGpya0U4bml1UnZkVHRVdW83TzJqYU8xaFpuMnpYQ3VHSlBWZ0R0NUFBNHhqSDQxbFhsd0ZnQ2haeTJ6YXYyaUFNSWh6d0FTUitPTThWa0cyYVZ5RjN2NkFxRXpYWGg4SzQ2MUp0bFhrbnBxYXR6cmtjdHdKVXRMYUdGQnRXS0pTQWZmNzJTZmZOVXBkY2VYWUpGTEJDZHBjZS9wbkZWdnNqUmdGNEpEay8zOTM4dWxTR0tFRWdSdXBISkpKQng3OEd1NVU2YTZFODlWOWJEM3ZrZkpDWnpnbmJIK25XaysyeDdsWklSbGVoMmpuOEtZeWphUDNaWFB2dXBEWnJ1WU1ZbEFITzAvd0JSbW5hSFVibFU2TWNiMUNYNkprZEVILzE2Z2U2aW1rM1NNejQrdjlhVmJDTnhoWkYvQnFqZXdDNUNOR2ZUZDFxbHlYTXBlM2EyUmFOemE4QlNRZmNnVWhVUzQ1STkxWUVmcFZKZFBrSjZaYkdTTThVNWJkMTZxdlBITW5GUGxqMFlLclVmeHgwTExKTUFkcHdBUDRud2FpM1RGZnZ0N2tObk5QRWNjUjJpVldiMExOaXBDU3E3bVljZEJ1d0tWeTByNi9xWld5VHFqYmZiT2FVTk1PSEtINm1wQVZJKzV6OUtVc3lqaGhXdHppVUV0VXhFeWZ1L2p0NS9uVHp2UDhESDNIRlIvYUpVSEtCODB2MmdnQTdBbnNhVFROSXpoYXpaT20wcmhnLzRpbDJoWHh0WWpzUUtxeVNTdU1nNEhxR3FJRjA5eVA4QWFvVWZNSGlFbmF4b2ZLT3FuUHZTWkJ4dFVBK3VCV2Y1c3ZCT0FCNzVwNnl0bkpsVVo5VC9BRW85bUpZdE43R2p2ZFI3ZXhwLzJyNWZ2TndQN21LeXpORm41bTNIL1pIRkFsaVBBZGg5RFM5a1g5Y1hScjd5ODA2RTh2MUZPRXF0OHVjZW1LbzdtMmdyRVdYMUpwVWNGdUNNL3dCM2JSN05Bc1RLK3BvS3pqNWh2WWRjWnByWEVwYkNGZHA2cm4vNjFWL010eTI2U0lqL0FHU0QvalVtNkJseURLdU8yY2orZFR5bzA5cTNvbitQL0FKMW5aQWVpbnZoZDM4dWYwcEJPWFhLU0VxZXVVNEZSQTI3c0J2ZGo3ak9Qd3FUeXBSaGhjQkJqMDZVclJMVXFqK0Y2Q05OT1FQbllyM3lNREh0U0tja2JDV1BUNW14elV2M0UrL052em5PY0tmMW9jeGJkeG1YbjczRks2SFo3dGpQczh6SjVrWUhCd3hJSkMvanlLY0xPUVFtV2FSbGlQQlpCbFJucDBIZkJxUUlXUU5Ba1RnK3JmenpVc04xSmJxQXNJUWRHS25hRDlmV2h5ZlFGVFRldjYyS3NReGhJa1loajh2emMvbFZoZFYxUzFqRnN3bWFGQ1NxU1NrQlQ3ZmlBZndxeDlzc1pJQWoyMXMweHptUXluUHNRRnhnL29mU25pTzFrbkFrQ0NJcVFHTHNDUHFjRWZsVU9TKzFFZnMzTDRaVzlEUFRYZFZpSHl0Tkd3WWtQR1NyTDdaSGF0S0R4MXJrVWUyWjJ2VUdBRnV3WkF1TzQ1R0QycGJRNlFzbmszVi9KRG5vNmNxQjlNYy81NXJlc2RHMERVbGxpaTFXNEU4YWhrYnkxQWtHQmxSM3o2WnJHdFVvcldjUHdNM1JkN2M5L3VNNkg0bGFpaTg2VnBlLzd1OWJjcStEMnlEbW1INHBlSTQ3ZFlZN3Z5UW9VQi9LRE9BTTQ1UDEvR3VoZnducFNoMXRyKzR2ZG93eVJRS0h6dUEyak9jbms4Y2RLeU5UOE9hWmFGQTEzSlo3OGxGdTJYTExqajdoT0RuakJBNml1ZUVzRE4yOW4rSDZNajJFbXJLZjNveW4rSXZpQ1VnVFh4a0djbmRDbko5U052UFFVeTU4YjYxZXpKS05RbFJrYmVteGl1MDR4d08xUW53OUpQS1VnQWtPQ3c1QU9CVVgvQ095SXpJOFI4MGM3UG0zSDZaQUZka1lZUmFxS1h5UlBzc1FueTZXR1RhamVYckJybWExWnVSdmtVQmpra2trOEVuSjYwc0VhU25Fc2NUTDAzTE5qL0VWWGswKzRDbG1XRkZ5UUF4UUUvbFRmN0p1UW9JQVVONkhuOHEydEMxazdGUmRSZlpiTnFQVEliWlJKS2x1RVVaNCtjdHlPdjU5UlZhN21RU0J2a3lUa3hyRzRVZTNYbXNsckc1UmdQS3o2ZktmNVU0UTNLUmh2c3AyZDIyNEJxVlRXN2xjcjIwbDd2Sll1U1hSWWdDR0hybkNrb2YxNXFLU1ZQbVlXWmp6d1NtVC9PcTZ4QXlidkttWDZQVTZHZUVueXlwUGJkd2Y1VmZLbHNTcHllLzlmZ0tBalJLR01pQTl6dHorV2MxR29oVWxWdVJnL3dDd3dPYWtTYVJlWkZJLzJnMjc5S2FMbUh6UTNuVGxza0VjWXgrVkdwVGNWWjMvQUsvQVdZd1IvZXkzVCtMT0toZGJNNEt4U042blBUODZta2ZkOG9nWmhqcURuL0NvVXRZemtxekt3NUtrSEFvV200cDNrL2RTc1JsSUNjS0dQNlkvU292SXlmbFZmb1dPVFZyeWdHKzhyRWZ4QmpUaUFxNER4OU83ak5XcGRqSjBVMXFVTUFubGorQXBkaVp6dmNudlVqUHlNQWxmYWphaDVLbjhTQlZYTXVSZE5mdkVWRTc3aGozb1lBZmRJRGRzOWFVSWNFcU0rd3A0SUs4b0ViMU5LNWNZMzBJMW1sQStaZC80QTA1U1grOGdCN2JoVG5CSEpjRUR0VGZPWEJHVi9uUnZzSHc2U1k4UU5qNWdNZmtLUTI0Si93QlVOdnNhYjU0R09RUHBVZ25BWEw0STl4Uzk0dGV5bG9NOGkzQndNN3ZUTlNMQkgyVXQ5VG1rZVdJajVkZ3o2VkR2R2N1dWNkTUdqVmlsN09EMlJiUTdmbFZjZHNZcEhoM0hJY0QyMlpxdXQybkFCWlNQZk5QZTViallEbnZ1Qi94cWVXVnkvYTAzRzI1Tjh3K1V4WkhxRFI1aFFEOTJvWHNjNHhVUW11TnYzRktubk9EVDFaMkdkdU9lZzRvdDNLak5QNGZ5Sm1kWmNuY3luMDM4ZnBURlhHTjBqRDBBWTAwL01TRldOeU9lQWY2VkdWWlQ5MWlmUWNEOWFFaHlscmUxeS9HaWZLRzg0b2VoSnovT3BQT1dNaHQ3RTQrVmkyTWZyV1dWQ3FYWXVEalB5dFNnUmxmdk9jL3d5ZjA3VkxoZlc0MVh0cGJVMkk1V1pCSWtzZVNmNGVvNC9MdlR3R1NSamlLWGFPb0lQdHprWnJIaFpJR0xSM0xXOGdPUVVmOEF3LzhBcjBzVnZ2T1k3dGp4L0NjZnp4VXVtdTVVY1JKNkpmaWpvbVN3Tm1XY2lDNlVqQ1N4Z3E0UGZjcEhyNlZTRnZMSmgxdE1ybktzckRZZndaVCt0VTRZcDEvMWN0eWpEb1JqQjl1by9yU2l3bmZlVEpNU0J1SVJNNUhxVG5pb1VWSDdScnpTbDlsL2dXcnl6bldMRGFReXlLY1BJcktVNllIVGdkUHhxdUxDNXRydFJjMk96eXpsMWxsQUJIcHhnL3JUQWw2QXlSVDNCNHk2Yk9NZHMrb3FuZUxmTGNPWnhJQ3hMZmNJSDREMHJTS2IwdXZ4L3dBemttMURWcC9nZC9jNnpCZDJWdlkzOTFyZHBiRlBrRWMzblJFakl5TjNMTDdidUt5N2ZSdFExdG1GcnFNRVZzZ0xvSnJzUnJHQ2VlR1lrYysvODY1VzBrbGptU1g3U2NLYzRJemo4RHdhMnRQMEdiV0luYTB2YldTVU54RXpNc2g0SnpqR08zYXVkMFZSVDVaVytWLzYrOHFGVG5XeDBGbEhyK2pSTmZXK3BRU3hxeFV0RmN4UjVPZTVQMysvRlU0bXRaWkF6VHlXaUVGdDAwN3VOMmVEbFFCK2hybnJqVExtTENHNGpuMnJ3c2JoOEQ4T2xXZE10OWJra0NXRnNjZzVCOHJkdDk4a0hING1sN0tOblBtVi91TlZVbkhSeExFMnBJVEZHTCtSeHlIWXhxeTg5Y0E0T2ZVNXEzTHFzNk1WdDIwK0tJbFY4cTFsMmcrN1l5VDY5YWFkSjFxZDVqY2VWTzhRRE1ua2pwak80bkczR0Ixenp4VU1UWE5oTWZrdHJZc0dJYVMxUmhnakdBVGtldmJ0U2FnOUZadit2SXRTazlWL1g0bEs2MUNCWTI4eU9aN3NIZ3E0Mi9xdVRWYzZ2NWdBanQxZ1lEQUxaUDhBOWI5S1V5VGVkOHM4VEgvYkNuK2VLc0lOU1JTeXlXb1JmdmJqdEdPUGI2VnZhS1czNG1ibkp1OTNiMHVWM2xkVkJubnVuM0RrcXVWUDU5YWlXVzFZbnkvT2tiUFYxWEdQeEJ3YVM0MWllU2M3MVRJNEFBSUEraHpVQzNzN1p3NC80RWdZRDlLMGpCMjFNcFZvWHNuL0FGOTViVjFja2ZaVlk5aXpnWS9QRklYdGdoUnQzWGtFY2YxcWg1cnRnVFhBUHB1UFNtaVMyVGwvbVBiREdxOW1TOFIxZHZuL0FNQXViZ24rcFJzZGNoRkg2OWFqTjNPb082MzR6MUxIaW9ZcGdveXBoR2VtV1A4QWpUaE5NcEx2NWUwOVNvL3JUNWZJWHRkck5vbml2QytGa0FiL0FEN2luRjRwQ0Q4b0E5UUtoODVKVndaTWovYXFOMmhROE03RWUvSDhxWEtyNkYrMGFXcnVpdDlwQjRSUm4xSXB3ODJVQU1xbjJ6VGw4b25iem4zR0tjWVZ6eWhBL3dCNnRHMGNxako2dDNHN1h4aFNBZjhBZXpUUEtuVTVZc2ZvMVRLc2FIaFZKOWppbW1WdDJQTFhQYjVxRTMwS2NJMjk1LzE5d3pZWFBJUC9BQUk1UDhxUVJsRy9qeDZZNjFKNXprL05oZnBTWmM4cExqNm1pN0ljWWJxNDFsSFh5V0g0MHhWUUhMQWsrelpOUHp6bmVDZStTYVlZNGlmdmpKOURpcVJuTHlzTDUwYWNiQ1BZaWdYTGsvS1BsOTZlSTdjWXl4L0FacFM4S2tZaVp2ZkZHbllhNStza2tOSHpISUtrbjBYbXBsazhzQUZXejJ6eC9Xb251UUNlTUR0Z0FFVTFacEdiOTN1YjJOS3pZMVVqRjZQVXV4enVPNkFkdHd4U2ViRjk1L0tQYkM1Tk1DbDEvZld3K29JelRsU0pUOGlBajBOWjJSMktjMzEwODdqMG1PY0NaQW1PTXBqOWFsU1dTYVFqQVpzY0txNXpVUWNMdUFNY2YxV3BXWElCM3hNdys2eWlwZGk0dVZ0SC9YM2pXUkpOck5GS01lbUIrbFBHbnd5THVWWlJqdXpqcjlNWnFhSnlDV2I1OW95Nmc4SDhLWTg5dnREQkpGRGNaS25INkdwNXBiSXQwNmRyeXNOTnBOQ0ZMMmpiZXp5ZnhmVE9LRlJwQ0N0czVib01Ma2ZwVTFyZk16cW9PQXB5b1VsZWZZNDRxWkxxUVRoNTFrWURuZEc0Qno5UlV0eTZseGpCL0Mvd0tqNmxLR0tQSXdPTnBMamQvUG50V2xiM3p0Skd5M2M2UTRBY3d3YjJRZXVEaitkTnU3eTN1WnZPam1tODJUNXBSTmtuZDM1Nm5uK2RYTEs3MHExamE0SkNYTVpHMGJRd2t5RGtjOU1FRHAwQnJPYlRqOE9vN1NTdTVhRXozbC9yRHd6eVNxV2kzRVhMN1lpMk94SklVbjZaUFBldFRWcHZFTG1PN3Z0TlpZbWxMU09UdWdLNTQ1akdRT0NDU1RtbTIrc2pUSW5oWFZXRWMyeVVXMXpITUc2ZDEya0VFWTU1QndLaXR0Y25TTjRiQzNTK2hTTU84ZHhhUnR0eXgzS0Q2WlBVZXZTdU5xVjAxRldYY09hL3dtTmZheHAwNVhPbVdnZmVEdWprbEp3T3h6d2Y1MCtHQ2Qwait6UTZjNk5LRDV4ZmJnNEoyczB1RnhqUEdlMVdaYmJYRGRTeVcyazdZcGwzQzMremlWRlU0UHlBcWNkUitkWk56NFoxVzFoTnpMYnl3QXlGQ2trTGpCR09DZHUzditsZE1QWjJzbWw4N21UbEpNMUcxRFd0RnRIc0xLNnNvVmRqNXB0N3FGaTVPUGMrM1E0cFArRXcxbTN0R2hsbnZET0VXT05vYmxZMFZSMklRYy9tS3pvOU5OdHpQSDlyK1RlRnM3dEdLOFp5UU1uanZ4VTJveWhMZUwreWJUVXJhRkZCa2FWaC9yQ01FaGdBY0hIVDYwZXpweWFUaW41LzB5YjNNYVM0MUpBZDhhc2ovTjh4NisvWG1vV3U3b1NHYWEvekpubGR4Y2tZeDdqcHgxcUYxdUE3SzY3czltT2Y1VUdDVlNUSmF5ZkwxMkRwK05kNlVldGpqbktkN3EvekxFZDJQT1NhTUxJNm5KRHBzQi9GVHorbFFYTjNKY1N0NXdaY25JVkZ4aW1DSm5CMlc4ekZlNmpwOWFsV1YxWGEvbXIvQUxMc01EOERUc2s3b1Y1UzBiL3lJMWxkTWVYT1Qvc3lqSDYwOGtuNXBOOGk5MVZnY1ZPUEtZZEZmUGJidHlmeE9La1czVUhJdG5qYkdReXNPbjBxWE5Hc2FVbnBjcW9pUGt3MlVqanFjbk9LZjVFVGc1QVE5MTI4Q3BuZ1Vya1JTbGovQUJGdmxxcElMa1pJa09CeGhjWUZKUG0yWTVSOW52Ry95UVBZcXovSmpIdC85ZWsrd2xGTGJpZ0hkdWxNRWw0TWZlNDlSajlLayswWEFHSGpFWi92RUFWZnZkekpld2V2SzBSbURjdUJLV1BvaW1vZkxWVHhJVmIwSzFiVzdjTjFCWHV3V243cEcrWStTNmY3V0tPYVMzRTZkT2VzZjYvRWpiYWYrV1pjL1FVMHNvR0RBRi9HbS9ia0hZL2dhUTNzZjkxaitOSlJsMkxsVnBQYVF1V0dDb0pIb1ZweXB1TzRJaFBvY2loTHRwR3hHb1VEKzhhVjlySGMwb0xlZ0lwNnJjRnl0WGk3aTRsSjJxdUI3Q2w4cmQ5NHlEM3pTQzVJNFVnZTVPYVUzQXhndkg5S24zalJPbjFZQ0NJRS92SkdQNVU1SW9jWThvZytyVkNKbmM1VnRyRHBnWkZBa2t6OHdCeWVvR0tkbjNJVTZhMlEvd0FxTUVEY1YrZ3FRUndyMGNIMUpPYXJrU0JzTHovd0lacDZpYkh6THVIKzBSUTArNFJrci9DU041SUgzVko5bG94QzR3VktudDhvR2FReXJzdzRLa2VqWnBKWWhnTkdFUHVUU1htVzVkVlpnRWhITEt3eDNKL3BUbE5zelo0Y2pzQmorVlZpOGlaK2NEUFBITk5YYklja25jTzQ0L2xWY3BoN1pKMlVVV2pIRTVJVlpTb0dSem45S2FGVWNGQ3c3YmxOQ3J0ejVhc1BvY1U4cEpKaFE3S3hHY2RLUmVqMXRxUHRYUkxoVkV2a2J6c0xiaXE0UHJ3ZUt0eUpjUVNsRVZteDFJY01wSGJrWkZVY09kcnU2Wk9BU0JnMEc0ZTJrWlR3eEdNZzQvV2s0M2VoY2Fuczk5RVduY0Z3Y051QjVCNU9hZTdDWE1xc1pXTDRCY0RQVEp6azV6K0hQclV1bjYxY0NPNGdtVzBuKzFFRHpMZ0FzalorOEc2aitWVEcwdUVZbWZUNHNTTGhDcktVTERyOHhQQk9DZXZjY0VFVmxxblovbWErMVVsZGZrVjF0cFo3VTNTVGVWdEdNQlNRdzc4ZzhZOThWVFNhOFNHV0dPN25FY25MeG94MnY5UUtVZVRCSjUzbUtoeGtLQnZJUG9jWTRQdFd4SDRqbGd2SkwyeWppamZMWk1DaEViT0J5akFncjZyanYxNlliNWw4S3VaU2FsOFQxOVREYVJmSVBueHppVUVCU2VRQmozNTlLdFdIaUNmU25ZMmFSNGRkckxOR3I5dXZJT1B3eFd0cVhqT2ZWSVkzK3c2VmJTeGdxNWloQytaa0RrajE0UDU5S2hmVmRQdkxXMm51dnNobmlCekhEYWhDY2RBY0tBMlR5ZWVsVGVVbzJxUStWN2twcFc1WjJJcDlVT3BLaHZVbEtKR3lyNVJ3RVBWUnlUa2RQUTBra0UwQytiYnczOGtVZTFuTXFsRUI3aHR2WTlPdGFIOXM2WkhHMzJleXRXQmN5RlpyRXFveUI4cXVyN2hnOUJuOGUxYW4vQ1k2ZGQ2ZTFyZnZjTEN4ajNRUkNWOXhIWC9XT2NkQU9EK0hGWXlsT051V0dodHpKcjNwSEd5b29RQjQ3VGRMaGhJc3pGazlqZzhmaU0xQWJ5U08zRVBtM1BsRTdtajM0VGQweU1lMks5Q3VOUThOYXhiaGJmVGJhRHlGQU0wbDNGQTdEdDhvWG4rZk5adXBTZUQ1QkM5aEs5dUV5Slkza0phUWRjOUN1ZTFFTVUzcEttL3ovd0F6UDJTZXZOWTVTM2VHV0tUekxobFpWQlVET1hPUU1jRHJ6blB0UThSUmp0YTRpVThraHljK25hdXN2dFc4UDNGemFqUjFXeUtCQTA4cUt1M0FHVytVWnpuUFRIU3NIVXByZTgxS1Iwdm5uZmVjM0Vqa2VaNzRKSjk2MXAxWExWeGE5VFRrVFN1MHpMZUJnQXhOeS9mTzNHUHhwcGh6d3F6cXVmNHVSVnlWSkRJekc5aWZIQVkveGZROWFaNWR5a083a3g5eW5OYktSbTZTN2YxOTVYOHFLSTdqY29Uajd2SnBZL3M4a3VKWmhESGduY2lFOGdIQXdQVTRINDAwamVkMGtnSi8yMU9menhTbU1Ea2dxT3dKQkg1VlhxWldlMFVDN05qT2s4aTQ2azlLZWwxR2pjeUdSczhNVXordFY1YmVUSms4d042OTZnODZkZmxWeUI3Y1lxdVZTSWRhVk42cTM5ZXBwK1pDeTVaMVZ1MjNqTktZa0hEVGI4L3c3ZHZINTFsaVI5dnpaSTljVXU1NUZ3cVlBN2hldjQwdlp0ZFMvcmllOFRSYUtGUUFGWFBYSk5RdEZ2Yjd5WUhyMC9TcTZwSW8rKzZuMEpxUmZ0T1BrVEovdkVZcGN0dXBYdFZMUnh0NkZJSWg2T2Z4b0dGUDNsUDRVeWl1aXg1UE41RG1Zc2M0L0toU1FjaFRTQWxmdXNmeXB4a2tJNUp4U0tUN2ppeXQwVEordk5BOG84RU1EU0xnSE8wbjhha0xxZW9VK3g3ZmxTTkkyZXJGVVJBNEJZL2pVbTVWR0gzQWVpc0JVT0lTUDRrUHR6VFFxQTVFdlB2eFN0Y3ZuYTJzUzc0VjVSWk0rNHBIa0QveE8vMUdLWVdZOGVia2ZXbFJRT3VDRDNORmtITzVhSUF3WHFYeitWT0xlWW95U0NPT2FlWWhHb0trblBjQ3BBMFVxZ1NiUVZHUHU0elNiNmx4Zy9oWlgyRUFFS1NlMlZKRktSSzJUa2ovQUhha2tXS1BqZHg3WnhUaEl1QnRMNUhwaWptRGtXelpDSVdKNGJjZnIwcHl3dmtOdk9mWElHS0pKVlU0Vk9mVXQxcUxlMk9EajJIRlBWa1AyY1gzTC84QVovbVc1bVJtSUIyc2V1RGpQUDYvbFVUMnNrUjJ5T0NCK3RWMG5ranp0bFlFam1ubStsWmd6SGN3eGdrQWo4cW5sa3VwZnRhTDNWbU5kWXdlVG1wN1crdWJKSkk0bitTUVlLRlF5c1BvZU0xQUpsSklZWUI3WUhGS0JIL0N4ejljMVRWMVptYXMzZUxzV3BOUVM0VlZOcGJ4T29BTElqQXRqdjE2L3BVbHZZeTNaVVF0Q1drSlVLMGlxekVZNDZqMTc5YWhqUUtRWEFaU0QxRzBqOUszdFB1N1N3bWphNXRJTHl6WUFObGtaa1lwZ2tkQ0NDZTQ2Z2VsWVRseXIzRWRjSU4vR3pLV3dtampqbGorenNya2pabFhkY2VxNXlLMEYwblZZQ2hUVFlwTTR3VlJYWmlUa0haem4wNmNpcDcrMmxUVjVUYWFkTXJNaGtoaU1jaW5HUHZMejI2K25GWXN1czZtendNODBtYmMvdXlSeXZ0bnFmeHFVNXoxVnZtWE4wNmF0cjhpNUxwL211ZjlJaWhUR0h5V3lHQXlRVjJnamtZNllCNzk2UzcwMDJSS2pXWWN3c0ZqTWMyUWM4NUdPUVBmRlBpOFg2ejlrRm9iMFBCa2tvNktTQWVxNVA4QUQ3ZEtybU8xa2NHT2FKblpja2xzRE9NbGNFVWtxa1g3MjMzL0FLQW5UcVI5M2N6MnMyY2tpWkhiUDN0L1grdEovWjF4ak8zQTljMXJRV0U5M0t4aWdMUkx5OG5aUi9lTEFkUHdxN2FlRzN2cExsTGU4Z0gyWlM3c2JuZUNBY2ZLQU10K0ZYTEVLTzdKK3F3ZTYvUTUyTFRwbUc0c2lLTzdOV3paYUphTEUwMTlxRnRHQXBLdy9ONWpjY1lHTURuSFUvVE5SMzFqYVd5UXRGZkpleXNOMG9qVXI1Zm9NbnYrRlVwSXJLUlZQbXlLU3hBM3VDUXZ2UTV1b3RIYjVBcVZPbHRIWHpaYXRCcHEzSUYxYzdJd0N4VVJGc2tkRnlEMzlhc3lhaERlNE0wNVZJNGdxUnBFa2FBamdFalBQQlBQWG1zRjFoQkhsU3NUL3RqaitkRnpMTE15R1FwZ0tGR3dBREFHT2NkNmZzazNlNUx4VW85RjhqYmMyb3VwSXZ0UTJSa2dQRXU0TVI2ZTFWSkpMWU9RUE9jOWczR2F4OEVmL1dxV05Ma3FSR3JsVDdWWHNrdXBQMXlVL3NsMDNzYXR0OGtLZ1BHNDVJRlArMVFPMzNVMmpwbGhWRVpCS3ZFV2IzT2FWb3B1b2dLcU8yS2ZKRXFPSXFyYjhpNmx6YmpKS1JqM3dLZWs4VDhiTWpzU01ZcWlrRWtyY1JTRWdaNDdZL0NtdGN2R0NtUHo2MUxwcm9Xc1c0cTgxK0JlZVhqaFFjZHNHb1h2dGo4eE1NZTlWRE9Xd2R4R1BlanpVN3V6SDNGVXFhNmtTeGNwZkM3ZmNOK3p0akovU28zVGFlMVBLU1orYkFwVjJMM0dmZXRMbkc0eDJ0WWpDTjE2Q25IR01xeEo5NmNTeE9ReXRUU3I1eXk4ZTlGeWVXMnhHV1BjODBvY2c1emo2VkwrNDZGV0o3a1VHREl5Z0xEMXAzUXVTVzZkeGhrM0VaSi9HbDJBbmpQMDYwb2drSEpYQTk2Y0hLOGVaOHZjWnBYN0ZLTCsyQ3BzNUM1STlhR09UazVadlRHQUtSblhKMnNRUDlrZjFwdVFlUVdZajFvRzJsb2hWd3h3N2NkdWFjeUZCOHJrajBvODdLNE1TZlhITkN2R3YzbzkzMG8xQktPMS93QXdCUWpETy84QVNnTEVPZk1QNERwVGpMRm5pSnZvVG1sVWlUTExCSHh5Ums1cGFsV2ozVCs4TWlRRE9NampjZTlNYU5kdVY1UHRWaFo0d2hCVERlamR2ODgwMzdRTTRVSXZ2bWxkbWpqVGExWlcyTUtYSkhCNUJxd3M1RFpISjloa1U5cDQ4QWhkcDlSMG81bjJJVktHNmtWbEFQRGZsam1wR2dhTTUyOEhrZDZtODJBc0N4TGM4a2pINjBzb1dPVm80cFJLcW5BSUhCOTgrbExtWm9xY0Y1anJZUnJOQzVBblF1TjBSQlBIMEJCL0kwLzdLelhiUTI4OFJHN0NkUVQ2Y0dxcFNKZVhtK1k4K3RLOG95V2FXYVJ6enVMWXhTdDJHbW83L21USjlyaTh5SFpNb3lOd1Fucm51UHJVejJkOU5iQzZXS1pvU2RwYklQUGYzSFh2VmpUdkZHcFdFQnRpRXVMZGtLZVRNcE9Cbk9Rd0lZYzg4SHJWYTYxYk1zVTluQzFtNEdTSVdZYld5Y1lKSko0eFVmdk9iWkRVNGN1clpUbHNybklCUmljY0FjMFc4RjB0eWpRcWZPVmdWd01uUGFyS2E3ZklwRE52WWdnT1dJWmM0emdnanNNWVBiTlNXdXE2cTAwTWRyTUlKRllHTm9nc2JaN2ZNTUg4elZ0MUxhcEVOVUhLOGIzSWx1TlE4eVpHdW5pTXYrc1h6Q2diMkk2VXR4REhid29HWXgzSDhTN3d5T09lY2c1SHBpdEdHTFVsczcrM2xtc1FWd1pGdXRobGJuK0FrWi9FVlgreUtrYWZNMXVIajNCWlVEQnNkU3JZNlpCL3hOWnFTdjhBNUdxcDMydjh6SWFWeSs0SUU5TnVhUXVDUUpVSDFIV3VpZzB5MWsrMHM5eElrS0xpUGVvRzlzWndSbmpPRGpBUGFsbnNkTlJoRkpDMExxcUFvR0VwSi9pYklPQjM0K2xQMjhiMnNEd2szOXI3em5mM1M4bU5tSGJKeFRQbEJ5clovd0JraXVpMU8zMGlDOFJiQnBaTFoxREIzQTNIMTQzSEZRejJTTHVaa0NNcCs2d0FJSkdSbnAvS21xeWFUc05ZTnkyYU1YelNEd3FyK0ZTb0o1MkVjWjNIc0ZOWFk3ZTRsWWd0dUFHY0ttU0JVVTBURTRWU0ZIcngvV3E1MHhld21sdS95Qmx1b3JVeUdmTWU3YmdIdi9YcFZNU09SajdRMk93R2FsTUlYNXcrY2RtcDJUTEdTSTlpanFRdWYxcG9pU2IwMkt6Qi93RGxvVyt0TUdEd2VucWFuTVVUY0ZpcDlTZUtVV3E0enZUQTdnNHFyb3hkS2JlaFZ3TTlUaWx3cCs2Q2F1QzNCT0ZqRGY3Uk5OTm9vRzR5WUhvT0tPZEI5V25hOWlQQmM0eXluNlVHME9NaHMvVTA3TDQrOHcrb3hTL0p0M081ejdVcnRiR3ZKQ1h4RVJnTVorWmdQcFNqZUR3VGoxWVU4U29RZGlFbjNwSGtUbzBmNU5SZDlTT1dFVmRQOHhQTUlPRHo5QlM3M1VaWGdlM05OM2pHQTUyK2hGSUhVRTQ2ZS9lbllubnQxSC9hSkNlZ0o2WklGTkpMY2VVQzFJWlFEOHVRT3dGTjVjNHlCL3ZIRk8xdWduTnZTOXhRb0IrY0tQWTBtZHYzU3VmWVV2bGdkV1hQNDA0T3B3Q1N3OXVLTGsydHBzTUpJQUpPNzgrS0JJdzQ1NDdacVVlVWNnRWo4Y0NnQkFwUmczYkJWcUxqNUgwWWZhTnlCZGc0OU9LYVdCYkxLZjVZcXhDa1dXVndRQ3A1eC84QVdwME5vWlhZUnFaTm9KSVVFNEhyeFVYU051U3BMZGtHK0ZvOXBEYjg5ZDNHUHBTS2tZeDc5QVIxcDVWUWNaK21CaWxFWCsxa2VtS2R4S0Q3QTBVU0VqNWczWGJuRlJueVZKNmoyeldncnhveTNGdTZRdkdWUGx0ODRPTy9USFVkRDY5NmV5V08xL3REcVdaOEpMRWZsSHJsY2JzY2pGUnpHcnAzV2xrVTRibG9ZSkl4QWtrVDQ1WVpLbjJQYW9mTko2SFlQcG1ya0gyUVhNVzZHVzRoSjVXT1RabjJ5UWNVbDliVGFkZVNXOHNDUXlSbkRLemc3VCtGTlNWN1dFNHl0dm9VdjN1MGdwbGZYYnorZElBZ2IvVzQ5ZUswN1kyRnpCS0xxN2t0cDF3WTJWTjBiRE9DQ001SHJ4bjZWSGRXOXVrRVBsM3NFclBuSUNrQmNFZ2Z5eitOTlQxc3pQMmFlcWR5aHVjRXRHR3gzT0tzMlNpNG5WSkpWaVJ1TXZ3TTlxaXpQRU5wa1pGYmtCZWhwcVN4eHlxelJyTUFja05rWjl1RFZQVmFFcDhqdXpidDlBdU5RTVAyT0dRR1hBVU91UVNUajd5ajJQVURwM3FPL3dERGVxMksrYTFtN0lDUXJ4Y2drSEJ4N0E4WjlhcERVNUlYWTZmTFBiN3VOcXlFYlI2QTU1SFBlbGkxdlVMZmFzTXpSbFczSEROOHh6bmtFNDdDc2VXc25kTldOblVwTldhKzRyVFdsNUUvNzZLUkpQUnhodnk2MXAyV2g2akpaU2FqRlBiUmlBYnNTWENxNTY5Rkp5VHgycGwzNGsxbTd2bnZaWjM4MXdBV0M0R0IwL2xXUTBzaDZzZWF1MVNVZGJMOFRCeXBSZlZsM3o1STl6L2FKV216a2c4aHU1eVQrRlhZdkVkK3M3em03SWxkY1NNVkh6ZTNUdU9QL3JWaUZ5d0FZOERwVGNkNnAwb3krSkMrc3ppL2NOWCsxb283eGJpQzFWU0RsZ3hQeitvT01ZQjZjWTRxaTl3WFlrbGptb2dGN21nRHVPUitWTlFpdGhPclVsdXk1QmZ6VzZ1TGVXV011TnJGVGdrZlhyVUF1N2hUZ1NIcjNGSjhpcXJJK0hPY2pIQUgxL09sRXBPRmxJSStsS3k3RmM4bjlxdzVyMldUQWZISEE0SEZJWjFKKzd6NjVxUXJBM0JiT2VuRkliTWM0Y1pwWGlqUndyUFozSVRMazhxTStvcE1GKy9IcmlyQzIySUhrT3pJSUFYT0NjNTZmbCtvcU5vdmw1U1FmbFZYWFF6ZE9mMmgwYzBNVERjWGJBeG5qaW0rYXJ0bkJQcGdWR3FCeVZTTmlRQ1NmUVUxdHFrRkdPYU9WQzlySkx5RTNlMmZxYUMyNytFQSsxUmpyVDA2aXEyTWsyOUJ3WlNPalp4MXpRTWprYy9obWgraCt0TlFrUHdUUU5MVklrRVJjOG5uMHhSNUp4emtlaDlhVm1iSzhuODZuakp6MU5RNU02STBZc3JZVkRoeHo3R3BoTEdvenQrblUxZmtSU1YrVWRQU3F6ZjZ0dm9hU2x6R25zblR2Wi9nUmxoMU1RWlQzSEZSdEZGbjVXSTlRYVgrTmFleXJrL0tPbnBUMk1tMDkwUW1OU2ZsVmhUK0FDb2JCUGVuU0tCakFIU2trQVZVSUFCejJwM3VKcFJJaXpJTVpPRDcwNUpkaHpodDQ2RUdoaVNqQWs0d0RVU2s3YzU1OWFlNUVyeGVoYUZ6S1JqT1I2R21sMmRqdWxWYzBJVGtuUEpISnAxenpjci9BTGkveXFiSzVyS1V1VzdaRnMydGtTQWdlbFhvb3pleEpGQ3F5dkdDQW0wQmprOXNjdDEvQ29aQUJERXc2N2V2NDB5WWtHTWc0T1J6U2QyQ2lvNmtMckt1UVZZQWUyS2RKTk5jcW9sbDNiT203citkU1B4S0tobkFEakZVbmN6cVI1T3R5V0RPeVJVdVZUSzhxUWZtNUhIVDhmd3AwS1dzYXlmYTQ1aVdUOTIwY2dHR3oxUEJ5T3ZIRlZEMXBLcmxNbk5Mb1dOcklIUkRHd2JxZUNldmFvaWhWdW96N1UwZHEyVitiUVpOM095VDVjOXVPMVRKOHBjSXFhN1dNamZnY0tBM3JWbTNqdkx5VVF3UXZQSWY0RVRjMU5WVnlEZ1p4NlZiMHRWWnBpeWdrUk9Sa2REdFBORW5aRjA0dHRLNUJOYlhWdGdYRWR4RUNNZ01oR2Z6cUZiYWFRNFNGK21TY1ZaMUM5dTd0WVd1YnFhWXFnQ21XUXRnWlBITmJUU3lXbmd5d3VMWjJobWtubGplU003V1pjRDVTUnlSN1ZoN1pxQ2xiYzJWRlNiVGV4emd0cE40akFCWmpnQ2tNV3ppU053M2JGSXp1Y0VzeFBybXVuOFB1OXpQR2JobWx6dko4dzd2NGZlcnFWSEhVS2RDTTIwdExITXJCSklEc2hKQTV6aXBFV1l4c1JBKzFNYm1DNUFyZDAzNXJxS051VVp4dVU5RHdlb3FLQUFXa2hBQUpZZys0eFVPdDVHNndpakt5WlFqczd2VUpZTGUyZ2tkNVRoRldQbGorSFhwVndlRzNYVFpiMmVkRjh0aWhqNTNaR0IvVVV5M2QvTWtUYzIwTHVBenhuam42MWJEdGNYTVhuc1pjV3pnYnp1d0JHY2RmU3BsVWx6S0swS2RDQ1RsTFV4MnNwb1pmTFZNdjNVaXBieFo0YmlTR2VPTGRHZkxQbERJQkI3WTRQMXJQUmlHWEJJNXE5RXpHVmNrbjVoM3JXVGFlcGxTakdTMDBHRXJzRzR5cUQwd01VMEpIbkxsampwazBTdXhkc3NUakFITlZaeGgrS2NWY1ZhWEpxMWN0SzZ1V1ZNaklJd2g3ZTlRR09QUHk4ajZITlJQd0JqMHBxOWF2bHNjMHF2TTdOSC8yUT09XCIsIFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvL2dBK1ExSkZRVlJQVWpvZ1oyUXRhbkJsWnlCMk1TNHdJQ2gxYzJsdVp5QkpTa2NnU2xCRlJ5QjJOaklwTENCa1pXWmhkV3gwSUhGMVlXeHBkSGtLLzlzQVF3QUlCZ1lIQmdVSUJ3Y0hDUWtJQ2d3VURRd0xDd3daRWhNUEZCMGFIeDRkR2h3Y0lDUXVKeUFpTENNY0hDZzNLU3d3TVRRME5COG5PVDA0TWp3dU16UXkvOXNBUXdFSkNRa01Dd3dZRFEwWU1pRWNJVEl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeS84QUFFUWdCbWdGQUF3RWlBQUlSQVFNUkFmL0VBQjhBQUFFRkFRRUJBUUVCQUFBQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVFBQUlCQXdNQ0JBTUZCUVFFQUFBQmZRRUNBd0FFRVFVU0lURkJCaE5SWVFjaWNSUXlnWkdoQ0NOQ3NjRVZVdEh3SkROaWNvSUpDaFlYR0JrYUpTWW5LQ2txTkRVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmc0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaDR1UGs1ZWJuNk9ucThmTHo5UFgyOS9qNSt2L0VBQjhCQUFNQkFRRUJBUUVCQVFFQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVJBQUlCQWdRRUF3UUhCUVFFQUFFQ2R3QUJBZ01SQkFVaE1RWVNRVkVIWVhFVElqS0JDQlJDa2FHeHdRa2pNMUx3RldKeTBRb1dKRFRoSmZFWEdCa2FKaWNvS1NvMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvS0RoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1TGo1T1htNStqcDZ2THo5UFgyOS9qNSt2L2FBQXdEQVFBQ0VRTVJBRDhBODdqNXFZQVZCR2VLblN0TG1aTWk1RldvbzhuTlZVSnJRdDhBYzBOZ1NiVDBGTGpGU0FacVJZODFJeUVBa1lxUFljMWY4bkF6aW8zVVlvR1Z3eFhnVTRTRUhyU0ZmYWdLZXRBRWdPVFN2a2ppazJHbkFIUFNnWkFGTk9rWDVNQ3BpdlBTbmxBVXBBWnBqN21reGlyYnhaNlUzeWVLcTRpdUNUeFNoZWFzSkR4UytXQjBGQWlORUJQTlAyK2xPRWZ0VDBUYUtZRmZ5OGMwaGpCNEZXV1VtbWlPZ0N2NVZMNVdlMVdoSG1sMkFVd0tvaUJvTUhGV1JnVXU0WUl4UUlxTEh0T2FuVndvNW9ZMUNUbnBUQXNHNHp3RFZhVjJZMFl4VEhQYW1Ja1c4ZUpOcUFEUFUxQXJDU1RNaE9CVFc1cHRNUmN1TG5NWWppNFh2VlBISE5CYnQyb0pvQWpJRk54VDhVVUFSTXRRc01WWkl6VWJyUUJXWVpxSWlyQldvaUtBSTBQRldFNXF2SHpWbEt6TEo0eHlLMEkxK1VWU2k2MWRROFVtTXR3SnVOWFVoK1lZR2FveFBqdlYrM25BSXpVM0N4TThZVmVhcE91U1FCVTl4TVdiQTZVd0gyb0hZcXNoQjVGS3FIMHF4c0wxSXNKeFFCQmpqcFM3T00xY1MxWTQ0cVg3TVFPUnhTdU15ekdUVTZSL3V6eFZ3V3BidGdWYWpzOEthTGhZd3pHZWFCRVNPbGF4dFF1ZUtpYTNJcDNGWW9GTnFWQ1FjMXB6UVlRRHZWWXhjOGluY0xGWWNVL0hGV1BJRlBXMkpPQUtMaFlwWU5MdEo3Vm9pekhjVU5iaGFMaXNVQWpIdFMrUXhxMXQybWd1QUtkd3NVekh0cUpoaXJVcmlxcnRtbWhXSW02NHFQR0tlMU5KcWhXR2s4VkVha05KaWdDRTgwM0ZURmFiZ1V4V0lzR2pHYW0yMG15bUloSTk2S2xLNHB1M0ZBRVpGTVlacWZIdFRTdEFGVmxxSmxxMlZ6VVRwUU1vUjVxMUhWYVB0VnFNWnJJc3NSOXF1Um5zYXFJQ0tzeEE1cE1FVzBYbXAxNE5ReDVKRmFVRm9aQUtrWlhEa25CcC9KYkZXbXNIVS9kNHBVZ09jRVVyakd4SmpGV2tRRG4xb1czWWRxdHdXMlI4d29HRUtGamhSVS9ra0hrR3Irbld5bVRCRmJGenB5dEZsVnJOenM3RDBPYldKUjJxVkl3YzhWYkZ2MUJIU2xTM3dhMEVaanc1enhVSmd5ZWxhNWc1Tk1GdjgzU2dESWx0KzJLZ050am5GYlR3WmJwVVRXL3RSY1JscmJybmtWT0kxVWNDclJoSUhTbStWN1VBVW5IY1ZXZk9EV2s2ZTFRTkdDT2xPNEdidFltbVA4bzVxNjRWQlZHVnNrODB4RldSdWFyc2VhbWJHVFVUQVZTRXhocHBweHBwNlZRaGhIUFdrcDFPVmMweERNVWJhbDJZcE1jVXdJOFlvcCtNOFViYUJFUlhKcE52dFZqWlNiS0FzUWxlS1lWelZqYmlqWjdVd3NWR1NvMkhGVzJRaW9IWGcwQVpLQ3JjUXpUSTRTZTFhTnRhRTRKRlkzTkFpUWJja1ZiaWhMZEJVeVdqTVFNWXJSdHJWb2lNZ2MxTFlXS1N4bFdBMjF1NmVvTVlCR0tjRXQxd1NCa1ZETE5oL3dCeitsUzJNMmx0dDZkTTFCSnA1TFpBcUd6dm5qQURtdG0ydUZtcERLTVZveDRJeFZsTGNBZ1ZxTEdyZE1acDRzdDU0cFhIWXB4S0VrVXJYVFd5ZWJBb0E2am1zeGRPYk9lSzNkTlZJazJ1UU1kNnpxWGF0SGMxcHRSZDJaVjVwbmx0dkM0QjYxVVd6NTZWMUdveXhDQUFBSE5VVmg0NlZTak9FVnprT2NadTZNRjdYREhpbzF0dVR4Vys5c0dKNHFJMllWVFQ1Z2NUQ2ExNzRxRnJmMnJhTUJCNlV4NE9PbE81TmpDYUQycUpvYTJKSU1kcXJ2QjYwN2hZeHBJYzFYa2l4V3pKQ0FEeFdkT25YclR1SXlaWThnMW55UTRKclpsUWdjaXMrYnZUVEV6TWtHMG5pcTdWY21HYXFzbnJWWEVRbnJTWXA3RUxVUmMxVnhXSGNDa1FGN21OY2tBWllqMTR4L1VWRTdFRElQUWo4YW1nWlB0Z1BYRVJJUFlBa2Y0VTdpTEpTankvYXA0b21ZN3lDRnh3Q09UNzFKNVdhcTRpbUlzOUJUeEJ4a2lyWWl4amluR0VtaTRGSXhqMHBCRms5SzBFdGpuMHAva3F2dlJjQ2dJQmprVXg0d280cTg2KzJLcVM4RHJRQlRreFZKeU9hdHk1TlZaQjFwZ1hyQzJpZkFJNU5ia09taE1ISEZZVnRLWXdPMWJsanFZQTJ1YzF6czBSZmhnanpnOFZPYmRUd296UkVFbklLbXJhMnJnWkREOEtrb3pKTE5lcEpGSWxtYzVXdHBiZFFvOHdacTFEQW1NWUZLNFdNRDdEbmxzMWF0WVdqUHlrMXVHelZ4akFvU3lFWjdVWEN3NjBaamdFZmpXckVGNjk2b0ErV01LUHhxMUJucm1wWXpSalhJcWJadVVqcFVNSjRxNGdGVGRwM1JTMUs2MnpGaHVKSUZXd21CaWw3WnB5bXFxMXBWTFhIR0tqc1JsQjZVeGs0cXd5NUZSdUNLeVJUS3hqSHBVVHhyaXJMQ29XVW1yUkJueXA2Q3FzaUR1SzFtaDRxdEphRnFkeFdNYVZRYXBTeEw2VjBCc0Y3NXBqV01JSDNhcm1GWTVPV0hPUnROVXBMR1J6OXc0K2xkak5GRkdEaFZGWnN6a2ZkRlVwQ3NjdSttdmpoU0Q3MVNuMDJibkkvV3Vta0xOeFZaNG1QYW5jVmprNUxGMUo0TlZudDNYcXBycTVMVGQwcWpkMmp4eGw4Z3FPV0JIVWUxTzRySEszQ3FkdVhJS3NPbjE2R2kyaVlYMHNxS3haQ293elpCenV6OUR4K3RiQWh0cFVuaWJsbWsvZDdSblBRWVBvY2cxVHNTWDFTNVJrS0FTaDJ5TnZ5Z0UvcmtVN2hZM2JXMkVjWVJpR2tBK1pzNUorcHFjUkFkcVMzVVJCNU1MR3hVREJIOFJQQS9EK3RiUXNXY2JsVGoxcXVZVmpIRU9lVFQvTHgwR1RXc2xoSTNDeE14OWhVamFYY0RIN3JiOWFPWkJZeHRwR01oYVpLeUw2RStnclZsMHlSRkpZcVB4cWxKRkZEeXk3bSt2RkNrS3hseXM3ZzdWd0twU28zVTFvM0Z3VzlBUFFkS3pwcENSVm9rcFNrRHJWT1JzOUt0U2lxemcwd0ZnRHl0Z0UxYUNUUW5rSDhxejdPNGRDQ08xZFZCSzBsbXNzd1NWUFFkUldEWm9rUmFmZk9qQVBtdW10NzBNZzVybHpkV3IvQUhZU2g3WU5QaXVXQjlQeHFSbllMT0g3MHB1Q0JnR3VjaHVwdjRRVFduYWxwQ053cERObTN2Sk1ZQXpXbEFrazMzbHFsWm9BUndLM3JmR01BVk1uWXBJU0d6NEc2cmFXaURvS2V0VExXVGt5MUVSWUFLbENCYVZUVWdYTks0V0dnQ25CTTlxZUVwNFdnQm0zaW8zWG1yV3ppbzJqT2FhRmU1VVphWVZ4VnBreFVETHpUdUJDUlRTdFNIaW8yTkFFVHJ4VktmNjFibGZBNjFtM0VoN1ZTRXlyTmoxcWxKdEZTeXM1TlU1Rlk1eWF0RXNpa2RlY1ZBN2luT3Z2VUxZempJSDFxaEVUeTdSV1ZmM0xOdGlRamZKa0JUMFlZNXorRlhMbVpFQk9SZ2RXN1Z6ZC9PNWFmYXdDakJYY1R3M1hnanBuT0tBTG1qTkpjeE10d0FGVnNLSGJrazg1K3ZQK2NWanhhSjUvaUsvMU9WM2UzdDUxaWpBeUR1T09Qb04zNDFhdEpSYVRSbVBjVW5HTjU2NU9XQVA0bHZ6OXFwd3pTUDVzYlNFSzk2NWw1K1hhdnk4L1hBSC9BT3FtSTYrektPa0VoUUJubWFabmtiR0ZHY1orbnlpdDIzblI1V1F5TXhUa2tMa2ZTdVl0U3JlYlBMNWhmTzBBbmI3QWZ6SjlPTS9kcllnWTJzUWhNNDNaeXdCeGttZ0RvMjFGTGVES241dXc0ckd1TlJubGJKYzFBQ1hQUW4zcHJBQWtVMUZBMk5ubmxrSHpTRTFRbDVCenpWeG8yZm9PUFdxaysxT0NRVDdHclJMTTJYdnhWT1hOWDVuSGFxTXBKNlZhSUtrbWFyT0NlOVczUWs5YVlJQ3h3S0FNdUdSVlhtcmNjeHh3NUFySmo5NnVSS1RXVExMcVNNVGpOWG9DeHdTYzFueFI0UEpyVHRnQjFOU3lqVnRKRzQ0elczYXlIajVheXJRb0FEeG10cTJKT09CVWpOYTBrNUhGZEJiQU1vckRzd3VSeFc1YmdCUnpXY2k0bDVVOTZsVmFoak9LblUxa1dQVmFtVmFZcEZUTFFBNVZxVUxpbXJVbFVqSnNLYXc0cDFJZWxOaUlIV3E3clZwcWdjVkpvaXF3cU5oVTdpb21GTzR5czhZUGFxc2xzRzdWZklxS1RBSE5OTUxHWExZNTdWVGt0Rlg3NnNmb2EyaTY5emdVMHBISU54Kzc2bnBWY3dySE9YUVVydGpoVkI2OVRXVEpibDJ3QXgvQ3VzbE5pdVNXRGZTczJXN2pEZktOaWR3dlUxU1pOakVPaFBJbTVsWEI5ZjhBQ3M0K0hZYk84bUV4VWp5bzVGUmozSlpjQUg2TCtkZEs5eGNYUkl0Z3luR0ZJR1NUWE9UcGNOZVdkM0pJUzZUdGJ5d0VndG4vQUd1MzNrYkgwcDNGWW9YR21iVk5qYVF4M0VMN3BIaUhCUWpCd0c0N2tFZE9uV3Nud3RZSlBCQktscmNTVFQzVXNoZVdRQkNBVzI4Wkp6bnZqcm5tdWowdUs2SzI3eUs2Z1dwYmJ1QTR5ZWNEdWR2NjQrdVo0WHVEWjZCWnlxNkIyaGxZTWY0UzB1MVI3bjVXTk80ckhTcG9yaVZHbFZIbFhxUzNFYTRQQVVmVE9UNkg2Vk5IYlc5aGV5SmNHSnNIYUFveHp0VThaeWY0dnB6V1hGcUQyNk1ESEpGRkdtTUJ1V0p3QjlTY0RqNlZKcGJ4V1lOMjZvWm1jS0EvUGZuSG9BU1FQWUNscVBRc2F2ZGlHeG1uc1kzbmtEQlk0UUNOM1RPRDM3bjhLZGJRUnkya2Nsd2p4enVnWXhCd1NwOUtTUzRsbTFGaUpZUnNUSlVnc1ZadXY1REhKL3ZkS2xhMW1UNXNEY1Q5N0pQNmNmeXFrMlN5dlBabmJ1QktyNkVrMW55UWtkY0FlcDRyYkVONDBaTHUrT3dDNHJOdUliaFdPK052THo4eHp6K2RXbVMwVTVyUkNuQWsrdmxrQ29CcG9ZY0NUUHV0YjhWL2F4TGkzc2Q4d0hMeW5wK2RWWnRXdTdtUXJCQ3BLOWRxOFVjekN5TVgrd3JxUnZsQUMrcHF5bmh4b2tMdktXT09nNEZXVnY4QVVTeDgxRUFIdUtrbDFKbWdLc1FTUjBWc1VPVEdram03andaZVdrYXNwV2R6MVNNNUlxby9oN1ZvSXhJMWpNRlBUQzVyMjZPd2l0NUM4Y0VaZGp5Y1Zia2phYUhhQ29idDZDdWYyeHA3TThIL0FMSzFLTjFWN09ZT3d5RjJuT1BwVjlOTTFHR01QTmFTb3A3bGE3L3hGbzExRENibTJ2SlZjREpXTWZlcmtGbjFtY2lON3Q0UTV3cVRTREorZ3ExSzVMVmhiTkdHTThIME5idHJ1eUtxV3ZoalZnd2N4dEpuK0phM0xUUWRTOHdCNGlpLzNpUlM1a096SnJmZnhXeGJGc2RhU0hRM1FmUFB6L3NpcnNlbUxIak1qR3MzTkZLTEpZbTZacTR2YmtWRWtjYUtFemo2Vk9zYXFCMU5aTm1pUklPRFVxbW93dmI5YWxDajFvVEV5UUduaGhVUVduZ2NkYXBNelkvclNNZWNVd0VpbGJzYWZOY1ZoclZBeTVxWW1veWFWelJGZGtOUmxhblkxR3hCb3VNaGJpb0hJOUttYyt0TlVaUFNuY0NydFJ6Z3F3SDBxcmR3bVFDTkQ4ZzdDcjd4ekYrQ1FLQXJCZm5ZMCtZVmpCRnNpdGtMeVA3MVEzS0lEL3ExT1BhdCs0akRLQXFaUHJWT1pUR2hHRko5NnBTdVRZeFpkVVo3S2ExbGdWRVFaS3FNYm9zODQvRElQLzF4V1pCYjJkMWI3WjQxaVZwR21pbCs4VWZ6RzJrazg1TERQYklVRG5KclVudDRydWJ5WmNraGNuWVNNQThkdlhuanZpb05OaWlzUERrcXhKdWFMemxabjVMTXJNQ1RuMXhUYVFITzJ0MUh2a1NOU0x1MXMwUzVQSnc4WmNIOCtEbjBybnZDczhSMEdPZVZva2l0MXdyU2Q1TUhBSHVOem4vZ1FycGZFZWxycDhGeGVXcU9xL1ozVnZKTzBnNHh6NmpnSG5Jem4rOWtjNzRmaWd0dkNjRjRFaTg2TkhLeTNNdWRoeTNFYVo0ejY4ZmpWb2htcFoyUjFIeXR6QzJaZ0hVRURLQThsM0k3QUVnQSt2T004YW1vbXhzTGFLRzJ1SVpaV1lFUm9jSGFNOGdIcjB4M0pwTGUwVFRiTXNYVXNzTFNTZy9PMkFCZ2tlcDlQL3Jtc3c2ZlplTDdnVFdxeXhCRTJyTHR5K1FlTTQ0K3ZweHp6UXhvMGJUeklrOHBWTHlBN24ybnF4OVQ2RG9QcFU2d3psaTA4cUtPeTdpY2YvWHJaMDNUekRDbHJFd1prUUF0dHhuSEdmMHJSajBXUGw1L205aFQ1MGhjclp6Y2JzR0MvYW1JL3VxcE9hMkxTM3VKaHQyT3VlN0d0bExLQ0pSc2pWQVBibjg2aG52cmExak9HeVBhb2M3N0ZLTnR5bSttMjhJSmxVU09ldVFLeTUvc2FBeUpFaURwbjd2OHFiZWE4ek1Ra2YweWMxajNWelBjZmY2ZWdxb3A5U1cxMEtPcVRSU2JoRXpFbnN2QXJFTVVxZ2tIYjc1cmFlTWs5T2FoYTIzZFJXeUlQU2JUV29ydEZrQ1NRc2Y0WEdLMDF1NGtVRjVWNTVyeEhUdkVsOHEvTmh2VE5hRGVJZFRsSTNGQXZwaXVWMHpWVFBYMnVyYVZTQ1VkVDF6V1ZjNkRwTTB2MmlLM2pXWE9jcmdjL1d1R3N0UXZKRG1TWUt2OTFhMDR0UWszWVdSajlEUzViYk1mTmM3bXdNc2NXeVFwZ2NBSWFzbWJxRnlUNlZ5TnBkM0c0RXMySzNZTHdNQmxHSHZpcGxFcFNMalhOd0hWUkYxNjQ3VmJFb1ZmM2pBZlUxQXNvS2c5NmdtS1MvNnlNa0NvdGNkeTU1OFIrNzgzMHF6RS93QXZURmMzTmZ5VzdBUXBnZTNOU1E2amNTOFNOdHF1UVhNZEx2RktKUjYxbXd5aHhuZm1udGNDTTgwa2h0bXFyZ2lsM0RGWmtkME81cXl0eWg5YUxFNkZuenNjQ2xXVGNLZ0JWdVFjMG9iSFNsY2ZLaVJ1bFJrZzBiczllbE1RODRJNG91VWtEZWdwbXdIblA1Vkt3QnFJb283bWxjZGhwakI5NlF4akhISDBvSytqbk5ST0pBT0dvQWMyZHZwOWFna1pWQitZZmhWV1c5OHRtU1JXYjNXczgzTXJ0ajV5dWVCaXJVU1hJMWxsVXFNSG4wRlU3aUIzSi9pOWhWWjVKVGdjajI2VTB5VGo1VllqUFhGVWxZVnlyYzRzWlV1dGpNQmlPUlFNa2drWVA0RW44ejN4V0M5L0JQcXQ3WndTQ1FOODY3RGtLcjdRM1RweWpIOFI2MTB0emFJYlZ6Tks2cmdFc3E4cWZVZlRyWFBHZGJ0RnZMWkdudkxObVNRUkhJbFUvZUg0Z0JoN2dlOVVpV1Y5V3ZpMmo2c3dBY0ZXaWpWaDNJMjUvd0Mrcy9sV0JhYWZhYXI4UDlPV1czYVNTRkpHUUs1QVg1bUdXOXM0NDkvcld6cVY3WjNPa3lSTEh1M0xMTUpCd2ZMQ3UrZmJEQUQ2MVQwSzlYVGZCbmg5cHBVaXRYYVdhWnNFNFZKTnd5QjF5eWhmeHFtN0lTUnFUeW0zdWxqdFJ1dVpNMjhLS2hiYWVyT1FPb0FCL0lldGErbFc4Vm5ieFcwWG1yYkpFR0pNYkRjekhrbk9DeEpIWGdjOTZ4ZkRIOXFTeXphNXFzRGJIWFphS29HUWpOdU9SMkxFajNQcGcxMk5yRUZjelhKQ3pNZDhnUnR3US8zY25nZmg3blBOWXltMjdGcEpFc0Jqand5MjBpNUdXWi92SDh1UDVWSGM2ajVhWlB5K2dJNXAxNXFVYVJrS2p0NkVjRDYxek56T3pzVzV4NzFwQ045eVpTTFZ6clVvemc1K3RaYytvenpjTVJqNlVycWpxQ3JFbnZrVkY1WXp0QTNFOUFLMlNTSXVRbDBQSnFPU2FQSEhKcTU5Z3VKUnhBd0h1S3VXL2h0MythVjFRZm1hRzBoV1pnTXhJNFdvSForZmxyc0k5QXR0ekJwV3dQU25UYVRZeHgvdTFZdjduTkh0RVBrWjVyWmVGN21Wc1NYU1JZNjdqL2hYV1czZzFJclFzbHdacENPckFBZmdPdFVSZVE2Z3dLaVJmUUlNVlhXOTFSYmhrRXhTTUhqTlpjMXgyTit5OE8rV2ZuZkgxclRHbDIwUEt5Qmo3TGl1ZHR0V2NTYlpKQ1Q2MXJ4M1Fma2swRE5LTlFnK1hHS2VKWk4zR1RWYUtWZHcrVW44YTBWbkcwYkFFUHFLVEdLdDNPckRkR0FQcFV5M21UaHVSVEZrOHc1WXFTTzVxWVFvd3pnWnFkQmpqR2pmTU1ZOXpWZWVNQmc2R3JIMmRlaEovT3BWaVFKZ1VYc0ZpZ1pyaEZCVEJBOUtUN1ZLNEpaV3pSY1FNa201WFpSN1ZQcDg2c3JLOG01czhFMVY5Q2JGYUs5a0RqSU9LMkxhVXlMelZXWllZeHVmSEZPVFVMWkFNSDhCU2J1dEJwV05lTWdEclVna3djWXJKVFZZaXdDcTNOUE9wQVB0d1Q3NHJOeFpkMGE2dGtkcVJuSXJQanZzdGdxZWZhcG1sTFl4eFUyQzVNek1lakNveVpEM0ZNQVlubkZSVE0wYWtoL3pGQlJZNDlhTW5IQnFwQkpLNjViQUhxZTlTTktGR1MyQjZtZ0JrOEhtOVFLcVR5eDJDWmFFNDlRS3NQZXdxNFhmdTNkd1J4VlM1MWkwaU8wRHpUN2MxU3VTN0NRMzhOMm1Zd1I5UlU4WWpEYjlwSkhvS3AyK294M1J4RGJxaDc1QXE5SFBHM3k4aGgxNHBzRUpkT2pSN1pmbFQwTlpzMm5wSkg1MWxNSWJqSHlObmhzSG93N2ovRTlLdlhDUnN2bU5oeU9nTllkcHFVa3QrNlRRdVVVN1ZDTGhTZTVKOXVuNTAxc0puRCtMUHRWci9hVjdIYlJ4RTI4c004UmsyaGZNQ2d1cEhVNVhsZStjNDZrNXZobUJkUnN0TXVkVU1Sc2JSU3NGcWlITXB5UHZiUVN4SkhUR0JqMU5kSjQ0MUN4YlQ5Zmd3alRlVERzd2VnTGMvWG1wZkNOcERCb2VtVzBKYU9XNWdFenlJQUJqc0R4bnZucjFGTzc1UlcxT2hsZlVOVHVZWHViZG9JVmt4RkNyNE9kcEpZNDlzakhiM3p4cEtrTnNBTmdMSjB6enQraE5aVVYyODJyVElKZG4yWTVlVjJ6dUpVRGo4QWUxYUZuZHhUaHdHVjBEN1JrNUpJN2srL0g0WXFWNWpZUGNHVGNFSUNucnVHVFZXN2h0cGtHTTU3MWZrdEltT1pHQ0o2Q29tRm5BdkIzZW5QU3RFK3hMUmxEVFlqakxFRDBGQzZkRWttNEVrZlhGVzVMbU1BbE1BZS9XcUU5M2c1QnE3c25RME55S3VCeCtOSDJqeTFPR3JDazFEYjFhcVUycG4xb3NGemVsdlF2SmVxVStyQkZPR0FybnA5Ulkvd0FWWnM5NnpaNXBxSXVZNjJCSVVoQUFCVWNZb2UxamROd2dWdnFhdUhUcEhMTXJxVjdLcDVwV2hhTXJHME15N3VqWTRyTXM1eDdtMlFIYkVjZzlOdFJ5YWxOQ1FYVmxqYm9WR2NWcFNlSHI3KzBIdUh1QTF1ZWRnVDV2cGl0ZUxUMU1RVUtPZXpDa0JoMlYrN3ZnT3hVL3hIdFY1N2k0aFlGcE55bnVLbzZqWTNObGRoeERtRWtENVFjMVpNMmJVdkRwOXpPVjlzQ21JdVFYdTQ5eWEwWWIvQUFMWXJEdG5qbnRFbGxranR5L1NOZVNQclU5MXB5eHdMTEhjdnVib3JjNW9HZEhIZG93L3dCWUtKTDZLSWNNV1A4QXMxeUl0cnZ5akl6bFUvV3JXbkpieVFrM0c5R3o4cnNlRFNzRnpWbTFlUmlWV0U3VC9lT0twUzZrWXdPaW4wV29MaUNWaVV0NUk1SEI1RzRjVmgzdW5hcExNemhTRlgxcTBTem9EcWhjZk94UDFOTU9wb1ByN1Z4TWw3UERJVWtZNUhGVlp0VGxVNUVocWtpYm5va1dzTXJnQWlyMzlxS0grWnlUWGxzT3F1WkZKYzlmV3I5N3JEaGtJWWdZb2NScG5yK242aEZjcXE3bERmenJVOHhOdWR3NHJ4clRQRWhqSVYyNmQ4MXVKNGhNekJWa0xaUFROWk9uZGxxWjZLTHFGdU1raWxNU01jaHVUMEdhNDZQVWJpS01rTHhWN1RkV0V4ekl4SkhRWnFYVGEySzV1NXRUVFhNVGlOSUM1Sis4QnhUTHVQelFpeUxJSFBQN3NaRkk5OUtzVzlJOTQ3MUZGcXNjN2JDRzNIc0ttekhkRmFmVEozWGJINUNwanZuZCtkVmwwU1JWekpPcUQwNjVxM05mU1JUQUNPVURvQU9jMUtJcGQ1bGRteC9jeC9qVHUwRmtWRGF5d0tQc3lxVzd1UmlyRnM4NFhOeEtNK2dxRzZudVZVbFZPQjJ4WE42bHJqMndPNUdVajBxclhKMk9udXIxWWlxS3dMdGtqSjdEcWF3YlB4SGFXMEVoa0taOHlWaVJ6d1hZZy9pQ0s0cS84V3ZLeEFCSHlNbVIxd2NmNENzR0s4TTg1UWJWUnlDUXZBeUJqR0t0UUpjamQ4VTZyYnllRnRTWkkxamU2UzNrd1NOeEpra1k4ZTJjWjloNjhhK2hhaTBtamFhMFpSaEZiUW9XWjlvR0VHVi9OeitQV3VBMW1RSFNibmRJV1lSSkdBT0FOcmp0K0kvT3Q2d3ZQc3VnMnNOc3hNMGtRU0k0KzZXN2dld0pQNDFYTG9Uekc3cHMwMTk1dTJRcmJ6Uy9mQzRkMFhoUm5zTnE1L0hyazhhajZxSTdoVXR5RmppUHpFY0FZL3orZGNpYmxmT05sRTdKYlFLRU93bFIwNUdSejZEcjB6NjFJdDRIWXhoSkZpaE9CR3FrWko3RURvT2xOUkM1Mk5ucXYycmNIbUtsbTRCR2ZiK2xMZDNua3liUTRiSGNWeWRsZE5MTTBnVnh2NFZjWXlQODkvYXJzakhISjVxbEVUa2FFbCtUbjVqVlNTK1BjMVJlUWlxenk1SnA4b3VZdHkzb1BWcXFTWFFQUTFYZjV1YzFXY04ycDhvcmswaytUMXFBdVc0RlFuZG1wNFVMVXdQU3A5U2l0STE4eGxYMEFxV0xVQlBFR1djTEg2SXdPYTVHZTBqc21pdkxpR1hEajV1TWtmV3JkdHExdEhheVBINVVvSk96UHk1OXVSWEliSFhSM0lNUkFtNEhkKzFWMWFDNmxCaXZkN3J5VmlmaXVkTTJvWE5oNXR0RGlROG1FU0Q3djVWSnBsdjg1YVcwV0c0QTNiMGZBSU5BenFHOHFXRm9Mc0JndzRESEdmeHJuN3lDNjAxVmgwNmVWVUhaRjNqNkU0cldRTGNvRmtYUG96QU5qOGFiQkliUHpSSmRoamt0OTdBQW9BemRMYU84VkkyUjFsUTVZTkVWeWU1NXJlZUhmWWxwTnpLRHdWWDd0WmNHcVIzTFBpN3RWVWNoRUk1cTNKNGhzN1lSSzhtNVpSMUI0b3V3MEZ0NDF1R01jazhZajZqY0RuOHFzVGFmQ1VhSUJaTXJ1MmpvMzRWemVyYS9hUzNPQmVtM2pRWUR4UUZtUDRuaXJ1amF4R2xwNXd2WHZDMlFHY2JjWTdHalVXaFlTenNKOXZud0NHVnZ1N1hJYXJyV2xuYnhnenlza1k3czFjbko0eFc0dkZNa1Vld25CeG5jdjQwNit1VXY3a3BEZkVXN0wxNUpGVlpoZEVmaUNhd2xYRnBDdXdkWkFuV3VOL3N1NXZRNzJ5N3d2VWQ2N1NHT3dNRFJueTQ1RUdCSVNUdXFLM20weTB1dHk3dDU0YmFEZzFTZGlHamdUQkpISnRZRU1EMHExZXh1aXg3ODV4WFgzME9tZWVabGhkc2pyeGpOWTJyeHJKQWhBeDZjVmZOY1ZqQWladzNHYTNkQm5aTlRpOHhUdHpnNTdWaUt6UVBuR2F1eDM4aWtPQURpbXdQVFRLSWNzN0FLTzlaTmpkc0wyUm8yK1hPY0dzVzA4UXhUS0k3cU01eGpJT2Mxb2FmcTlpdHhzVkNHWThzYXpaVjduVFJhdTJkdVhJOUFPS25qaTg5eTNNUy9VNU5VMTF5M2hieWxpVmo2bGVLdVFhd1dJSGxvRVBYQzRxWGZvVWk0MTNMWXdoZ2dkQnhrOG1xNmF1a3NtK2FSa1U5bHovS3BwdFJ0VERnQmh4NlZ6OXhQWXh5WmE5Q1o2aHFsTHVOczZiem9ibVB6Vm1BVDBjMW5Ya05nOER1UWtveHppdWRlNTBhM204MXI5WEI2cnZPUHlGYTZhaFkzRnFCRnNDTndObzVOQ1ZndmM4MDFtR0JwWGEzaUsvT1JqMDUveWZ4ckppenR3T0hXUWZyeC9XdlQ3elNvUk52aGlqeVYzT2o4YmgvajcxdzJveFF4M1Yyc1VKaUxxQ3FONmduZ2UvVS9oV3NaZEROeE9iMTFpdGc3QWxKUE8yUEhuK0UvTnorT0sydEhobE5uRE5Jd2FSWVFVQVBFYTQ3L0FPZmFxSGlKRk9tTXgyc0dkV1UrMzNlUHlIUHZXeEJJdG5vdGpIR1Bsa1JjTVBwa2sxb1NXN1Z6Ym92eWJKSEp3ejQ5ZVNUNlpKSUh1S3N6VENWNDRWaE1rSUh6WUEvSHI2L24xcXZidzNLeENXV1R5bmx3RWpEYlNCMkhUZ0FmMU5YVnRqR1dTS1F1dzVsbVdUTFo5QnU2ZjRmblRFU1FlWjV6Q0tDTmNMZ2daWEFQVHF2dFVyb1Z6dVlFK3d3S1pDMHNVUlZZQ3FaNCtZYysvV29iaTQyeE0zY2RxWkk0amNvWWNxZVFhaU1XYXR3cHRoV044WlJGQi9rQitsS3NXOU4yTUE4ajZVd00xNFNNOFZBeVlQSXJWa2h4VldTTDJvQXBCRjNkS3N4SU1pb21RaWxSaU85QTdoTHFseE5DUlBLc2lFL0toNEswNUxzUEZIRUlSdFRKR1BVOTZuVFJYWTVacy9XdEcyMHFPTUFrRE5jcmxGR3lUTWkyL3RDR1V2QkxJdnBtcmswbXF6eEFTU3pNdzc1R0sya2lSTVlVVk1ISFRBeFU4NVhLYzRsbnFFb0FEeUlvN0t4R2FsajBTOVlNVE0zemRkeDYxMEFrQTZERlBXVTR5YzBjNGNwa3BvYy8yZFlKSmg1UU9kdU85T2JRVXlDVys2T01uTmJBdURqaE0valZlVzRtejhzYS9uUzVnNVNsTnAwMDhIbFN6QXg5bEMxQXVnZnV4R0p5RUhPTW5GYVFlVmg4MjFmeHB1OERxeE5ITUhLVll0RXRvMjVZRS9TdEZMVzFpVGhNMHhDaEdkdVRVcWxpY0JlS2ZNRmlJcWg0RUl4OUtvejJpdTJkbVBwVzlEQTBneW9BSTlUUTlvU2ZteCtGSE1Gam5wSWhHb0czODZmZHdMUFpBTXExcDNkbHhsU0QrR0t6NWJlWHlTQWVhWE1GamxycXhDdGphS3JmWVpQNEJXM2RSeW9wTGNEMXJIazFJUkVqNXlSN1ZwR1RaTFNLclF5Um5PMGdpdEt4UU9ReEJEVm1TYXB2T08zdlZ5eDFBS3c5L2FxZDdFblVXY2VIeWUvclczQ0NNWjZWZ1c5NXVRWUlEZTlha054S0l4dktrLzdOWjNMc2F6S0RIMnJFdnROUzRKWW9HeDJxK2wxbGNHbUc1S25wa1VOaFl3MFRUNDhyTHBlNGoxR2Y2MWFpMXBMVlBMdHJQeXdPeXhnZjFxN0xOQy9KQUJxdVZ0bU83SXFXeXJGU2ZYWnBIUm1nMnNweHU0NkhqOHM0L0tzZTdta212SlVkVWg4MWZNVndjN1NuZjllbGJsd0xWME1RQUpjRVo5T092OHF3OVFram1XVWNvOGZDc2ZRREpIMTdmZ0RSRmlhT1Y4U1JtMzBpS0dZRlpQTUFUakNrRGR1eDY4NC9TdExUWkJQYVc5M01BSUxhQlVRSCtJZ0RPQjFQSUEvREhjMG5qS0Y1dE90cmp6RmtCY2RPTUVyL0FQV0g1VnA2SmF5TnAxcTg3cEZicEVqaENoSXpqZ2tqcWZZK3RicVdobTFxVEs4N00xeHRkSm4rU0pEMUEveDducFY0VzM3dFVGdFBJdzd2SWc1K3VjMU45bVZWRjRCQ0Z4OGlyRGh1ZTVHZXA2RDYrOVFxa3YzeHZMdHp0WGFvVWU1L3o3VlNkeVdoR1diNVEwTEloT0d5MjcyOWFyWFNpTzFSaXJQNW55NEF5U1NjRC8wTCtWU1RYRXJMdFloQXZvbVFNRFBYUDg2aGt1SFdHMVVFczI1ZHpiZW1BVGdEL2dQOHFZQmNsdHR3bTdMRXFBQWVBM29QcFY2RWxXRWVkeEF5NUo2ZWdyUHRiZVdad3dZbkIzTWVuUFhyK1EvT3JNTXcyTUY2Ymo4M3JWSWxvdE93elZhVVpxSnB2eXBubmp2UUExK0RUY3I2VTlzTnlEVEFvSW9IWTZCV0FITlA4NVJWUHplS2FaQWVBYTg5blVYRGNEc0tjSEo3VlRWZ09hbFdYMHBBWEJrbmlwTnB4MXFxazJQU2g3azR4bWxjWlB0NXl6a1U1VmhKNVluOGF6WHVDeCs5VG9wc2RUUUJzb0xUYmdvVCtOVG9samo3bUt4aGNxQmpOT1c3VCs5UmNkamRSTFRzS21WTGVzSkx5UHJ1cHgxQkIwYW56Qlkzc3dJUGxVWnBQdEk5V3JtM3ZuKzhBY0h2VnVJU3V1ZHhQcGcwdVlMR3diZ054eitOSmhIWEpVZmxXU0RLa20xbno3YnF0aGtDOGh6OUtPWWZLRTl2QXlFRlVJOTFGWU56b1VEbG1RSmcrbzZWcUdkbzVQdUJVejFaZ1AwcVlUMnpzUG5SaWFTbUhLY2JjK0dqeTNsZkw2Z1ZWVFM1SU03SXlSWG9qVElpZ01PdlFZcGtrVnU0QUlVTTNRY1ZxcXJJZE5IQnJGY3F3d2hyUWhlOGpJREtkdnZXK2JXMzgwcVd3M29hQkZFNFpTUU52VUdqbnVMa3NWTFV0TDk4a1ZkZlRkK0NKdXZZMHlPSUFGbHd3OUJ6VnFHNlVaMzRCSFkwWEN4RFBvNnFvQ09XYzl2WC9DcTAyaXJzOHRXYjdSdHovc2o4YTJCZFpUY0ZwZk9ZL050VURIVTlhQjJPWnRkTUhsU1N6ckl6eEhHQzNCN2tjZTFWYmUyekM4WDJkWEx5NGJMZEEzR1R6eU1IUEFOZEZkZmFDa25sS3JCMTVHQjE5YXk3WWtHU01QdGxrekVPQ05yQWNBKzVYQjZmdzByc0xITitMck5JZkR0a3lOR1RLNFprVmNGVzJuSTYrcFA2MXU2SGFFYVRwb2x3MitOSEVRR2QzeWpCWStuQTQ3ZjdWWi9qS1l2b1Z2RXlGQ0pta1VIcnRPVCtoSkg0ZlN0YlNaSGxzYkdMeUdJK3pScUVQVmxDODVHY2hTZWMrd0hzYTVueWl0cVdoYnJ1RXM4ak9TVDVjYXNkcDl3T09QenorUERyalJvWkUza0JtSnkwWkpPVDcxWTh1U1R6TG1hUklGVTRNelpLa2pQeXJqSEg5YzFVWFhyQkpQS3dyZ0VqY1YzZnFmbW9VM2NIRXpkUWpNQ0lySVZBWVlWUjc5QldPOWpQSmV4S2tpUnJJWG1abTVJeGhlTzNPN05kUmZ6R2Z5NWxDRlB2S3FPRzNEdmpQZkdhejFTS0hVNERLclJzbG80WlhQS25jbmIxNFAxcmFOVHVadUJCZFJ5V2Vuc3E0QmJnUHV5V0ovQ3FOdmJBMnE3emlQbGl1TUZ2dzlLdTNvWjU0UjVidUNTQU92YmxpQjA5QjA2NW9NRXQ0cnBJWWdvT3pZaDNFZTNGV3BKa09MTTdjWlc4eFNvZ0gzZlZ2ZjZVUEMyTndHTTF0SmFwRkdvOG5EQWNBS1MzNjgwMTdOM0c0REdhdTVKaGJwRk9LZkd6THlSeFYrU3lmUFNvbXRuQ2tBY1VBUlBQS1RnQ2tFazM5MDFwTEJHS2tDS09tTTF5WFIwV013UGNOakNzS21YN1NGeml0T09NSHJpcHhFTWRLaHlHb21LMHR5T29xdExjemdjZzEwVFFxZjRCVktlMmJuWkNoK3RDa2h1TE1MN1RMbXA0N2ljOUFhdC9aWmlmK1BkQjlCU05ET0IvcW0vQVZYTW1UWmpvbWtmN3kxYVJFUDNoK3RaMnk1TFlBbEg0Vko5a3V0cHpKdEhYbkgrTlMwdTQwYVFGcW81NS9HajdYQkVDRXd2MHJQRmtuL0xTOUErZ3FhS3lzUWYrUGhtUHZVUGxYVXRYTEF2aTJRbStSdlRibWtXK3ZUbGt0U0ZYbGpqQk5YSXByZUlBSzR5T0J6VHpkTURsTmhBNzV6V2ZNdXhweStaQ2wxcVV4VWkxMmoxYzVxOFBNNDNvNWsvMlY0UDU4VlRtdjVRcEhYQXp3Y0NxOFdvVFB6MVhvZWVsR3IyUWFJMEpaWllpeCt4dTRQTzNJT1B5cGtGdzg4Z1o3VHlnTzRKQnFpZFRrRzdMSEEvS29KTlNabEJMbkE5K3ROUmI2RXVTTithUlpDTXB1eDNQYjhha0U4VHFBVGtqdURYT2ZheXlsZ1J6MTVwMER5U1pNWkFIcFZxREpjMGJjczBjampMQWtkKzRxVWhKR0RJNmhRT1FSL1dzaEVjNStkVDY4MVpWbCt6bjVza2RCbWxhekM5eTJvUjFPNXQ2ZEJrSFA0VkVzdHVyYk1ibXp5U3ZOVmlzanhCaXdEL1htbXRDK0EyVkxIcnpXaWlSekdpSjRCTHRaeWM5RDFxVjVraHdOeFppZUFhenloSkJadVFPQlNnNStiYXhQb2V0UGxEbU5HYVViY0lIY25xUWVsWnNjR05RbGdrWndKQWtxdGtEYTR6ZyttY0tUK0ZTSStVSU1mNEdxOGpiN3hSeUhNWklKR2Z1a2Y0NXg3VTFCaHpHTDQ0aG5pdExaWnRoRE03S1ZKNXpqUEhibm5xZXRiMmp0NVdod3lUeUxCYXJDak9SOTZRN1J4bnI3ZnlyQThkWFMzTnBZeUEvS1EzSG9lTWpQZXE5N3JRdmJLeXM0Q0V0NDR4OVdJQXorRk5xeXNFZFdPMW5YNWIrUXJHaXhReGZMSEV2R0IvbkZZMDl3d2RTZ3crY2tub2FGSzdnMk1nL2QzbmlvTHFUTWdkWkFDdnB5YzFLM0xhME5mUjlhTUxQQk94YUZ2dnFHL1VlL3dEbjZkQkhOTGQ2MjhRUkppbHVpcklXd3I1Sk9TY0U4NDZEMDYxNXI1aEZ3UVpEbnFUbXV4OEphbmJDOGtqbWxJZVVLTng2REhGYWNxdVpYc2RRMXBleFpNc2NRUmhqYmJFa2dkK1NRZmM0NSt0VElzU3g1OHFCTnZHWk91UGJQK1BldEVad0ZKRGZoVHhiRmVkeDlodTZVK1ZDNW1VN2VLMktFeGNGdVR3UDgvbFN6UW9PQWMvU3JMUlNoZUFuNDlhaFlTQWplRi9PcldoTEtUd3JqN3RWM2hYc0t2eVNvRHprL2pWV1YwWUhBSS9HcXVLeHpZTTNYSnB5UEpucm1wZzRiZ1ZZRnJKak9Cejdpc2l5dUx4a09OcHFUKzB5bzZHbXlSYk9EMXFqTXB4eC9LbHlwaHpNdU5xK0tqT3MxbGxHTGpka0wzSUdhMEliU3dDWmRuYys0eFV5akZkQ2s1TWNkYlljQUNnNnRjQVoyREgxRlNxbGdyRFpCdVBUTzMvR3BHanNYSHpLcS9pS3piajJMU2wzS1oxbHg5NVZIL0FoVGY3WWpiN3lFL2pSS3RteDh1S0V0L3RHb3d0c255clp0SWY5NnJ0SHNUZDl5VWFpcnVQTHRsSittYXNDUy9mN2x1RVUvd0N6aitWUlFUR1A3dW43RDZrWXE0TGlZZ2JtalQyQXpXVW4yUnBGZDJNV3p1NUJsNUZUUFlEbW5SNmRORm5aYzdjOVR0cGZ0QlU1YVIyK2lBQ29wcjBBOWMvVmhVWG05QytXQzFKVGJzbit0MUNUbnJnQ2w4cUtOZm12YmhoNmJnUDZWVysySkl3eEd6RWR5S2t5c2ovY21COVFNQ2ozdW9hZEJ5cmFvdytlUmo2RnlhZkxkMm9VaDBqQTl4azFDSUdCSkV4RGU5UnkyaXVNdTZzZSthYVNiMVpMdWxvVkpyaVBjUkVFVlQ2REZOaXV3ajRESEI0SXpVcldsbW4rdFpSbjBhb0pvck5TR1JnZnpycGkxc1l5VExxM0FVOEEvblU4VjRWR09Lb3hDSjB5clU4SU05YXF5SXVhYXpFbkpaZnpwN1RLMFpHOGV0WjZnNDRxYUx6R0dNMFdDNUlMcm5JY1ZZUzR5T0pLem5XVlhLbm44S3NXNjRQS0EwN0FhU3VTQVZPZnhwemhpRWtIOERBa2V4NFA2RW44S1NBanA1Uy9sV1hySGlDMnNQTXRRMitka1pjUjRBUWtIcWVjbjJvMkdjLzQ4MU9HNHUvSWlVRHlDVmRnZnZOMy9sV0xheW43T3Z6REhsakg1VlExUTVVa2tsczVKcTFhdkcxbEdBUDRGNzBuc05ibG1GQ1VHZm00SlQzTk1td2tSM0VsdW1RT0tMYmNJVkdRQWVNanFLZ3VycU5HQ2dZQUdlaE9TYW0ycFZ5QjBPNGs1MmdjOXFJN2xyYVZTalkybmc1ejJwTXJLemVVQ3VEaGk0L3hwcnFuK3NPWkdQQlZmbDQrbFdpV2VnK0gvRnNjMFN3WFdmbEdCSVIwK3Z0WFhMUGtBaGh6eUNLOFppdWt0b3NMQUVjL2R5UXhQLzFxNi93cnJyWElleG1mNTE1aTV6OVIvWDg2YUpaMjczREhxeHF0TEtUMFkxUWt1R1hxYW8zZDY2d1NPcE9RcHhWQ05DUzRQUmpWU1M1Y2RYVUQzTlVMT1FEVDdkbVp0MnpPVzY1TkUwbm1LUVd6UUJvUmFlaWpKbUIrbFdCYnhBY3N4K2dxZUlFakpLRDhCVS9BR1BsUDRWazJ5MGpPZU9FOGZNUHFSVmVTR0EveC9yV25MdlAzUVB5RlFGR0J5ZG40MUxiSFl5WklvUWVDVC93TC93Q3RTckZFcTVLZGY5by80VnBNckU1M3hqOEtZN3V1UjVrZUttN0haR1cwTVRIbUkvOEFmUnBGdG9qL0FNc2dSL3ZHcmtoQkh6VERuL1pxdUJFcC93QmRqL2dOTUJ5MlVad1JFdjR1YXViV1JSc2pBeDIzRC9DcVlLYnY5YXgvNEQvOWVuRjRnUHZPZndwT0xZMUt3NlEzZklDSitKcUlRM0RIY1JDUHFLYTBrWS92L3BTQzRqSDhML3AvaFJ5QnpEM2dmR2ZNUUh2dE5RR09Vbi9XSC92c2lwVGNwbmlJL25UbHVoMmliL3ZxamxZY3lLM2tUbm8zNmswM3lMamZnODFkRjBRT0lmek5PRTc1R0lGelZXWXJvei9JdU4yTWtVOFdjNTZTRC92azFkZWFYUEVLajhLQkpQOEE4OHdQd29zd3VpZ2RQbmM0TW8vNzVwajZYSmptVDlLMUI5b2JzQjlCU20ybmsrOFNhcFhKZGpMdDdTV044YnNxYXRtMW1VY0FIOGFrL3M1eWF2V3RsbGRyOWUxVmNrcDJ6UENHRWtZYkk0NTZVcVBLRHhpdGRkT1VkcW1Xd1grN1FTWUZ5OHF1cmNjMUxiU081NS9sV3pOWUt5aksxSEhieEkrM2VnSVBUSXpRbU01bnhGcmtscC9vRnFXV1lnR1IxNnFEMkh2WEhSdjV0MmdPU1JrNS9ELzY5WE5VbTg3VmJ5VVBnUEt4VSsyZUtvUmJSY3VRY0VMZ1o3RS8vcXBibEprR3FFN1F1T01aempyd0t0V2hLV2NZQTI1UlQycWhxVGt1T3YzZTlUMmJ0TERFb1loUW9CT08vdCtWTnJRRTlUU2pLbjVBQm5ra2c4OWFxNzRYa1pwR0tuZHQyai9HbXUyM2xTcVpQVStuditkUVN6Q1FsVVZwTUVrc3E4Wi96eFNTRzJXeThmbHRHcVl4SHhuUFBQOEE5ZW1sSVZ0VmZadWtjWTlLcm0ydVhjRjhSNUF5V1lBOGUyYzlhdjhBbHdJcUF6ckluQzdVSElQNDQ5YUxBbVlValB1S3NjWVBDaXI5aGRQYlRSWENOdGNNQ0dGV3pwRnZQTDhzekxnNUlLai9BQnFiK3hZc0UvYVV5Qnpubkg2MVhNaWJNNzJ6dVl0VnNsbmp4dnhpUkIvQ2FyWHR1VXQ1U0FNN1RqUHJYUGFVOCtuU2I0NVFBbzVLcWRwSG9SbnBYUk40ZzArZU5vcDBhSnlweWNibC9UbjlLTGhZa05pRmpXTUxnS01BZTFRTlpIbmcxcjJsN2E2ZzdtM21qWlI5MVFmbTl5UlV3VlMrMHFRVDB5UDYwN2lzUkM0QVhBQzB4N3M5cTU1dGR0Z09rdjhBM3pWZVR4RmFqb0pEK0FwY2t1d2M2N25RUGVFOTZydGRaNzF6aitJb2YrZVVuNWlvZitFamd6ekcvd0NZbzluTHNITWpwamNBRHJUR3VBZTljMDNpU0h0RTUvR3FzdmlHWm0vZFJxbzkrYUZUa0hPanF6TXBvTXlLTW5BQTdtdUxsMWk4bUJIbWJBZjdneCt0VkRJN25MTXhQdWMxYW92cVM2aU80L3Rld1ZzRzRqeVBRNXBKTmIwOUYvMTZuMlVFMXhHYVVOVmV4UXZhTTdNYXpwOGlaODlWOWlwelJGckduUG45K294L2VVaXVPelRnYzAvWW9YdEdkc21wV0RuQzNNWDRuRlR4M2RxVGhab20rakN1Qzcwb0FxZllMdVAybmtlakpMRmpPQlR2dEtCaGdDdlBZN2llRC9WVE9uMFBGV0JxMStNZnZ5ZitBaXA5Zys1WHRVZDc5cGozZEJVdjJtUDBGY0VOZnZJK0dDTjc0d2FmL3dBSkpPY2ZJQVJVK3hrUDJpTzZGMmc3Q25DOFErbGNRdmlTVEhNUy9yVXNmaU5lOGJBL25SN0tRZTBSMTczYWcxSkhkamdpdVBieEFqRVloa1A0NHA4ZXZYREhFY0txT3hZNXBxbklUbkU3eUs1RWc5NnpkUjhTSmFTTkJicUpKUndYSitWVDZlNXJrYnJ4QmQyeEVYMmdoNUJ6Z1kyaW1XYlJ5WXlRVkhvYTVNVldkSFFYdlNWNGwzVnRWMUdlRk45Mi93QTU0VkJ0SDZWZ3NoaUJrdUpSMSs2RGlydXQzWGtMRXFjY2NBY21xTnBENXlOUGNBNC9oUnUvdWF5dzA1U2h6TXV6U1NaVjNTWE80UlJCbDZibUFILzE2aWExYUYzVUFFc2M0SndmeTcxcFQzcXdxRHNWZmNua2oySFNzZTQxZG1aMHQ0azNOMUtyeit0ZGNXM3NHaEJxVnU4VUNTRmw2WTJqclVkZzB1VmlqRzRqT0IvTTArSzF1cjV5WldMbnVTZUFlMzFyUW1VV2NLd1FnbVNRSGMvZkE5UFFjR3JjcmFEUzZrclNFQUt1R1plcmxRUXYwRlZKN3FTYVFocFgyamdBZjUvQ3ByZUVMR1dlUmc1NUtrK3VjVm1aa0V4TzMzT1A2VWtVeXk3bG5CMjVISTVIYW5IZU5pSVd5R3lTVnh4UkVKZCtTQW03djFKL0NyYW5ibmVOenlEam5PYUxoWWFtUmJZejkvSno5T0tsdHA0NHh1Mjdpb3lQOGFwWE4zaU9KVkFJWmR1QndRYzlmOCtsT1Y5aXJoZHdZNUswMFNhRVYwWFFqaEpOb0RBak83Sjl1S3NTUGNTSXAyS2dBNlp5T0QwK3Z0V1VMeGtLa0VGTTVJSFFIL0lxM1p6QXNSZ2JXNEtzZS9zUFduWVZ5L0V4VWpIeU9DZVNPOWFkdHI5L2JJZk8vZUozREg1Z2ZVSHJYUHM2cElWVTdoblByV2hHdTYzWjg4TU1iaDF6K09lMUd3OXpKa0pQSkpOVjNGU21VbjBwaHlhNmptS3pEbWsyWXF5STI5QlFZbVBhZ0xsYkdUVGhHYWxFTFpxZEltb0M1V0VScDRpSjdWY1dGalVxMjdIcUtZcmxFUU42VW90MjlLMUZ0V1BhcFZ0RGlnVnpIK3p0VDF0V3JWK3pqUDNoK2ROL2RLU054NDlLQXVaNHRXejBxUmJRMWRWNHoxRC9BSlZPcGpJK1hKUHBRRnpQK3hIRk9GbnhXbUZPUHVZcGtoOHZ0azBCY3pwTE1aNlZGOWo1NlZlbWxsWWphcWo2ODFCdW56OThmbFFNalcwLzJhbVN6UDhBZG9EVGorUDlLZG1jOVpEU0FsVzBBSGFwN2VKUStDVnpuajZWVUNPeWtNM1dpMlZoTDk0azU1emtZRkFqTTFoVy90VzR3TXF1MytRb3RXS1lhSXNBQm5tcTkxY090OWRNM09XWVo2OUtTR1NOU2lJMjdjZHpjOGRLNEtxdTJkTWJyWTFHa0RBU1RsWkpjY0RQQzFSZTVPMG5PT2VBTzRwNlRMTXpFN203QWdaelVFaXBiWElEU0tXUFhqSVg4TzlaUmlsb2lwTnZVenJveXl2ZzV4MkFxMWE2ZUlodmx6ODJQbEZEeXhKS2VXTWpkU1R6ajI5S3RwT3UzSkNQSVQweDByZTlsWkNTTGNBTWhDcEp0d004amovOVgrTlZMMlUvYk9uRFJsVklHZnlxM0JMc1ltWFB6SGJnNU9UNlZEZGhZSlZ1TndMakpQR2Y4OWFoYm1yMkdYR0k3ZU9QNVF4d3pFSFBiSFgvQUQxclBqWXlvNkVIS1l3UU8zdlQ1cEM4akVINXU0ei9BSjlxdVcwSWhVc0J1TzNKendCVlhzaWR4TFNCVEM3RmNjWndjNWIvQU92Vm55b2hqS3NHRFo1UFR2ajlLamVTT09JS0FDek1PVzU0L3dBbWxWdCswdWRnKzlsZU9lbVIvbnRRVVU3dXlaNWk2NVZkd2JsZUNEei9BREg4cWxhM01zaWhFQ2xlRHU3SHIvV3Jzb1o0RURFamNUaktZM2ZqVUJ0MllrZzR3QU1Zd2FmTVRZejFqeFBrcXdBSkpKNTdWUGJrc0NtTUVrWVBmUDhBUVZiaVFFUDFJYkM0WThmblVLckNIRE1NRCs5MlBwaXE1aVdpVlZDNVluSFlZOWZXcjFubVNjS0VZeDhCMVU0L0g5S3BTS1ZJS2tZL1BIOWZ5cGJlNU5ySVpmbE9PRG51UFg5YVVydUxzSXkxaWx6bmUzNTFZajh4QmdnTjlhbVJ2OW1wbFA4QXNWMm5NUWhwVDBWZnlwdmtTc2VXUDRHcmk5ZnVWTUJ4OXcwQVp3aGxCenVhckVUU29Sa0EvVVZmU0VPUFQycVVXb3hrMEN1VmtsOVZ4OUttV1ppZStCVmhMWk9Lc3gyeWpIeTBDdVZGa1p1U0NLYTZQSTNldFVXd09PQlVxMnFqcUtCR090c1QxRlRKWWh1UXRiS1c0OUJVd2dJR0F2V2dERUZnZlNsL3M5dXkxdEcySjdVdmtPT2xBekYrd1NrZFRpbE9uUGdFMXRlWElWQW8renRqbHFRR0xKcHhJNlZFdW5uT05wcm9KSWlxOTZyYlhCNEdLQXVaZzA0OTFwdzA3ajd0YVlhUUhwbW5ydko2VUJjeWswNXMvZHBSWXFybmZ3ZWdHZTFiSWRod1VGTmZFZ0lNWTk4MEFlWjYzSDlqMUtlUGNRdTdlcDY1enpWUFQ3TXlIZTJTemNnSDA5VFczNGxrbHY3NHVrSDdtTDVVSUhMVm1SM2lxQ3ZLSEczQTdmblhMSjcyT3BiSzVwVzF1STRDNnR4Zy9wL2tWUmhUekhtY0x1Yjd1T3VlNS9wVC90SlRFQ3lic25xUUsxRjA2V040V2hYNVdYTEg2MXl5bW92VWx5MXNZODFnK3pmL0FCZE9lZWF0NmJFOGtXSGpDeHFlR1A4QW42VjBaMG9KYmI1TUVzTWdlbnZWRW95amxpQ09nSEpOS25XVTBhUTExSURFNGJhV2oyQTV3RitZODU2MW5TQzQ4OHVXWVJiY0ZldjRmaldrb2Jld0VaR1R3ZTlYcmF3YVNNRWxWUmljNUdLMHZZMXRjNTUxWnJjdUNoSzUrVmNFOGRLY3pZVXFFZG1kZDJNWUl6N2RxMWRVUllZQ0U4dHovZEdCbjYvNFZoZjZkYTdtQzRCLzJjZ2V3cWxxSjZFenBEc0hsdmxrNmorOTZVNFFnU1F5QTRrYmdZemdudngvaDYxWFVYQUFhVjR5elpHR09Qd0grVFZwTE82ZFVjUjhoc2d0eDE1NmQ2WkpJamg1TnJaTzBqR2Z6NHA0U2NRckswUkNqT1FHQkxkai9LcnR2cHFRQlpYSWFRSE81MU9CNm5IK2VsU1hjb1NSOW9iZHR3dnk4QWV2UEZUZld5S3RwY3lyYTNjUU9TektoSkdCL01ESGVwWHNFRWhJbHdvNGJQcjE0ejBxYnpQTVpmOEFTRWwyY2tNTnFuMEhYRkpNazkzdnhNN0lCazdZempQK2Y1VlY3YXNrejVwSXhJb1FrdHU1TEx4OWVhakxDNVoxVm5kemtuYXZIdjcxcVFhWkUwV1pJMEF6L3JDM0xZUGIvUFNsalQ3Q1hqSHpzVkJCSStWY2pQVHNPZjFGUzZ5U2ZMdVF3anRmYXJDMnd4MDVyV2pzY2lyY1ducjNHYTlLeHgzTVJMVUU5S3NwYVo0QXJjU3hYc3RRU3lMQmVSdzdBVllmTTRQM1Q2VW1HcG5KWXNUOTJwZnNHQld5SWNqcUJVYndrbmcwQzFNd1dtMGMxUEhiY1pHY1ZZRVo3aXBBckRnQ2dDS08yOWVsV0Z0QWVUMHFSQVFSa2ZoVmhWR09LUTBpQmJjRDZWT3NYYW5CU2VsUFZjYzBERytXS1F4aW5zNFVjbW9XblpUOXpOQXgva2pGSVloam1xLzJxUTg3UlVWemRtS0ZwbkRFREdRdldnTGx0NHhqR2FoTWFnODFSdU5WdDdkZ3U4dEtjZkt2WG1zaHRUdW11QjVyTHVqWmxCQUk1NlpJL1BqM3Fib2RtZElZMUJBSkFKT0JudlVRdTdRZVlQTlhkRVNHWHZtdVZOektaa3VXa3pJbnB6MFA4dWFZOG9qU1E5R2ZqNWw3WkIvcFVTcUpGeHB0bTVjNnZicllUTVpRc3U3QzdSempQQi9Lc0MrMXE2dkJzd3FvT3kvMXFrUzByRWg4aXE3cVdtOHBBV09jRTFqS281YUc4YVNqcVBhWUZUSXpuam9UMEZZY3pDVzRMcmhRRDk3dWF1M1FlNW5XR0ZUdFRoUi9XckZ2b3NqRlRrWjY1UDhBaFVwcElidXlLMXNtdUowWnNncndUakhOZDdwMXQ1VVNJNURIQXdQYXNleXRGdGxqR0E4cDZBOXZldEtQS0tWUnlXUExNZUs0Nnk5cDZGZXkwTHQ5S3NyQ09GUnVBd1FhemhDRmNrN1dmcmpvSzBJVjJSbGh5VDk0ajFxaGMzZHZieWdNM3RqSDUvV3M2S1VmZFJvcWFpaC8yS05nWkdIVHNCaW83bTRNYWxWdzJCZ2pPQUtTUy9rbUlFTVJPNC9lQXdvRlJUYVdac2ZhSE9QN3FuYi9BUFgvQUJyb1htVmZzWmtsKzMybjdQRGJtZVE4bFVQVDYxTjlobnVJOFhMeHdSbjV0cWpleCtwUC93QmV0S0szanRJakhFRmpBNmhRTUUrK2Y2MEt5eGdoNU1ZeHV3NXpnOWV2NGMxWE4ySXQzTXYreVlQTVYzTWtvVG9HT0I2OEFVK1o3aGlCNVFpakErYm9jQWRzQ3JrMHpOdVlrODhqcWNlLy93Q3FxdSs0bUdGU05ZMkdEdVhCL0QvUHJWSnNWa1JySTBqSVlVemtBSytTQ2VjWng2ZC93cUkyQ3dKdnVYQkdDZDVZOWUzUTFmYTFTU1VPNmhjRGJuaGNIQk9UVVd4WkhlV1g1Z1FRQzJHWGtucDJ6MDR6K05MbTF1TnJRby9JOGJwRStWeUNHSklIcHo3MCtJckFYRStDR3lTU29PM2pqanRVVzVsVStVWkN4NUh5bkp4MCtuYXJGeHBoWXhlWGhjTGx0dmZQU3RXMXNacE1kYVF5U1phU1dTUGF2eUlYdzJPbkhmdFUxL2MyOEZsYnBid09Ya1hFN25KemdodS91Qm42VVdrRXNDRWxWYmNPTTRJT2VPK0R4ak5SUndUU3d5S3pjT3VRd0lQR1BYR1I5YTU1ZTYzSUpLeU9pbHVZN2VFdWVuWURxVDZDblJYa1p0MW5KS0lSbjV1TVZ6UW5hV3pqZzNjSzNJTFlOVzRicEUwdTRqWUNSUjl3ZzhuUDByMU9jNHVTeHMzT3FyYjdrRzVwZGhJQ2pPUGMxUVdNenMwUWJERlMwa21DTUU4L24yck0rMVNGU0pSdERqamJ3T25UM3JYTWtTd1FOREdWZFZicHpsczkvVWpubXBjcmo1YkR0Tm1XMmdrd1NWSExLVys0ZW1NSG5IdlVNdXBUWE4yMGF5K1hHVXdDdlBJNm4rZFZZais1WUlwWm1JeTJSbW5TZ1ptZVBDNFVLb0g4T2NraitkVHpPeFhLcm5TMk1idmJSdEkyOWlQdkFZelZ0eEhDQXhiYnlCaytwclBzTGhvUzNteko1YURZRHprNDlCMU5VOVMxZHBvMFdFR01pUWc1OXF1NW5ZM2hFQU9SbW5ncXB4Z1Z6cmE4L3dCcWdBejVRSHorcE5TLzI5SkpPOGF3cVYyZ3JnL25taTQ3RzI4cmRGR0tpRDdRZm01NzFtdHFmbUFlV1NjOE5qK0gzcWxEck1ER1lic0tuS2s5V0dLZDBMVTJuazJqQzlhaUxuYmxtd3ZxYWkrMjI2UUpNemJnL3dCd0RxVDZWVHU3dExxM2tBQ2lKWEFHVDk3amo5YUxpc3pRbnVZcmVJN3psaC9DT3ZUTmM5THFqeVJTeDdtSkxiZ2ZUMitsVkxtYk12elNFOWxKYlBTb1JrdGdMOHBCelVPUnJHQmNMNWxkdGd4Z1k1NUErdEx2UXh1b0JaakpsYzg1NmY0VkNaQ2NBWjdkS3F6U3VyRlZPMWpqSjYxbTUyUnFvWExIQzdna29YMVBjOStLaGJEZktjNVBjLzV6VlpSaGk4akhHUHlwa2psMUVVQ2puZ3NCMkg4cXcxWnVrbG9oWkpqSklJSTJDQUw4eC9yVEx1ZU95V09PTDd6RWJtNm1tQjdPMDNaZmMvVXNEMXJLdVpUZVQ3a0dGSEhQZW1vM1luS3lOK0pZWTFMYmdGeG5QK2V0RVZ4UGNiVEJHVmp5UjVyK3ZxUFdzdXlzMzM1dWlXQUkyUmc4SDYxdkxLdTFrS0hLOHFCd1B3cUphQkhVdlFSckVqTVczRWpsejFOT1c2RVVpc2N0azQycXVhWkZHN3hEZUNvWUU1RlR4SWtKQVZPZlQxUHZVMlJxYXFvc2lqQUlWdVN1Y1ZSbHRZa2tiQk84ZFFvQi9NazFHc3pvaDN5WUlIM1ZBSkdlbnRVWG5Pak5HNnBqcmxoa242RHBXY2FhanFnYkxzVWtjYVo4c0I4OTJ6ai9BRDlhZExkUSthY2tKbnE3OUtwb0hsY0VTTndNN0NtUDVVaUpNckdTU1NTTUE1Q0VoUWZ4cTFIVzdKY21sWkVzN0txc0l3ek4xQktFRWZwOU9hcmVjUXFJdTBzZXE3d05wOU0xRzg5ckpJWWtSd3dHQVk1ZUd3Ty9IOHFxN3ZJMnl2NWlGUWNDVE9HOWdSOWZRVlNpVHpNdHgyMG1XYVpzNTdKbmFPT2VPMy8xNmY4QXVtYmFRVGpKQUFCSDUxVGoxQjJJZEgzSXZ6TnRRQXJrZi9xclFON2F5Z2ZOSU1IQlpTT3Y0ZHZwNzFUUWt5T056Tks4YU5zVnM3dXZidm4zelVOemJxSXZKVnRxcjBVWXlUM0pwL214UVM0RXZsdmduN3BQQk9SZzk2b3lUS3hBZ2JEa0VZMkU0SFQycVVuY3BzdTJFVWErVmh3VDA0d2NlbytuTldMemFaQ1M1eXlqQlVkdTM2MWl4U1hBdWNnbVNOUm5LODg5Y1UrNXZOOTBVU04xMi9MbkJLZTR5T2c3VW12ZkdtbEUwQUZLRml4Y1p5UUdQVC9Db3BDc2tNaXFvVjlvd2QyQU05OEVuUDRZcXRGUFA1ZVdmNS9tSGw1NittTWVvNC9FMHhacExjU2hnTjdOMlRuSHAxd08xSnE0YVNLNmxnZzJjOGtBNTU2VkxIZ0pLTWc0R1I3SEhTa1pVOGxBb3d3WTVPZUFNVktkeXh6WVJTTnFndGp0MDRydk9NaDgzTXJqYUR4dE9lL0lyU1dYTXUxczhiaHQ5UHhxc1lGSlp3Y0hjQUNPQlVrUUtUTVdJNzQ5QjFwQ0pZRlpiY3VEMUlYK1ZJQXUxMTV4Z0g4ZWFWQ0dnd3BQM3dRUGJGT0FCa2tPUnQyZ1l6N1VCY3N6Uk16S3NYUUhQMHBrNmd5Z1p3ZDJUZzFNN3h2SDVpTnRYb2NyVmRwSTFIM3QyZU00cGN3ckVUWVYySTVwa2N6UmtzdUZJNEpxRVhTcU9vNDRKOVRudFRXa0RFcXBIUDQwK1lhUlpobVdPNU9TeEp6am5yN1ZWYU5JbElLc0d6bkdhalZXRzVnNUxObjlhUXlDVjFEWjM1STNldkZTMnlra2lXUy9sSWpTTmRvUWpiampGUlBjU3Z5KzdrNTdZcU5ITEh5OWhYSGNqOUthMGFzMlM1T081NkdnZWdDVWJpZUFCem5IV252TVRzd01jOWFoQzREa2tldUtlSkkxWlVSQzNHUWZRMEFXSVAzd0djNUhKQkp4L09xbDVjaU80Y0tSeHdPL1RyVXNTUHVZNElYcVQweldQcVRNazBnVnVReC9Hb2tpNE1zM0dva0lGSEErdldzeHJtNnVHYUdBQmgzMjhEOFRUbDB5YVpVYTRrSUpBSlJldi82NjFFaFcxZ1VKR2NMMFJSa2swdEVWZHN6bzlKY3J2dWJnS3ZYQzlQenEvYS9ZNDNTT0pRMGg0M0h0K05PWFRybTZsVnBmM1lKUDRDdEMyMHEydHN0UDh6NDRCeUJtbEtTNmpVV1MyZHFzcEV6T0dqend4NEdmYjFyVDJSeHFXNUxaemdEampqbi9BQXFzYmhRdTBBRmdNQUtPblR0LzllbTNVNm9qOUNRbVBtSFBQYlBhc0hkbXFzaU02ajV6TjVSa1ZCd3E0UHpIMTQ1cVJwSFlEZEVZOXcrOXdDQlZPM3ZraWJZQ0hCSE9XSUI5c0QvUFNyYTNrWVR5M2pYWUJ1TWZIWC9QOHpXbGtqUG1aTkJISE1DdkFCWEk0NmUvL3dDdnJUemRLU0FrVGVXb3dHYmpwM0hZVkN0eEhpT05ZMkJQZlBINDgvNTVxZDNmTFNLamxNNEhUSkg5S1ZrTG1KNHJ6QWRSdXlDQmhjWlA0LzhBMTZjWjRWWUNWMlppTWtBN1FQeTYvV3FQN2hGV2QyR3drcW96Z0QxemlxenpxSFJGRFNSOU9UbmlsWVZ5NDh4ZFQ5bkNnbjJ6ajM1NC9yVk15U2gwamVFYk0vZkNFWjdkUnoycG9FeVB1d0FDdkFJL3p6MW8vd0JJUXJJak1ZMEdRVGtLTS9TclZnYkZsamdqa1dVcUpWMi9OdEhRNTlNVTYzYmRjcklIRFRIR1N3UEl4NzUrdFY1TGw1VkltSVVLYzdpTWppa2FiRnJrZ3Zqb0FCalBRLzVOVUJOY2JtaythYkVpa25jSEJ5TWRNZHVuV21SdzcxVnBGamtYRzRuQU9QNmNpb29aSEtMS1NNZ0FrRVlJNXhqMnFkTG9yZEZBMkdmbzJPYzlmdy8rdFNZMFhJWTBqa1FLcExNMlNDYzdzWjllT2ZiRlRtR0FUK1cwb0h5OEhrWXp3ZVB4cW45cER6b1F1V2pPZUIzemlvMG4zM0pTRUk2ay9OSXlaNXpnNEhmdHovT3NXbTB5MjFZRW5LTEo1ck1HVjhZWEJWdmxBSEEvMlQrbFEzRjZ6TWZLQVVjNEo0eXg0d08vQTlxbGhUeVVrWlg4MEw5MG9Na2h1TVo5ZU0vaFZXV2FOWnpOSXdrY2tLdUI5em9jWjZaNC93QW5vUXM5UlhzaTRZWTJoK2ZlbkJ6eU1meXByaU5nZGsvQkhPM2tuMHF2aGxrVW93ejNIQTROYUVkdEZjRXFreFNUSFIxSEkrb3JxNXpCUnVVWGtSY2haV0p6eUFCeFVxTTgyNGlSQUNSZ0VFRUR2Mit0Uk1KWUpXaWVLSXYyMnJ3UWZlcFVhSklodWpKNms4ZEtmTUxsSFRlYWtKOHZZMGg2RU5VcS9hZklVTkdkdTM1dG5KeitGUW9JQUNZWEhxY01SVXlCd0RKSEp0STVBVThpbHpCeWdXM0o1V2R1M2o1dU0xR3lLRkI4d0VZUEo0RlhrdVpuUUxKQ3I5dDJCazFEZFIyOTNzeTBrQUhKR001bzVnNWV4UU5xenRuN3Erby9wVDlqUm5DQURIYlBXdEJZVkpBaW1oa1VMeXBPRG4zcUF3c3NnVjRmbEs4NHkyUHlvNWc1U2dGZDVjeUVFQWVsUUVNN0Ixaks3ZWhIVTFwU0NFTHM4eEM0T2ZtRlFLSkV5U29QeTVJNjVOUG1DeFVZT0UrWTRicndQV25KYnZMdDNGZ21EelZ3N1dmOTRwVTlSZ2ZyVVprbFp5c2NaWkR4MDVvNWdzSkZZeG41VmtHUUIxenpUakM2U09HVWhSOTF1MktmRUFTNm1WVTI5UW9MRWluc1pwZ2l4cVVqSEFCT01uL0Q2LzhBMXFoektzUUxKSHZQSjRIVURGVmpwYlRYelM0eGs1VU1PRi8rdld0RkZGYkR6R0lad01raEMyZnk2Q21DUVpiYnU0K1p1YzQvR29jbTlqUlJTM0kwdFkwWUJ6a2c4QWpqL1AxeFVvaVRBQVZzOUNBT29INFZFV2Q1MkNuS25KMnFNQWQrbmFuNGtKTDRRS004RnVjNC93QS9uU3Mrbytic1BmQ3FRcW9FendOd3lmclVMNzFKTFBIR0QwRzRBblA2L25tbnBsMlZ5dUIvY0I1eitJeVIvbnZUU0N1RWFJN1J5eWs4NDk4amdjZjV6UW9qNWhnZ2xmZDVaREFIcXBBejcrOVEzVVVwdHBNS3cyODVJeG5uOWFtWlptZjk0VklVL0tBbitUL2sxWkEySXFPakZPbVNNMEN1Y3VaY1NiK1FvSXhpdEcxdWxEYlI4MlJrWkhUL0FENzFteTVpRFJIamEyTTlLZERGNWpBcytNY0hQYi9QTlU5aURhV1VyY2h3b1JoL2Q3bjhxc1JJcFYvTVoxWkR0SXdNZTlRV2x2OEFadzVPOFNBbkJJNDlxc3hlZEs1alB5SVRrN0RoYy9wV2JLU0d2YnkzRWliZ1JrWjJuam45S25XSUF0RXhUY0NUaFJnazRwazE3NUJXUGVEamgyQjYvalVUMzl2amVzd1U1NU9lL3J6UzFIWkU4dHU2NUNiQUZ3UWM4ZGZwK3RNVzFtalR5NVRINkFnVkcxMDAwYkVOTWNIcUZKelRmdEtUL3VjbmZqSklITEg2ZGY1VlNKSzBsdEVaZHlUWkpQUWZxTVU0V2tKWURPOVF3eDgzZjN3T2xPRHV1R0FZWU9NaGM4ZlNvZlBDazdZeWQyUUFjQWpwK3RWcUJiV05GVUZwdHBPV1ZRM3FNZGY4OXFyN01UeHlLeWJsNkVkdlhQOEFudlVydkFHamNxdVI5ZW4rTlU3dWVTTStlb3dXK1lEcno3MHhsdS9JYkpZSElCd3dISjlqMy9LcTl2YVNUSzdYVXBBSy9MRWcycmo4TzNTcWkzRTh3SVpjcm5JSFFEbnZpdENDN2lrdGxKbVVQSGtJaTRHT3JmZTc1OS9Tb3FYVWRCclZseTRERUdKcEJFcmNGWEpHUm5ucDYxbE9yUXU2WE5vOEtoOXloOXdBQzlPMzE0OXFrU3pudUEzMldKeXlmdldjeUFFRmVjN3VNY0RQV28vdDcvWXA0d3lTTXlmTkpJTXMzWEl5YzFNWXBJVW5jbWNBcDhxRm1IT1NLdDZiY3FsM0N4NFpUeXBYaXFpNWRoayt4WUowL0dwa1Jsa1ZXUVBubnpNYzFzMG1pRFQxdTJmYjUyTnk3anlwd2R1YXljU0tDVmtDRmV5akpKeHhXMjhjc3Rwc0VZeUU1SHJXR3l6Qk14ZWF6RTRQQTZDbEhzT1c0c2FpVXVaTmhBSFJUNyttZU9hbkZ2RWtibUo5dWZ1N1dKL09xa1Z2TkhLcmVadGJIUWRPdjQxblhzMTdjWHJxcXUrMGJRUXVlbjBxdVc3MFpHeHRPV1F4SWp1ejQ1NTRGVENSMHdVV1BKSkFPU0NSaXE5cVpWZ2phVUZMbHZsQ2pxZlQySDFOVnJxenZoZHlSdGRMRnRPZm5PQjM3OS93elNTWXkvdVRKODRTSHVTaEp3ZS9iK3RPRjliSk45bmdkZy9iblBQcFZPUzV0cmZLdGM3NU1jckdjZ25uZ1lIclZjYWpiUkxtQzFqaUs5SGtUTGZyL244cWFUWUdxODdTUnNIZEM0SU9UaHZ3cUc2a2t3Z2cyc3pINW4vdS9RVlRpMVNXUnRxeGhzblBBSXgrV08xU3kzNFNWU0k4TnhqSXhqMzRvNVpCdVQrVklRQTQrWnVlUmtEQTU0cVZSSzZ1c1NGdHVBV2NsVXgzNmQrYXJyZk00REVLd1ljbFZ3UWM4WXhUMDh0bWxOekpKbk9GYk9CbjJHU2YwcWJkeXJMb0p3MFpKZEFWR1I1UzVQOEFQK3RDNG5kY2IyeTMzNUZKK21Cbkh0MTl2YW5SeFI3ZzBhNVVaSXdTKzNrRDE2L2tEVWpwTERLTmgyWkpHMHNRVDd0ODNINjlhZDBPeENQT01rcUs3cXdJemhNQS9nUHJpcC9KbThvbktQZ0RHNDRmUDY4MGp4enlSZ21aaU9teU51UG9lOVF2Yi92Q3JUSGMzQVhkbjg4a2Y1N2RhVndzUGRKbXlmUHdjRWdiY2tmUTg1Tk1XT1NOU2sxNFVIWWJpcC9sL25QdFMvNlFZd3FOMSs5SXk0eU80eWVlY1ZVa3VTQXluWUhPZHdhTE9EbjFQV2dMRm1MNURtSStZT1d3Q0JuL0FJRjNINDFJczdRdnVraWppTERraGh3UFlaUHJXY1hRN256SEhnOVdCNUg4L1hybjlLZEd0dXpGaVYyamdESndUbjNISDVVTWFMajNUbFNJcGpJTTdTVytVL2x6bW8wdkpRQ0dpVUFZNWp6MHBQdEE0QVlJM1FsT2d4anZUa3VJbFZmS0JaanhtUURBejNxUm1icUNMTGNQSnRLZ2p2Ni8xcXNtVklHZHJFQTdoMElyUnZDMHdqTzVRTTdTd1hnWnJLdXA4RWMvTm5IVC9QV3FSTFJxQjI4dkxURHBuYVJqTlN4WGhLdWt1VUQ4aGw3Vm4yek5JbVd4bi9hTlNzYzRVRlNSd1FEbk5UWUMybG5CSXBkNW5iMkF4aXRTeHNZcGprUm9zYUhKY1lKSXFucGRrSjJLc0NNOEZmYXVwdE5MV01FN1NPT01qUHZYTlZyV2ZLam9oQld1eklXR1Q3V3FPUGxCQUFJNUl3U0NPTytPOUxkWGtZbU1VQjJiY2dra2Mvam10dDdFaVE3Z1FvR1FGYmxUNi9YMzlxeDdyVFR1YVRsMkp5V0p6bjhlOVRHdHJxS1VFbG9ZdDlNeXN3RWdHVzVQUFA4QW5yVkkyN01xSHpBbzY3bGZPUHgvR3RHV0ZJNFowbHprZnZGNXdXL3pqOWF4bHVWVk5zanVyWStYdlhaQ1Y5akN4WmRXVURMbG1HTU9Sbi9QR2FxeWxRMGFCMnd4SDUvU2xOK3ZLeExsUDlya24xd0JWV2VRR1BjcWdFOVFUMXozcWtNdUMzaUR1NUdXenp0UFArZi9BSzFMYXMwUlpXQ3NBZHdaUnozSEovR29YRE9qWlh5OE1Oelo1NlZQWVMrVEcwK01nT3E0STY4OURTbHNDTHR4NU1kbzBmbnUxeHUrYzhCTWNqajF6anZXU0VXMHQyTHloMmtMa2hHNjVBd0NmMXJZdUxlT1ZVYmNkcmovQUZqZWhMZHY4L3JXVEpmQzJnQ0x0azh1VUVHU0VMN1l3T2NkS2lHdXdwS3pOSDdkREpiNG5sbVpzZ2JTdkdmUTVQdDJQcjBxS2ErdDR5WGlpU0hkeWdhVGVmeEgrZWxZOXY4QU5jUXEzSzhjSHAwTkY4b1c2UlZBQ25PUU9oNXJxNVZjenVYMjFtWUU3QXJ5dHdaU2V2SHFmOCsxRUdxWFN6RU1rYmJ1T1ZMRWZUR1AwcXU2Z1FSNEFIeWcvcTFhTnFvT2w3eUJ2REhEZDZUU0JEenJGNGQwUWlTSGpKVkY1UHJtb1RxbDBWSVNPS0lFampaMTYrcHFwYmZQZHVIK1lIMTU3MDJBbHl5TVN5Z0VoVHlCelNTUTdsMU5UdkNoOHNxcUVGV2M1SFBmL0k1clBtVGR5V1ZzNTZOa24vUHY2MVlsUlJjSUFvQTJFOEQ2MDYzQTJCZXdUSUhvYzBlWS9JeXBwRkVxcStRb0JBMmtFWi9yU3hOSTBaY1JZQUpCSlhQR085VDNDcUoyd0J3ckVjZEtvdXhGcGdFNDJEaXJKTkczdjJSRlV5THRicU1kS3Y4QW1RdEdjSXJZQk9jNEFQYmpIU3ViZ0pFallKSE5iYWdDM2dBSEJKejcvS0tMQWFTdXF4YmlDT2ZrMmp2Z1ovci9BSjRxM1p0NWlGVlp0KzRsaVVCeHp6am5qbko2VlNVQVMzSkFBd3dxMVpPNW1JTE1RQndNKzVyS3BzWERjMG9vcG8wWUM0Y3VjWXlRUjljWS9LcThzZHhGSUNUS3lIcUJsajc5TzM0VmEzTjlxbVhjZHZCeG4vYU5KSXpOSXdZa2dOd0Nlbnltc1V6WGxSUU1ublpqQmozSWVqRXFSbjI1R2Z6OTZjcndSUStVZVR1QllpUS80RFArZnhyeHFGblJRQUZLZEFPTzlSUWdOYWxXR1J0SndmcFYySXVXcFl5eEVxYldpUWNoVlBUMzV5Yys5UmN6VzRNY2VPUUNqNEkvbnhUbFJWV05sVUJ0M1VEbnFLdjdGSXVXS2drQmNFanA4dWFXdzl6TmRHYVFTU2lNcWd3aW9NY2UyZlNpR09RamJJTmlaeW9BNSt1ZmZpcTByTUwyNElKQlYyQzg5T3ZTcElKWkJjS1E3WjNqblAxb1lMY2ZOQUJNWEhERnNjTVB3Ny8wcUZVTEtJakw4bzZGeHgvalduSjh0dE9Sd1JBcEdPeEpPYXliVm04ck80NTJNYzU3MGs5QjJKVWNFaEZWUm5BRzFjYzU2NDlheWJ1R1Q3V1M0eDN6NjF0a2tiR0JPNHJ5ZS9hcXVwQUZZaVFDZHcvbFRUMUUxb1FXKzM3T0dJVWtuSTllQnpVcWlOaXJCaVgzY2dqaWlUNWJwUXZBODdISHBoYWk2YXB4eDJvZTF4SmFuYmFGYUJrOHpBNDZjMTBUZktva0RISU9DQldMb25FRFk0K2F0UmlkNUdlRDFyejRhdHRtMHV3NlIxSEJUTEVudnhqSGVxVEs3VE1yb3JLZXcvejcxZWxBMnljRDdvL25VY1ArcVBzYXU1b3FTZXBnM1dpQXBLNEgzdXhIcU9hNWk2MEFSSEw4QS9sWHBRNWk1NSthc2UvUmZMYjVSMzdWRHJUakxRMWpRakphbm43V3p3SEVZSzR6azRxR1ZRMXVOb0Vhb2ZtUHJtdG01SjJ5RFBISEg0MWgzWkp0bkpKSjgzK2hydHBUY2xxY3RhQ2c5Q3lTdm03c2Vad1BsOWdPYzFDcnNBanJ4ODI3Ym43M0g2OUtrUWtsUm5nakJIcnd0T2lKKzNvTW5HNGNmald2UXhKVXU1WkxBUmIvQUpVdzIxL1RyajM3L3dDUldaTGo3VThvWUdQWVR0UFgxN0dyZ0E4cUVZR0RDQ2ZjN3FaSW84K1FZR05nNC9DaUtTMkU5VC8vMlE9PVwiLCBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELy9nQStRMUpGUVZSUFVqb2daMlF0YW5CbFp5QjJNUzR3SUNoMWMybHVaeUJKU2tjZ1NsQkZSeUIyTmpJcExDQmtaV1poZFd4MElIRjFZV3hwZEhrSy85c0FRd0FJQmdZSEJnVUlCd2NIQ1FrSUNnd1VEUXdMQ3d3WkVoTVBGQjBhSHg0ZEdod2NJQ1F1SnlBaUxDTWNIQ2czS1N3d01UUTBOQjhuT1QwNE1qd3VNelF5LzlzQVF3RUpDUWtNQ3d3WURRMFlNaUVjSVRJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXkvOEFBRVFnQm1nRkFBd0VpQUFJUkFRTVJBZi9FQUI4QUFBRUZBUUVCQVFFQkFBQUFBQUFBQUFBQkFnTUVCUVlIQ0FrS0MvL0VBTFVRQUFJQkF3TUNCQU1GQlFRRUFBQUJmUUVDQXdBRUVRVVNJVEZCQmhOUllRY2ljUlF5Z1pHaENDTkNzY0VWVXRId0pETmljb0lKQ2hZWEdCa2FKU1luS0NrcU5EVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnNFNGaG9lSWlZcVNrNVNWbHBlWW1acWlvNlNscHFlb3FhcXlzN1MxdHJlNHVickN3OFRGeHNmSXljclMwOVRWMXRmWTJkcmg0dVBrNWVibjZPbnE4Zkx6OVBYMjkvajUrdi9FQUI4QkFBTUJBUUVCQVFFQkFRRUFBQUFBQUFBQkFnTUVCUVlIQ0FrS0MvL0VBTFVSQUFJQkFnUUVBd1FIQlFRRUFBRUNkd0FCQWdNUkJBVWhNUVlTUVZFSFlYRVRJaktCQ0JSQ2thR3h3UWtqTTFMd0ZXSnkwUW9XSkRUaEpmRVhHQmthSmljb0tTbzFOamM0T1RwRFJFVkdSMGhKU2xOVVZWWlhXRmxhWTJSbFptZG9hV3B6ZEhWMmQzaDVlb0tEaElXR2g0aUppcEtUbEpXV2w1aVptcUtqcEtXbXA2aXBxckt6dExXMnQ3aTV1c0xEeE1YR3g4akp5dExUMU5YVzE5aloydUxqNU9YbTUranA2dkx6OVBYMjkvajUrdi9hQUF3REFRQUNFUU1SQUQ4QTZIYlJzRlQ3S1RaNlY5UnpHSEtRbE9LVFpVK3cwb1NqbURsS3ZsWjdVdmxBVloyVWhRVWN3Y2hXS2VsUk5IbnJWM1ptbWxLYWtEaVVUQ0RRSVI2VmI4dWxFZnRWZTBKNUNyNUE5S2NzQTlLdUxFeDdWSUlBT3RTNmhhcGxNUWdkcVF4VmNhUEZNTVpxZWNya0tUUkExRVlSMkZhUGs1cGZKQXF2YUM5bVpuMlludGlqN01CV2l5WTdVd3g1bzlvdzltak9NSG9LVDdMbnFLMFJENjBGQXZhbjdRUFpvei9zNFVkS0Z0MTZrWnEyd3pTYmVLZk94OGlLRjNGdVhBRlp6MnpWdE1NbW9XUVo2VmNhalNNNTAwM2N3N2kzUDJXZlAvUE52NVY1VGRvY0F0ampISDUxN1Rjb0JhemY5YzIvbFhqZmwrYWt6YlFRdUd5ZTFlRG5FcnlpemVqRGxSMXRuRXI2TGJrOE5HUWMrdVJYU3l3SGNlS3dkSGk4elNvenU2Ykc1Ny9JTTExMGdHYzRyTGgrVFRuL0FGM05jYkZOUk1vMjVQYW1HMk9jbXRJZ1ZHd3I2bFRaNWpwb3pqYlpxTTI1clFZWXFKcXRUWkRnaWlZT09sUXREN1ZlYkZST2ZRVmFreUhGRkl4ZTFSbUhQYXJiR29tSnEwMlp1S0twaEZSdER6elZwbXFOemlxVFptNG9yR1AycGhqNzlLblp2UVZFemV0VW14V1I3VDVaSjZVNFFqdlUxRzAxODl6SHZjcEVVSFlVM3k4MU5pbkJDZWxITVBsSVBMQUdBS2I1ZWFzRldIYWdJVDJvNWg4cERzSFRGTU1PYXRtSWdVbTMybzV4OGhXRUZQRUlGV05sTklwY3pCUkdiQUtRcFVsSjBwWFpWaUl4MGhUQXFYSXBwWVU3aFpFUlNtRlQ2Vk1XRk5NZ0hhcVRZckloMkgwbzhyMXA3UzFHWlNhZW9uWkR2TEZSU0pucFRqTGdkYWlhVWVsTkppYlF6eXdEelNNUVJnVXgzSjlxaUxrVnBac2hzVmx6MDZWRXlERkJsTlJOSTNQTldreUcwaGs4WU1NZzlWSXJ4bTVkQkFvVUZBeVlmanFSbi9HdllaSkdLTU05alhqTnd6U3hBdXcycUNBQngweC9qWGg1dXRZbXROMzJPeDBVci9aa1o2TjhxajEyN1JYWlNHdUdzR3hwOXVDNFV0dDZEMnJzWGNrRDZWamtQeHpScGpIN3FCeUtpWnhTRjgxR1RYMWFSNWprTlpxaFpxZXhxTnZhdEVqTnNqWnVLaFpxbVBPYWpJRlVyR2JJR1krbFJNMVRrRG1vejlLMFRJWkFUbnRUQ1Q2Vk8zc0tpTGM0cG9oa09DVDBwTm96elVwSlBIZWp5ejFwM0pzZTRDSG1wUkdBT2xUcWhOS3ljY0N2bVhJK21VU3MwUUpwVmp4VmhJU1RVaGhwT1krVXBsTTlxQ21PbFdUSFRTbENrRml1UWFhUlU3S2FZVU5VbUZpQTU3VXc1cXdZL2FrTVJwOHdyRlU1elNFVmE4azBlVDYwK1lYS1VtelVaejZWZk1OTk1RSGFtcG9YSXlodFkwZVdhdW1NZWxOOG8rbFBuRGtLWlErbFJsRFdnWWhqazFDNEFHQlZLWW5BcG1QQXFJcm1yTGcxR1Z4MXExSXphSzdMZ1ZBd05XWDY4VkV3TlhHUkRSV1lWRXlZcXl5bW9uV3RFeVdybFZremtaeG12R1p3TU9HQUp4bkk3R3ZheWgzVjRyT3dqbkRnODU2R3ZEemQ2eE5hU09oc0J1czRDd3lBaWZ5RmQwNmdxTUN1SXNXYVd5QWJBd0ZJNDZuaXUrRVpNYW5IWVZoa1R0T1pyaTFlTVNwc0hwVEdRZGhWMHhIMHBqUisxZlU4eDVyZ1VESDdVd3gxZU1kTU1kVXBrOGhRTVhiRk1NVlgyanFOb3hWS1pMcGxGb3FpTWRYbVFWR1ZXcVV5SEFwTkgwcU5vL1VWZUtqMHFJclZLWkxnVXhIejBwU21CVnRZOG5wVEpFeHdLT2NYSWU3aUxGUDhzVXVhWE5mTFhaOUhZVGFCMEZOWVU3TkpRQkhzcENsU0dtMVZ3c1JtT2s4b0NwQ1IzcHBZQ25kaFlhVlgwcHUxZlNsWTVwdWFwQUljVXdrZWxLZXRNTk1CRGowcHBOS2FhYXRBTlpzVkUwaHA3QW1tbVBOUFFuVXJ1NXFKaWF0dEZrVkg1WHRWSm9UaXlvUVRTbUhDNXEwc1hQTks0R0tmT0xrTXRrT1R4VVpRazFvRkJVYktLdFRNM0FvbUkweG9qVjFoaW9uQXErY2x4S1hsODE0YmRRNWxseXdBWGQxOVIycjNodW9yd1cvYy9hcEIvRDVoNC9FMTVHYU83aVZGYUhSNll2OEFvcThrNTIvenIwaEYyeElQUlFLODhzSTRvOU90Q3N1V2RBU3ZvZHhGZWlvRDVTLzdvcm55Wi92Sm1sZGU2aGhBcU5oVSsybU10ZlNxUnh0RlpnYWpZR3JKQXBoQXEwek54S3JLVFVUUnNhdHRURzRxbElseEtiUm1tbUdyUnFJOWF0U1pQS2lzWXNVMHhDckRjMDBwbWptSjVVUWhOb3FLUmU5V3ltQlZka0p6VFVnY1QyL05HYU1lOUdQZXZuYm50MkUzVW02bllIclNZWDFvdUZocEpwdk5TWldqZXRGd0k4RTBtM0pwNWtXbU5JTzFOQUpsUWNVMWxPYVp5VFM1YjBwZ0JGTklvTEdtbHpWSzRCdHB1M21ndlNHU25xQXBXbTRGSTBnOWFZWHBpSE1CVVpJcEdlb21rcHBBT1pxWXg0cUl2azBoZXFzSnNVbk5SdFNGNmpacTBTSWJCalVUWW9acWlacXBJemJJMlB6Q3ZDTlFVcGVTNUgvTFFucDdtdmRHKzlYaCtvQlUxU1paZW05K1B6cnlzeit5T094dGFYa1djQllaNFVjZlVWNllqZnVrL3dCMFY1bnBqLzhBRXZ0ODlEamdmV3ZUSWhtR1AvZEg4cTU4bWY3eVpyWFh1b1hjYWpZbk5TN2VPbElVNHI2UzZPVGxaWE9hWVJWa29NVXdxdFVwaTVXVnl0TUsxWktyVENCMUFvNTBUeUZZclRTbFdDUGFta0dxNWllUXIrWHhtamFGOTZsSTVwL2svTDcwT1FLQlZZWkZSN0FPMVROR2QxU1J4ZHpRNVdEa2JaNnhrMGhCcVhZVDJwZkxOZUZjOWF4QmcwWU5UaUgzcDNsTGluem9MRlVxYVRZYXViRkZOSlVkcU9jTEZUeXo3MGVYVTdTTFVUU2oycDNZV0diY1V3c000cEpKZU9LcmVZUWF0SnNST2V0TWFtZVlDS2FYcWtnSEdtRTRwcGVtTTlVU09MVXhucHBKcGh6VklCUzFSa2ttbjdjMFlIU25jTEVPY0dtTWFsS1pOSjVZcDNJNVdRdFREVTVRQ203UlQ1aGNwWEk1cGpLYXNNQUQwcGo5T2xWekV1SlZaYThKMTk5MnAzRzNPUE5mQXowNXIyYnhEcUV1bDZSTGVSQk55TW8rY0VnWllEb09lOWVhTnBGbnFyUE41amVlN2IzSSs3eWNuQXJ5c3drbTBnMFdndW1zRTArd1pnR0RBanAwK1kxNmRiLzhlMFgrNFA1VjVWSmFmWlhTSDdRcVJJZVBueVIrbnJpckR2ZDNKRXMydHplVkVjZ0NRakFIc01ZNHpYRGc2bjFlY3BQVzVVcWlra2oxQm5STTdtQXdNbko3VlNsMWZUb2lSSmYyeUVkbW1VSCtkZVh6RTIxOUhHMTA4ckpsdk1rY0hqcUJnKzVOVmJTY3U3Z3haWjVOd01ZT1IrbnJpdTk1bExvakxVOU1tOFQ2UEVjbTlSZ0RnbU5Td0gxd0toWHhOWnpLVGJ4M0VweVFNUjRCeDM1NkR0WENpMysxU3UxeFpTQlMyUzBVWlA4QVRCclhpbW5zenNFTTBpc2VDVlVmblVQTWFyMlFyTTFOVjhSM2NhcUxDQlU0TE0xd3BQSHNBY1orcHFTMzFMVW9uS1hUd3pFeGlWU2taVVlJQngxcm5yMkc2a0pER09ESUpHVzY0N2NEcWEyN2lUeXpFU0FTbHBHRHRQWENmNS9LdURGNCt1bW5HUnZRcEtmeEhRV014dTdPT2RsQ2xzOEEraHhVK3dlbE0wYTNWTkd0ZXZLYnVmYzUvclY4UkwzcjZURFZYS2xGeTNzWnlwNjZGUlk4dDBwN1JjY2RhdHBEazRVVVN4RmExYzlScW5aR2NVNTZWSXNYRldraExucGdWTTBJVmNDazZnUnBub205ZldtbVZSV2VaMjlhYVpTZTllYnlIWFkwR25BcU5yaXFXNG1rT1RUVUVCWmFjbnZVUm1OUjROR3dtcXNnc0swaE5SbGlhZnNwTmg5S2FDeEVTYVRITlM3S1RZZlNxdUt4RVY5S2FWTldRbWV0QmdOTG1IeWxYYWMwaFUrbFd2SWZzS1BzN250VDV3NVNwc1BwUjVmdlYzN01lOUo1QjdDbHpoeWxVUmdVeGt6VncyemVocFJiSEhOTG5IeWxEeTZUeWg2R3REeUNPMUhra2Z3MC9hQnlHZjVYdFNlU1BTdER5aU93cENtUFNqMmdjaFErei83TkliY0RxS3VrRDFxTmdEMk5IT3g4aU9TOGIyMi93bmZLaTVmQ2JmcnZYRmVTMjJqYXVaeURkZVc3REJDWXlRT2Ywelh1bXJhZkZxZW56V1U2djVVb0FiWWNIZ2cvMHJ3SFZyM1ZyWFVMMjFGNHl3eHl0R0J0SEtnNHdlUGF1REZhdlU1NjlOM1RScHg2SHA3U3VzNzNNOXlGM2ZlT09mNTFjWFN0SVY3YUo0MURTSEFYa2xzKzRyazdkcnUyZTFrTHV5dHlQbUlBendjWTZWN3JvbmgyeGswMjB1alkyb2xsZ1JtY3hLV09WSFU5YTVxY09kMnVLRkZzNUM2dE5OdDRpNnBiSkpHbWRuQTc0L09zMHpPdW5Bb1hrbWtIRWNLWkk1eU00L0N2V285SnQ0UHVKSEdmOWhRS2ViUk81Si9HdDFnOWI4eHI3RThvaVhVV1JWL3MrOWxZQW5jSVhBeVIwR1JWazJPcDNkcWtiNmRPRHVEUHVDRE9PY2Nucm52WHB2MmVNZEVwalFnZEl4K1ZiTERSUzNKK3JJOGY4UzNjdWtmWjRieTFZcEpHd1hvV09NY2tnOGRhMWRQZ2kxWFM0dFVsdVZqdGpGNWZsRmh2RzNJNkQxcUQ0cnJ0azAvNUFEdGYrbFkrbWFoZHBvdHZieFNnQlFNSzREREJKUGV2Snh0T0syN21sS0hMT3lQVHRNaURhZGIrV3JDUFlBb2JyZ2NDcjR0L1UxQjRmdDUzME95YVRHOHhBdHRHQm10cU95SlB6VjcxQ3JhbXZRZnNpa2taQXdvcU5rSk9DdWEzQkVpTHQ0cU13cjFCcS9hbCt6TWZ5bUE2WXFOZ1FlOWE3dzVxRm9jZEJUVlFYc3pjMkNsMkNqUHZRRzk2eXVPd29XbHh4U2JoNjB1VjlhQXNKZ1V2NFVaWDFwY2lrRmhLVEZQNG9KVWQ2TGhZYmoybzI1N1Vwa1VVM3poUnFPdzRMVGhVSm1wUE5QcmlpekFzWkE2bWdNdnFLcUdRSHF3cFBNakg4VkxsQXU1WHVhUXpJdlRtcVhuUi9Xanp4MldqbEdYUHRBL3UwbjJnOWxxcDVybm9CUnVsUGNDamxDeFo4NS83b3Bwa2M5U0JVR3lROVhwZks5WG9zZ3NTSEhlU21sb3gxWW1rOG1NZFcvV2wyd3IxSW8wSFlRVFFyL0RtbE53djhNV2Z3cEJMQ3B3QlQvT2p4eFNIeWxhV2FRZzdZc2ZoWHpUNG5rVCszNzhjYmpjdnV3ZStUWDB4UGNZQndLK1pmRTRWdkVWK01BSDdTL2IvQUdqWEppRnFqS3VyUkw5ckhISloyWjJnNDdINjE3em9ObXphSllIZng5bmp4LzN5SzhJMDlBYkd4QnlSdHlUbjNyM1hRN3Jab2xpdS9wYnhqL3gwVnk0Sy90SkpGMDlsYzJGc0ZBNVltbml6aUhhcXB2QmpsalNHN1VqbHE5UzBpOUM1OW5pWHNLWTRpVWNiYW9TWHlLT29xbkpxc1lGTlFrd2NranpYNHlzRGQ2Y0Z4Z1J1ZjFybHRIY0Myanp5UXFqOUNhMmZpeGVDNHZMQUl1Q3NiRW44ZW42VmcyTGo3TENlZ0tKay9oLzlldkl4a2JKcG1ITXZhdXg3cG9Vb1hRN0VZNUVDZnlyUk14cmx0TzFYeWRPdGtBSHl4S1AwRldHMWxqMHIyS0ZHWElpdmJSTjEzSjcwemV3L2l4V0EyclA2MUUycVNrL2VOYit4a1Q3ZUowWmNuK00xR3orclZ6amFsSi9mUDUxR2I5Lzd4L09xVkNRdnJFVHR6S2FCUDcxUk53UDcxUnRjQmU5Unloem8xUkptbDgwMW14M0trZmVwN1hTZ2RhT1VybVJmODZsODQrdFpEWG96MXByWCtCd2FQWnNYT2paTndhWWJnMWltL2MwZmIyUFUwL1pzWHRFYS9udFRUSy9yV1NiNXV4cHB2MjlhcjJiRDJzVFhMdDNZMDNkNnRXTTE4NUhXbUc4Yzl6VDlreWZheE53T2c2bWd6eEw3MWhmYVdQYzBodVRqclI3SVBhbzNmdGNWU0xlUjQ3VnpmMmsrdEtMbzQ2MGV4RDJ5TnlUVVFyWUdCVGsxUlNlUlhPTk16bms4VW9rSS9pcCt4UWUyWjByMzY0eURWVnRTNTYxaUdadjd4cUl5RTgwS2loT3V6b2t2ZzNVMURjMzVVYlVQTlkwY3hIZWg1eG5xS0ZTU1kzVzBMWXVKZzRmZVRXbkhkdXlqR0t4NFoxeDFGVHJkSXZPUlNsRy9RdW5KZHk5UExkWXlxZ2o2MTg4ZUpuQjhRWGhJK2Y3UStmOEF2bzE3dExxYWdmZS9XdkNmRWhENjNjeVkrOU8zT2Y4QWFOZWRpMDAxY1ZhU2NkR2F1bXMzMlMwQUgzUUQvSTE2YllYMHlhZmJoU1FCRW9BSGJnVjVucGczdzJxRHFVNHhYb01EbU8yaVRwaEFQMHJteXBYclQvcnFUT1ZvcXhvblVadTdta0dweWorS3M4eVpvQXpYMFBKRTUvYVM3bDE5UVp1NU5RaS9kR3pnVkdGVCtKZ1B4cDRFSDk0R2hxS1FKeWIzUFBmaVBkK2ZmMm55NHhDZjVtcyt4VjJ0SWNESTJxTUQ2Q3J2eERhTCsxclFJTjJJYzRIKzgxUmFTTjBOdXVPTnFzZWZZVjh6ajNxL1UycC9HN25mMno0dG9oNWVjSXY4cWwzc2Y0TVZEQk50dDR4eHdvSDZWSjU0UGV2b3FIOE5HRDMzSGhqajdtYWRrbitDbzFsejNBcHhrR09aQVB4clZqVmgyM2NmdTBvaHovZEZSaWFIdklLa1NlM0hWODBtMlVralZTN3kyR2JtaVdjS1I4M1dzVkxwaktNWUpBNXFlOHVIVnVnK3REaDd5Umg3VFEwQmNFZDZVM0pQZXNuN1YvbzVZSGtHbWZhK2FwUXVMMnBybWMwMHpWbGZheWFYN1VUVDVCZTFOUVRGZTlIMmpOWm4ybWo3UlJ5QjdVMGpMNzBubWoxck5Oemp2VFRkSDFwOGd2YW8wL01CNzBlWUIzcktOMGNkY1ZHMTBmV2prWWUxUnNHNEFIVVZHYmhmV3NnM0I5YzBodU1EclQ5bUwyeHJtNFdtbTVXc2czSHZUVFA3bW55QzlzYkp1bHFOcnpCcklOd2ZXbWVlZldqa1FlMlpybThQclRXdkQ2MWttNDk2WWJpcTVFVDdWbXFid2c5YWphNkxIcldZWi9lbUdjNTYwK1JFdXF6V0Y4eThacGpYckgrSS9uV1daelRmUG81RUwyck5JM2VlOWVZNjI1L3RHWE9NZVl4L1d1NE0vT0s0ZlYwUDIxaXg0THNjL1d2SXpOSk9KdlJuYzM5QzRGczdkbFA0SE5kYzF6ZzllSzUvd3ZCNThDSndlRGdudVRWNmRtam1kRzRLbkJyaHlaWHJUT2pGUzVZeE5IN1dSME5CdkdQOFZaUG1IMXBQTVByWDB2S2VmN1ZtcWJyM3FOcm84ODFtbVUrdE1hV2s0Z3FoejNpNlhkcVNTRTgrVGdEOFQvalZ6U25SYmVOaHhuR1BwdHJIOFVIZHFDRS84OHNEOHovalYzVGtKZ1RITzFBZjBGZkpaakZjejlUMHNOSTdEN1NWVUFIZ0NrKzFuMXJPYVFqaWtNdGZVMEkrNGp6WjFIYzBUZG4xbysxbXMzekQ2MGViNzFyeWsrMFpwZmFqNjBodWpXZDUzdlFaYzB1VWFtelpXVXM2ak9HempQclZ2VVpDSkJ6eGpOWlZzKzY0akI2YmhWbThuRWtTeUFuSVlnNXB5WHZvYWw3ckprY3RaeWNucjBwaGxPQWZiTlFST1JBQnpnZzlQOCsxTmpZN2NlaWtVWHN4N2svbm4xcFZ1RFdmNXZOS1pEbkZhOHFNdVptbDUvdlI1NXJPRXBCeFVubTVGUzQySHpNdG1hazgzaXFoa3BETHpTRmN0R1hQZW1tWDNxdDUxSVpjMEJjcytaVGZOTlZ4S0JtanpCUU81T1pEMnBDNXgxcUh6QUtReUNsY1pLV05KbW96SU94cHBrR0tMaFlrTEdreWZXb3ZNRklaUjYwY3dyRXZQclRlbmVvakxTZWJUdUltcHBOUmViVGZOb3VCTDNyaTcrYnpOVWxVb0JoaW8vbFhYQ1Qzcmp0UUczVjNKUFZ5ZjFyeDh6MXNkV0hQU05Cc1k3alNiRllBVU1VUmVTVUg1U2Q1d1ByaXF0MjRsdVpHQjZzVGswend0TTZ4Q01FN1pBTWpQMS94cUc0YmJNNmc5R0lyZ3lWcjJzemZHTDNVQk9LYVR6VVprT2FUelBXdnBlWTg2eElTYzAwODB3dlRTeHpTbExRYVJ6bmlJZzNxQWpuYjFyYXRidUw3RWtVVUxCMWpYbk9kM0hQYXNMeEQ4MSttZjdvRmRsbzkvcG1uV2UwV3dsdVdqUmQ2Z2pHVkhxVFh5T1lXYy9tZXBodGlCemtrMHpOTmR5WE5NMzE5WFNsYUtQTG51UDNVYnFqTEgwcHU0NXJUbUpzUzdoUzc2ZzNVQnZlam1Ha2RCYld6eHo3aVFkb1lrRHFPRFVvU2E2dFpGRUVtNVRrZnV6eVB5cTMvQU1JdHF4ang5cU83L3JzZVAwcU4vQ09yc29CdmYvSWgvd0FLOGI2N2lHN3VKNjMxU210TGxZV2x3a2NibUc0NE8zQ3hNU1B3eDBwMGNVeWJpMXRjQWRqNUQ5UHlxWWVEZFdPYzNrWkhZRmljZnBUditFTTFQamRkeGZnVC9VVS9yZGQvWkQ2dFQ3bVk5bmM3OHJiVGJkM0oySC9Dbi9ZN2gyQkVFdU9QNFNNMWYvNFFlL0pKYThqWWUvOEErcWsvNFFTNklBTThJUGM4bitsSDEzRS95aStxVXU1VE5oZERjUmJTRUhQZFIvTTBMWjNoQS8wVnovd05QL2lxdkw0Qm1WY2ZhNC8rK2Mwbi9DQVRZT2I1UCsvZEgxekV2N0lmVktYY3BmWXJzOGZaVy83K1IvOEF4VkliRzh4eGFrdGpnR1dNZit6VmUvNFYrNDYzcW42Si93RFhwbytIcEdmOU5IdGxEeCt0SDFyRTloZlZhUlJXd3VzZnZZVlJ2VHo0ei83TUtIMCs1Q2tnUlo3YjUwQS9tYTBCOFB5TWY2Y1ArL2YvQU5lbi93RENDWVVBWGFmWHl2OEE2OUgxbkZkaHJDMGpLK3hUQmNtUzJIMXVFL3hwR3NwZ29ZVDJRSHExd0sxbThEdWR2L0V3T0IyMkgvR3BHOEZsOW9rdmR5RCtIeS8vQUs5UzhUaSt3MWhhSmcvWlpDUWZ0dW5ZN2o3UjEvR25wWlN0MHV0Ty93REFyLzdHdGsrQ0l3Zmx1VUE5UEsvK3ZURjhEWXp1dnlmKzJZL3hvVmZGZGcrcjBqRmVEWXhWcjNUaGovcDVKLzhBWmFpa0NvdVRlMkgvQUFHUjIva2xkQi93Z3lZeDlzYi9BTDQ2L3JTbndSR2VsNHdIY0JUL0FJMG5YeFhZRmg2UnpEWEVDZzV1b1NmUlEvOEE4UlVMWDF1dU4wZ0E5Y0hpdW1rOEJvNS80L25BOU5uL0FOZXFjbnc0VnpuKzBueU9oOHYvQU92VSsxeFFQRDAxc1lIOXJXWklBbVk1UFZZei9VaXBXMUt4WWxZNUpndy92UmovQU9LclgvNFZ3QUFCZTV3Yy93Q3Ivd0RyMWFqOEF3cklHZTZMWUg5ei93Q3ZVT3JpMnhxaFRPYlMvaENaa1oxYnR0aXlQejMwb3ZMVVpKbWxCOVBzK2Y4QTJwWFdyNEt0Z1R1blpobk9DZ3hXbXVnV1NEaTJzODR4azJxSCtlYVRxNHREK3IwVHp0dFJ0ZW5uT1A4QXRnUC9BSTVYTzN6ZVpxWlBWYzVCeGpyelhwcmVDTEpYWnZPa3dld0E0cnp6V0xZV3V1U1FqbFZZcXBQZkZZMXBWVzE3UVBaUmo4SjJPaFJIYkNRU0NUL2pYUDNtcnZIcWNxRmRxTEl3QllaM0N1dDBLUEVFVDlDQWZ6eWFiUDRIc3J1VnBaSnBjdVN4eGpqTmNHWHVvNXo5bWJWb1JhVnpsVHJNT0dJakxiZXBCNy9sVU1ldFpaaElnNm5idEk2ZmtlYTZ3ZUJMSkRnVFNCZm9NMDArQTlQWmdXbG40T1J5UDhLOVcySmZYOFREMmRNNVk2czI5VjRVc2VBVXpWazN5a2diV3o2YjF6LzZEWFRqd1pZWUdXbU9QVmgvaFRtOEtXSUp3MG95T2ZtLyt0VThtSzcvQUlsY2xFODMxaVlTWHFQdFljRGhpQ2YwQXJZVnR0M3Mvd0N1WDQ1VmFxK0tOUFN4MXBZSWQzbGhCMU9hMkliVU5QRzUvaTh2L3dCQkZjR0lrMDBwYjZqcFExZHRpaStyeHJuNUhPTys5UDhBNGlvanFNamJYREhaM1hDOC9qaXRpMzBmUkx2V24wdUsydTJuREZTMlJ0eU9ldWExWmZCbW5Rc1lXU1hLSEJHL3BYYkIxWlBrakxVejVJNzJPVGZWZG9CR1RrK3Yvd0JhbURVbmRtRzNnY2ZmSXJxajRRMHc0SldUai9icEI0VTA5ZUFraDV6eTFhK3h4RDZrMmdjeTE2MkI4bkkvNmFOVGZ0YkZ4bEJ6eC9yWEIvblhWTjRZMC92R3gvNEZUZjhBaEdOT0RoeEcyNGREdU5Db1ludVYrNzdIcVFIdlR0dE1BUHJUajA2MTZCUXVCUnhUUXZ2UmdpZ0JUN0NsRkorRkdLQUZJK2xKZ2UxR0I3MGhBOTZBRUorbEg0aWp0U1k3MEFKem1rT2FjS2F4cGlzSitOQitwcEQwcGFBR25GSlNuNlVVQU42MGhweHBLUURTS2JqMHFRbmltRTRvR054N1VtS1hkU0UwQ0RGQkhGSnVwQytLQUk1QU1WNUQ0aTJSNjdLekFFQ1FuSDQxNjVJOWVUYXdBUEVNeGZkaG5iR2NlcDZWNW1ZUGI1bWtEc2RHK1d6WHR3M0g1NHJvMHhzWDZDdWIwbDgyQ0hJNk54K0pyb28zQmlROWlveFhuNUsvM2t6WEViSWVRS1p4bWxMMUcwbU8xZlNIR0tTQlViVTFuTk1hUnM0R0tUQk04NzhZU2h0ZW5qWlJ3aWdONmNDdWdodGxTRzNIY3JIei93QUJGWTNpU05wdGJtVlI4ekJRRDZjQ3V0dExRUGJSU0VqS0VBbjZDdmxNZFA4QWVwZVozMFk2TXhQRDhqSjQ5bjI0UDc5c0RIcndUK1ZkaHFBeGZ6NTVPODF4L2hYTC9FQ2Nqbjk5SVA1MTFXb09XMUNmQi9qUHJYcDRIL2VwdnlPV2Z3a1JIRk5OUmxqajVpVFRTeW5vT2ZldmFSejNIazlhWWVuWG1rSkFYbjlLalBQYzRwaU85eFM0elNBalBXbC9Hc2JuU0dLTWZTajZHaW56QllNVVlGSGFpbGNCY0NrTkpta3lhTGhZRFNab3o3VTBtbmNCeE5OSkZKdXB1YWR4Q2swbWNVMG5ta0pwWEFkbWszVTNOSm1pNENrMGhOSm1tazVvdUlVbm1relRTYVFtaTRDazhWWHU3MjJzWWZOdXBraFRPQVdPTW4wSHFha2tkbFg1RjNPZWcvejJybE5XOFBXc083Vy9FZXB0SktrcW1DQmVGQ0E1SVZRYzU0NjUrdWF4cVZsQjI2aWQ3YUhWb3dkRmRlakRJeU1VRTFWc2JnM05va3ZrTkNqQWVXakRCMjQ0eU8zMHF3ZWxhM3Vob2lsUEI1cnlIWEpISGlPWEp6dGtjRDh6WHJraDRyeG5YSmM2MWR2dXlSTTQvVTF3WXhYc1V0RHRQRHM1bDA5Y25ueTJZLzhBZlJycWJkdDF0RXdZRUZBUWV2YXVNOE15SXVrUnZ4dk1SQko5TjVyczA0VlJuc0s0Y3FWcTlRM3IvQkVreWZXb3lEbmswNGduMnBwSDByMzduSFlZd09lcHFOelVwSXFNNDlCUTJDUnh1dGdqVkJJSEFJa0FJSjdWMVZzeGpzUzdjS01lM0gxcmlOZmt6ck1vVThiL0FGN2dmNDExdXJoNGZERjFKRXhFaXg1VWc4akp3UHg1cjVIRlFicng5WCtaNkZOMmd6SThKdzNFSGpHZStsZ2tTMTg2UWlWaGhTRG5vVFcxSnF0bGM2aktpWDlzSkdZbkJmSGV2TnJ0YnRtSUx1eFlaeGtzUi9oVVBtT2R4bGZncU1BOWlQclhmU2xPRTNVVDNPYVZsRzFqMWJaRzMvTDFDZm9XL3dBS0ZXMnlmTW1mQTZiRnpuOVJYa3F6bU1rcHhqb1Y0L1VZclowdWJVN20rczdhSzlsQm5rQ1l5U1YvNzZKcnIrdHVLdk52OERKSyt5UFJIT25nRFlMbGpqK0xBL3hwcjNGb293TFVrWS9pa1A4QVFDc1ZsdnJTS3pNdHcweG1mYTI1RkF4eG5HTWVvcTlsYTZNTFdwNGhOeGJLcVJsVDBhTytGTG1takZLSzZMbDJESnpSbm1qaWxvdUZoTTBVREZCb3VGZ3pTWnBNVVVYQ3dFMDBtbE5Ob3VLd2hOSVRrVUdtbnJSY0xBYVRKb0pwQ2FkeEJrMG5OR2FibWtGZ05KUmtVbWZXZ0JDY1UzTk11YmlHMWdlYVp0a2FETE1lMVVqZW5Vb3hiYVN3bHZKejVVUTUrVmovQUJIMEFIUDRVTjJKY2t0RFc4Tm1HL3M1NzlsT3hwMmpRNTRLcWNESDE2L2pTNmlsdElYVHlFSWJJWXNvSklQWWsxZlBoaTcwM1Q3WnJDNWNXbHNCQ2JaTWdiUWNGejdra3NlT2xaZDFNSnBpeVpDRGhjMXdVNGUwcWN6S1Q5MnhGMEFBNEhZQ2duaW04K3ROUDQxM2lHU1Y0VHJCYisyYnpKNnpQL00xN25KeFhoMnJZZlZycmJ5RE0yUHpybHhEMVJOUmU2YldpM3BXMGlqSFFBTC9BT1BWNlpGTVRHaEhRcUs4Z3M3d1FRYkNxNVVBNTl3MVR3K0s5YmpHRXZXS2pvcktwL21LNDhQKzZxU2xiYzFuVVRoRkhybm0rOUp2ejNyemFEeFpxNWk4d3lSeWV6Ui80WXExSDQ0dVZJRWxyRTMwSlgvR3U1WXFCbTBkNjJTT3RSczJCWElwNDdpQ2p6ckNSZmRaQWY1Z1ZPdmpmU1h4dlM1VDMyQS95Tlg3ZUQ2aXVrYzdyNDNhbk1SMTg3dC92R3ZSNVFxMjYyN21PUlczQVlHUWNFZm4welhtVjFNdDFjdE92S3RJV0dlT0NlSzlRdTdKbzdHMG1rMnhyRmdzU1FPb3I1eXZVNWE5TnZ1enRweFRqSThoYVM1MDNVVGRFQS92SENxVHgzRmRIb2x6QnJKbGllRHkxeGhzUDY1NkExanp3U1htcFNSbEcySTdrZW1NOWEzL0FBbllSd2FoY05zUG1MSGpINDEyU2pDcE5SZS8vQk1ZUWxGTnJZYzNnK0FITUYxSXYrK29iL0NzKzZEK0c5WHNaNW1NZzVaZkxIY2NkRDlhN3phU09tUHdyalBHN0NLNHNDVnp3eHlmd3J1eEdIcDhqZGlJeWFPdWx0a24wZlRMbU5zRWx0NEo2RUVaeCtRcU03Y1pyWnZyZUZOTTB0bzBDK1piSzdBSGpkanIvS3MwcHh3dFJsTUl4b0tTNmw0aHVVdFRwYlMvbW1pbWt1N0tTekVSL2paVzNER2MvTG1xWC9DVjZmNWhTTkxod0NBV0VlQit1S3FlTk5TRmxwc0VJY3E5ek9xWUI1Mmc1UDhBSUQ4YXptZU1vVTJLWEdEMTY1NUZjMk54OHNPMUdLdXpTRk55ZWgyOGNna1JYVTVWaGtIMUZQNHJOMHVVU1czbGpIN3I1Y0N0QWRhOUdoV1ZTbXBycVM0MmRoU0tPMUJwTTF0Y1ZneFNFVXVhYVRRS3doNlUwMHVhUTB4Q1UwMDRuaWtKb0N3d2tVaHB4SEZOUEZGd3NONHBEUzRveFJjVmhweFRTUlRtSG9LWWVhWE1GaUM1Z2l1by9MbVFPbWNsRzZINmp2VHZEOTQvaExVSko3ZTBXNXNKZVpZYzRlTDFaTThINlU4cm52Vlc3RXBpQ1FraDNZTHU2N1IzUDVaL0hGVEpLU0lsQmJzN3JVSjUyMDk5WTBhL054WlhHUzZqQjhzRWR1NHhYR1lIclczNGQxbUxTSXByV2FGcExhWmNNRlBJNHgzNjVyS0tyazRIR2VNMU1GeTZCRlBabGNnZHFNSEhTcCtLUTR4V2x5MUVxUEdUMUZlTVhObTgxOU5OdENneU5sU2VSelh0a21NVjVCck4zSERyVjdHRUh5enYvd0NoR3VMRk9XbGlyTHFaWDJWOThod1FBcFA5YTFaUENzbG5CYU85MUh1dVl5NEJVL0xnQW5uOGFrMGlQN1haeWdjaFZQNGNWMWZpTkVMNlNFNUFrZU1BZTY0L3BYR3FqYW41RnFqRmNyN25PVzNoTFZJcENVamlsSGNDVEI3K3VQU3ErcjZWTnBkdUo3bXlLcHUybGlRUm44RFhvT2p4bjdWT3oveExrYzUvaU9QNTFrL0VDVURTYmUyRzFVbGx5NVBzQ1FQei9sUlFpcXRKVlpQVXFwRlJiU1BQelBETWNSNGJqN3A0SXFLVzFWU01NTTQ1R2VsYlhnKzFpbTE2MmsycVNyRTQvRVY2YnFFTnI5am1sbmhpY0lqTjg2QTlCNzFyQ043MmV4aW9jeTFQSUxRTzZxQ3hLWjI3UlhyWGpTNnRUNE92SWxtektvVmR1MFp6eDZWNW5wK250Y1hhb2dDcTF4dEJQUWNqL3dDdFhvK3JlRkwyNmRMUzczcEU3aFM2OUFNNC9QSDlLOG5HVGg3V0RiMmYrUjJVWVdpenpzNjFxdW5OSERDNkdNSXAyTkdHNml1ZzBhNTFmVnJhVzV0WXJTSjBZSVNVSUw4WjkvV3VhdlptajFDZVBKYlk1VEo5QndLOUY4STI0aTBDS1RITXpNNS9rUDBGZWpRb3duTlhWbjNSRWx5eDNNVWE1cU1FN1EzZHVnYU00YmJnbjY0NHF0cVg5bjYrWWZ0TXpRR1BJQks0Nit3M2VsZDlKQ2tpa09pc1BSaG11SDhZb0xHNHRUYkJZdzZuY29VWU9QYXRLOUdyRlg1OUJSY0phTkc3YlhpbTJoaCswUXlDTlFpRnA5b3hrNDRiSHJWYTlsMXN6S05QMHp6b2d2ek1qcTVKOXVmNlV6VE5LRjNaaDhSNytQdnBrWS9DcDVkRk1XR0VhSDAyYnNqOGhYSlJsaUlVMXlMM1RTVk9tM3ZxWXZ4QnVCTDR4MCszYmRzaGgzWTl5VC9nS210TGpmY0pDQVJ4bDJ6L0FKL3lLUEVzQTFEeHRNZHZ5d1JvcEo5Y1ovcWEwN2JTekpxTGppT05RR1luakFQU3VmTXFzWE96NkdlR2k3dHM2WFJVSWdsbVBXUnp6bnJqdldydTRya1Y4UzZkbzl1MXV2bVR5S3hPMklBanI2NTlLenB2aUVXeUliTVE5TnJ5WmNmcGorZGVwaEswSVVJcnlKbmJtWjMyK2pjTVY1dWZGbXNYSHpXOXhadVFQdXhNQm44Ry93QWFuWHhqZlFSNW1YcGdFeXduQlBmbGVCK3RkQ3hVR1pPYVBRTjFJVFhIMjNqVkppQVk3WnhuQk1kd00va1JXckY0a3NKRnkwalI0L3ZyeCtZeUswaldpOW1PNk5yT0thV0dhcFJhamEzUCtwdVlwRDZLNEpvbnZiZTN4NTAwYVo2Ym1BelduTXR3dVc5dzlhUXRXUEw0Z3NFQjJ5R1RIWkIvamlxY3ZpcXdUdExqR1N4WEFINDFEeEZOYnNrNkhlS1F1SzQrYnhiSkpJVnRZNFFjSEhtUDFxdStzYW5NTjhsMHRySG5IRWVRZm8zL0FOYXNKWSttaWttenRUSUIzcUNYVUxhSUV2Y1JxQjErWWNWeUN5MjI3TjFxRjNKM08xQzJmb1R0eFVVcyttMjVMUjJyU0U0Tys0bkFQNUtDZjFybmxtSzZJcFU1UG9kQmVlSjdTT00vWnMzTW5RYmM0Qjl6Mi9Lc2VmeFJxcnVWZ3NsUlFNN2lOMmZwbGgvS3FiYXVYd2tRaVhBd0JiMis0ajhUazFBWTd5Y0V4MlY4KzRkV3lxbXNmcmRhYjkxRmV4N3V3azNpSFdGRFR0ZHN1Q0R0Q0JRQjA3am1wTGZ4bHFmSWVHM256MDJIR1B4Qi9wVks1OE82emMyN0tsdEhEa2RDNHlmMXJOaThJK0lVQkl0MWJIcTYvd0NOYjAzWHRkbUUwb3V5ZHpzclh4cmJ5a0NhMG1qT2NmS2Mvd0E4Vm94K0tOTmZoNW1pUHBJaC9tTWl1QVRRZGNCeExZeW5JNmlVY2ZyVGt0OWJzMUtQYVhMTDdwdi9BRkJyVDIxZGJvTEhwTUdxMmwzL0FNZTkxREwvQUxqZzFZODdIV3ZLSlo1RHhjYWV5RTlXRUpHUHd4UzIycFNXM3l4WGx4RWdPZHBMRDhPbUt0WXA5WWliYVBVWGx6bm12R2ZFUzQxNi9ZSHJPMzg2NkdMeEhxQUlVWHF5WkhHRlZ2OEFBMWlhaEVaNVpMaHl6U09TeHdNWkpOUlV4RVpOSkNhNW9sL3crSlliU2ZhcC9leFlCeDM1cnBmRVE4bUxTVlQ1VEhOeGoyVTF5RnRxVXlXb2lpVUJsWEdHNzFydGU2anJFNkNhRUdLSjJhTjBVNDVHQm11U0thNTdyYzZIT05veE9uMElsTHVVTzdGdHVNRStockgrSVB5LzJkTHdjTXlsU01nOVAvci9BSjFwZUhuZDRaYnVUNzhyRUZQN21DUnRyRjhmU2w0ckVFY2JuL3BYVmg2VW9ZYTBpWnpUbGN5dkNOd3ErSklncW9vWmpnZW1mU3ZSTmJkenBVdTFRVnlwY2Y3T1Jtdk1QREVpeCtJTFU3Y25mWHFVa2l5UnNoNUREQnJXbFM1b1NYY2xTMnVjUlphamJDOUNMdFdKSnl3SjZjdG4vQ3ZUWi9FWDJpNmhWMzNBSE9mZkhGZUhrRmJ0MS82YUVmclhRUjZnNEpsQndBRGhUNjROZUZpc0dwVFR1ZWhTa25GM011UzJtdUxxU1l4c1JLNWNmaWE5TTBlNGhoMHExaFYxK1NKUWVlK0s4dUY1S0c0SkJCOVRWaGJ4OXVEa24vZU5lalNxeXB5dVl6VVdySHJCdWsvdkN1SThjekNTN3NnR0gzVy9uV0lOUWtYcCtwTlFYVHphbmVRQjNQQUlGYlZjUkdjTE15akd6MFBVZE9rald4Z1ZNZjZ0YzRxMzVnSFUxeTlsY05IQmFSN2lkM1g4NjJTYzk2MHk2VVhSUzdCV1RVaml0R3ZkUjBtQmkxcWx4TklRR2M1M0JSMkE5ZmVuM1BpYThsdVp3SWtoTDhyRWNuYndNZW5wVmVLMnZvZ3dpZWFOZW8zY3IrVGNqODZzVzl6SUhQMm0zZ2xiSDNoaitWZUxPRVhKemFUWmRLYnRaR0V0M2VSc2N3SktXUE8xaU0vaGtWYWoxWll3STdxS2EyYnNxZ3FDZng2L25YVDZWb1A5c084NjJxaU5XdzJXd00vVEZkdEQ0YjB4YllRdGFSU0xqa09Od3IwS05GMW8zYXNaU2k3bmxFbHpZWGpPenBidXg1K2FQWTJmK0E4VkNyUnc0OGo3UkVUMEtTRWdmZ2E5T3V2QVhoKzRKUDJCWW1QZUYyWDlBY1Zqei9EUzNWdDFscVYxQmpvSEFrQS9sV2p3czB0RE9VTG5JTGNYaFRiR1laVDM4MUkrZnJnQTBydGRMdTNhWGFIUGVGaWgvd0RIU0RXNWNlQU5XVjhyTlozUS92RXZFLzZaRlo4bmhYVTdTVU5OcGx3NkwzZ2RaYy95UDZWSHNwcmRHYmkwWnMxM0loMm1PNWlZZFBtRERQNGdIOWFlMTVEY29GdTdlZDVWQkNNNmRQb01IRmFsdTlsYU9xNmhEUEdnUHpib21qY2owK1lFZmtSV3RBL2hlU05sVVhSSjV5QU0vcWFTcFNub0N1Y1ltb3lRL0tDOFlKeUQ1aEg2TngrbFBHbzdvd25uc3pNMkRsaVNSOWMvMHJvcnhMSGVEYW9aQnV5UmRSUm44Qmdab2htc3lDa21sMk1zWjdMSHRJL0htdFZoVzl3c3pFdFVnMkVNRHV6MWFRTmo4RGdmcFcvWldWcGRJRWVhK2R4amlNb3EvbDFGV2JkUEQyOGw5TTh2STUyNUs0L01WcldkdDRlUVpnU0dQblBJSzgvalZRd1h2WGxxYVJsTmFKaVcvaGpTM1VTRzFkMjlaWFluOHM0clFqMFhUNGlDbGpiZ2p2NVl6VjIxaGdpVDl3RjJuKzZjaXJJVUU4aXU1VUlMWkZOdDlTaUxkVUdGVUtQUWNVZVVLdm1NSHZUREhqM3JSUlNJYUtMUmUxUTNBa2lnRHhLVzJITEtPNDcxZHVKb2JkTjB6ckdtY2JtT0JWU3czZUlMdDRMU1pZclNQaVNVOHMvc3YrTktUVVZxUkt5TGxscHEzOFVrN3VVaVFaeUJ5YXpUQ005T1BldCtiTWRxMWpZMnNrVnZEd3pZeHVyS0lBNjBVcGMybzBVdkpVREFKSE9ldWFoa3QwZjc2cS8xQXE4d0ZSTUJXdGtCbFNhWlpFRUcyajV6bks1cnpYVnMyK3IzYVFIWWl5dHRWZUFPZlN2V0pBTVY1WnJDcStzM2hCNDg1dWZ4cmh4aVNTTkthdU10SG1tM01YK1lET2NEZzE2TFo0YTFpYmFWSlVaSG9hODZ0Q3NjYjg0eUs5SXRuRDIwVEFqREtEK2xaWUczUEl1c2tvcXhYaFJiZlVwbzR4OGs2aVVnRG8zUS9uZ2ZrYTUveHY4QU5IWngvd0FXV1A0Y1YxaDI1M1lHY1l6WEwrTVk5OXJCS0FNcXhCUHRYWGlGYW03R2NOWmFuTytIb2l1dTIvczM5SzlHUEp4WG52aDl0bXJRTVQvRlhvQllkaldXRWxwSkRxUlN0WTh3a1lwZU1PdTF6MSt0WHJWbXVaNDRkMjBNM1FDb0o0U2J5WWovQUo2SCtkYmRoWmJiNkJpdU1NRFhtVkpSVWttZGNJeXM3SFAzQ0dPNmtUUDNYSXJaMDZ3RnphTEpqazVGWm1vNFRVYmpJL2pKcmE4T1RvTEtWWGJHSDR6OUsycHhqS1ZwYkdWUzZXZzE5TDJudFN3V1pqdTR5U3Y0VkJkM2twdVpWUnZsREhIRlZsZTVkd2NzVFdkVDJleUNNV3RUcVl3RmUzSmZoVDYxcHRmUXFlWkJYR3hyY25IeXVhbkNYR2NtTS9qUlRxeXBxMElsdUNrL2VaMS9qKzNodGJhMG5TSXFvY3A4dlRuMXJra21TVmxJSTVGZW4rTGJBWDJnWE1lTXNvM3I5Ulhsa1Z1ZGd5T2F6eHNJeGtPaStoNkQ0SmY5M2NRZWhEMTJIbGoycmhQQkVVaVhNMG1TRTJCYTdvT1IxcnZ3TGJvb2lyOFFHTWRqVFN1UGVuN3dhWmo1dXRkaG1NS2dqcFVUUmcxWVBGTUlvMEFyTkVHR0NBUjZWUm4wVFRyZzVsc29HUHJzQVA1MXBuRk56VFNRbVliK0c5UHdkc1RML3dBREpINUVtcUxlRmhFU2JlWUFkZ3lEK2xkT3pBMHduakdhcXhOa2N3Tkh1WXl1K0ZKQVA3c2hINkduTFp4cnRXVzFZWjlGemcxMFJOUm5IcFRRcklvVzFwQ00rV1F2UGJJTmFrWUtxUG56VmNnZGNVbTRxUGxOTWQ3RjNlT2xJZUtwZWV3NmdHZzNJLzJoUllMajd1Mml2TGQ0SjEzUnQxR2NWbk5aUjZYQUxqVGthT1dFN3dOeElZZHdjMWRFNFlmZUZOa2xBUTU1QnFYRytqSWtreDBtdXozRU1VTnRDL2xQaHpNb0pEQTl1T2hwak1DZU9sVmRMTWR2YXRhTXhLbzVLZzlnYVNhUlluTExJdTN1Q2E1S1UvWno1V0xwY25ZZzk2aWJ2ZzFGOW96MS9Pa0w5d2E3eFhHUG5tdkt0UzNKcWx5UCttcmZ6cjFHUit0ZVhheXhHcTNCOVhKcmh4bXRqYWs3RlRjMkNPYTBiZlhibUNKVTNIQ2pBNXFoRUM0SnJTVFJwWklWWlVCeU0xeFJidmFKcko5V1dZdkVzK1FDRGp2VU9xNnkxOVppRWpIemcxR2RGblFjZ2o4S2drMHlaZXgvR3JjcW16dVJlSlhzNTN0YnlLVS93a0g2MTEwZmlDQnNGc2o4YTVGN1NST3FIOEtqWU92VmNVUXFTaHNKMmU1cFJTckpjNUIrL0ovTTEwMTNORGJ1aXF3eUR5ZlN1S2dkbGRDT3VhM05RZ2NXTHpNVG11Q3REOTRyczdLY3ZkWm5YZmxHOWN0OHdKem1yMmxSdzNNeng3Y0xqT0t6cmxBdHBGTmpxU0tzYURLd3V5Y0VBOEd1cUVmZVRaenluN3JTT2tXd3R4L0FEVXl3UXB5RUZMQVlwTDIzdHBaMWhNNzdGZHdkb1B2aXVuaThKNzFKKzN4SEg5MkpqL1N1NnJYd3VIZHFqU1p5eFZTZndvNXZnZmRVZmxTTUN3NXJyRThJSUkyZDc0bkhaWWpuOWFTSHd0QzhjcnRjeWpieW9LS1AvWnVmMHJuZWI0R1AyMFdzUFdmUTZHY0NXRjBQUmxJcmg3cnc0OGNqZVdNanRYWkdTbXNRM1d0cTJIalYrSXVNM0hZemZEVmkxalp1R0hMTm10M2RWUldDOENuZVp4MXJXbkJRaW9vVGxkM1paTDAzZFZmelJTZWJudlZpdVRsNllaT0toODJtbDZZWEpTOU1MYzFFWHBqT2FwTUd5VXRnMDB0VUprTklYcHBpdVNscWF6VkNaTWQ2ak1wcGl1VGxzQ21Nd3FFeWtVeHBUVEUyU2xxWXpDb1RKNzAwdFFLNDlpTWMxSHVCNkVpbWxxWVhwM0ZjZEp1S25hZm1IVE5jMWZhelpYai9BTm1hdGFQYjNSY0trbkl5UFVNSzZBdlZXN3RiZTlSVnVJVmZCeXBJNUI5UWUxWlZLU203a3l2MEpvRWFHQlkya2FUYU1CbTZrVXA5ZWxNREFLRkhRY1VoYml0bHNJSFlucFhtMnRBLzJyTmtjNTVyMFZtcmhOYlFmMm5NZlU4VnhZeDJzYlV0U3JZeGJnRGl1NXRBdjJXTWRlSzViVFl4NUlHUHhycXJVWnRreDJGYzJCbGVySTFyNlJSS3lMNlZDOE1aNnFEOWFsTk5OZXZ5bzQrWXJQYlJIK0JmeXFySnA5dXh5WXdhdnNDYWlmZ1ZFcWNXdGdVbWNaTkVFdmlGR0FHNHJvYnBVdUxaWVR3R3gwckN1OC9iMzQ0MzhWdlJMdWVMUDhJelhnVGh6Vm94OHowbEsxTnNobDAxR3RZb0FEOG5yU1d0aXRzd0s4Vm9uSFdvbnhYdHJEdzNzZWE2akNKODYvcE9BcFZaV1k1R2VpMTM4WGlOQW1ZbEpiaktqRmVYWGp5eFh0bzhURkdCYkRBK3dxZnpkVWI1emN5azlQdlY4NW0rRWpXcjNrOWtlcmduKzdQVEU4VXRJZC8yV053TWdGbjR4K0ZQR3Y4QW5iaXRuYjdWUE9HNEg2VjVnc09weUhtU1RQdS9OUDhBc04zZzczSC9BQUo4MTVUeTZrdXFPeFB5UFR6TFI1dWU5VXpKU2VaNzE5enluaDNMdm0rOUo1dk5VL05vODMzb3NGeTU1dEo1dFZQTjk2VHphVmd1Vy9NcFBOcW9KYzB2bVVXQzVaMzVwQzlWdk05NlhmbnZTSGNuTGcwd3RVZTdBcHUvRkZ4RWhQclRDUlNGcVFzTVU3akViTk1OT0xBMDBrVWN3ckRDYVE1cFQxcEtmTUZpTTVwcHFRZ1UxZ0tPWVZpS2tOUzdSU0ZmU256QlloMjVORzNtcGR0S0Y3MCtZVmlBcHh6MHJpZGFUL2laU0QzcnZkdkhOY1RyU2Y4QUUwbFBZbXVESFM5MUc5RmFpNmRHZktCcnBiVlA5SFg2VmgyQzRneFhTV3FEN0tuMHJreTZYNzZSdGlWN3FJekh4bW95bFhDbkZSRmMrbGU3ekhBNGxVclVMTHVPTVZjS25QVGlvbVRCTktVaEtPcHgxOUVScURlejF1d3g0VmF6YjlQOVBiam5kV3JIMFUxODk3VGx4RVg1bnBjbDZUUUZjMHhreFZyYUIycGpMK2RmUktSNVRpWmwxYXROSkM2c0FZMnp5S3VvNVZlY1pIZWxLODlLUXJYSFh3ZEt0TG1rZEZMRVZLU3RFRE9kcFA4QUZqSFNveFB0VTdnQ1QrbEtSNlZFd3hXS3l5aDJOUHIxYnVkdHZ4U2VaVmJlZXRJWk85ZWdZM0xYbVUzemNHcTNtSE5OTXRBcmx2ektUemFxZVptZ3kwZ3VXL01wUE45NnFlWjYwZWJRd3VXL05IclNpWEhlcVhtMG5uVk5oM0wvQUoxSjUxVWZPenptazg2bFlPWXYrYUtCTFdmNTJhUE9wV0RtTDVsSHJTZVptcVBtKzlLSmVlRFNIekZ3dm1qZlZRUzBva0dhQXVXaWZTak5RQi9lbDh6TkE3azJhS2g4dzlxWGRRRnlVRVlwMVFiKzRwREpURmNtWWpGY1hyV0RxTG4vQUNhNnN5R3VUMWptK1krdGNPTytGSFJRZXBZc0NQS3dhNlMyYjl3b3JsN0ZpSXhXOURKaUxBTmNtWC94Wkd1SWZ1b3ZGNmpMQ29DL0ZOTDE3ZHppdVNzMVFzZWFhWkIrTlJzL3FhbHNSZ1h2L0lSZi9lclVqSUFTc2UvYi9UMit2WDFxL3Z3RXdmU3ZucXkvZXArWjZjZmdmb2FXUmltTVJVZS9GSnY0cjZHTDBQTGFISHBUQ2FhMG5iTk5MREZWY1FHbXNBYWFXeWZha0w0TkhNS3gwWmVtNzZabkZOSnJTd1hINzZidnBoTk4zYzBXRmNmdjk2UXVhWVRUYzRvc0Z5YmZUUytLaUxVbWFRcmtwZW1tVDJxSW4zcENhQXVUR1NtK1llbFJacHBlZ1Z5ZnpPS1BONHF2dTQ5YU4xS3dYSi9OcDNtVlZEMDdkeFNzTzVaRWxTQ1RtcWdiaW5CcU9VRkl0aVROT0VsVkEyS1hlYU9VcFNMWG1HbDh6bXF1K2d2eDFwV1E3bG95KzlOMzFXMzg5YU45SUV5ZHBEeUs1alZHQnVqVzZ6OGRhNTdVam01UHJYQmpka2RORGN0V1IrVVZyd3ZsS3hMSGxjVnF3c0FtSzRzRnBWWnRYK0ZGb3ZTRnMxQjVsSjVsZXpjNGlWajZWRXh6VERKM3BqUFNiQkdQZG5OMmNWT2o1QzFVdWY4QWo1cVZTUmpGZUpVWHZub1JmdUdxR3d2Rkp1NDk2alZ2a0FvTFY3TUhvZWU5eDI0MHhpUlNFKzlSbGlldlNydVRZZHVOSVc0cHBPS1l6RWlsekFkS1d6U1pKNHFNdnhUUy9OZGxpQ1VqT2FhY1V6ZFNGczByQU9KOTZhV3B1YzBFMFdFTG1tbHFibW03cUxBS1d4U2JxYVNhUnVhTEFPSjVwbWV0Rk5MVXJDWXU0aWpPZXROQk5Ma1VnSFo5S1hOTXpudlJta01tRFVwYW9kMktYZDcwbXdKZDlLSDV6VUllZ3ZVdGpTSi9NcHBmRlFialFYcVJrNWtGSVpPOVFiNmJ2Tks0eWN5Vmg2ZzJiazgxcG1Tc2ErT2JnbXVMRjdJNktEMUxkaklBblhrVm9wSmxheGJWc2Q2MEkzNDYxeDRWV3FtOWQrNFhDK2FidjdWQnZ6M3BDOWVzY1JNWDRxTm56M3FQZDJwaGJOUzJDS04xZ1hQV3JDTDhnSTdWVW1PWnVhc1JzUW5XdkhxL0VlaEQ0QzJHSUZMdTQ2MVhSenQ1b1p2ZXZWZy9kT0I3a3hmSTYwMHVBT3RRYmlCMXBDLzZWVnlia3hmbnJUV1lZNjgxSHY0cGpOM0ZGeDNPbDNab3ptb1RKazBic2l2UklzU2JxTndGUkVuOEthWHhTRllsMzgwbTZvUS9yUnY2VUFTc3hwaDU1cHUvTklYcWJnUEJwTjNOUjc4MG1hVnhFak54VEN4cHRNTDBBU2hxQzJEVUlhZ3ZuaWtCS1dOTHVxRGZSdnFXd0ppK090SnV3YzFDSDlhVXZ6eFVqSmQvTktaS2d6M3BOeHBESnk5TTh6RlJab0xERlRjWkx2NzAwdWV1YWozVWhiUFNsY0J4ZXNxNmI5NGEwTjFabDBSNXBya3hPcVJ0UjNKSVRnWnE5RklkdFowWitXclVMZkthNWFLL2VHMWI0UzF2NW9hU29jbnZTRnNjMTZOemp1Uytaa1VGczFBWDVwTjVPYW1UR2l2TTM3MzYxT3JmTFZXVTdwS21YN2xlWlVXcDN3ZnVrNE9BS053SXpVUWI1YVFFNXJ2ZzlEaWx1U1pwQ1FlYWpMWVBGSUd6bXF1U1BMZHFhU2ZXbTd2eHByTlJjRG9zKzlBUFdtZHhRZnZWNmc3RGkzdlRDeHBHNmlrb0pzRzQ0b0RaUFdtbW10MHBNUklUVGQrS2JUVzZWSUQ5OUp2NXBCMEZKMk5JQnpQVEMxSTFNUFNrU09MMG04NXBoNlUwMG13SkMvdlFINHFQdCtOQnFRSlBNNHBSSlVGS0tUR1RiNk4yZTlRaW5kNmhsSWxMQWNVbWFZZnUwM3RVdGpKQytPbEp1R2MxRFI2MGd1UFo4aXM2YzVlcm5hcVUzMzY1cSt4clMzSFJuQ21wNFgrVTVQZXF5OURVa1hmNjF6MC9qTmEzd2xuZHhTRnNDbWRxUWRLN0xuSVAzQTAzZDFwcHBCU1kwUlBqekttVTRXb0gvd0JaVWcvMWRjTlRjN3Fmd2o5K0JTRnVhakgzYUJYVkhZNG1QSjVwTjNOTmJwVGY0cW9rY1RnMDNjTzlEZGFhYUxqWi85az1cIiwgXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8vZ0ErUTFKRlFWUlBVam9nWjJRdGFuQmxaeUIyTVM0d0lDaDFjMmx1WnlCSlNrY2dTbEJGUnlCMk5qSXBMQ0JrWldaaGRXeDBJSEYxWVd4cGRIa0svOXNBUXdBSUJnWUhCZ1VJQndjSENRa0lDZ3dVRFF3TEN3d1pFaE1QRkIwYUh4NGRHaHdjSUNRdUp5QWlMQ01jSENnM0tTd3dNVFEwTkI4bk9UMDRNand1TXpReS85c0FRd0VKQ1FrTUN3d1lEUTBZTWlFY0lUSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5LzhBQUVRZ0JtZ0ZBQXdFaUFBSVJBUU1SQWYvRUFCOEFBQUVGQVFFQkFRRUJBQUFBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUUFBSUJBd01DQkFNRkJRUUVBQUFCZlFFQ0F3QUVFUVVTSVRGQkJoTlJZUWNpY1JReWdaR2hDQ05Dc2NFVlV0SHdKRE5pY29JSkNoWVhHQmthSlNZbktDa3FORFUyTnpnNU9rTkVSVVpIU0VsS1UxUlZWbGRZV1ZwalpHVm1aMmhwYW5OMGRYWjNlSGw2ZzRTRmhvZUlpWXFTazVTVmxwZVltWnFpbzZTbHBxZW9xYXF5czdTMXRyZTR1YnJDdzhURnhzZkl5Y3JTMDlUVjF0ZlkyZHJoNHVQazVlYm42T25xOGZMejlQWDI5L2o1K3YvRUFCOEJBQU1CQVFFQkFRRUJBUUVBQUFBQUFBQUJBZ01FQlFZSENBa0tDLy9FQUxVUkFBSUJBZ1FFQXdRSEJRUUVBQUVDZHdBQkFnTVJCQVVoTVFZU1FWRUhZWEVUSWpLQkNCUkNrYUd4d1Frak0xTHdGV0p5MFFvV0pEVGhKZkVYR0JrYUppY29LU28xTmpjNE9UcERSRVZHUjBoSlNsTlVWVlpYV0ZsYVkyUmxabWRvYVdwemRIVjJkM2g1ZW9LRGhJV0doNGlKaXBLVGxKV1dsNWlabXFLanBLV21wNmlwcXJLenRMVzJ0N2k1dXNMRHhNWEd4OGpKeXRMVDFOWFcxOWpaMnVMajVPWG01K2pwNnZMejlQWDI5L2o1K3YvYUFBd0RBUUFDRVFNUkFEOEFzTmJKOWxOMWJrQlpDR0xjN1dPT2dOVDJqWHRsNWQxYzdRR1VJQk12SElCd2ZiQlBOWTZSU3oyOEUybVNqeVpDUWtDRTVqWUhwK1dEa2YwcXBKTExJc3NzZ1ptQStlWlR1d0J4Z25vTWVsZklPbDlsbnUyNXJPNTFWdnJkNml5RkdsbkVQM0pNWUs1YkJJejFHQ1IrSTlLMC93QzJoY1hFclhPMEtTa2tlMThBWSs5MjY0cmg3U0s1a2pZeDNTcUFoYmF6NExEMkhmOEFDcmRwcU54RzcyMHo4Z2JDb0l6eit1S0p6bTF5OWc5aEhWbm9jRjdlM1VLK1ErNmRBc1JhV01xc29CT09jNEJ4K3VEVkN5MVdlYTRFOWpZenh0Z3d2dXp0T2Z4NjhIcjAvR3VZdmRWbXRMUVJrdEd5a29FUnNBamFCbkE0NUhldEh3dHFMejM5NWJHNjh4cFlkMEhtQWdaQTVCQlA0ZmdEVFZXcjlsNm1Qc2JSY21qcUxUVnJtOXVnTjhTbUJTU3BCRy90eC9uMHJBMVZ3MmxYRVVFaXgzRndZbGNtRGF2bWtibXd3OVFwejZaSFN0clRWajFMVUxjMi9td05IR3FobUhMQWhqeUQzeU1mU3M2KzhQM054UGNXMGwySS9NbWtlQ05sNUxCZnZBOFo1T1BhdElWWmFOL2wxTXZkdVZiUzBDYXZlVHoyMGtjM2x4Z3RHU1FXT0ZKQjc1QTU5K2U5ZEZJR3NwWTI4c2VXM3k1WnVWUGZJNzlheVBzcnhYVEM3WVJJNDNtTmZsWUZjWlVaOVJubjYwNmZVSmJlOGxndVVtZ1NhUEFXWTdpZWhHVG44NjVhdFNVNUxVMFViNklqdnRWazFEVVV0eE41RnVwWm9pb0RBeWJEdEpJd1Y1UDUxajY3TmNpL3MxMCs0a2tnWGF0d0JsREowQkI5ZUFlVFY2L2hoTWtMVzl2RkdycytURUNWYzhjWTdZQUhvY2tudlZSN015WE85Sk43ZVVFQ0hQeWdjbmoxem1rc1RHNjYyVE5ZME5MbFFCb3IrOGtkRlZwSk0rVXI0QUlKL1BCeCtWWWw3YyticTZlV1Nka2JaQjVKQllZL0xGYks2YmMzalNSWUVaM0JWa0pBQ2xqakpIZXNLemdRNnhjdk9zamdTQ0FiZmx5QjFJSjl6K2xYR1VwUmMzdFkyakdFWFpiaXlURW51VzdVejk0NHlFK1U5VFZ1MFNDUzlqUzVrU0tJaGlEZ0VaSFFINm1ud3hSelFUZVMzbVE3aWd4N2RjY2NqbkdmYW9hNVk4MWpYMmlVdVV5alp5VHl1KzNiR3EvZVlaNzFmczdXNFJFdWJhUldSZUNXWURQNFZIdGRpeWtkZVR1SUFGUnVrbjJoWUxYYnVWQTh6YnNCRUovVW5zS2Jia3JGdVNXb21yYWpNaHVMTjBTVzdkVktlV1I4Z3huSlBUQkI3MWxyWjN6eVJ2S1VrQWI3aDRRSDF4M1AxclZXMWlobFpZNDErY2s3aU8vcWF1VzltSHRFOGxHM0hra2RQYitWVXFzYWNiUlg5Zm9TNDMrSmxjUGNiU1hrZ0c0RTdRcllKd1FPaHF2NU53MGkzUG5SUVN4ZzlJaVc5TWVoL3dEclZ2UWFETlBZcE1idUtQTGJUdTZnK25iQnJMdW96Wnl6NEE4bTNJRHlLU3d4Z2NnazgvbldkT3FwTnhpOVNKeFJqeXlOSmRCSGFScDk1ZFdZY1pJR1c5TThWWHZyRm5zcEl5MldiREErcHpXcFp6YWJlM3Nxd3pHR1NRL3UwbUdDK1dBQUI2ZFBmSFg4YmR4YTJOdmZQYnRjeE9vTG9yWnp1S2s0L0E0NCtvcnRjNVJrdERDRW9TaXlMd1Q0enVMVFMyMG9SQjVBeFlTdTV6MUhHUFRyK2Rla2YyMjBRZ0NRb0wyNEFMSnVBQVVMbkc3OC93Q1ZlSWFVclcvaXlXM2pVUWgyWWJUL0FBakdjYzExc3QwOXZZWEU3dXhVSDVnRGs1SEF4K1pINDF6NDNCMG5XNWt2aTErOFZLOG9laHArSWRic0p0VnRZVjB1MmVaOXp6RndvWjhqajV4MHh0T2MrMks1N1ViVjdiOTFKTVpWT0hrR2M3ampHNEhQNEQycW5kVzcydXE2WTF5eWk0WnNURU51SXoySTdZQngrRmFXcVh0dGRTMnNkekxsZ3hWY2RDdkhGYVFwcW1vcUcxaHBYZHkzWlNReHROTjVSZVoxd2daanR6MEg1Y2ZsV2RyMnAzRnFuL0VzdWpiVHRGNUVteDhGNHlNSGQyN25tb3ZOYVNVdzJyRUQrS1RydDl2clUwK21STlpQQ0ZKYVFFRmljbGo2bWlNdVNhbE1jcVNlc1RtMDBYVG96Rk11cEtWWC9XU05nS0c3NDdrRElxeExydGxITlBGQkk4eXhidHNwR1BNQTdqNjF5bHd6RGc1NDR4VlFzUTR3ZUR3YTlwWVQybXRTVnprK3RjbWtGWTZsZkZFMGQ5YVhOa1hpbWliTzd1ZmJqdFhSZUg5Y252cmxaSmJ5VjVoTm5lL0lYSno4by9QdjZkSzh6Vmpuaml1dThJNU56RkNpN3BYZkNEMU9LSytIcHhwTldJaFduT2QyejB3bWVKdnRVanE0em5hekhHN2s4NDQ2OC9oV0hMY0xDeEJYNWdPQURuSDQxWnVMK2FTSTJ1NG9KTnVTL3dBd2NucGpBeU90WVY3YlhrVWpyR3pSSkdvREVFTmtnY25ubXZFVkc3MWRqdmk3STZLeDFNMi9sUGRUTEZhQTVJREJTZWNZSjlhM0xieFhZYWJOSkhhekM3bFdYSllENVFoR1JnNTU2L3BYa21zbVZMU1BkTy96UGdSdEhzUEE2bXIyaitIOVl1WUJQREE4UmNaVjJPTnkrdVBUM3JYNmpDSzlwS1Z2eUpsVjVwY3FXaDdQSDQ3KzAzTVBteHJEQklQbVlEN3ZQZk5ia2Q2aHVERkhMSElTUUU4c2ZlSFgrVmVYYVo0R2dtc0lwYmpYZkt2Q0NKSUpGSlFEUEdEbXI5aHBONURPd1M0ZmNGSjgxQ2ZsNmZNUC93QmRjZUlsUjVyYzJxOGlWUlRXaXNjamZlTXRHMklsbWx4dFZwQ0VFYW9vQk9WeHlTRDYrdFp5ZUtyYVZEYW1OMGlZNXprZmVQYy9yK2RkcXZnNWxzcHBaZElzRnVJUUN5cUFlUFFyaklKOWVsUVIrSHRLazFDSW0zaWl1SlVHWVpiYmFWSU9NQURnbklJOWVuclhlNnRGcHRSYnQ1bWNHMXB6ZmdjK05RZFQ1YnVkaWpBMm5wVlpaNGlwbWhiZmprTXA3aXUvdWRIdHRST3kzczdOcFl3VjN4UmVXU0dJNUk2RVpJeDZaeFhMMytsUzZmcWIyYXdzSm95VjI0L2w2MXpRclJsMHN6dWhVVE0yTzZ1SnJNVHd3dktOcFlJRGs0cTdvdmlyUURQcDV2SUpZREV4ODZRTnVEZ2s5dTJNOVI2VnBhUHBMWDBKV0l5Sk14eEgzREhqUFBiclY2ODhPYVpid3hRMzl0Q0xwNGpKL3FlZW9CSHZ5ZXZYSjlxMmhPbkp0TmZjYzllbzFvbWRqWjYxb0lFTTFycTFqTGNlWVFGKzFnYzVKQjdlNDVIOFgwcDU4UmFVOXliYVhVN041cEI1a0JlYlBsbnB0NDRBNm52WER5ZURkRVV6SkxaeHh5Umo1MWh1SEpVSHZnbnNTUDhBNithbzIzdzh0WnpFSlJkeFRlY0VkUXdJMnRqQjU1SEpQUEk1SHJtdFlTdzdzNDNYclk0K1I5VHUvRXQ2MGRoQmZyUGIzRzFsUlVCUmpnOGtFalBIR09QVTg5cTVUVk5iL3RLK055OFFYNWlSdFA4QUQvQ0Q3aXNWZkJrOE54UEhaWGR5ajIwYnlNa3VBdTlUMEkrbFN4K0IvRU0wWXVHMVJiZVJ2dXh5a3FDQ1I2Y1lybmFwTnU4MTgwZEZOeGdscHFkUnAxOTVNOW90ckt4RjBuNzJNcWNFNFBwMTR3ZlVVMTdXMk54cmp4WG5sU2hVTVRSZ2tlWmpoUUIrdjFybVpQRDNpY1NRU0pyRm5OQ0FKV21Ma0xFd3l1RzQ0NUJBSjRQNDFSc3JyWEJjS28xR1A1WDNFS054Sjc5YTNXSHAwMXpKNjIvcm9Tbk9wSTYvVWRiVjlUbW10N2RRcjdGVkhPTmpMdHd4K2pMbjZVbWoyVnF6RzBXS1J3QzRXVkNCbm9TQzNSZjRqK0lybHJtTzk4NUZXVlJIdUxTWkhPZTliVnF1b05aR1czLzFNWU9GM1p5ZS9BL3JYSFdrM0JSdWRTcEpiQzMxNnNkdFpSMk1DeHRjV2lTWENzK1NwTEZrTGV1Umc0clRsQ1dtbnJKYUxGTGJvcVFSeU5FUUZLOEU1OWR4Sk5aOWpKZXlYQ1hDV3lUWXdWUjQvTTV4anQxd09sTzFxOTEwV3pXOFdrQjdmYXF5RlgyOURubGNqMC9sV3k5bk9LcHBwZk01cHhuQjh4WjFmU3NXTmhkV3Nva3Vib0pERGJLck1ESVIxT09PTytlZ0JwRnRyZlNOT2dzakhETU54WnlwSVo1TUFGajlld3JLanZ0ZDFXN1NhNTBpWkk3UlFxZVM0akVDS2ZtYmFUM3lNK3VQYXJ1dHozMnBXOGNFY3FXNnRtUVA1YkZnUWNZQkZZVjZVVTFCU1Z2WC9JMHB0L0ZMb1MzQ1F4aDVZWXBFdDhmTUhiZDVmdG4wK3RYTFR4SmR3UnhwNVVjMXF1QXVSZ2dmaFhHdFphblpzczF2cTBGNGthRGFydzdsYm5BQkI2akJ6elV0cDRobTB5N3RvcExkb3dFL2VoWFY5NXh5U3JZQ2pqT0tqNmxHb3JKcVg5ZVpUcnhqdWp2TGlIVEpSOXJ1M01UUEdDSVVYYTdmN1JKNjljQ3NtNmtzVVAyYTNlUTJzeDJ2KzVWblU4WUpKNXg5UGVzeS93REVOanFXblJyQmNUUk5EY2J4TE5adnRhTmxiNWNxRGpuSGZ0N1ZWczlXMCtPNVc0L3RHMGxoUjhtTm1LTXdCSTZFQ3BqbDlXR3VwS3JRbEhWNms4K2x3WFdudEE4WW0yeUYvdWxXNllIUFllMmF6OFJhZmJIVGIxZzByTG0xbEtZM1I3c2xXUHN5NUJycjdSSGwrME9rcHRyamZ2YU1zdXphYzhEMXgvbkZabmlMVDdlL3NJWnlDMXVRMFNZeUpJbVU1eHlUMUJ6a2V0WFNyT01uVG50L1dvSnFUOTNjNGE2MGpVMDE3N1liUzQ4cG1CTXFnbjVjZGZ5cnNyYlIxbnM3YVNXM2Y3S29NamhDUDNqWU96cU9Ca2duNlZ3MWpyVjVvMnZReXJjZ3h3c2NpWUZsWmNkeDM0eFhvdjhBd2xIbjZUOWxOdGJtZVZWZFpyVmRxa1lCT1Z4NzRyb3h5cnhVT1ZLM2NkS1VXMmtjbDRyVjdRYWJLRVh5Z3pLbkk0UEdjNHFycmNOc05Uc1k3VzVEcVdHWlFuWTQ3SDhmeW84UVhIMjJYenBvVkNXMGdEQmY0aVNNajhCaWthMFF3MmQ1SVQ1QkJjeVJuK0xqQStuK0ZiVWs0d2czNS9pRWxlVHQ1R3JIYVFScUFxcnQ3REgrYzFaVUx4MUF4akdlVDdqME5SV0dibmZObjVBNVRJT2NBSEdhdkdNQnd4WElVWndLNEp5YWRtZFNzMW9lWDY1Q3NPcDNLSU1LSEpBOU04MWtIaklOZGQ0d2dIOXErYXFNb2tqVTg4OU1pdVdrUTdpSyttd3RUbnBSZmtlTFhqeXphSVFPbGRuNEZuTU9wbDhBNGpZbjFJNDRIb1QwcmpRRG5GZWhmRHEyelBkWExXc2x4QkZHdm1MR09jRTQ2bmdEMzlxZU0vZ3NWRDQwZEJxVXh1THkya25aRjJUTEo1SUdOKzBjREE0d0trVjRwblJodTg2ZVVreDlOd3dPVno5SzZxK3RmRGlvakxadXNsMGpBQm55MXZub1ZKNEg2MXpSZ2dpY21HVjI0Q25jUWVSL1ExODVWL2RwUmJ2NkhxMGx6WGFWamhQRm04NnlZWERlWkdNeUVuZGxqejE3MWQwN3h0cXRyTm1RcE5HWWZJWkpCOTVmNmRCMHJwZFRzSWhlUWk4Z1I1aWNLT285ZWZ5ck92UERkbThiM00xekZieUhjMGNVWXdYT2VNNTQ5T2xkZExGMEpRakdwSDlTSjBKcHVVV1h2RE92emZ2TGk1UkpqR0FGVitoUE9janZ4WGJhSnFjT3NlWlp0WWhRdytkbzVObUY3REhldUkwclNtMDFEdWFLV1hjR0EyaGh4NjVxOWJUUzIwMHNsdXpMZzhiZU0rdGNHSlZHVTI0R2thYzVSOTdjMzlRdW1nMU41THJRekhKSTNCV1VNUXBYcm5vUm5QNjlhc1JmWjNsejhubXpKdGRKVHlRTUVEQituYjBxanFuaUxWYlprdDd5eHRwb2czTFNvMFJCTzdoU0NRZW82SHQwcXRlYXNiR2VNM0ZqY1J0NWU4K1dCTUFHR2RwQTVIYmdqak5LcFRxTnFVZTNSLzVuTlRhdFpvWFY5UGl0b0JQQkxLWlZJRWlzKzdhQ2VjNTVQK2ZyVVZ4cVIxZWUzdU5Rak1jMFI4dUo0MVB6aGdjRnVRRGdnRDhjMXFXZmlIUTdtMUN0TmJXN0FmT2ttRUtnK3g3VWsxakJQYkIvSWpNVGhaVUtBS3BUL09NVVU2MDRMbHFSZnpLY0UyVUxtM2lsc29JclNHNml1U2pNaUZkeXlFNElBWWRHSHYwOXExTC9BUHRWTnNkMUVrNGppZjU0OG1RZ3FDRUpQVUhqT01na2ZTcVpSbXVoRkZLWnQyY0ZPMkRnL1RqQnF5SE1BNXVIbWJiemdjSVF4RzM4Z0t2NnpLTVhHMnd2WXB0TzRsc2kzYUcyczBTTzQrWldiNXNFWXp0eVY0UEhwK05hdDNieGsvMmhhM3UrR01KeWtoekU3QUFuZDNBQkJ3UjF6bkhhb0Z2akpCY1FsaWpqQ2xlQ3BDNU9TT2c2alB0VWIzWW1nVmk1bElQRzErT21PZmYvQUFvK3Nja2RZNmsreXU5R0ttbnJwK3R5VEFQZHZjd2lKNHNxQUZiRGJpQjlPVC9MTmFFYzBoY1EyTnMwSGxjbEpJeGxUMDRCSEkvSCtsWThabVhVb1dDRlkyQVV1cEk0KzkxSFRwVy9ZM2RtMDg4ZDFOUEN3ajJMTTV5cjVHUWVlM3VQYWlDZFdhYjZpbWxEVGM1Njh0enFWM2F4WGx1cm45OHJQekhnZCtuVWQrYzFvYUhvZW0yaVBjVzBBZVJqc1l2SUdDQWoyOVFha2t1YmhkcVNqNXZzNmxSa0VnTmpuSkdSMFBIWG5wendhWmNSRi9PVkprMkVBbVo4N25DaFRoUU8zSStvSjk2NzRRVnJTNmY1bWJrN1dSRHJXbnhYc004NWlNVWNFUG1SVDdRVmt4bnY2RFBQSHB6NnF0amJYL2h1VzIwcFk0NTU0ZHBhUnp0M0UvTm5nL0tPUWZmQXJGdk5Ra3ZMUzhKanVVbkRzaUFTRmtSY0RkakgzaGdrYzhEOERWMncxQ00yMXBFSTBsa1ZsdDJFVGJQT1ZzajY5RG44czFOYW5GUDNkeWVkMnRjTk92N2pSOUlXMHVjd3lrZnZKQU9YZlBJWEhwZ0N0dVM2TCtHNzJRTUhKbFVzNHp2QUpHNHNDUGZvUFRyWEc2bGR4ZzNVZUdZN3cwTFo0VUJpUVRqdmdyVUdwYXRKcUZwRzhnYnpCbnpKZG1ON1lHY2tjZHYxTmNzbktUdWlHemV1ZGRiVDlTbGxOeWJnaVBIeUJYendjcm4rNlR6aXNQWDlRbXVkYW1rayt6eHZNcE1NVVFERDVpZmxidHVHNm5XV2xYOXkrTEtXT2UzdHlaZzV5T3dIVDE2WUhmQjlNVjI5dDRkaGlza1puUzYxQm9WVHp5dTBnbkdXSjduNWdUM05FbHl4c2liczRPQjd5MThOUGJUV2thU1N5WlRhQnZLS2ZtR0Q5QnlQV3NmVUxXZTV1THhwWGpqaWlnSmtXUTV5T3ZVZlRqNjEwc01NY3M4dG5kNm84SmFKbzJsZUlZVWtqSzVQQUJIdDJyQjFSTk11dFp1WXJPM0Z0RktwQTh4Z0VWT29ZWTlSejM0UEZGQmUrNUZTZG8yYjBNYlN0YXZJTkUxYUN5U1ZMa3Q1aUNGanVUSU85dHA0MmhOd09CM0I3Vm82RFBCcWt5NlpmV2NUeDVNZjJ0eGt3Z1pZYlR4MWJIWHNUNjFzMzNoM1N2RDlsYTNvYU9XNW51L3NvSEJqbWpLc0diR2NrY1l6eHpqOGJRMDJOWERLMnlTSjVJN2lMRzFRNFlncXA3amFWNzU1NXJyeEZWUmhkUnQvVmgwNHhiM0pOSThHeDNXcVNlVE5OWXlSU2xpOXZOdVhhUVBsQ3R4MTU1NmcwbW8rSFBFOElFKzYyMWEzY2hvd2c4aVVybkJBVURhRGpHYTZiVFlQczgrbXVrMFN4cXl5U0lTSGRoaGh6Z0RvT001UDlLVkliNU5RZXkwcStBZXp1U1o1WlNXOHVPUUJzQUhqZ0wxOWZxVFhGR2M1cE9WbS9OZjFwOHk1U2NaZTZ6eUxYZEpTN1lTR3h2Tk11V2wyQnIzQWdhTUFZSmZIRGNqanBYUitGL0RjMXhwTTlvMDhVZDZxTklwRXl1SGpBeVFoWElQVDF6N1lycWIvQUUxNUd2TE80L2UvYnJGbHQ1Wll3L3pZd3dVbkczT1FPQU04R3ZGOU5hNnNOVHQvS25raGxaekdoU1RZVVpoanIyOUQrTmVuUmNjUlRjTmt2bVRHbzFKeU5yVk5NTWpYQlJEc1JmbDVQek1PY24xN2ZuVk9YeEhxbDE0YmpzV254WjI3YlJIc0dCbjN4a2QvenJZbHVkVTA2N2swcTVFVi93Q1dwM0xPMkpFSnprYjE1OWVEa1Z5MDhzTnI5cnR4RExHSnRyUnBOamNvNmpucDB4V2xPaTdKU3M3V3NiU3FKNnJROVI4Q1FXMTNaU0pKcDdYRWhnQVVaVURiNmpPT2Vldk5kUm8razZmRFBlUHFNRWNRaFBDeU96RURIT1NUaHZ3RmNENFR2YlpkSVIza2srMHdxUXFwbkk1NElJNkg2MXAzV3ROZVJEejdtWnBPaFZ6OHJZSEg0OUsrZnhOR2Nxc2t0UDY2SFRGT1M4alYxbndqb2ZpSFdZaXVZNFFtZDBENDMvTU9PY2o2NDU1Rlpmam5TZkQyZ2VGNS9JME9DUjVIRVljU2JDakFZQkp6bHVuUVp5ZVRYSWVKN2syVm5aelcxelBGY2g1RWtHNGdnSEhRL2hpc2FKZFExblRFU2ZVbmEzalB5UXNTd1VqNjEyNGZDVlVvVkpWSHlMcHIzOGlKSk9UaEZYWnpCWDU4ajFyMHI0YVNOQW1wUHVZSVlraktDTXQ1bVN4eG50eVBXc2pTdkN6UVhrTTd2SE9BYytYZ2pOZDdwbDFiYWRlRkpiZTNuMnJueWdmdUVldU9PL1ExMTVqakl6cHVsRFc1blJ3MG92bWw5eHI2dEhaTlkyOXc4bTY3Vk5yUksrNEtNRWduSDNSMnJtMXZ0UHRvMWU2WGx5VlRKK1VOak9EN2NWMDBXb1dtcGFWTkJjbUszaEFBM1JqNTFQUHpLUFhwWEphM3BGdGVXOEZza2t5eEx1YU10Zzg4REo2WjZmcFhpNGFNSDdsVnRIVW5VV2lSZXR0UnROTzBSSDhoRmlkaXlPNDJodS8xSjYxeTJwK0swdVF6V3Nma2tQeHgyeld6ckZuQnFOb21uYm5nTUxoeXVQbUdCajhPL1N1VTFqUWhab0pvQ1JGd01PMlRtdlJ3VkxEeW5lZnhOazFwVkV2ZDJPbml2VE5hMnpFWmtKWUVxRHdSMC9USFdyTnRlWXdBKzJUSnlRY2o2ZTFjL3BiVFcrbGh0c2hqWnlBUjA0QUovUWlwa2RvM1o0UThrall5dVBsWEo0L3lLZGVoRG5haXRBcDFIeTNiUFJyalhvWXJXZXpleCsxUmVjQzhrWjNFbkE1SVlIK25UdFdMcWM5bEhjd0N3RTVpZG1ZTmM0Y1NuY2Vjbm5CQkdPUjBxRTMwbWtzOXhKRTBEazRJQjNGOGc1S2s4a1l6bjY5cTJZTk1oMUo0WTdLNGh1V0UzbklFRzB2Z0E0d2V1TUE3ZU1jK2xST0NkcnAvNW5QRit6ZWpNZWI3TmZYa2NOOXAvbElpc3NnT1dRdG51RGdqT0NlTWprR2k0c05MdDR3ZE9udWJHNlZ6NVJTVWxYUTQ0YlBHUnoyNkFWcmFwTXdubGxObEJEZEkrNlVxVzQ0QXdVWVk3anQycXFrU3lxdDFtS0xiaGZMQ2dxMlQwSVA4OGpnOWF4VTVLeVR0NWFteVNhNW1WNEpkUTB1OUV1cUkxM2JxZm5taVBJSnhuY2dPZVFjWkZYbGdqWkk1ck10TGJHWEhtaVRCMkhKUEJKejZjWnF4WVMrUmNLYiszTnRiUm94YWZKZEJqUExBODlSZzR6akhYRmFWeDRYdHdJcml6a1dEemNTbUdERFF6RTlEZzV3U2U0UDUwVm95VUhLYVhyL1czOWFFS29yMlRGaXVvNGg5bnR0aFU0R0ZKeVNldWNZNitsU3JweXRGTE5PN05LM2NPQzNUcXk5dWNqMzlxejdxeWEzaE54ZHd1b1Z5bmx4Tmd0Z1pCQjY0UE9mcFZXODFhNGUxa2ZZVU5zdVdFblZsSkczakFHZnU4NDV4V0VWSng1Wk1PWG1kNGs2bVVBQndwS2dnYnljampIRlBqbWx0MVZyVlFzTzFWYlBMRG5qT2NESFBUMnJKZzFUN1JiQTRLdEhsWk9wd2M5L1E5dndxL3BjOE81bWtsM3hzYytVVGxlblVEOEJTNTUwcnFScEttcEs2SmRERzAzY2x5NWxrQlY1RmxYT2ZseWRqZFBYcFNhRENiV3hSSXBKU1pIM25KQlBRS1AwQU9QV215UUlkVWxaWS9LalFEb1Q4M3FNY1l6bjlLbXNMbDdsR3dJMGtnKy81T2RvR2Y4TVZyVnhNNXBwUGUxek5Va3RXWWR6SEhEUG1EVW8vc3ZuTVJFRkpXUG5rRWRBTWVudldmTHFGMWJvSUVDQ2VGL0xWVzRRcU9WWld6MTV3Zm9NNXJwbUZ0ZDJqR1pQS2xMYkJ3UVNRRGpudU1rOSs5VVA3TmFDT0tTTUNRRTVLeW9ObTBuREVBOU9QZnFPb3JwaGlVcFdsdjVuUEtsTGRCZDJyYWt5VFhPb3dMS1lSS3lZeUZiYjY5ODRIMDNmV3ExamYyY1dueVdGMFFJbW1Ndm1JcFo0eUNjTGp1T1J4N0gxcDkxRUxoSGdtdlZqRnJGaUZteUZjOWNESTZad2VmZW9ZWUVqZ2t1TlFqbHQ1cEFqUkdIQlBROVZ6eG51YTNpMDlqSnMyN3k5bVNTYTJFS1FTeXFmM2MwZ0FYNWlReEI3Wnh4bnFEem1pRHhGQTBoV2Q0N1pXQkR2RzdseXc0SUJINTg1N0NxSWt0TG1iN0x0M0xDRU1lM2pxU1BueU1BZXBIWHRuazFuZUk1NDdSSWJJUFBKTUNKZk5sSnh0SUlJVVo2RTkrK0t6cXg5N2xHM3BkbER4SHFhYXJmUEtubkpMTkdHa1R5OFlrNStWUjF4MzU1NjVxejRNZ3M0ZFJSYmg1UHRQbStYNVloTGxsM0FBNUhRSExBOWhnR29iYUNXUlVaWTJRWExZOCtSeUZYYmtGUU9oUFBjZDYxNEdHaDJaVVNtSlkyaW5tM1JxelozNFVZUE9DaEpHQ09jY2lsekxsY0YxTTNGTjNPWTFaTlB2THk3MUsvdUpQTmU0bWhXempVQjRDcllVNTUrUURKeGdkSzlUOEpXbW5OQzJseXlpN3VMTzNDbDFYWW14aU1kU2NzT2ZiSnJ5clVkTzh1NFBreWlkblppdjJoaXpobVk3eXd4eTVQWDZDdTk4SlBjV2VueXpReEJGdFVWWEczaVFJUm5ramNlUUI3YzEwT3JEU0wxajZmZDl4TTlGb2RSb0dtYWVaWldTUXp5TEdGeUFvQXprZm1QMU5XcmxOT3RMbTV2akpERzl3a1ptandNc3lGZ3JuMTYrbmFyZHZiL2FydThlR2VlTElLY0lObzU0S2tmajc4MVQxdlQ5TlpaNWJrbGdUdkFpY0J0aHhuajZnblByWE9veVZOOHFTL1ZkL3dEaHhjems5VGsvRUZ6RUpZclBUdzI5WjIzK2MvOEFFV1BmUENqSi93QUs4VDhVSnMxYTRrUnQ2U3lHVlpBZUh5ZVdIc1RuSHRYclYzYlRTM2M5cGIyb0hueHRreWdiMmlLNUl6eDFBSDYxeFhqZUQ3VlpRU0JZa2toREF4eG9FVlZCeGtBZXZYOWU5YTVkWFVaS0w2blZPbDd1aEg0ZjFVUTZHdTJDM2U0M2w1WkpWQlpoMDI4OXNBVm1lSXBJVTFxQzhpalZvcGJVSVFGT04yemIzN2pqOHFpOEpYTnVMcDRiaDVJd1FDcnB6MzVCR1JrRWRhdCtJWTRCWXI1Q2hkaytWSlVCdHBVY0hyMFBIV3ZUZGxVNVgxSlYzSG1YUTFmREdsMjE3NGZ5a0Z4SmZMS2VMZmNneHg5NXdjWnhrZ0RKeGs5S1M2MEhVTkp2Q0RjaFpkbzNKTXhkTW5IUitwemtkaGpOZGg0UHNnM2d1MlNFemd5SzMyaUpPUE5SaVFSeUQxQkdNYzlPbVRUM3RnTE9lM3VMbFhpUm1LSThuenpZVm0yRFBIeTdSMS9EclhtVG5OMUpjdXF2dC9XaDBVMmt0VHpmeElsMS9aVnZGZTJQbFRDVnBQdE8vY0dYN3VPT25QcmcxekVNZDJjUndySVZjNXd2VGl1NDhTNnBEWncyTHdFWEMzRVBtdXJyZ3huUEE2MXhoMWZaZXJMYVc2UWJUODNPNE1UNjEzWVJ6ZE8zTFltc29jMStZMmJLM3ZMYVBiL2FPSG5YNVlvbnl6NEJ3dTd0bm11bjBHNnRYMFZaZHNNVW5uRkdoUmp1eUJ5emV1ZlhOY1ZCcUt6M3Jia1dDWW5hcDNZVmVDQ1BhdWxzNUpIdE5rVVBrRUhBTEtHejdqc2E1c1pTazQrOGROQ1VXL2RaMHlSeUt3UkdTTnBkdVM1d3BHZU1uOGMxaVJocE5kdURQSVF5cXFLc1pKVmh6eVQrZFB6TEJBKzZRbGUrUjA5VFZLMXZvTlJta1JadkwyREpVZkx1QTdrMXdVNmJTazkwZER0cGN2YWhEYXl6eFNOS2N3ZzdrajZrZStLMExDMGp2eEtaWFMzTXFBS3pIek1keDN3T1ByWEwzN1dGdXlxOHMyMThraEJqY1BmMXE5WjNGb2JRcFlIYUpEdFljNEhxZWUrUDZWYzZVdlpxemYzRUpybWFKOVZndHROdnJTQ3pWamcveDVPNFkvMWd6eDE2ZHVLdlc4aXB0ZVJmbUhUSi9YanZXUFBiTE5PVzJDTkZHMVNyZHFnaHU3YTIvY0M0Wi9tM0Z6MzlnYWJwdWNFcjNZbDdyMTJOdVpvTlIxTnJtMjgrTjUzWm1RTU1LU1FENVpCSFRuR2ZUUFRnYVYyclhKOGw3bjdLMldLek53Q2NzM0xkTnhJUG9EZ0FZNHJiMCtTNHN2UGVPeHQ3VlpwdDZreGdvdkFHT1FUMk5WTlcweGY3TmxkTDZCejVnYnlJd2ZOWk53QmNaNzg1eGc5NmYxcm5hVlBaSEU2VFh4RG9OSDFacFAzYlJ6Vyswa0ZmbEtFSDdoVmlUa0hnY25qRk8wNmV3VkRCZWVhWXhENXBDcGtrZ2s4bi9kOUtxYVpKL1p5b3NrbHdzaURhelpQN3hTQ0JrSHZ0YjJQVDA0aGE2M0F4UkRFQndxbWNaWmVNRWpCd3VjRE5aYzY5b3kxVG5heDIwR29lSEpaV0VOeVppeU5FeEVZNEI1NVlBSG5yazFxR3d0WkZaZ1pIbVhCWnc0RERHY2J0dU4yTzJjMTVSRzl6YVhrc0VXeU9TTm1WZkxZZytZZ1RjU0NNYzdsQi9sWFU2TnFsM0RZSWI5b3Z0Q2gwQmlIM2xZamhoOWM4bjg2dXRMMmJ2ZGFveVZHVDJKOWJpdjdsV2gvdFFTUnJuYUpRc1p4emxTeWpuUEhYQXJrVUtXT29iMmN3dHlZeEtNbHVjY1k0YnZ5T0s3TzdsaXZJNXZMakIzT09BNVVvQ0NEd092T0Qvd0RxckN2dEtzeWx0SkpOY1NSVFMrV2taUU95N2w1NXhnY3FPblBXc0tFblBTYjFmWTM1K1JXU0tGbzBjdDU1UXVmNGh2TEFnblBQT2Z6cmZ1NFVDSkpMSmlNOElaQ01FWTkvVEZZT2o2WGNhWXpMSkNseEp2ZG1Cd1QwWEJPVDdISUk5Zld1d2lzdjdUQk4xQ3psTjM3eEZHMVFXYmpHZUJ6L0FKelRyVWxLYjVYZXcxV2FzMlovMktDMUF0M2tTU1NjaG9ZMFBCQkpIQTc5czllMVFMWUcwWnZzc2YyT0Z2OEFXYkJnWUpQcG4welZyVlkvc3NzYnpzR2pqaktSU01SaFNjWXdENlkvVS9nbHZyTytQYUxsblRnQld3UmpzT09SMXJsank4dk1wUFUxOTk2MnVNYUpZMmlDdkhPN2hpenRuSjR4OUJqanAzclR0cFBORVVGMjlxK3lNT3pDTTVCNDkvWCtWWnNsck1yd3VkSmR2S1lZa2VQSXg2NSt2YXBEYzNsbmJDRzh0bWp0NW5UekpDbVBsRGZkSEhVZ0g4NnR2blVkZGUraG5KV1l0ejRkaHZMRmJRU3RLOEVRalRjZHAyZ2tnTWV2VEErZ3JOZTJnaXYwKzF4cE91d3ErMThaSFFkRDE0SjdHbTJkODZwSzhqZVJPQ3pCZzdZT0crWEovd0IwbnR3Y2RhbXVCZjJrYnk0UzdXZVRHRVpXSnhrN3M5UHpycHcwcXFtL2FPNWxWcHd0b1VyV0thejNTUVJGSG5ta0M1WG1NSTM4WFhubjhNWXJLdk5WczljMXlDNVN4VjBpVUpJWkNUdjY0SkFPQXVUMjlhM2JhSTNOcmNOSTgva1B3VUI0VXZnTm5CN2pqSTk2ejdhRmRIdWZQamdCaUJKRWFxT1RuSDN1dzR5TWQ2MnJWSXR0bzU1UWRyRU0wNGZTWDMyczBkM0xJTnJxeCs1eURnZW1RT2ZZMHlPZTVnR0haUExFSmNzVGdya0ZRUVNNazgvcFY1WGEzaGFGQjh5S3VHWk01SnhuZzV4My9QbW85VHRESmI1amp4YlNLVVVEN3diWnljQThqTzREOGF3cFZOZEJXc2NSb3R6TEJyOE4xTzNucmJ5cXJHTmxEZ04vRUFlTSsvWWtWNm40VWt1Ymg1WUhoRWx2RXl6NGJCZnk1TXNHeDBJSWJIeStoR0J4WGxsbTduUzdlMk5nWWZzTXh1TG01T2ZtVnNLcWtZOVJqOGZZMTZSNEtabnVFU08xbXRveEVJcHBDMlFIM2IwQnowSFFZK25yWFpqWXg1T1ptTWxaWE83c05VU1dDM21FY3NUU0ZsUVlKVUVubzNjWk5jeHE4VisrWmJueTl4azJMc1kvTWVDUUZQUGY4NjZQUXJCTER3M0JGc1o3bFZFZ01vNTNNZW5zdWNjVmdlSVh2RnZRYnZ5emNiU3dDajVGVE9BUjc1OWZhdkpsSjhpVGQwdHY2K1J0aDR2blRPY2w4c3lGQVNxK1p1Zmtoa0E3WjQ1L0NzM1ZyQ1NielJjaHh0VHlzTURrRG9SejlmMXJTbTJ1ck0wdm1UTWVXRDVPQjFKOWExdE5pM1dCUnNTQXk1ZFBKM2dad01scWxWblQ5NUhvU1dsbWVIYVZabVRXMXRHZlkyOWtKempubnZXL3E5azhGcVl5aXNUeWV1NDdSMUgwNyt0VTliait3K083MFFrWUYyV1VqZ2NuUHY2MTZGcXRsZVMrWGJYRUNLbTltL2VBYnR4VGFTcEF5UjF3QndPK01BMTlSS1Nrb1ZHN2FYUFBpN1hpa2N4NEQxV2UwMVNEWmVwQnNJR0pYSVdSU3d5dU1IbkJiQjdHdlE3ait5Sk5EdlJBcU8zbXRIRVhMTVhCKzg2alBvZVNlNE5lZVduaEc1aXZFK3lYRWNoY0JWRGdyeit2K1RYWGFsY1dWclpLMW92bTNNcTR1M2ZNYm41UndkdkJHY0huKzczeWM4ZGVwU3Fhd2xxYXFuT0wxUnh1dTJKdWJUN05iS0pIWDdpZzlBUDU4VnlkdEJiMittelR6UW1TWGVWSTY3ZjBxZSsxNjRiVjN1STJraGgzQXJFRzZER0RrZS9QSHZUZFE4U1RYVWdhMUxXNjhnZ0hxSzZhTkd0Q0todW5ydWF6clVwUG42b3hsQmFZNEJKNm5GZGRwVUZ4YmFjakNTYUIyR1NTY3I3Y0dzUFR2RUV1bnBzanRvbmIrOHc1eDZjZGE2WFNybFpyYUZwTGRpV1hjR09kdWUrQjJxc1pPb28yYTAvTW5Dd2czdnFMYzZnN1FpM21HMDR6NXFLV0J4NmpyMTlNMURwOW8zMmlhZUs2czNCNWJ5NWdNQURKNGJCL1NuNnZlcFp3TVZSR2ZPQ3BQYXN2VEF0MDRXZGtXSUtaSFJmVW5qNmR2eXJDbkZleWJ0Wkc5VDQxRk81cFgrbG03WXlwY3h5T3FqOTNEODdjNTY4Z0RwNjFreFhwdFZNVVRTOVRrRlF1UDUrbFRYRXkyV29NSXJ2WWhqeXVQbUgwTlk3VE01ZVE0eWV5MTFVSWMwYlA0VG1yUGtkMDlUWGU1dWJuWkxMZzdjNWJ6RGpIb1FPSzBHdUxtL1pCSWJjUU9RNU1jTzFJajBBeUJrNEgxcWpwdHBjVFFMSzVpMk1nTEt4Q0RHZW5QVTk2N2Z3elBZS0V1SjRicGJFTDVjYURBUXMyVkc0NDVCeWVjOFk0cmx4RTFENFZleE1XM3F6dDMwb3BhUmhacFhVT1MwWk9BdzdkK0ttdDV0T1FOQ2xyTmFxVlZKSnhObkp6MVBHUG9mcFZDRFY0N0dXUzIxUjVGZEJoUXNUYlNDVHRZbmtkQmo4S250NzZPZFBJdEkzOG1YT1c4dktjZGZVY1Y4eEdWU2szZFhYYzY1UlUxWmlhb0lSZVdhV2swTWpUS0xab3BaU3JYT1gzS1FlZ0k1N1o1QStsQzgwZ3c2Y205aENVREZ4SWVTUTJDQjY5Y0RIWDhhamxzcG9wemQyVThhK1c2NEJKT1FPaksyZW9QWWZXckV1cDNyMlYwOHl1WkxkUnNMODdkMzhRNStmdHdEbms5SzcxVTlyYnVadURndmRlaHpESkUwOTFkVGcrWDlxYkRvU3hMTUFRVHozMmo4aFZ6Uzd5M3VMK0NHTkdZZjZvb01qQUh5N3M1L0h2U0c1U1hRSkxRYWRFbDZwQ0xjUnV3MzRMQUZnUmdEYVQxSFErMVNhT21xUjJVczB5eGwyUm1aWTlvWlFHQmJBL2h6blBBN0hGZE5TRVpxOS94QlZKUlhLMVkzYnhqYVRlWGF2NWdhTU5Jckx6SG5wdSt2clNXdG5QTEFySUR2REs4WUJHRHllZlhPUVNCN0dzMjd2Q3RyOW91NEk1SlZoWWVWR1NyS0J4dVlrZ2NiczRGT3RkVm5NMEVNRWtKdUFoYVNhRWxBd3dvVU1lYzR4bkFPU2ZvRFdFYVQzanBvRXAzVmpYVU9pK1hIc0NpTWJsWWdtVGs4alAxNjQ3MDdTWEVTb3VIZ1hmL3E5L0JIVS9MajZmbUtvMjFtZE8xQ0ZXbU16amVyd3lNU1R0QUlWU2VnSTRPTTlUNlZjdWJ6VU5sNUkrMTRkM2xxMlZPQ0QySjVQSDE2ZlduS1BzbGE5N2tMM3RoMnMzTTBEV3V5Wmk4MHhpQmsyZ2ZRbjZrSGlxRUNSWEVFdjJrV3R1OGhPNktNa01NRmgxejdaNDlhclgxL1p6UGJSelJ6RVpFN0ZXMnF6b2Z1NDU2Z3NmeXJNZTRNMTM1UVdTUHpYK1VZTHNvSXlQci84QVhvbkJPQzVOR3pXa212aTJOc1hJam5EVDNFa2pveHlqTjhnVW5JeU9uUWdHdEdYeEJhU1c0c2JpS1ZSSmxQT3RZaXlMbnB1VTl2Y2ZwWEgzRWtZTHZDY0l6L0tTTUgvRVUyMUxOZXhMQ3FqbjdqcmtIOHVlUGF1ZFVWZjN0VG9sRlNWelYxUFM0N0MzZVZiOUpEamJzWElMZE9neWM5YzFqS3BMc1FrbUF1U2QzR09uVDhmMXJXazFHSkYvMFdNSEhVQVpYSVByNmZXc2NUcnUrZFpIQ3NBVkM1NXgweFd0S01rclBWaDVzMXJlNFdLTkkxbTJ4TUF6a3I5MDhqajlEeFVsMU5FRGlHVUtvNDU1Skg5S29STEw1NlJ3eGt4a0VrRVpJSGZIR2ZUcjc0b3ViZWUydVJESkM2c1JuNXVNTGpJeU85RW9OR1RVVzdrdHZiejMweStXUVFDQkdtUXVlQ1R5VDY0NDl6N1ZEZDNMUjNYa1hFWGxTQUFaTWdZZ2drSFBIVC9Db1JQSTBoTWtVZ0djTDh1QjB6MzYvV3JPb0x0Z2pJc1pWWjJhUkpaR1JpNm5BR2NIc1F3eHgwejM0SXhzOVNHck5PNVduZzA2WFFab0ZkbzdpZWFOR2tHQ3JMa2tkQnh0UC9vVmQ1b3R0YnhRMnl3M0NtZWRGdU44aWdlWSsvTExrOU9Bb3dQVFBVMXhQaDliZnpYdE5RdHJpL1V4U01vdDBYY1dISTR6eGdleHJvYmFXZUl3czhGK0M4Q1NJMGxyNXNMNXh0d0Z6MEhQcWNkQm11bVVaenAyZTMrUnkxYWE1cmJHdzJvUVJzUk1rZ0Y0SkhoWkpoaUtRRGNUeDZuZGdub1ZxcmJUVFBaTzE0MDk1SnNaWGxiR2RtYzQ2ZEI2bjFyTjBYVVpWVy9FVnpHNy92RkNZSUliUHpibE9OcEFIVHB5ZnBUTGhIbjAvYzBNZ2ZJOHlUNWprSE9DT09Cd2UvT0s4NnZGMzVFckpmNW10R25HN2JISzhVZ0VVbTExUmNNTVk4enJsZnB6ejdjVTBUTUxhTVJFUkFuZGJpQ1hHQ1NBZWVlZWU1cUcxbXRMZlVJcmFTTU1ZMFZwRWRNK1dEa1pPYzRQSFVrZGZlbHVMamF2MmJUWXJjTElkZzNMaDJQUFBYSFFaL3d4VUtMNWxGSTNscHFlYStON0FhZHJrY2kzYTNIbng3L01VODV5Ui9UTmVuV3V2WHQxcDlyY0N5UzZuTUlhM2pFNERsbVZSazhBWUNrajhoWG1makJVbnQ3ZThpSVpBMnhtNkhKR1J4K0I5cTBmQ3lDKzArRXNERVl0Mitkand5cU81N0tCamovR3ZkcVJVc0xDVStuOWVSd1NpM1VhVEc2YjRtU0MwaFM0V1Z5R0llVGZsZ2VvT091UGZOUjZuck1rOEVxV3pueTVJOEJnM0JHTTV4NjlxNTZLSVM2WmVOR04wa2JLd2ZPUGw1ei9BSTFMcDBFaHRSZHNDMFliYUJuSHpEcDM5LzFybytyVVl5YytwdEtyVWNVakhoczdqVUxveHhkZTViT0taYzZkY1dSQ3p4bFN3TzN2bm1yc3R4ZGFWUElJcENtL0JJR0NEV2syczJONHFQY0lmM1EzYkhIVnVNWXhYWEtyVVRUU3ZIOFNZVXFjbzJidEk1NDZkZUNNeXRiU2hQVXFhN1hUTFFqVHJRQm5IN29NR0tnY0hzUGJQZXNvYWpjNmtKTGUxakxJMkNHNmJCNkhzYTZnN1lyS0NPYVVlUmJ4Q0ZXWWM0N1p3T1R6WEZpNjAzRlJsb3plaFNVWk53MVJ5ZmlXTklwWVFNczdrbG1KeVQwSGV0QzJza0tyNU1pSkd4V0loc2ZNUVBtL25WZlZJbXV2RTFyYkxiRUlycWdTWEkzZk4vRnlNWjlPSzJMRzBFVTA4TGhDd2xiY1Z3YzU1d1Awb25VNWFNVmZXd1FYTlZaeU9zeGVYZnVxRWtKZ1ozWnp3S1hUN1kzRWdUSDQrbGREYzJGdjlxdUpwekU0a2JBeU1iU0IwNjFnd3RzbkpqY0tSOHAyY2RQL0FOVmRkR3R6MDdSM1NNcWxMa2x6UzJOMktUWXFXVWJoVEVBeXVnd1FlcHorT09lMWFNT2p6WHN5UVdqUDVPMVN5eU16RGRua0tCMTQ1UHNEelZDR3dqVTI2UU1mdFVyNDJNdVJqam5kbmp2MnJ0ZkROdENaZkprQm1obGsyRldrd1E1OWoxT1B5QngzcnpLMVJ4VjRibWppck82TmczVU9yVDJpd1RNMGxybVJZMGljQ1AzWW5rakhyNjFxcWJPN2FBN3JtSUt2enlLTUZYR2NqajFIdDI3MXhLVEc1VXY1aGtnZGZNSUF5TW5vZlkxcEliaUZWbHM3aVpJVlU3WlFSa0U0NHljNDVBUFh0WGtxbkNMdCtmOEFTTkpLWFFmck4xWURVSlZzNTVHRVJYREVOajZBNEE0ejE5dXRMWnlOY2dxRWtjRG5jZTNwMXFoZE1Fa2tNN09abFB6NytqZE05T094UEZXWWZKV0dTOGZkRWtNWkprQXo2NDZEZ1p4MS9XcW5CUzBpaldMVVk2bW5GcGx6RG85NWQ2ZE1MbWRoaHJkUGtmYnVIQWRoZ0hITlVkUWVXT3d2TlR2SUpDUEtqM3g3TU51UHlObm5rZ2tFa0QrTEZYN2ZVbWhzTGp5Wmlza29HUmxWREQrSTR4a0hwK3YxcS84QVk3YS9aSWRUdUdhMmFOVmtpbFlCdHh3UjN5RnpnNTlzR3VuQzJmdXYrdjZzY3RibVVtMmNXODFxMHJRSVpJNzFrYmhnVUxEQlBRZ1o2R3RPeXVCRXJDM1FnTXBWU1l6eXhHQ1IxOXZYb0Qycm5OUXM3aXoxeTN0SUpMa1JUa21HT1RLb3lzb09VS2s5UjF4WFJ4cnFHaVR4eVRqZUJrdG1iZXZ5NVZUanFPZW5zSzJyMGxCSnAvZUNsejZXTFVrMEtXVUxiVWVLVkR0UVozUkh6TTdzOFpQWGo5ZWxVWXI2NWlYYWhqQTNCZ1NBY0VBOU05OEUxRXR6RWVpci9FUkZ0UHJ3RGo2L3BXZEtaQzRKS2daeUJuQXJrZk5PWHZIVENDVWJEcm9QTTBvODlWWWNram5KelVFTjZiYU15czdMTXc0ZFh4Zzk4ZS9TcVVrZDQ5MFdqVnZKVVlaejkzSjZERlhsMHh4RGFzc201N29NemhWd3dZa2pIT2NkcTZJeFVWZTQyMDlCa1Z4RkhINVltSm1HUHZOam4xMm5rL3AxcTFiM0Z3MTgwaUxIdndRSkcvZGJRU0dPTy9ZZFJqclQxdEpOS21lUVFlVk1NZnVjY3NNK3ZUdG5yVjZHR1I3bUpwMVZvaEd4S2hmNHNIYWM1OVRrL1NwYzRwOHlKM1JreTZZK29NWlZMb0hkbWs4Z0VjOWVUbmpubkdCMjRxL0hacGEyeEpZcHRDZ0xqb01aenlPU2V1Yzg1clJnK3ovTkJjU3BFbjNtTHJ4SUNjSFAwd3YwNjVxUzN2MUVLd1F4anlseXpNWDNLeXIwejN4Z0FkYVU1elVVM2Y4QXJ6SnVydEl0NkxhUlFOTkpQRTd0T2R5aVhCSTY3UXVlTzQ3YzRKcE5Wc0V1THNXOXNWRnhLZDBTSVFWeGpKSkk0SHFCMS9PcmtrdHNKWS8zTnQ5ckpNYmhCR2l4cmdIZm5JeHdlbzlnZWxYTHVPMkZzU0pJMnRoKzVFV3dKaFZQSVVqR2VBUi9oVnVsS1ViczUvYU5TdWpsN1JGZ1l5Ym1rWFkySFp4a2prWlFuanA4dkZNMSthRFROT1NaV0Y2OHAyZ2wyQml4ampJT0dPQ0J4MDVyUUVQbitjeUl5cEs0V04rQ0JHQ1R5T1NHYkhmbnA5RHpuaUt4czRJZFVlWloxdVlsVllvOTRJaXhnc3pFWnpuSUdPTWJxemhTL2Uya1JVcU5xeTNFTFhVVFJib1l2TWtSWlZNRTRPM25vU08vZkZlZ2FRa2YyUk5RREF6MmFGMmhVbFFWNHljS01aQUIvS3ZNZkRmaUM0RWN6TEE1Z2Exa1NRYnNsdU9NTCtCL0t1OThHWGN0OTRldjFqV2VGcEkzS3VpOHhrS09BT0FjOWZYbXRad1VYWm9tcFVja2tjcG9FV24zV3IzR282bkxMYnFKNWd6eHV3WkN3SkJ5dUQxYnIwN2Q2NkdQU0NuZ3E5dUUxUzRpODFaOHdTT3JLNklHWCtJWjUzWjRQUWo2MW4yZmhiU0xHRzZjM2tsMnlTRUFvb1ZmdWdxQ00rdWMvUWl0elh0VXQ0OUNoMHhITTd6UU0wejNNbjNDK0RqanBqSEFIVGdlMVg3U0VuS1Nsc1p3VlJ5MDJPS3NidTRHbHl5dlppNW0xSDk0am81RElGWXJsaDBDOWFXNTNXYzNsT3hndUNDaXFYMjV6d1J6eGc1clMweU94RnZIRDVVaGRJZ29XTmhqY0ZPNWllRHNIQi9BL2hrTnFNVWhrU09QemlwUHVvendjc09PZnhyR1VuS3BlSzBQUWd2ZGFsdXpuZkVkcVRZRXRJVDViQWdsZzM1RWNkNmc4TlhhTnA4dHEwU2hBMlhmSnk0SlVoVDJ3Q21meE5hZXFXUnYwZEY4cXpqU0xKamozRldPQ1FUK09PaWl1VzBKSUh2ekRQSVl3dytWZ3hIUDRWNmxQMzhQSlgyT2R4VUtrZERRMHZ5NUd2MDhuNUhQQ3BuQUdUeDlLazAzUzcyNnRaSVdWSVlrSWZCSUc3UEhHVHpTNkE1c3hjYmdWVjBBTE9BZHh6bmpqSTZWTnB5R0xVc05idENzckZRNE9ZK3Vja0RuOGVhbXBLU2N1WHlOWVJUVWJrRi80WW1ZRmxuaVZWVHEzQko5UGIvNjFacStHYjJWdHNPMXp1d1RrQUQ4VFhTNmhxVW1uMlFlV0JIdVppVmpmT1ZqeDFJSGZyV3pEWU9icUlqV0xHNWpraXlCREVVUmZjazVMZGh4V1N4ZGFuQzdmOUwwTlBxOUdVcldaem1pZUhiNnl1MGttbFJJV3lDVnlRZjByczdLMTh1Znl6YlBLZXNiRnRpa2dISFB0V0RySjFQUk5NYUMwMXVXN2pjNWwyeGtCZUNNS1R5QnorTlMydmlIV1k5Tml2TDc3Vk5GY3hNc1pjRUpJVk9NOFl6ZzhaOS9wWE5XalZ4QzlvbW5mVHFpbFVoUzl4Sm9icWR4cVZoNG50ZlB0clpvbGZ6a1FzV0RZSFZtSUhmbkgwSGV0WFE0YmMyVW1yTkdXaWlkM1pWVGVUemhlNHh6dDdkRFhNM09uNnJEcUIxUFVmS2FPUWx0dWQ0K2JvQW80eGtqSUhiTlRTNm5MbzhNbG1ubWVTaHh1VWJrazZmcHdPRFdqcEtVSXhoWnZ5T1dvNWN6dmRKbVpxdWxYRjVlWEZ5cklxTzVZS1RqcWVBT3RVTlBzSm12SllBbS9aMTI4Z2ZqMHFqZWFwY1hrcmlSMjhzc1hDZEZCUG9PbGEvaHE0a0Y4a0Q1V0dSU3BmSEk3OGZsWHFSaFZwMHVoRjZUa2tyblUydHEwMm9yZFhkdG55ZVdhTkY2RTQ2REFVWngrZGFoa2ltODZZVEtpSktNUk13a3dTQURqR000Mi95cS9iYWZEWVdOczFyZXlhakFHQmtTWk5oa2JKUE9EazRJUFgwckdNQ1QzVS83bzd6SXJKQTZibGZKT2M4amdiY2NuMXJ3MDFVZWoyL3JabTNPdFdpejRldXJLQ1BVRTFNVzhYa3R2aW1ra0lTVDJDRDZaUFBmcFZ2Uzc2QnI4UXc0bFJpQ1FneitJenhXSkxIWnpXTGt3VEM4Sk9Ua2JNY1k0NXlEeWM4ZW1EVlRUa3VZWlZhM1lCa1lNRnpnL3dENi93Qktpcmg0eTVtM1ovZ2J3bXJIb1dveEpPMGpSdytmR2lZWkhRQXJ6MXgxUEF4ajNyRWt0TDJTNlAyVi9LaGtUTWxySW1JMzJnODQ5YzRJK2xKRDR0dUpMZHJZc0VNaDJ6T3NleWJibm9mZjhPOVBrMWJUcnRmTm1zcjRTdHd6dE5sdU81QjZrKzJLNXFhcTB0TENjT1pFVWd1VURiMlFSSmhHd1NmbnhuMjU3WTlxdVdPb3BDNUppTXpGZmx6a1k0SHk4K3h4VVZ6WXlyYWllRzVTYTBLYmtSQVJsdU81Snh4V2RjU3BJMGJ4Ymt4enQ5UFludjJPYXVNazlVVjdPNnN6UXUvRTJvU3F5VE8wTXdEUlN4OUIxT05weHg4dURucmsxbjN1clhGN0I1czZqWkVOdS9razhaUDA1enhWWmtEVFJzeWhpVDJ6MXp3YVpmdVlZNVNXZFlrY2JpUWNaSi9IcmorVmJ0cWJTS2pCUlEyNGtXR0xmS0R1NGJMRHNSa0hQNGlvV3RtdmxCSy9kR2NjNTY4Y1ZQY1djRVVNY1RGaXMwYXlGVTlTQVFEVGpNOGR3MHU0TEd3d3lqNVJuT2M4Zmp4MHFscDhPNVRlbHpXanVMYUxSY1NMTERHVmJJY2NvNEdBY1l6L0FCSEdQVE5RRzVtaXNyZXdFYVNRb3BsV2ZCM0VEa0U4YzhaNTlxZ2E3ZjdQWnpSS2pTY1BMNXFrOGhqZ2NkZ01jZXRPbGw4NFNtVjJsWmprdjBZWkhiR01EbjhPMVM0UVMxZHpLMG03MkxUcmNCeEhMR3lqeXhMRzA1STY5TVorOTMvS28wM3BMQ2s3Z3lUVHBDUGx4dFptd294MjYvcFZDTzZMU3JCa3FpcmhRV0o0SFlEOFRXbDVzMXRFMXdYZFl3Umx5ZUFjK3RSUGtVa3JhRjJsWXZQQkRzak9aWGs2cmxlVkpBT1FDT1BlcDdlQXEzbFJnRVR3S3ZsNEVnYjVmbEdPZmFzNjltbnRKUk41Nnh2bjVKSGNnNS9EdlRUcWhqdERBakdUNWhpUkZCSklHTWIrb0hQVEk3Vk1ZdWF1bm9adE5IUld0NUV0ekdzQ2VYSjhzVE5KeXFkaDF3Ty9UOEtsWVdrclhNZC9haVdTU0VGeTdjN21PTm1Cd3ZKN2U1N1Z5Mm5hcEpLR1V2REhOczNLTjIvZzhjOGpIR2Z4RmExdzdUUFpTcEpOZDJ6T1dTNGpJaWpSaEczUWRYQUs1enpua0QwcldsVDVYWm1GVmRURWx0L3NlczNNZHZlVEpjcnVqYmNVMmx6bmNSbHVwQjQ5T2xSVHdUYVpvTnhISk1KbTFDMUlrRzF0a1l6d29JUFVrTDE2ZmpTMzd3YWhOTmMzVTVobGprMk5sbWNwa1lkdnFUdEF4NkU0NkNxbXEyRU1QaHZVMG1udUJKQ25tcUZrWm9pU1JqdnR5U005ODU5cTNpbTVMWFc2NkhIYStwaExwcmFYYmFYOWx1NDU3K2Q1SjVvb1pPSW9sYmJ0T1RnNUlZOU8zcFhvK2xhOHh0NExheWpnUzZVaVFSRTczbkN4amFNTHp1NEJ3T3U0alBCcnlHNUg3c1BoL01qR0FveWNqSkpQcGdkL3JYWFdGN2ZycGRyYTJubXdpMVY3bDVyWWJERVFRRGtnL01jZmorZGRsZU1YNzBpVmRxeU9ndXZFV282d2tNSGxlYXFLUDNrdzh0Qm5ra0RCUDZWbDMwRjVHV0YxY3BENWFsbldGZm1YZ0hCTFo3SDBIV3RIU1hnazBreXhuN3R3SGtsYVREakkrNm83NEg4dmFwYnVGUHNjOTZKcG4zYjVaSk51ODRYcWZjNC9sWGpjNmpQbFM4ajBxVFNYWXdiU3o4cEJkU0JwUUY1OHdrRVpIWUE0NlZaZStoOHBZekN4WCtFb0FmeFBTdEthdzhuWWt1WERLQ0NUZ2dmaDBQOEFLc3lXM2plZFVMTkdGN2s0UFRvYy9weFYrMGpVZDJkU1dtaG0zeS9ibGN1VVFrN2k3WitZOXg3ZCthNFlRK1RxNGdKREFTYkFjNEI1eG12UTdxQ3hTOHhGZFNGQW9JV1VBSGQxT1BwMHJrOVd0N0NYVTk4VjNzdVpNT0F5NFVuL0FIdXhPUHpyMDhEVlN2SFd6Uno0bWsybEpEdFBUeVpKa01JZVpUaGdqQW5yOVAxcDk0QmEzd3VQSWtRNHcwMjBsUjA3WS9EUHRXaFpzcDFHY1J5bGhqYjVJWEd4ampuZDA5YXMzYVNDS1I0bkVxamtSZ2ZlUDVVU3ErL3F0eHFrMnRIc2JvMTN3MXAraDJZMWZRYmU4Y0ZoNTRBWm0rVWtFWi9BZGVPS3FSTjRPMU8wODJTMnV0Tm5aQ25tVzF5WENnNEl6MTdZNEFyajladW51ckZMWkxTUlhNZ0lMQWRkcEdQMXJBemQ2WEloWW1PUS9NQURtbFN3Q2xHNmsxTDEvVGI4REtjMUNidXJvMzlkZ05xcitYckwzU0tUSEdyS1VaazdFZzgrbmF1aDBTODBwZkRGdE5mMmtNMEl6RE5KUGNscEVVc3grUkJrNEcwLzNmMXJ6eVc2bnZITFRTTTdLQ0JudFZ1UDV0QmQvS2I1SDJiczhjblA1NHJ0bmhyMDFDYjY5TlB5c2M3cXR5YmgrT3AyOXhkYVJjeEcyME41anA4VXFiek14Um4vQU4wa0hBNzg0NkNwcDdTd2tkWlJhek1veDhyT1dPM1BQK2NWeitsR2RmQzBpSmFxViswZWFaaXVQdW9SdHozKzluRmRKWXpDN3RyNjZabFc2aWo4NVVBeVFCMVVldkdTQjdWNTFhbjdQNFc5SDMxZTI1b3NRN2U4cm5uTjVLSlhVTERISHQvdUxqTmFXbTNKaFRhRHRLamVwOSsxUTZXTFZ0UlJieEF5TndNdGdBOWlhMVp0TEVOMXR0WVhNZXdGZWQyNC93QXE5V1ZXTWYzYjdHYXB5a3VkSFZhUHJscDVjY054ZU9ybFZaTGdKdTJGUndPZXZVakhJOVBXbGU0TTBycUoybFZXSWpabElERFBVWjZEdldUcGFpMnNSNTBjY0xJeERFWUxFZGVCK1hHYUpkUThpNWlrTnZIUENRWENTTWNzT1J6dGI1ZU9ldnBYa1NwcVUyb25SVC9kTG1lL1kzYmw3YTVzSUZqdVJGSkFmbFZWTEJseHd1U1NjQS9welVDUTI3ZVdZWno1aElZZ2taQTQ2SDg2cnhTbStZVFFTTWVmbWtCM2J1ZWVUM3lUVHJGekJJNnp3TE9wSlJTNm5JR1FlQ0NNZE9vOWF3bGQ3dlkyakRrajdwczNLUXVNeVlKajVFOGZ5UGpBUFVFbjE5cXdVVFpOR1kydUZ2UXhPNW55ckQyQjc1SHJ4Vi83Zk0wanJkbnowM2JoalB5RWdmTmpqL0lxU2U0TFBzbWsrWU9zb0ROdFlubkJINWsrK2Vhemc1UjBIc1FGNWJTMFVZdDN5Y0xHSHl5NTZrZ2RNZE9lYXFrdE8vbU8wbVZ6MzRJL25WaWVDU3dVQ1JmTVNRRWlYT2MrNUkrbyttUjJxZUlNOW8wYUJINDNzQWdPQm4rOWpJL1BCcXRGcWFwcTF5cXBKU1ErWUFjanBqOUtoMUMzTjRrY0pVSkRKSXZBWWtzY0U5TThmeGV2V2xrODFOVm10aVVRd2tmS2hEY2tad1QraHJRaHVuczNoZU9ZeHlwT2pMODJDRjNESUhya1pyU21uR2E2R05TYWNXMXFUWDlqTEZjMjBtQVJNZjNZMjRIT01nTi9FZTNRVm5yYnZJV3VESDVlQ1hqY2tFT0FTQUI2Ky9welhYYTdpL3Y3SzRXQ0c0dFlwZzZGc296cVF4Mmh0d1hlTm1mVWNkaWM4bTFsYzZmYUxZeUJVbGc0ZFZZSGFUMUJQUS9oWFJVaEduRlM2bU5LVXFqNVNaSlNDWDJnSGJoaDFIWThmbFVFa3pKY0FTbmY1aHdGeDA0NzRwcG1hSk14SXBCd2NIOHFrOHhKSFJwTUllZWd6K0FyaHNkdGlFb2ZPU09JS0h6dUc3UHkrcHorTlR5L3UxMmx5V3llQjBQK2ZlcmZtU0ZmTGdoU01NU2R6QURINGY0MUt1bU5LZ0t5cStHWHpIQkhYcmpwOVIrZFJ6NnE0Mjdhaytqd1drc2QybHdqeXl2R3d3QUdBVWNaeWVRT2UzUFh0VC9zcEsyNUNSYlkzSVI0MUtMbnFPRDFOUDAyMkt6SWpySkhKUExoVERjQUZSemdnRlFjRDNHZjUxTEtzUWQwRnJQNXl5c0FxUjVDc2VmMVBIOHF6bktYTnlwbUthdmN6NExkTGFhNlY0blJnVlg5M3N5VG5BYkJPTUFlcEhYNjRUVmRSdWJqUkJwMEZxZ0VhWlVya2xGSFB5NXpqZzRIZkdmZW5IVWxndFpFWlZLbVBhMlNkM2IwT1R6ajhhQWl2Y0pKcURHR1ZzS0ErRkNjazUyZ1pKd2UzUDhBWG9oVW1vNnIvaHpHcEM3TVJkUHZMZTBZcmR6UXhTaUx6REdTQ004L01mVWVudDN4Vi80Z2F1SS9EOEZpSVpvcG5SUVpTKzRTSnQ1VW5vUnpuSXJVRnJwamF3RGNHR2VOY0F5cVRnQVp5dzVIdjE2NC9DdVI4Y3ozRWdodDBqMnRFREc2SXBJSmpPM3Y3TGtqdG11eWgrOGxHVWxzempxUVVOaXp2aHQ5RHNiUkpWSm5UNW5palVzeUhna3NPZnZFNEhzYTBkSmdqbU1GdEMyeDBiSVJ3REhnS2R3WmozKzc3MXdsaFlhdGV1cmxwWVk3cnE3ZklqQURqcDdWMlBoKzFOdnAvd0JxOGlNUEhjTEV4YzRMa0VrZ0E4NEtuSHB5UFExT0pweGhGKzlkL3FiS1Vta29xeDFsM2E2ZWJhK2EyaGdGM01tNHZERVFrWDNYM2JPdUR5Q1FjZ1o5cXhwcm04K3ltT2EwSlVxTVFwSWRvejk0ZTMxcTdGQjlqTTEwV052RzZlYnZ6bkpJQXg2am1wOUdsdExtR2Rwak5zbGkrUk5weXo1RzBmbjYxNXNwdHZ2ci9YOWZrWENDanJjeWJTU1pFTUx3TktHaklBYVRjWS9tN05rRWtsdlEvcFRiMk9hR2RvNWJhU09ROUZkU0Qrb3FhNmFEVDdVVFhWc2Z0RDNBUzN0eGRCSk9lQnZYYWRvNHoyNjlxemZGL2lHYjdYYTJ5Zk5QYU1CY2Z1U3U0NEhERW5MVnZDbk9yVVNTL3BmZWJLdEdDdWlGSVdsZFdjQTRjWUhxTSt2MHpXSnEra3czV3F4UzNRTnJESXhoalVaUG1FZFNEemprOS93cVdMeExjM09waDd0RlE0Mk41YUZTZXB6am9UMC9TdWp1ZkNyK0lQREFuam1jWERqZEdreUVBWWJxQ092R2Z6cnJkOExKT283SjZYWFFYdEkxbG9yK1J6dHBJbHBPMEZwSXR4RzMzOFNEY3B4eDllTVZadUdNa1I4bE1rOEhubXNIUnRPdWJUVkpMVzU4MjFsQUk1VGs0K3ZVVnUzTnQ1VUdTWGtHQU1qT1JudnhWVm94alVWbmMwaFVrNmQyckl5OVJ2TGZUTEZSSEJpUlcybGM5ejNOY1pOY3pYRHEwMGpPMk9DVDByWjEyM2UzL3dDV21VWnNvck51WURIWDNIK0ZZQ2N5alBhdld3bE9LaHpMVnM4L0UxcFNseTlEYjBTK3M3QVRQY05jZVl4Q2dScUNNZTVKNHFlNzFUVEd0M3Q3U3kzTXpmNjJUa24zOWo2VlIwU1BUSmI4THFra3FXNXovcXgxUGJKN0N0RzZ0L0RoKzBmWUpaMW5UR3haU2RyODQ0T1B4NXhVMUZCVmRVNy9BSUZVNXpkT3lhdCtKcVJRenhhU3NjZXhnd0J5Q2NnZDhWcDJ0NHR6YnZiVzFoUExLWXZuVkcyaGlNNHpuR092VSt0VnJLZUZZVmh1QXFORXYzMGJja2dIR1J6Nmo2ZWxTeWFnbGpvMHJ3VDNFVVV1UjVjYkZUazV4bXZPcWN6ZkxiVzUxUmpIU1Nlbm1jOWNSejZMZlJUUzJzSUorWVJrN2dLMDRkYWtiOTVGYnFnSTI0SnlNa2pIODY1MjRsa3ZYYTR1cnN5T280QllsdmJxTVYwR2thNWNHQ0MyWk4vbGpDbEZ3UmpwWFpXcC91MUtVYnZxWVU2bnZOSjJSZFNSaGJ2OW9TUlpIWVBGSXBHUHA3RSt2Rldab0xWbWlnbmhtZ2ZHMldSVHYyblBKeDE0NTZFZlNvRnVwSm04bVdIYVJ5Zmw2ZlgwcTg4UXZMT0VXeXI5cDZ0SjVtMFozY2RUanQ2Q3VGT3pWOUNweGpxMDdqZHF6cTBjVWNwaEpJWGVxZ2hjbkJPRDEvR3B4TERINWNTTTRHRDh1TTgxVFcwMUszZVNYelZjN1NFamJKM2RmeW9IMjFyUmc3eGpuZXZsS1FjWVB5alA0VmpLS2IwYXNhUmszMFphaURRWHF6d2tNWXdOMmVRQ0Rudm45YXo3Mnl2WkdNMExxNVhsUXluSkh5NFhQOFAzZUFNRHJWL1NtaWlzN2xmc2lLMGdKMnlnU2RBZWNyMzVQdlR4NWtkczl5djJlK21rUU5KR0hZTVBUYVQ5N0dlaFBZOWF1SE5HN2k5dTVsVWxkcFNRcXp6TEF6WERPejdYVXBJd0pCQzRJSEhQOCtLaGdJYnpjTHRBYkdIeU1qSXoyK2gvUDBxYUFQZVFTeHRENWM2d3NzYWhTUXo4OCszVlIrZFZvWWJvYjhsVUpBT2M4TVR6VVdTdWFSbmZvV0h0NDFtTHhSRmlldlkvengyclRXT1dKQnRqaWRreDhyWUdQZlBxT2FvMnA4NlNhSTNEdExBOGZLUmphVjZucjE5TzFiNFlXa2ZtTWtUamtPaFBPY2NFZmo5YTVhN2NiSjZzMXB1K3kwQzF0NUpJRlY1WXphYldZNzNCVU1jcnd2VW5ISFR2OWF5YjBlV0FJaHNCWFBJQXhWeTcxUVNSck90Z0xlWmxIbUFOdUJKenlQVE5aRU1xejI3dVlmTVZsYmhod0RqNkgrWGFpUE5LMTlMZk11S2F2SUZ0TjhRTWtha0ZBUnU0R09vSS9MclZ4TGFPQ1dOZHlpVGRnc1R4azlNSDM5S2xueGN4QU82aDJRank0VjRBd0FDTTg4a0hyNlZVdFZhS1o0cEVZSkdBcW1YYjgyUFkrL3FLcHRPNmJLdTdGMjBqWjdzUmVZRU1yWTNTRUFBNC93QUJXaGJUQzExQ05saFV0RzV3eVA4QUtUMHdlZWUvNTFXU09HSzBXS0tHNGl5djdzTElHK1RJWTVCNzhEbjA3VlRtdUVLQ1lSQzJSSCtYTDVaams4NC9ILzYxUnlwU3ZGa2F6VFRKcnlWVGNGeEswREpKbGZMQnh3TWJTT2NqUFdyYTM4alJCR1o0eTRPUnYzSGtkUVIyL2xXZEd6RzdCa21qQ3VOeVlKRFo2WUl4d2Z4cSs0UXpMSDVaaUJRc1BMTzNrREpQcG52a1ZsVTBlcUs1VjBLVnBERmJuQ3dnTEZIM1BKNi9NU01jaWxuZ2lqMHlRU1NsZHU1dzdmZUxGaWNaNTduRkxEY1dzMGhFUkJsdDhySWhCSlJnU1Bwemo5YXJhbWduczQxZUowa0VtNU1ESURaOWoxUFd1aW01dWFUN21OV3lpMmhsdDl1VFI3bmJxVm1Jekd1YlVqRWtpa2dENVNNZDgvaVRVRjB6V05ySTBjbm1FREllVTdoR08vSTU5T2c2ZHF6OVZrRnhwZ2h0b2xqZ0V6VCtZV0JrQUs0QzU5T0IrUXJucm0ydTdsNFlOc3Nsd1g1UjN4bmprODl6WG8reVUrdGwxUFBwVkhCMmt0VFdzdnNhM2t5d1RQSXNVZm1Lc2JzWTErZ3lDM1hvZjZWMFZ0SE9zY005eE1KanVac29tQjl4aUJqcnljRDI0cUNPeHM0Mzh4TEszamJiaktvRHp5Q09sWFlOa2M4YnBiUnlyQ2gvZEZpZzNlNTloNlk2MXhWYWludCtOajBPV1NqcCtCcHkzWDJpRko1USt4VlZKWlpIQTJuUFE4WndNL2tLc2FYcU5yQVpySzVsdDRJWUVhU1FGOXZDL2RJZnZrRUhIWHI2Q2lTN3ViR3h0NDRiWnZ0ZHd3RFJPQnNKWkRuYnU2ZmRCeVQwUFExWXNMQzN2TE1TNmphMjhNdmxDTGN4RTJ4UXgyWkM4T2NLQjBQQTU2MWg3T0tWNS9nY002cjI2RVhpZlMvQy9pWFQ3clc3UzlWYm1DS1dTZGtUWnYycUN1NEhub01jYy9OWGpzMDdTWDdNMGpNdUFNazllTUN2b1M1dHZEZHpKTFoya2NVTnpjcTBVK3dNTjQya0Zpb3hqZ2RmY1Y0SmY2UkpZNnZkMlZ3ckpKQ1RoU3B5NDdNUFk5ZnhyMnNIVVVuSlgydGIrdDl6bDVtdENPeGVTSFZaV2lZU09VSi9kc1Y2alB5NDV5UGIwcmVzUEVOOWJhTkM2M1VqR003ZVpHR3dkQmpKeGpyeDcxaVcwWGt3eVhQbFBqTzFXRERHRG5nLzk4bkk5S2tnanVKd1UzUlcwVW00TDBVWjRCQjc4Zy9wOWE2YXRPRlJXbXJtMU9Vb2FvWlorTHRWdGJyeUo3bjdWRUdLN1p1Y0E5Y0hxSzZsNzJLSEVrU09JVTZvall5b3hnQTgrbU85ZWEzeStYY2JnY3FmdXQ2MTA5cGMvYXRKTXU4S2tNZUhKT0RuQXhnZTVQOEFPc2NSZzRPMG9LM2MzcFlpV3NaUDBFOGFhbUx5M3M0WTgrU29MeExJaWg0Z1NRVXl2VWNBOGdldmMxeGcrWGNmd3JiOFFYTUwzQ1FRU0dUeWdRNzdzcVQwNDl1UDFyRE9TSzdzTlRWT21vbzVha25LVjJXYlNFenpKQ3BYYzdBRGNjRDgrMWRuTjRTdGZzRXQ1YjNhUWlOVkplZVVGZWZvTTVQYXVLc3hFOXpESE5LSW9tY0I1R3poUm5rOGMxNkpkV1hnYUN4YUtDOWVTNFpBdm5SNzJ5L2NoVHgrZkdQVTF5NDJwS0U0cUxmeVYvdk9uRHFMaTdwZmViR2s2SHB0MXBsemF3N3k5cVJzbTJGa2tiYUNjTUJnODlSV0RyMm1KYmFOY3lSMm9nZFZScEVuYmRKMlVzdUJnREpIR2UvU3V2OEFEbHZiNmQ0YnRvMnZJNURKKzhFWndwanlmbUdmcjF6NlZ3WGlYWHBMdUM1dHpJNkFzcUNJdVNjS2VTZlhKR1IyNXJ5OEpLYzhSSlJkMG4xTjhScEJObks1SkdNMXZhTkliUmhLYmN6TVNTb1VrRWNkZnBYT3E0TFk3MTBXaTNNUXZZazJ5T1NoM2hUeGpCNCtuU3ZkeEMvZHM0cWNtcFhScFQ2aVp0enlSTkVVY2dzQTJSMHlEK2RiRmxlUGRBSHlwTjRZRUNTUUtTZ0hISnhucnhqR09ldWMxaFgwNWd2NUVWMzJUU2tyc2JQeTd1UmcxdXkzbG9McDBpV1dSVUFWUE1JKzczSEhRWno2OWE4aXNrb3BSUjIwMXp1OG5ablRYVUVEM3Noc2JrU1JMR1hTUUhKMjl5UU9oNmRjZFI2MWp5L1lMQzJTT2FPN21kZ3hCUmVFVUQwNXp6Z2RSeHoyclloMS93RHMzVjNrZEZqdHBDR2xnakpZU0lCbE1aeDF5T2VNZ2ZuVTFUWDdXWGZjYWM5cXM3cnVmeTNJS1pKT3dMMU9lT1IweGpqclhOR25aNkw1R0tydEt6TXlZeEJybTBNaEVUeEpzbGpVSTB1ZWNCc2tBY2ZYSEdPY1ZIWTJsdERicENtb0xMaFdXTW80dy9JT0NRTTk4ZzUvTG5QUFByYndYa3hhM2hobUM0M0g1U1dERTVJNlo1STVIQXg2VlgwclY1WHVaREt5Z3l0a3YwMjVQSUgxNlYzU29UVVdsc1lxcjcxMmRuS3IyanVKTndhUDcwYWtrbmdjY0g2ZDZxejNscnNGMzltYVlPREdBNU1RNUhCQkhvVDMvcFR2dFVZdS9zY01SWVBHTm9iQ2pPVG5IYmtZNjR4V3JieFdOeHV0cmFPQXlTcDVrY0JiZXJNVjNiTXJuNWdQYmdpdUhrY0phcS8rUjFPdEdjZDdGSFNHbmVCdDhxU0RqYW1Dclk3a2NjakdPYXVYaVR4S1M2U3UyT0Z6eWZUclRidlVyL1JsaWl1ZElObk1VWmR6REQ3Y25ISjdEai9EbXFsN0RyVjdwOGQ5RkRMSlpxTnBraURNcGM5UXc0NkVIa0RHVDFQRlA2dEtwVTVwSklJNG1NSTJXcExkTXpmSWhod3B3VWlPUmtZNUhjNUpQNlZSdHBHS3p0TkROQkhDTU0wZ0NnNXdBY25qcm4yckh2SlZrZ2dpbUlTWm1MU09Na0FnQlNlbzlNKzNGZFBwVmdXdFE5NHJPcXNiMlZaR3lGU0lobVQvQUdnUjA3Y2ZqWFo5VVNkM3N5VmlueTI2bWpDV21udjdlTmhMUHBhbFpzcUdMaFFja0FBZWhybjd2V0ZpUnBvR1JYRUJuSmx6ajVnTnEvWGsvcDY1clV1OVZ0NEZ2NVdhVmJ0Skd0eXhJRHpiaEo4eHhuSXdlK0R5UHg1NjkwK1NXZHl5eHM4WDJlM1FKakh5Z0tXUHNTaEFPT3ZXbXNGUzVydEV2RVRVYklMbldMaURVWTRWazgxcEkwZDNqSUlIQnlBQm5ucjc5S2JOcUVTM04wMHRwTnV0c0xKS0p2TVBMWk81aGdEcGpqMy9BQWh1ZjdQMDZ5a3RwckNRWG9sVXlTc0NBVS9pVVlJeDI3WjY4MVV2NzlaTEM0ZWN5L2JKN3Q1RDh5c2hUeTJDajJLbkhHZS90V3F3OEhaV0k5dE5POXlmVk5VdVVtRTl2SWtTZWZKRVZqWGJ1WmR1ZHd5UWNaQS9DdTJzSlhmUk5QdUpVaGQzaloyWUhiamRrY3I2Ky9mRmNEcjE0YjJ6MHU0a0VYbXpQUFBJSVYycVdaaHpqcms0L2wwcnJMQzdpT2wyU0pDc2FjNVBKQ0E1d09lcHprQVovcldPTXdzWFRpb3JVdWxYbHo2dlFzK2FJYm5ZYkhZd09QTVZsRVpKUGIzNUdjOTZoUTdNdVZUQU9SbkdBUGJ0K1ZjemRhZ0pOVHVoTWlMRVdHMUVYY3E0d0FjZXVCeWZyVit6Y3oyNUUyUkRJelk4aHdwNXp0K1VqNXMvVWREWE5MQnVLVHYvQUY5NXQ5WVR1ckZpUzN1VmdleGp0M2tsdVNGaGl0d2NGUUMzWWNuT09QVDg2aC9zZVE2bERJektxeEZKVDV5L014QU9SanNjbjlCV3V0bkFySXdWMlpvdm1ua0d4d2ZSZXdIVWM1NC9PcmNoanVJRlpacEZrWEdTQ1FSMzZqcCtGWlZjUTRybFh6Q25SVXBjeklJclpybVRhcDJxTTVQb1IxSHRWc3d4V2tzWlZodkNnSEJHQng2NHJQdmJpQ0FScEtiZ3lTWmlVbVFnRTU0NSt2WDZuMHBsNXB6MnpMQzlveXVzTzZUekVZa2dEQllaN2s1TmNxaHpkYkk2bk5HamVYK254V1VjRHlmdlJKdkprWWRSbkJ4ampxUjlBT085TnV2RWdoMHNRYWRkU1R1eUY1a0ZxR0VYUERCdlRKV3FjdW0vMmRwVWd2TGJ5Wko4QmRyY2JTZHBiSUhCSHpjYzlqNjVwMk5pZnRHbkdlWnZMa215MXcyV0xMZ0Jlb3djWUp4MTVyc29VWWZiMS9xNXdWWEdTOTFHMmZFY043Slp0Y1dJanY0VG1LN2xrYUFZVURHNGs4OVc0d2ZhdUMxVyt2MzFlY2ViNXV4dktTYjc1MkE0VWdrREl4akhBK2xkSnFkOWUzR29TV3R6Y2I3UVdqcEZIR05xaGNiMU8zUEhLb2NEc08xUTJlanh6ZUdiZVpaSW9XL3RRSVFXQ21SQ3FEbnJuRGRPMkNUanBYcFVxY0lhcGJuSTFkNkdEYXhYcDgzTXNodDQ1T1J0T3hqOTNQUEc3Mm91YmU2MHlHNHRwQkNXakJhVDErK3E0M0FrSG4rdFN2ZVN4NlBHSXdVWnBTRHNLcUN1T2hVRFBZWVBQZXBiNk9TVFZROHlFUXRFSkFqbjVTMkFINDQvajNmaml0NHliMzJIRm5HNmxzYVNKSTBjYll4a3QvRnllYWJhMzdXdHZORmtEY09BZS84QW5tdFhYN0g3RkhhUzcxSnVFTGhRUWRvempCeDA2SGl1Y2RjdjlhNm9XbkVtU3N3TGJ5eDY1N21nZmR6OWFhdkdCeFRzOEd0Q1JVQUxqSTQ0cnJmQzl2WlNvMGswbTY1YVRZc1JUY0ZYSDNqK1BGY2loL0xyWFdlRXdCY0hiRTd5YmV5NXdPOWN1TnY3SjJPakRTU3FKczdYVkpMZWVHQWFkYU5HMFVZUmlTU1h4MzlQL3dCZGNqNG50eWJDSm1BeUg1OVJuMXJyN3krc1pFalNGSGptWTRWUDg4aysyTzljMzRtbVMzc0NqK2FzMHZ5cU5nd1Izemsva1JYaDRKeVZTS3NlaldWTndidWNRcWpldkhOZEw0Y1FwcU1VcFZCRzI2Rm1iZ0FzakFmVHBYUHhqbkdPTTExVWNNbW0yMmlUc1Brdlo1RGpxR1ZkbzZmOENOZTlYVjZiWGt6ektmeEptL0xaUlhWMnNVZmxySXB3c2JTQmM4NHpub2FzZjJiWjIwWDJrMzhSbFpDNGlYNWxPZTNRSFBmcFZxNTF5YTZ0NDN1cDNWRk8xTTg0NDdBZXdxZTQ4UDZjTk9XN25tdlk3Z1IrWktZWUFRaUE1eVJ4NjlhK1pkUnF5bTJ2eFBUdGJvWXR2b0Z6Y3RNOTZ2bXBHcGttZFcrN0g5MGM4OXhqcDBCcXhiK0hiT2ZVTFdmVEpSYlNoLzNoT1NFVW5oMVBYSStvUEl3T09laXY5UlczanU0MHQxU1N6SlJrZ3kyN2JuT1dHY2ZLK2U0QjZkYXAyV3ByY1dqZVZwN1RLUVdJa1E3dG9HZWNkZ0JrZlhQcFhaT3BWaGFYVDhEeWtrOURudkV2aCswbjE0eDJZbVo1STBhWGNBUEpmY3djRWNiaVBsd0JqcUIxcmkxdHAxbmVRRHppQXpzeThnWU9DU2VuY2ZtSzd2VUo3MmJ4QkZaTmQ0UTJ6YnlNYzVZSEdldkRZL0k4OTZ2djRNa3R0VnRMQ3hDaVVXaGVUZkg1ZkRkaWVRMzNoejZZQjl1bW5pdVdQdjhBWW1TWFE1elI0TVdNOHR6a2hZbUNseHVDZ2NsVnpqUEE3RWZlSE5kNzRldTlDdHREa3RkV3V0dHpieUJ0OW9Od2xHMEZlQXZKQkdjY2tkTTR6VmZTTkhFV2tDT1JJcExkaWNXOC93QXhTVmNwSnd2UFp1ZlllMU92Yld6WFU0RmdpaUVMa3RKTkRKdDh5UEFHMDV6bkJIWHZrWnJubFhpNTJlbW83YVhPbWdzdEpHbCtlTkplNGhrUnptWk56a0FnaHQ3YzlPTWRmcUt5TC9TOVRlNXZVTjZHc0pKUE1sdG95RkN4NEc0RUQwQVVaWHZrakhiYzBrWE50YlBISm02S0FSSkEyVlRhZU4rUU1jNUdPbkdjZDZTWFNibTlXU08vdTRNbkR0YlRLU05nWldCM2NjNEJHUU81NjhWckRXVjdrN0hDL3dCa0xCOW51TlJ1NXZKalpmTWp3SlBLSk83YVdPTnA2a05rOUI2ZzFyM2M1WTM4a3l4d1c2YVF3TXFvWGVNdnNYR000Sk9ldnQycUZZOVl0ZGNlMDFZa1JOSm1NeTNaODE0MUhDZ0xrc3B5ZmJPZW5lbGRXMXhhZUloUDVNaGp1WlpJME1KMi9mR0N1VDBZQUsyY2pCSDRWMkp5Vm15bHF6SzFtWjd5eG44bEJEQUpGa2pEa0JtMlI3U1QwTEhMRG5IYjJxemVYY2wxcTEzblVmS3RsbkxOSEtyU2VYMWRCZ0hJUmh4OHY5N25wVmJXSVJjVzB0K0FJbGt0anNoa08wcSs0Z3FDZXZMSHA2ZHVnRHBLMjJwM1l2MkhrU1c4SmZCVmdaRVdQakl6eGtrSDhlb3FsYnFhZVJUdTdQN1pZUTJwbHRZaEpPa2NiTmhObWU1UDNpTThIT2NkdmZMOFVXQzJQMlcxalpVbVF5UnpOdUNna0twSGZIYzg5em10dG50VzhRVzRobmJ5VGNJVWlLZjZoZlhHZVNCOVIxcks4VWFMUGQzSXVMU0NGWXd3RGJDd1oySjVZaHVuUGJzS2lOV01aSlNkZ2NXMDdJa2ZUZ1lyR0hBbUZsYlJrckU2ZFpuSlg1eGtaL090R0hUcmZUelkzQW1ka1c2Q3NwbE9XNElBSzlGR1Q5UUNTYW9YazE3REZaV1YxY283YkkwQWtqRHRnZE9TQ01Bazk4L3JXbGFTdHFLV3RxU3lmYTJWY2xRd0Ryakw3bXg4eHdCNy9YRkZXUzViMzBDTWRiZFNwWkxhWDA5M2VUQXgyK0FodUczTjVqYmhsaHdCeVBYSDUxYk50Q0hXQVMyMXNzR1Azeks1V1lGaU53QUJJR0NQeTdWcmlLR3h0M3Q3UzE4c1NSRkpQTDNIS3FjaklJN25IYk5aYkNGTEdPOWhhSXR1d2JhVlQ4aHh4eU9jSHNUNm4wcmdWZFZidUtONVUzRGMxN0NhUzhRWk1jeGlWUWJWbjZidlhHRDlPZWdvdXNRaTVqZzh2ZjVoa0NZR0VPQU1aUEkvQ3N5NHZuamkzUnNUYWtBc0kzL1ZqZ2UrUHJWeEVzazA2V2I3UnVsQ2IwV01nK2dBNUE1NUhldk1uRjgzTjNPMm0wbHlsQ1EzVWl5d3BJakxJVkV1VjVYQnorQTRINGV0YnlKOXAwMk9hUzdBWlFZblVqZDVqQmd3QnljOUNCK0Fybm9YRWR2ZVN2TVpaa2lPRTJaVXZsUmdZd2NqT2Z3TlhJV2R0SUVna2lFNkhvQmhYWU12QWJzUnU3bnQxcmVTazBrYzFXRU9ibVc1MXQ3WjJYbVF4eVJUSTZUSXFTVGJ3dTBCcE1jZHNCaHh3UFhyVlMrMEd3MDlMSzV0NW5KQjhveHhFTW9LOE1Uakp5RDE5TWZuZzMzblhXb0ZHbVppaElkZys3SHk3UW94d2ZsTGRQWDNyYXNieTd0cmxveUVjdmxIbExFb3g2WjlBY2Q4RDg2ZEdwR25GSm5QS2hQZTVxWE5tOHJ5MzBPbUdacDE4dG1tSVFqZ3J1QzlnQUFNZWg5ODF5bzFRMkZ1dHZiMklWSTJQRHJsUXc1eHdBZnZNZU9lbzYxMTk3ZFRXMEYzRmNUU2JyaE5pUlBMdlZNY1o3NHoxNjhnZTVyalRMRWp0YUJwZDVDTWhiYVdES09NY0h1QUFQU3UyZFZMWm1FbEpLNWRqdHJTN3NqZTZsYndKd1pFampqQ000TEFEN3ZLampPZXRJaTZZTGlTNXVZN0c4dTVZZjNYblpVaVFObmdrZ0FBRTl1ZUFPbFZybUdDMHQ0V24yRTNCVWJVSFJWeVNDUU9EakdmWFB0VVhtMkw3NHJhWXpTdEVpUlNCTnBMZEFBT2VjSHIzTlFxelNzOWJncE9LMU1ueDlZUUd3MFNjMlRXc2M3c0FxS0Fvanp3QVIzNzlPNS9EZzljMGFmUmRSbGdkV2FGWkdXT2JIRGdIMTlhNi94TkxKSjRlMCtWOVJOMGtjcWhJbU9HaUdINFlZNSt2WGsxUzhVWFQ2NWIzV29QSWtNUll0REJsbUpVRTRiMEdkeC9YOGZSdzgzR01WMC9xd1NrcGFuQ3R5L3RpakJJeFR1clVBNGIzcjBTQjBhZ2pQdUJYb0duMjhtaytGaHFFYWZacmdTUk9yeWs1bTNiajhudGdEOHVEMnJ6OUQ4eWoxcnFuMUM5TmpCQTd5dkVzTzFBelpPQmpwLzN6WEppbEtTU1ExSnJZM3hlWEYvZTNkMG9UYkdFUm1Bd3NZT08zWEpQUEhUSGJOYzk0b3VESWxwRjV1OEp2NDdqSkgrRlhiZDRvMUVyT051TXVSbms5Qi9JZmxXRnJ6K1pjeEhCWDl5T0NNZFNUL1d1UERVdjNxYVdpTnVaY3ZteVBTTGY3YnFFZHVNYm15VkJPQXhBemo4Y1lyb1BFTjJSb3ZoaDFNVFJLODdoWTNCS0V1bnlIME8wS2Z4cmtJMDNuYUd4NzFyVFhKVFR0UGlHeGxnWnhncU1aWWMvWDhmYXZTbVJFN2F5djdHSU9Xc3JhNGs1eEpLcEpRK3FqcDI5S21sczVkUmlaYkdPV1JlQkk0ZDhONmprY0RBQXhYTlc2eVJCTnhCanlTd0E1NEg4cTJkTThRM1ZoSGN4VzNsaU1zdVNSazU3NFAweFhnVmFjbzYwOVg1bnB4YWx2b2Q3cUZwSnFjdDVwN3lXOEx6cXFFa0FlYURnakJJR0R3dnQ4dU01cGx6WlhNZW4zRi81QWhrZU5USkdveDV1N2Q4cTREQmVNamc5Z0Q3NFUrcDZwYzRTNnVXZFVqOHVCbFhhSGNFbm5HZWNuMjRyVTBhNXZZa1pyNjlrRnRHd0tRb3dJWit1ZHhHUnllTTl1dnNweTVJZTk5eDVMVHZvYy9QYlMyM2lLME01QkgyYVFNZVJ2Q3VwNHo3bkZkWnBObGFXK21QSmN0ZXlJMFc2U2QwSkxLRGtoVzZZeUFNRG5qcldacStvUVdYaUt3ZlVWQWttZ3VFQVEvZTNoR1FBZ2tZSkdCajE1cS9OckVZczBTMU1rZW55SXFzcFEvS3h5Q2M0SUJQWEh0WE5WVlJ4ai9XelplNVhobXVmc1Y3ZHhqRVR5WWtubFVzNXlyTVJ0MmpQM3l2L0FBTGsxSmVhaEcrbTIxOUJETEJieUJVS3Nva0tBRUtXWGs4RGIxOXZiTlR0cWx1SnJhNHQ3MkY5UG5YeW9tbEozSVNoQjNBQUVIR08zWGlyVWxqL0FHbHBxaGxYTjBvU09DUmZrS2xzamNUM0hKeUR4Z2NWclVyWDVicmRpWm1SeVJhVnJFeXBkUlhCUmxqRFJoNDNUSkl3eUJSdXlBUmduR2NkTysyMTVjWGQ1QzF0ZkZZVWtkVW1LN3RveU53MjQrN2duQStiQlhHUUt5Ny9BRXpVN09mekRZSUx0dzBneTZ2OHdZbkl6d1JnZ2daN2UxWW9rdGhtTytRd3l3cWJlUVIvZExGaVNTZUFPZHB6MzJrbm12UXB6aTB5ZER0TmF2QmZPdHYvQUtLWjdXUHpJcGxrS3NoS25ES3JkT3ZjWTdkUURYSnp3UHA5eEFacnlONUxXU1NNdXJzOGFQNUxIYTNIM3VWNTRHRyt0YkZqY3plUzg4enhTU3U2eCtiRnZQNGM5R08wZ1l6d2F3ZGVhNWVheFdGWXdrczBiUENJc0NWd3o3czl5Y2NrWTdpdFZiWXVPanNaK3FTWE9kUWh2bjNXOGtidXJQS2ZsbXdTbU1EcHVQVGpvYWZxZDlCWVcxcGIybHVoa2EzUlpaVzUzcTBTNUFrWUhuUFBwbkhIRlIzZGpiNmhheUZaNVlXQUg3eG9jN3lWVW5kam51VHgvZFB2VTYyenhXOEV6a3E4VUlqM2hHWHpGVTREQlNBUndWN0QxcUoxL1p4djFOYWNlZDJNSzBqdUpwZ3NieElaRmNtTkhCQk9NRElPUmdaSHJ6bXVqYUNlNmRZdzdTek0yQXhJeWNuT09QcWZhcTZvelNyUGlQNVdBWmt3Q00rL1g4cXVTcWtyd0dCREJ0QlZ5enNZM2IxSHBuSDU0NEZlWlhydXExYlE3b1VsUzgyUnJaUk1yUTNzY2lMZ3JKOHE1WFBJd053SkhVOGV2NTFMSHo3V0pYZ2E1Q0xJSTFmbU9OaWVBQ280NUdUeno3NXJYbWxLaUdPV2VaMVhEcDNCd09PQ2VPZUFmVE5SMnQ0OXJZaUNLMzNydnhMdVp0ckRkbmtEdngxSFBGUlJxTkswZ3F4YjFSa1hpeUplWDF3TGpFWUc2RlhPQStGYmdEbkJKQTc5VDcxUmdHb1cwNngzc0pFY2poOFkzRmVPRGpJN2Q4OTYxTmxzYm5mYzVrakRFU0xFd3p4eU1ZNzlPZXRRZVZNLzcxcDh3Z1lWRlhCWSsvT1IxcmJuWExzaUhGOTJ5RjVvbFNWUVFHbEd5UmlwQ2trQUgrZFo5NU85bEViV05vb1pCalpKdnl2T09lUGFydDFhSmRMNWhXUGVqRUF4QWpJNmdFZXZQWC9DcDVJb1RhcEhOYlJ2S1gzYnBBR3d2WmZUQXpRbkNOdXBGNjBtbGI1bGV4TG84aUc5KzFFbmVTTUFqMUE1NDRQRmFyTE5GYnJiSXMwaXpidHpRNUFabFBKWFB0dFBQWE5aN1JzeGJ5NGd6bmpqQzUvSC9QU280ZnRLUlRzcVB2TVF4c2ZPY1oveHJQU1R1eldjV21qV1AvSHM2MjBFVVlNZ0pWUnVkVjNZSFBZbXRobm10Yk5ZSmRzUmtPNVY4emNjRWM1eDJHQjIvcldUWnhoNDQ3c2dSRnNpNVVuR0NGTzNCUHJnZnJWcUc3dDcrR2FkSlNvdFl6c2FabFF2MkE1UGIyL1NzSlU1TjdHTHJRMkoxMVNTMVF3UTNSamNuREZZZzI0RWNIbnQwNDk2eUxxUzRqdExnU1hCa2RsM0RmZ01HeDBKSDZWUm11SWhKSVNKZHo0MklTZUQrR2NmblhUV0ZwWi8yVkRIZDZiTmZhY1FYbHVrZmE4UlBYazQ0L0gxbzVWVGFiWDVmbVhVVGNkRGw3bTRVWW1kbURwR3FxZnVuQkdTY1k1N25QMEZTV0YyNWtqZWExZTZFWVdTQ1BwaDJZRVpIb2VmejdWdDZqcGh0SnMyQ3pUV3NscVlYVjJYZGpxdURnZzRKSEE1T08rTTF6OWpxMDFzRVNDM2xkdk1DekJWQVZRdUNvTEhnRWJRY2tDdTZMalVoZW5xZWJPRW92M2lwNHowcTZzTk9nRnpiR0RNZ1pPTUFnZzlPeDdjMVIxelFKYkxReGZ6aGJLMG1RQzNFcFpqTVN1UUZ3Q094T1NSL0t0RHhacVR6YWROYVhFMXhOTkdReDg0ZzdYMzl1T0JzMmdEMk5aK3B6d2FsNEplV1hIMm1ONHhDRC9zakRZNDlEem5qcHpYVlE1K1dIcnFFZVZvNFhBVW5CeVQxTkxnRWRPYVRqblBVMDdCSDFyMlJENEkvTW1SUjFPQUs2eTlpbnUzaWU0dGpEc1FScWtTbGlBQ2NmcCtsY3paTUV1MGRnU0F3T0I5UlhwRnEya1RJbjJpZWFLV1hndEVRQXBQUWx2VDE0cno4YldsVGFzcm5SUnBSbW5kMk9YTHJIZ0dDWkZLaGd4WGIyK1U0STZISU5aL2lLYVNiVkdNanE1Q2hRVlVLTUQySEZkZHEybHhXdmx2WnlHVmZ1czhzZzNmVWRLNGpWeVRmTnVQTzFjODlPTTQvV2xoYWtha3J4Sm5UY055dENRSEhGYUU4ZjhBeExza0hDa01jRHYwNjFuUitudFhZK0g5T2cxS0NlTzZlTUJZaTZwSkw1WWt4MUdjWUhIcVJYUmlhaXB4VW4wSFJqek94SmF4dExKRTBuQllicytaNWc2QW5KOWVmNTBTU3VMVVFDM2hYNXZNVjl1SFlOeU1uL2RJL0lVMUZXMnRZM2p0Z3NBeVVpV1FPYzg4aHV2VWRmU3J6T0dFa2tqN0FPcFk5Y2NESDVDdktsS3p1ZDZqWmFuWFNXejZWcWpRdUZqenNEZVR0QVpjWlhvZXFsaHlldlBhc09TZG52R0lkUkpLV0RGeWNzM1h0MDV6MnJUbld6dTdpNWtUVUh2WGdWWTVHbVk1SExiU1J0QXp0SzlPQVJ6MUZaa3Vselhrc1NCNDNFaEt5SThpSTVHQjBVdHlUazRBT2VLeWxUdFVhWjVscm1YZFhSdXRXMHlHNmtqa2lTYmFwVUVzTXJ4d2NIampyNlYxZWk2eERZNk0wMGp4UzJ0eHVVeFM4b1BteVZkY25PQm5COWp6Nll1b1c5bnBGMUhGQkVzUVc1eEFzaWtNUnNBSUxFRExmTjB4M3JMbnNwWnRPYVMzRE90b3Y3eU15S01SamtuUEdjSEhIT01uM3JXVk5WYlJXbjlNY1VkUGJhUGRhVmJRaUhVRXZMZTZWWm1LNGFOZ0RuWTRQVGhqbm5wazU0cUR3LzRwbWdNOW5lMnJaWm01THNOampsUU1IR00rL3AweFI0VDEyM3RiVzVTZXlsbFI0SE1NUi9lTVZCQ3NRY2RNZGVNY2RLejNtdEZabWlpbldTT1hNVFl3cnJuak9CZ2NkeGo3MVJPbHpYak5hOXluNUc1TEZINWYyMjFtQWtiRXFXenlFT0FXUENrakJCN2RPaDYwMjl0NzNXWXJ0M3Q4WEUweXhmSVZBRzFTb1hIWnVDZmYrZWJmeVBxTjBJNDdwSmpHN1kyc0ZBQVZlZDNjWUF4bm5nMWUwOHhKQkxiM0RMS0RscEk1SDNQQ1IwWVlHY2tBNDV4K1hPVVl1T3JNbXRkQllrdjlPMEsyaGtWcHdyb3pGeWN4bFNOdUFlbkh2M3hWbURXZEt1YmRiaWQ3dUNTTzVpbE1tOEFsczdkK2NraFRuQnhnSE5ObjhwYmNRT3J4MnI3R2kzUzdkd0RIaytoeXhCQTU0R0tyYXpkMlY5YlQ2ZWJON2N1U2tFL2w3a2s0WWpQZms0T2VjWjZZcnZnMjF6RFc5eDBNTXR0WlNKY3FKTmx3UXlrWkxGWHp0NTZBL01DUHI2MDNUUzBPeGJ1K1piUlcyamVqRXhxVGdxdkI0SFQyNlZMck05ekpZSjVVOHNMdkRITTVpQ2wyTGpseUNkcE84dU01NmJmUVZqVzE1WlN5U09McGxhVHpaSi9PVUlXSlRJSFhxQ1BicjZIaktWQ1R2WjZIUkdjZHJhOXk2Wm1rMUdaWVFJb0NDeVJsaDh5azVISDRWYmpNY2wxRmNNa2hFWXhEdUgzQ0RrajZaSklQMHJQdjViaXoxYXpsTmxCTkdRVk1qTHVTVmZmQjZET2UzVDJyV3Q3VjFoVzhTU0l2QWNmdTBLaFR3TTljQTVIYnIySEZjMHFVNHg1dGpxOXRCdmxLS1N0NXlMa1NST2YzTEJlY0U5Q2ZRZE9hdXpSTHRRQkVZeUhjWTQzeVJ0NnFSMUdRS3UyOFN2S1lCQkhFQXFpTm9ZU3FvMlEzb08rUWVvd2UrS3FYMXFiTjNhNzJxNkJ1SFljNDZucm5QNjFnNHR1Nkg3V0tWbm9JdHhwc0Z2TTkxR3R1R3RpcXRzM0ZqakFJendHN2RPdUR4am5PaHRKeGF4NVlURmhuY09RZU00K29xUzhDUzJTUnRCR0dreE4vcEdOdTMrSThkTXFQWHR4V0F1c21HNzJXNkYwREswY2NlVU9mUUh0MTlNOFZxcVRuSHpPTlYzR3A3cHJ5azI4QTg1dW55bmF1UVNPdlR0VWRzMFYwanFvZmFwNXlNWlAwTk9sV2FSUTA2TWtvK1loR3lWL1RpbUNZc0E2bVJ0eHdYemtmcFdGdE5OejFFM3BkajNnTFNSSFlQS0orWXJ3d1BialBQMDk2RmhNOC9sUU0vVDV0bkRZN2pIZjNwcGI1c2pEZk1CakpCUHI5TzlhOWxERGIzY1RTd3lHQWpiaER1M0FkUUQrSS9PbEtUaWdtMWJVcnd1MXc3Unk0VGdLNmprTUZIQnh4Nm45ZldzelVMcUZHbnRYU1Zvekdra3NEYk1BZ2dEYWV1T1EyT25QNDFvNjFFanRJcWI3YzhyR29PU09jRUVqcjAvUDByR09ubzhubGhTQzR3MGpaeG4zeHpqanJXbEZwdTdPS3JCeTk1SXJ3WG9LcmRTeGxKNUEza2NZWGIvdFlPZnhQcHhWOVBGbXJhTTZwQmV4QzJtUUhkRXZtSTJPdnlzQWV1UmpqcFZhV0gvVGtTTzd0WG1PVWthZHNLRGpvNS94ckV1YmlBMzcyOW1XUU41aE53U1FYeXZUQTR3U0QyL2lydnAwYWRUVnE1eTFhbFNQdXRseVhXcm1TVzZtZVYxTGdsL0x3aTVibkdCeDY4ZHF6RnVESXBLZzdRY3NmYW9aRWtsalIxajNLU1R1QnlUZ0RPZWUzK05kUGI2WjlxdHJhWVJMRkFEaHBiakFqeHRKQklWdDNJVlFUanVUbml0WHlVa2MzdlRLZXZpMWF4Y1dDeEtpV3lDWnd4SG1FTUJ1K1lBbk9SeCtuRmFtakxwZDE0WGlpdVRkRElLa0s2ckd6RVk2dHd1UFd1ZnVacDQ5TWJTVXRRci9lZkVlUzJRTzVHUjA3SG1raHRyNWRNanRSRWlsVmQyWlpWSmJrWUJHY0RIMHovUW5TVHBxTGxiVTNwTnJWSzV4ekREa0hyM294NzBrb1pKblZoOHdKQkh2UXZKRmV1aUMvWUQvVG9RRGo5Nm5QWHZYb2R0TjltY041YjNTaktuWXZHRHh6bmdacnptd1ArbDI0Yk9ESU00OU0xM2Q1R2tVOFpoKzB3MjdwdVpHVU43WnpuMHpnMTVXUGlwU2pGbmJocFdpem9GdnRHdVkwWFhiU1YwakdBOEpKbFFjOGJlVklHZXd6WGxXdVBhVGF2Y3k2ZjlvRnF6NWpGd2YzbVA4QWE5NjdHNTFmN0h0dUJhTkxHdUFCNStPbzU3SFA0K3RjUnFNL25YOXhKdDJocENjSHRTeTZrNE52cDYvb1RpbkY3RWNQTERISGJOZE5ZaVd6WXVqRjhJQThaNmRQZXVjczlvblF2OXdFWnJveDVyU0NHVXVKSlZWMWkyYnR5dGh1UGZrZEs3TVRxckdWSjIxSUlOU3VGZHJmTWpiRysrR0I0Njk2dkc0RnpDVlV0bmR6a1kvbFdGcXNFbHBmbVUyN3c3SkNyS3c2RUhwOWV2RmFhc2pxaktRQTNJNHJscVU0MlVsMU42VTNLNlozUGg1Yjg2ZGN1cjdVbGpMekJlRHN3Zm5Qdjh1TTg5S252WmRHdnJDNXVJRElMbUloRnQ5aTdXR0FyRU1RUURndDE1NmNnNHJKdDN2N2k5a2x1WkQ5cGdCVjk2dHNSZ3VGd0FDTTlldkhQYXRTMnR2czlrcVhrSk1NN3BPMGhBVWdBRmlCam9DWHgzNkhqakZjdG9xVGxjNFZKOURubnVwTG1KWTdyWk5KQklDaUVjeC9MZzQ5dW42WXFoOXFlYUN6Mm1CbGozSzBNMFpiZG5uNXNkVG1SZ0R3UnQ2aXQ3VzlHdE5PMFNhYXduKzBUdnVPR2NBSERBN2w5ZURqQVBPYzl1Y0NLZUcxczNXVkkxbmxWZHJPb0pRRVl3TzZuSUp6bjBycHB5MDVsMU5FOURaOFBXd3ZTNmxvNG5DcTRMS3hiT0NwVVk1S25jY2dub0szNE5EZ2gxTXc2ak9rYytIbWpTT0ZwVmxUQVpjeWNrQUFIcnlNams1cURRYktTMWh0aGV4SmNOSzdPeUlwVXdlV29aR2JBNEp3MkNlVCtGYTcvYmRhdnhORE9rTnphUnlSa3huY3JKaGdDQ2VlTnhINDhWaFVxS04yMlMxZlU1eG9YamdpbnM3UHk3bEkyTndzeWpMK1h5MjNPY2Q4OGNiZmVtNkptNWxrMU12RWdLc3FIakJKVXNTNTlCZ2taNDR4MDRyYjFLSjF2UjVhM0hsZWM2SkpLdmNrS1dYUEkrWW41dWV2ZXJQaEt3dUlkWkgyZTBoRnMveTdGWWtJY2pkbmc4RVpIdHU5eFdFcW43dThkeWRVWmx5bDlQYVJXelJ4aWZCUkVZaERrOGNIT09XSFAxSnFuYm9zdHY4QVk3bEo4cUdrRFFuSVhqTExqSGNxQjBQVFBPSzE3Mi9zN2pVVmZ5bnRvNDVjUnFKQVFuSUNoc1lPZUQ5TW5qdldWOXNuZ2FXQ0tWQ1pWYnptWmd5YzhBbGdCZ0RqUEdUaXVpbGVNYkR1TVVwZmVIb28zbWlodWJKMnNpN0t3RWtTYm5BNEJ3dzQ1SDk0VlMwOUxXMXZMMVkwbGxVV1FKRnlSR1pHRTZjazg3ZnUvbDE5YVlacmdXK3RScmFsN0VtTzU4eEEyME53bkdlV0IzQTdjaklHYXNhWGVYaTNkNUpLUEtqYXhEd1NCUkZ2eTZISitZZ25ERUViajFJN2tWMk50UnVYMUg1aEI4dVhVcExTZFZTVHlsWXlDTkdQVXYzNVlIR2NZOWVLNkhVZFBseEFMZUdLNWpabWpFMXBiRllzZ25PNFpPTUFMZ2dIZ0FkcTg3dGJ1NGZVYm02aGRZU003aUNSaFR4eGl1Z3MvRXQzcDRTMWhVTUIzSTRVNE8zSFhCQlB2elhQTG1pUzVXZGp0ckF3bTdabk1OamJORm5ETUZCUFVETEx6Zzd4NllZOU1WeDkxNGpoczJsQ1JSTVMrNVM0OHo1dlZSM3pqbk9lYXE2cGQzTXR2RERjekpPQ0dmRVhHTUhBSXlCajAvbFdmQnFWaEQ1cVR3TSs1QUFRNFVqMzZISUhVWjlzMXpSak9Xc3RmUW1VaCtzNjdkYXFzS09xZVdwWm80NDBDaE1uSi96N1ZIWldpdXJYVXF4NFpOeWx3U1R5Um5IZmtHcG81SWI5TEtCa1FpTlNrcDJINXdPUnlUNzQ0eC9LdEI0RkZ1VWdqaldQQUs1SFU1OUJVMUpxQ1VGb2RPRm8zZk85aU8zYTFtUmpjUlN4T3dCZG1ZcGtZN2pxTThWSWtYM1BzNkVCeW9HU2NFK21UK2RSR1JyY3lKS2dNbWR1QU1rNHgrWDQxb1d0N1BEYVpobW5oY2o3cVlHVDF4L0t1YVYxcXZ6TzZDNjMxS2dpbW0welRaRm1GbkN6VFBKY3VRU0dEYkNyNUk0QkhiamdlcHJvOUEwK3lhTXBxTXNDRzRRT0Nrby9kNFAzUVRrZW1UNzk4Q3NYVTdSTlZuZUhVYnhWU08wU1dGMEFBWm1YZGpqTzdERnNrZWhxZlRMc0pzVjRyZVJVQVNTNUsvTTMrMHd4M3lSMzZlMWFZaHljTFIwL3J1Y3F0SWt1NDdPM3UxVUFxdVQ1a2EvZFlFOVEyTWRjSDZmV3NxN3VYdEhraTJ3ckxLNENJQUZ4bnVTZjUxS3BFY2draWR0cWo1bzNHOEx0QkpJT0IyQlA0VkJyYnhYVm1namlNakhPOWlRU3I0QnlDQ2Nncm5qQTVIUFNwbzB2ZVNsc09kWngrRW8zZDhXdFk0NFlvL05uQU1ja2NvWmtJNXljY2creCt2cG5Lc1d1TlBPL3o0NFhQeUhlTXFHSndNakJCN2tmVDJyVSsxeDJ4ZUY1RkNSMnpScjVlY0ZqeXA0ems4amc4am5vYXk1TFNkcmFQYlB0KzB5RmRtMWtVRUhQN3pQR2VWSXhrWVBiRmVsU2lsR3lPR3BVYzNka0N5bnpaQklFRXBSa3dVRzFjREF4K1hXclVHcFJSV3J4WGtJWmdkd0dXSU9PaWdaeGpQZm5qMTZWWXVOTGsvcytPNHVibUdReER5a2pqSHpiUVR5U0J6M0hQdDBBRllqUnJJeGxVeUNLTlU4d0RHU3pEZ0ErK1BiR2VsYUtFYWdRY29hbzJOUm5Pb0I1ZnRxaGZzNnJHTWJnMnpHVXg5NEtNOEVqbkZVZE12bGF4TUlqYUNhU1J2OEFTRWJiaGNMaE1kQjh3Nis5V0xDeVdJeVc3RzBrbTNoVlNXVXFDUURrWlhnZ0hIZk9jZHMwencxSmJUUXJZWEJWQThqSHpXR1JId01FNEhUUCtlY0crVlJwdlM1b3BTYjFaeU4zSDVOM05FZVdXUmxKQnowT090TlhyVTJveGVUcVYxSHUzYkpuWGRnak9HUFBOUXBqSDQxM3JZanFXTFJsRnpDWkI4Z2ZMWTlPOWR2RGYyOHpSMnR3OE1DZmVTWmd6WUdPQVFPMzRHdURqemsrd09LOUQwN3d4QTNob2F4cVR4U3RjUWhiR0paOE16QTdUa0RuakIvSS9VY09OakRSeU5xVlZ3VHNWWnJYZHAwN3BKYXlBWUNHT1J0MHJBNDZZQkhYdmdmWE5jVE9HbHU1UGwyc3puNWZRNTZWMzBOaThsdklsbVBNSVJUdWRWVUlOd1VqTzdqTEVjK2xlZXVUNW1lTUhrVThHck9RVlo4MWk4bW4zS2dIeW5HY2NrY2ZuWFZlWE8xcGJRT2pNSVVBUm5rM0JNOWNkY0ErblRqb09heDlIMUpWaGVHNWwyeGdaVTU1SHRXK3R3MGlJcms3UjBWaG5ISG9LeXhOU2ZOWnJZMGhUaTQ2TXlieTl1YjYybXRwQkZMTEt1M2M2S0hPRzNBNUhmSXhuMDQ3MURwcG1sc1FyZ3EwSndBdlVyam5uMjY0L3dEMVZzVExGSURFYmRXWUhrY2JjWjdFZnl3S2dpMDJLMmx6RVBLVnVDb09SOWNacWZiUjViV0ZHazc2TTZHZUhWdnNKdVVzSm5qblhjKzFJa1VFTVJuYXJFNU9QcDE3VlJqOFFYRFFMWkZ0MGJObnkyQWJPYzlCK2Y1KzlVbXZnclRmWnJpU1dUN205dWdCN2dZNEova2FoZzFKNDNqZDFJazJzRWRJeXNwYm9VRFl4ME9UbnRpazZQTjBPVTZDYlM3aHJheWl1cEV6TE90bVVCQU1UdWNCUUQ4Mk1FY2dZSFA0MHJleDArZlZyWjd5Q0szam1kWTFFODVqamlVN1FHeWVveGs0eitOVnB0WEVzTUYwMHJpZFpGblRhVDgwb1liU2ZVam4ycTliZU1iNlM0MDhNbGtyVzhCczA4eFI1Wk80SGNWYklCQXdNNEJJNzBSZzFDMnc3MjBMQ3l6YVZyMXhxV2xUdmNwYlN1b25qVWxXWUtNZkxqcDk3SjU3OWNBbmU4QzN6UzZpbDVQY1lpUmc4Z1JWSjJrSHJuSEhQWGpqbnRYbjZUM0l2STlQdDR5V2pEU3VpdVJ1WUtlVDI0R2NIME5FTXp4bUpqSmhteXJRb3gzaFFCaytuUWtkYzhIMnFaVSthTmltZXU2dEphNmxwN200YUM2dUZkUWpDTlh3ZHVTU1IwQXo2OS9wVnJTZFhpMDY2a2tlK3Q4YmRraFdMcnlBcFgrOGNrOXVBUms5SzQxTldCMGgwUzRkTGVkVlJVZGNoMzQ0VTdqdEdEbkEvdTEwOWxibVR3K3FSRlNrZTVaeDVQNzBnRURQQnlCbkpIUHJYbEtFb1N2SmlscWpNOGJzdDFmUnRwMFVuMlVSQkN5WThzT0R3QUFNY0xnOGRNKzFjSGFYYzRtU0s1U1ZvVG5rOEZBU0NUdUk5QWZiQk5kcHFkakhxS1hjMXpQQWt4UlVpRzB4a01YWDVjSGpuRDg4amc1NXJsNExVVHRnek5NNk1GQU1aVldUSkFDODVMYzl3QmdkZTFlckNxcExtWlBvVTQyTnByRW45bzNyS2hRS1pJNHc3RUJnUW9EY0FrTGpucFdsZGZhTHEzV1MwdUxlNFZveEdpS3lLN0ZXM2ZkT09lQWVBVHpnNTYxbzNEV2xvdDVhM0VLdThqTEl4WkZMcTJDY2J3ZTI3a1k1NzRybXA3eTVqdGxpdFpGWmZNWnc3S0VJT01kZXBIUGY4aFd2dEl5U2FLNWtpdXRyNUduTkpMRWtUekxsRnlDTVp4Nm5IUTllL3BWWVhDU0Frc0VLajVTY25hT3ZUMXBKNUdTSkxkOXpTWjRiek1xQmpJd08xVkpSS0k5ckJRdTNsdHZ6Wkk0elQ1YjZtYjExTkI3eVc0Vlo1RU11MVZET1A3bzJxUDBBRlQyR25yTTVhNldNck5IaFhkbVh5bUxiUWVQdlk3am5xYXliT0tTYy9OKzVWVlAzMjRQQjRQMTRyb0xPRzlqaWt4SytGWFlDMGhVSnhqcDFIR2UxUlVYS3JJSXJ1WE5SMEdIUlo3ZEhra1NSb1F5QnprSXhPQ1BsemtBaHZROGZuV2x2NTJSWW9aMzh0QUNTUGx3Y1lPUHlyY2kwZGJTeXRvWkpvWlo1Q1k1eHVJZUVBY0RrY0FaNU9lb3hnak5SWGxuWU5mVFhEaVY0bkozUjI0RzAraTU3ZzRPY1Z4dWFrL2UxTll5Y2R0Q3BJczBOcmJPVkVrMTBxdkVJb2l6SDVpTUVkUXh4NzVCck9sdmJ5ZVc2aW1aSThmdWpGSWhVQWtFWng2amJXenFVVjVQZFJSTklzVjNiUjdZaExNVmtJQlgrOWpCeWVnOURYS1hXcWYyYmNpUUo1M21LQVNUZzV6ejY1K3RYU2dwclJYWnBDYlRzM29PTUY1WXpoNHRSazJxZHlQRkd4WUU1NjQ3Y252VitFS3JQRzdTaUNQOEE1YklDd1VBRE9UK09QeXJFc3I2OWx1Q0RJNkNWOXFxbzVYdUFQVHNLNjIwc2tzTFJSUGJCWE1ybHBJNWoxSUJDbFFlUU1ldjFyV3RCeFh2dlh5TkhKSlhndERRaHRaTFNHVnA3TVNXNVh5MU1vK1ZpVTRZZXVNNXFoY1dzY2NrUmhrRVRGLzNZT0FPZUdHZU1ESnlmUVo2MXNXbW9mTmRtZVZZNFpJNVNtOGh3SkNEaGl2SlBVZy9wWEk2cHEwVE9GZ3R5cUVIT1gzTUQwK1U0NEhUajlhNWFGT2JrWjFKcHJYY2NGdTdwMmxudFF6eU1KSkh3Q2pMMDVVZW5yK0ZUMjE1WkpidEZjL3ZDUmxXTzM1R0pmY0FlNEtrZCtPZmFzZDlRbE1UTVpKR0l3U1R4eDBJNDZkcXl6ZDdsTEREWkorOEFldGR5cHlsdWNkMmp0ZFR2MDFSTHk1Z2drU1ppWGFWV0xaNEM0NDZLRituWEhQRlV0RDB1S2NzTG9NbU1CSTFRZk93M0ZRZWhKM2JmOEQwckkwdHJpU2NwQVBNZGlvOG9FN21KSXdCajhEWFphRk5kUVNORkJDV2tNWVlNWCthSXJ5dkhYT1ZJNUdBZXZlczVYcFI1VXpTS2U1azZSNGNoMTJkamQrWkJiMjRHK1JHQ2drdWR4WGRua2Z5RlErQ29aR3ZkUmp0cDQ0bVYxQ3JJUUF3eWVOMzhQUWM4am5CeUsyMmYreExSVjhwSkpwbFdkbWNrcnUrWWZLTVlEZk1lZW5KR2MxemZoVzZsSGlPOFMyVmxFenN3RVJ4dEFKUEI3Y1pGVXB6Y1p0N2RQMUtPVTFvRWEzZkswaVNGYmgxM3A5MXNNUmtlM0ZVYzhHcnVwekc2MVM5dUN4WXlYRWpsaU1FNVluUDYxU3IxbzdDSkVPT1I5SzlLOFAyQzNOdVczMjhBQ3ZHa2Nwd1R3RHhuZ0huMXpYbWFNZjBycmZEMTJKVWRHZVNLSlNOOGlxR0tnanFSM0F4MjU1UFhwWEpqS2JsSFEzb3lTdW1kSnJOL0RZcEtMSnBZTGhZV0RrRlFDVjJuakRldTcwNkN2TG5QU3UrMTlVMC9UNTRFdVlMbU9SU2ZPSXlUa2NFWTZkU1ByNlY1KzVIRkxBVStTRFJuTmsxdnl5Z1p5VFhxRVY1dlM1dmJxOEQzVnlvWWVYRnR3MlRrSGdkUjZFZGE4eHNkL3dCcWgyWjNCaGpiMXpYcDJqYWJkM0x3K2VDQmRmNnVSb3d3d2NuSXgwUEdPaHg2Vm5qNVdTMUtwN016ME1UUXJiSmJxa2hVQmdDY2xpYzd1djhBS3JPdmFaZGFMNGVXL2laWnNsVWRvOEFKbmpQWG5uajhhNkRUdEtnc0VFYVdoVVNMc2xtTE1RamtOemdnZGlQKythbDFQVDF1TEthS2NTd3hBQjVERnlNQTlTU1NNNXowOVIySXJ6M1UvZUxxaWszSFpubHkzSzIxdURnbmNRY2xobmpPY2pyM0dEeDNva3VHbHRvMCtkQmxuSUJKQlluNzM1VkhOQzR1U216ek9oYllRZXZPT09Qd3JVL3MxSkxVUzRWYlhjVVZaaVZMZDkyUU9neVByWHF5Y1Y3eHpwTm1XQzF1VWx3LzdtVldPM0lQRERrSEhIU3RHNHNMdFhodDlSU08xRUVJbGZhMmNwa2dQOHVjbkovWDB6VWtNY2R2SEhjeVJ2NXZsRUtJendXenhrSGx2Y0Q5S3Z4bzk4MGNid1BGQzhRaWtjcXliVkxnWjU2L01TZWVNbkZaeXFhbWtZMk1UVG9YaHVycWFPNFdZK1ZLcXloV3d3MmtGdVI2WjY4ODFac21nYU9ZM3BjM1FYZkdBdVE1eUFRZVJqdmpBclJqc2JUVGJTVzJsdnZQYVdLUlFzQ2tLMlR4a25CeGtLZW5RR283UzRXSkZFQUVrak9BV3h1S0FaT1Y2SCtJblBxUHpVcHhscWdlaHNhYnEwMm5hU3NWcmFSdXJFQWlkWXlVeXhPNEZ1ZHd6alBwK25kV09vUzNXcTJVbDRCYUlvelBiSnhKSHRHZHVBT2hJQnhnSEJOY0ZaVDNNVTZtQzRmenBlV0pBTy9uSEFQMVBQYzVyWjB6VkxXY3BMZHlPekNONDNUQURzRlFJb1hqM1VISkI2bk5lZlZwdHU2Rm8wYnQ1Yng2dHJVcXhYYjdqL3FSZ2xHQTNFcmtuN3BHRGdkRG42MVhiUkxyVE5YTXR4Q2wxTUlTaVBFUVZaOXVCa2tncmpnNTlpUjdVOUx1M01qWmxSVmlRcEhBc2hlUWpJT0FjRUhybnRrQTg5YTNJdFd0Tll1U1k1NVpKTnJSeVFzdkVlUU1rc3VHR0NjQmdEejlEU1VIc2hOMk9SMXZTOVZ1cjZGSmJXUlpTcXY5cEVnWkptSndINU9BUW9VRWRlTTF6V3BRMnlwS3duZVpWM0lyeXhHTXIwdzJNNCs4eDRCUFErdGRUcWp5UGNYU0kzbDNTQWJSSVZTT0wrRWcrdlVqOGVmYkthS0M2UUc3ODA3d0pJMmorVlVZOFlZRmVUa2RxMXB1VWZRcmx2c2NuS3l4elJLcUtlUVZkaGdnZzlhMVliT01yTkpMSDVlRTMvTXBDdU1jWk9Sak9lM3JVZHpwb2oxbXd0M1pYODFIWStXYzl6eDdkSzYrejA2SnJlYU9XV2VPNGxEd3hJbkVNakJlUHBrZ2ZNZlVIaXQ2dFZSU0RsT1h0YlZKNVdCZnk0ajk5bEpiSjQ0SC93QmMxMFZ2YndZV0Vuelp5eEIyU0srUm5uQnp6em51UFgycklOaDlrdWtTU2QzaEJWbThscytXU3E3dnIxNjU3ZGVLdVdUdUpzeEJ6SXBiYUY2cVJ6ZzljZmhXTlozV2dXTDAyb3dSTVdubEszRWlMR1RndHdEMWJ0emh1bmM4OXFsRjVhc3ZsQlZXMlZ6bFlpeUU3czRJeU1zUDRmeEp4elZXNXZ0TGsxS0Mza2drZVM0VVd5eU0rd0lkMk04OERCNDU3WitsYzNLTGl3bmFHUWc4N2dWTy9uSjQ0enpTcDAwMXJ1VzlEc1B0RUNYelhFaUlaSWxZRXdzUUZKK1hjRzc0dzNHYzg5SzRuVlRBMTdIdWhNbHVrcXlsU1NjcVJ6bkI3NUE2anAyclZtdjBBbGh1U0pZdnZNZVFBT1RqcHgrSHJXSnJWa2d0SG1qYjVpM3pScms3ZWcvb2VjbXQ2TUVwV0UzYlUwTGNwTVJiMlZuR2tTSTdnQnR6TGtqNWpnRWs1SXdQeHJaZ2d2ckd4OHVkMm5oUjJVRVNsbFZ3L3dBd2JISVBIZnI3aXVVMGEya3VyKzI4cEFJMkIyeVNnbFFNSHJnK29PUFhGYTFyUEpwNFdXYVlsTi9tQ05wQ1VkUnlNakdDZmx4ejZkS3FwVCt5TlNiSjlRdUZrY1lsalpwRlljQmlxakJQUFU1K3A3Vm11b250RWtqZ2tqVVlVTytEdUpIQTZaeWNmU3RaakNtaTN0NUhlS0xtUlpDMFpYQ01NRUZNRmZmakIvcFdscG1nbWFHQ3lsa1YxRnVzeStYSHZaK1l3QmtFOGtsOGNkeHgwd28yakVIcXpoYnFGd29WdzhFdThLUTNYNXVoUHAvaFVJc1p4RE5pRlMwSlVPVnk0VTV4akk0NmtWMkYydjhBeFVSVFVJcm1lWHpBb2VVYmkyM0hISngwT09hbHZ0R2xraGx1N1pXSnVma2VLM2pFQzhBSGtoc0hKQlBRNXdlL1RhTlMxa3lPVzV3OXJlM0VVenRhS1VuWDV5K0FyTGpCeURuanBqSC9BTmFyVjdjMzE5T05RdVJ1KzFxb1VzUW9KSEFPZndQdlhTNi80ZXZubGVRU1F3Z0JTKzBxMGtoT09XWlRqY1J5ZVA0VG4zejdTd2Vka01naldHM0RaS0FETGcvZTJrOGs4WkEvTGpBcHpoOFExRjdGU3dzOVZtdDMrMFJ6RFQ1bnc4aU9kcDVIUXJrTmdrSEhQUTl4VW5obmZaK01ibUdSOThtWkl5V3o4elo2NUhJNlp6VzNaV0Z4Yk5DMXZLZHJMS1dpV1VEWWlnZktSbnJrZFBmMU5jdGJYQ1duaWErWjR4dFdSd1k1RG5vMmRwSUo5TVZOK2RTWFN3Y3RySFB6TVMwcFlFRXVTUWV0UU4wcVIyTE14WTVKSnlmV296alBOZDZJSHI5MG52MHJydkFkNjBGNWMyMGNYbVMzQ3FJMS93QnNIZzVIUGYxSE9NOUs1R00rbGJHajNKMDdYM2JZMDIxbVVxUnRMRDNIYnAvOWVzNnl2Qm9jWFozTi93QVd5aDdNYk5rYmJWTWlnNVk1SXdDZnd6K05jRzJjOWE2N3hWS1JaMnNXeVJBT1NrbWR3T001NUFISUsrdGNqZ0UxT0crQzRWTldhV2pwdnZvY3VFQ25kdU9lM1Bhdlg3ZTRiK3lyYTI4ME13WXBDcERFdHV5TWc1NCs4T2g3K2xlWGVGa2diV0VhNlNWN2FOV2VSWVNBMjNHRGpQQjYxMlU4a00xNkV0cFo0N2NTQkZEbmFVMm94WmlCMkJCT2V2RmNXTmh6elM3R3ROZTZkaHFtbzNMSVdpblc2dHBXKzBGbEorVWdIZzVHUXdISk9jVlVHcUVvV0NpNmhSVVB5bzBaajY1T000SkFQVWQ4ZW1LeVk0N3FDNE1Fa3NiYlpOMFlVTVVNYlpCY25QVDVmUTlmYXAvM1U3dkJQSjVhcFB1VUVoOTJCNmdmamdrNDdkNjRmWjJLY1RoNUZXTy9TN3RWUGtNd0lWazVVZzlEakFQMUhVZWxTM2QzTERLNXNDOEZvcHluOThjNXlEOWNHdGkwMDZTV1VzSVRKSWhHVlhCT2NqakhRK2xWcG9sUlNKQkkxcXJqYkVIK2JQT1JuR0QvQVBYRmQzdGsyWjJzWnpSQmJ2Zkl6RzVrazh6YWpEYWM3U3VNRG5xZUJUdFExUzhobml1U3pMSXhhUkhBQU9HNS9tQngwR09sUjN6YkwrQ1dCZHNaVk5vNm5LampwMzRxMmRKYWZUWXBuRXp5QmdHWWRBQ0NTU1A2KzRxM0tLczVEdnBvVTRKMm1lS1NZTDEyN1MyQTJlY2VnSDFyb0x2VDVGaW5kb1JiMndrREFqNXkzZkc0WnoyNmNjMWtSV3FXZGdseVVSNTVHd29rUEd4ZnZaSGJPVkE5Y0dyMm1YdHJIcHN2MithUVJ1K3lQeWlTY25CNzhZeU9uc1BVVmxOWGQ0a3BkeFlyQnJqZXl5c0lrVWtBbkRZQTVJSGNBbXRPM2lpdDQ0enNrOHNobGxhTzRWUkx0T2NBWUhHRjl6N0h2Tm8wZHZjWHlYRUtCNUlqdWhXVmZuYzlCOG9PUitlQWEwWkpmSXRyVzB1RU1DTSs5V1hobzkzWHIweVBsTzQ4YzF6enFhMkJ4SXRXa09vVzlsZVNXOFROdVlSaFJuYW1jN0NUd2NIUFVaNXh6Mnc0SkwvVDlWVm9tRnBMYjhGeTJXYmFUa1k5OGRQVVYxQ1grbGYyZmJ5MjBFYzdTSTZOYkk1RDQ2WlBma1BrNFBxZTFZTjFya2EyMW02SFBsYlM3TXBBY2toaUNEMUFBNElJNzl1U1UzSnJZYWl1cERxOTM5cnUwdGN4dmJna21XQlN2eThsZHc2QmhuQkE2NVBYcVVXZDdTTXd1NW10UEw4MkU0REtId01IMUJHQ0I2Wkp3SzU3N1Nna2VJeUhZeWdxcUhnWTZEaytnQXpTL2I1V21aWWd3WW9JNDFBeVNRUWZUdWY1MXU2VDJEYlltL3RLNVR4RmJYWmRYblhQM2tCSFFqcDNHSzF2N1c4MVNqZ3hxUG13amJCbmoxejJ6MXJrTHlSM3V3Nks2TXVRVnllTTlSL1N0ZlR6Q3IrYWlOTk5KbU1SU0lRRXlCODNvUjFINjFkU2lta3cxTm1HT0M1ZTZLU1NSUUY5dTJRampnY0hHTTV3UitOV2JDSzNzYnBMbGxRUXM2NGpHTVl5TUZ1ZW1PTy9ldWJXNWl0clNlV0ptanVQUElWVlBLcnh5VDNCL3BXdFlhakRERkViNWhOQXh4SUFQbUkrVTRIR2Y2WitsWTFLY3JlUW9vajF3VHczTTZ5aUpWODE5ang0SWJMWkpBNll6anAyTlVGdFpXZkRTZnV3cFpFREhnOURqSjc4SGl0S1c5aGtFVWFvRlhaL3JIWUlRVGdkUjFCeDlUVEZhZG9KSllVaVlzeEc1amtjamxRZS93QkQvaFZ4azByYkduTGMwbzlLYWUzalpsa3g1WGxSREE2Z0hKem5ybjA2OCsxRnRwVjFFSlZONElwd1FJNDNPM3pHTGc0eHhuZ2ZuVTBGdnFWemJ6WE1kbmR0YVBsbWxnUnh1SVBQemRGNjlqNjVGRnRwOHR6bVNNWE9WbmRqSWM1NDZxRy92RUVudjFyQzhrOVdWeXF3K0t3a2Fkb1o0TFZuVUtnUnNCaXU0a25xRDF5TTQ3KzlaMm9hWGVXczkzcC9rRzRqUTVpbElJQ0xuak9NbkF5ZU9PZWVuWG9MMk5yNy9UTGo1eThxTHRTSUtZVUdBQUd5T1BsUHk1UFN0MlRUNXJyU3JlR0F4eVNSdytYZEdNbGxVNUpJeU1aN2UvemRlOVI3UndlNU5yYUhtZHpiM1Z0WXpXVGtlYmI3MFlSTVh5Q0FOMkR4eXZRaitRclN0N1JwTHV6eGNmWm1pUVpDQmxPQjF5ZWVRT2Z4cm9iUHd6SmZSYWc2WE41aE1GWVlsSU0vWVo0T1IrblE1eFdnTkFON1lRTzh0eEdQT2FJMnU4SVk5dnRrWjlUeHppdDVWMHRMaHluUHphZkpmM2JYU3MwaXVjUnl2SVNBeW41dHBKNlpIUWp1YTBMbTBobEtXMHJ4dFBsVkVRVTRZNVhzQnd3QlA0OWNWUG8zaHdlU3Q5OW9sZThXWEt0L2ZqeGxoMXlEMTU2OWEwdGEwdTYxUnBiaU5aRWwydTRWbVlCbFgrTHFReW5LNDY5L2VvYzd2VmxLUFE1KzUweE5YaHN6RGN6UGVENUhSWUE1VldKd3A3L0xnQUVaSXl2SEZjNlRORTF2SGQ3b1hWR0J6SU1MdXdDT0I2RDlmZXV1dDdEV0lidjdMUE83czhXM2VzSHpFSVFNS3dYR1RuajlUeFVFV2phbEhwNW0vcys1V05KM05xaE1hL1BrSElKSGNEajNIR00xU25aZDdEYWFPWjFFM0RUdTBRMk5HUE5aZ0JsU296OUR5Y2ppdUxrayswYTFkU1NzUzByczVaeVRrazU1UFUxMlYvcFY5T2tTWGtNak41UVpHWmxLa1pPY3NDUmdFSDhSOWE1QzlzTG0zMTZhekViTk1DUUZQQkl4blBYMDVyc29XMVM3R1UxTGRveFhQSk9NYzB6T2FmTXBTUjBaU3JLU0NEMUJxSVYzb3hKa09mbEhldFRlYkxYMlpSa2IrQmpHUVIvZ2F5b3VDRFd2cWY3cldoY0dQZEhJVmxDc2NnZzg0eUQrRlp6VjNiMUtqdGNOZVovOUgzT2pHUlRMOHBIR2VNRURvZU9uWDFyRVUvTlczNG9WSWRYTUsya2xySkZHcXpSeUhuZjFKeGdZNEk0ckQ3NDlxZEZXZ2hUMGswYnVoRWlhYkRGVU1SVjhKdXl1UVR4K0ZkQWRSdElXc2JhU1NHZTJNck8yejVXWWZMZ0VubGM4L24xcms3U2FhMnRacDRoOHFsVlluM3p4K09EK1ZWNVo1SkxsNXlDR0ozSEh2V1VxWFBKc3RTNVVqMTIwVzF2aERjUk1uMmVCbUVrbmxoZ0Z3RGs4NXpnSE9PZllkYW9hZk5aM3QwdHRiV255Uk5JMjl3T1U1SUFQR000NmtkL1ROVVBBTXlYR20zZG1saGMzYzI1bUlRWlZWWlF2VWNnOEhzZWdybzQ5TnVMbU5wOUwwZDRESCs3S3h5QStXaDY1ems1UE9DZVNEMHJ6cFJWS1Rpem9qRnlWMFdGMC93Q3lMY2Vhakl3R1FETXA0NTc5L2YwNDlheGJyUnRSdVE3V3RzaXFXeXl0S2dVTmdER1NlT282MTBkM3E5czVabXRMSHlEOTVYRGtuR0JqSko5QVBXcWNsN0FrL252R3l4azRjSVdCWWNZN2owNjVGY3luWm5ROE9wTFV4MzBXKzh3TVVqKzFGeGdpZFYzOU9QcmsrdFNSYVJyRXNjbGdZQ3l1ZDZoaUZJWURuQUpBeU9tZjhhZDVzSnVTVzg4d3RrK1dTUVdQVTVKSlArUlJIcVMzQVVmWnhLc2FiVklmY09CMEk5ZVA1VnE1dG9YMVpiRWN1aTNzdHNJcHlWS0V4eHF6YlFCbnVjanJuL1BGVXJmUVhpaWVlV05TRUNsRStVamNwWGs4OU1BL25XdkRxOGpRSkY5anRpZ1VBNWlCT001eTJSeU9uQnFPOXVaWGRualcxS2JnUWhpWEFQZkdPY1krdlNwak9hOTBmMWFBSWJtQzJNQy9abGVTRFpFc2FGeVZiNW03RUFqSXdlMktzR09XOWpiVG8zTUptUVI3djRYVU1HM0FIbkp4Nzlxc3grSnRSRm9rWGwyKzJFRlZMVzY4ZFIrRkQrSjlSaWlCUVcwSE9TeUpnNS92QW5QUGJpbzk0UHE2QlBENDBxQnJLK0VrbkMrWWtZSll1MlFwQXdjampQRllGN3BkM0pPYmEzTXlSeXNvZU9hRXJzd0J5TThjbi9JNHJvSnZGR3NZRC8ybVpBQis3K1FaR2VPMzhxcFd2aWJWMFl1ZFVuK1lIZHVjazU1NmMrL1N0SVNtcnRpVkV3NC9DdXMzREdHR0s1bGtWUklBa1o0R1FPZnhQYWxid1BydldTQzZoYmFEdEVMdG5KeDE2QSt4clkvdHErekVQdDd5U0tDRjJOZ0JUN2U5UlJYTjNjU05jeW56ZHc1T1N1UFRKei9XdEZXcVd1eXZZUnVaRTNoTzdTWGJQZFhIbW5PWXhHUzZuMVBQZnRSYmVIN2kzdUloNWpoWkFRL21SZ01EaklBNU9NK3RhRXZtaEZuS2dBbkRiQWM1OXpXZnUvZXN4bFFBT09OaEk0QVBCeGc5dnh6VktyT1MzSEtsQmREU09nYVRkWW1ZM0NNekVsY2pIcmdrTHdQODhaelU4T25XRWMwQ3ZFandPdzNLemx0dzU1eDlEMnFvdDNjaUR6Qktka2d4dFplRjU1N1k5S1Q3VktZbk1VRHVFNXlGKzZ1ZXZYcFdMYytyRnlVK2lOQ2Eyc0lZV1V4V1VpdElqYmZMeUN3SStZYmdTTWpzT0RVMWs5dkpPclMyK25oZkwzcnZjQWRlbUJ3RDA0d1A1MWdUWGJKS3lUeEJaRXg5NWR2UGNZejNQZW9USTZUYlBNQWpPQ09lQngxejFxcmR4SnEyaDI5dGN4YjVRTDNUcmRIQ2w0bVZsR1FPTThmTmpPRC9BRXA2TkRheHRjMnJhV3FvbTBwSE0rY2c1TFlQcnoxd2Zya1Y1L05lZVhjZ3huNVYrWldCOWZla2Ura2tsVWVZVlZqdENyak9ENiszRlQ3Ry93QXlaU08waTFxVVN5VHhNbmxFTkdzYmdLcWx1VHRBeit2clVsdDRvYUdkTGN6UkxIamN4REg1Zmw5RklKempudno5SzRpNXVTYmRvaVhLTjgwWWRjQW4xeDYxVmlra1pnNkJneVNmSWNjSHNlS3RVVTlXSE10ckhvc2V2U3BJMHozRnNxTzVPR0xuYnlNY2M4WTZESnhpcExEeElyM1RYRjFld3R3OGVSRzN5SWNjQUFBQnVoR1BTdUtudUpsdDFScElvNDBrNUJ3V0xNQmtrOXhoY2ZqV2ZjYWpOT3pCQW5tdWNiVVhhQWNBWndQcG5GVEdqZlZEazEyUFJiM3hqRktFOHk2aytSeTNsZ1BIbGNrOEZYQUhRL25pblNlTG9qRThMNnQ1Y1RIQ3FMY3lNUWVjY245VDcxNUhOZVhqU016N2dqTW9iblAweG5tcDVibEk1RHRETWg2Ymx4bkhTdC9xMW1ydTVtcWwraDZUZWVMSTdWbFMwMXZVR013RE9GaXh0QUo0NUkrWWpCT1BYclZhOThjeG16dGlyUEtWS3VZNW9SR0kyQUFMRGEyRG5ucU8vT2E4Kzg0aUFzWnNNMGdWWTFCSjU3ajlhVm1hUnBOa1lNTERhQnR4MDdWWHNsMUU1ZVIzMG5pdTAreGgvczhMekt6L0FMbFlGMnVNRERIbmpwLyt1dUUxSFdMbVB4bEhxa3UxWmxhTm0yb0dIQ2dkRDdWU2E3TVNNMjRxUjkxU2VSV1hlWFgyaDBKeHVBd1RucjZWclF3NmkyKzVsVXEzUkZjeUdXNGxrWVlMdVdJK3BxQWRhZG5QV20rdGVndERtWkl1Y0U0clExQStWNUJCSjN4QThuMHlQNlZucm5iaXByb3RKRkEyR0FDbGN0ME9DVHgrWXFXdFE2RU54Y1MzTTdTelNNN3QxWmprbnRVWS9XbWM1NXA0NjU3MWFKSjkwclF0RWpueXlRN0puZ2taQVA2bjg2ZmFKSUgzREdCMTNKdUg0MCswZWFPSjJqUldVakRBMVpCdWxpVXl4RllsKzdub2F4bEpyUTJqRlBWbXZvK3FUNkJKY1hOcTRWTGxmS2RBcDJPQ2M3Y0hQNjFzV25qUFVWTE9zeVJibUM3VmpBeU91ZnUvUWRmdzcxeW91WTNoS0Y1Qmc5TnB4U2doc2dGT21TU1FNZlExeVRwUm5keVdwMHhseTdQUTdSTmJsOHRVUTVZdnZCVWNENjQ2amsvV3BZOVhrTGlhV1R6SmR1d0JzbkFQWTg1d0tvbXhzb1dMUTM2bFRuZWlzVGc5Umc3UmtkS2k4cUR6STBsdW9XUjFKR3grUmdZNTY4NTdWeGNzWkxSSG9XZlVuYWFWcFVlNHhIRnV5K09RZndKNlZLMTFtUnB3NkNOWHhoWWluYy93ZzRBK3RMYVh2MmU2V2UyRURwRDh1MlNETEZmWGtjREhQV25HNnRicWJ6akhJNmpKRWUxVUJ6NjQrblRGUzNiV3c3WGU1Sk5kM1JzRmtoaWQ4NXl3alZnQjM5emluUVhzaXhTUm1DTEpRNWNFWkFQMW90YjNUYlIyYVd5a2xkaGhUNXBVKzRCSEhTZ1hXbFNvVE5hM0twdnlSSFA4eEdBQ01ZOVFhbGY0UWFLNlhrZU5xK1Z2SkNobWJCSHZ3M05MTmVSaFJ0dDRoR0R1Q2lSdHJkZTJjKy80VkxablNmTE1SV1dKM1U0ZVp3L2xuKzlnS08yUjNxVzIxSFFvSUpwYisydWJpNDI3ZDhjd1VBODVmSEhQdDcxYTFleEwwVnpLS2huMzVjWWNGRVFqTEgwSXdTUHJUak1aSnRtMmNNVzNJVEh5VC9rVWVYYU0rK05yaEVHVHZjTHh4N0VZNm5pcWpTUVJUamU3dW9BWURkdUJQcDdWb2xmUW56TFJmNWpFRWszanFaRjJuM09UM3E0elFBeHcyNHVFaUovNWFkT3VlbU1IL1AwcktlNFI0RlpncVkrNnU3UEhwelRKcEo5Z2RIYU5UOHBBSHk1UDFIWEdPMUxrYkt1alZsWStlcFdmSk9ENVlCWEg0akdhU1pwTGxXaXVKaVVWMmFKVTJyOTdBUFBYR0JuNjFtbUl2TjV1RHU0NVFuYURqcnpWeTMzK1hzTnhsV3oxWHYySEhRVkxUUzBEbFV0ek9qUzRpSmpMT1VIT09vQUhQTlhMcTdXZk0yemEyejVvVlhiejNJd085U0xiU3ZreHBIRzU0ekhMZzlPMmNubXRPLzhBRHpXVWNZYXluV1RrTk10NGtpUGpyd295djQxVG10MlpleFNka1lwMUJyaTNXTzgzeXlydDhwbWY3Z0JPUVIvd0xPZlVVNmFZTGJ4OEtlQXpNU2Nqc01ldjhxc2FoYVJQTXErWExHQVFDSHgxeHpuOGFodWJKWTVGTWV6YVB2RlNjaXBVNHUzUXBVcEppeFhZaWw4MjJXTmxCeXlTS2pBbnVNRVlJNVBhcUczemo1NmdBa2drS3VRcEpxL0xFbTBOSGRCK1FpcXdLRXFSMTlNZmpWT1dCMVVxRGhBZVFEa01jOXF1TFhRSlU3N2tMeHlwYW1FN1hpQU93dHpzNmNVb2NSeG9iSkNqai9XRUVudnoxNmZoU09QT2xHNlF5U0FBSEI1eFNCWlZBVlcrVUhuY01nMXBjejlrV2hldDlrZ3RaN1VoRmN1QWdDWk9BT3VPbkZJeVdkelpwTWtEUjdFS3NRNUlMWTRPUC9ybm1xc2xxWkdWa2tZZ3Q4eEhZZDhEUHBWTFU3TkpyY2VUdmlLWUdISlBtZS9vS2NZeGJ0ZXduR1VGZTF4WndnS2t6cXNZUHlLU0NjZlRKcU5ybTJabUpuUkJqMUp6K1ZaNDBXN0xmTVZWZlUxTWRBa0E1bHdCMUpYRmROcWEza2MvNzE3UkV1dFFUY1VpbU1pRGtmS1JWWTNqeUVGNUg0NkZWNXJTdC9EOGJ5QlhrY0FucU9SK1BwVXlhREhIa3RCSTU1eG5PTS9YR0thcVVvNkM5aFdscVlSbUF5eGczWkp3WEpxTmp1VUF4UnFEemtkZjUxdHlhWkRIbGpCdHhuaHM0eldHNXl4T01mU3RxYzR6Mk1hdE9WUDRoQjBGTjdtbEI0cG9PYTFNUjQrNzcxZFlyUFl4eHlrNGlZbGVlQnVIUC9vSXFrcDcxWmlrQ3JJR0dRVkhIME5USWNSb2pWV0g3MVNuOTBmL0FGNmNzVWJBQVBHQ2U3NUg4cWxhNXRTTnYyVFlSM0xaTlhZRnNISDcyM09QWE9EMDQ1ck55YTZHeWpGOVVWTE1yR0NDRXdlb0o2NDlLMFlwaGxuV0dLVElJOHRqd0Q5QVJVNlcya0Rhd3RHY1lBWUYyNi9nUlhTMkh3NnROV3NJcDRMdDdlUTR6NW9HTWZRYzUvR3NKeWk5WG9heHZGYVdaeUwyN3NBN1FReFpCUDNzSEhwelZhZTN0L09JSUFVdHg1UkpCSHNPUDZWMEhpTHdWSDRmZFZsMUdPWm1IQVFFRSsvSXJuMHNBNzVFekJSMzcxVUducW1US1hkSFNTMjhrQ0tXdDJVTU1rc2h3dy9yVlZiVlpIQmVSWEdOMjFHNUE5ZXZIMHJwYlRVUmJwRTF5OGM4RVROdGlVakJ6emdnQWUxUlhWKzhkenZ0N2EzampHMTBqWmdvNE9SeWNaRmVlcWtrN1dQVWNVekJhUStXVmJJWGpJM0FkUFhCcTBqWGNaM3BFblBxcWtmbDYxb1BBa2hNN1EyUUxyL3Fvc2hSays1SEk5YVJyV1MzdUhteGJlV3NaK1lUS3VlMk1nOC9yK05EbW1DallwTGNUeHBIRzhNSkpKT0RuSUpIWHIxSDVWTE5NMGtlK0tGR0lKQk9NRG4yeCtYcFVzN1N6UTdneUxuUHpSTU1MeDk0SDhjVkJOTnNkUXR5em93RzkxYkFBNTlldnJTWHZQUkR0eWlRWFQyN1N0S1FGa1VveWlCV0pCK3Y5S3V4WHNFc2F3TmJRaFZIRFNXeU1TY2RlaElHTzNJck5lS0lyc2llSU1yZkt3ZGlUMzU5ajI1cFdtWmlXWUVMZ2JrTW5CeDE2OUtweDZrNkdnUHNDUU1JcmU5anlRUTNucVFUM3dBZ3FSTGpTNW92Tyt5T0FBMlRFVUJaczRCYjVPTzNRMW1DU0tTYkNIeXhqYmtlbmNFZmxUaXBuaUFlNFpRZytabHdjQWQ4NUZLdzlPaExjLzJWOHNWaytvN20rOGtraXF1ZXg0SHI2MHdMYlF0QVpFZkFHMlZaWjl3WWtuSlFLQVJ4MjUrdFhGakNxRkVTejNEOEt3UVpPT28rWGlvcHhJYmNBVzBLdHdvbThzazVIYkpQOHFGTG9ITDFOaFpOQ3RwRmxqMDZGRkRBc3BtYVhDalA4Szg5OEVIcGo4cTFtdWxpY3N0dGJTUVNJMFpTUU9yS1NDTjJPY0VIQjZqcldNbHJNbUpqQjVqY0FzeEpHZXc5alRtdUxuNTJlSlZadXFLQ0FNL3Azb2NHOW1KTkkyQ2xqRkxHcno0WEM0Q2t0blBCK21PRGlxVHFaVEwrK2hrQ2RHRFliQjlpT2F6MWxKakJPNlF4akxZR01aUFhvZVB5cXhIYStWRXR5YlY0MVp3QzdLU1FUeHpVK3p0dXkxTTBUYjI3RnhMcWNaSVlKSHVqNFlrNEJ6MkhmQkZXTGZSTGU3bkZ1K3BReVRTWUFhTEd4ZU9yazlPb0hmdldVTElYbUdVZ3hzd0xTYnNGaVB5cTI5bjlrUmkwZTZGbHlzaEJPT25IcDBQSFhyVWN0dG1ObXBwL2hTN3VKcFk3YTZzQSt6aUw3U1BuNDV3UndRT1IxcWpINFcxUVJTTjluaUd4c2J2UGpZYysyN05Vbzd5ZTN5Y3l4Yk1FYmh0SUhwajJxYVcvRnhDY1RYTWc0V1dSajhvOWordUtIR2ZRbTQ2NThLWEdteklra2NhWGt4NEI3anQ5M1Bwbk5RUytHOVVodTNNdHVTZUNkcnF3N1pHUVRRTlR1N1MxRm90MUpKYnNwVVJ5TVNxNTYvZTU3MHlDNjFBd3llUmVxdm5TZVpKQ0dJSmIrOFJuSGIrVlYrOFd0dzBzdEI3YVJkcXFTdUk0a09jNXp0YjJCNlorcHB6ZUh5cmdHZEd5Q3d3TWdqcGpJNDc5ZTVxUWF0cWNMQmt2REhsY09jNTM4OU1ZSUkrdnRTUHIrcU5Fc1V0eE1VQVlmTW9WaURuamQ3NTZVbDdSOVNtMTJDeDBPNGRuSnRXSmlUaFZQSmJxUmc0N0gzcWFHd3NvQmNQY1dxYjJZQkJJdzJCc2dZWXQwR0NQOGlzcVc2dTVKMWxacC9NVWtvMlR1Qkk3ajZWQklKZDRWbVZwcEQ4aGtjREo3NUpxbENUZXJKdXV4MUVuOWt3K1pHczBLcklSNVVxSXBhTUE1NkFIZUNPT0NNVlJONXA2dkNseGQzVEt3YmUwY1ErWE9jSERkVG5uNlZqdkpHNC9kb3l1bkJSaUF1Yyt2b2Z3cTVmYVpxRGViY1IyczNsTTJBSXhsY25QVEdmUTBlelYwcE1YTzdhRmZXVXMyMHhoWmljeWo1QkpJcWdPQ2VXSTNaWDIrdGNYYzZiTkFrak9VQVRHNGJzOWVsZGd2aDdVcHBsaldPWlFRRnpJcFhEY2NBZXZJcXluZ2k3MUNNbHBZVlpXK1pITEZnb0FKWTVHM3Y2MTFVNjhhV2x6bXJVWFYxUE45cDU5S1JGSnJ2RThGUXhTeVEzbDVFa2pzRjJRZ3pNQnlRUnRHTzJPVFdsYmVEZkRyTzBjMGwvRjVlZDhyeEFMd3VSL0Z6a2tjOFl5UHc2SGphU09SWU9vOVR6cUdFdUdBOU0xTUxXV1NlTUl2TExrZHNqMXIwZTIwYTBzMmprdFBENG5DSmlTNHVXZGxJSXdDRUhCSSt2NWRhdDNUeWZZVnQxMGkyZ2oyR05taXRpclA2RXR0SFhCSTllVHpXY3NhcjZJMGhnMjkyZWRYYVg4clhFbW9YRWk5QXp6S3piajBBSndlYXpZSW4rYmE0MkE5U2VEWFNlSVpkZXU0cnN5eVhNbW1KSXJGU2ZrUTR3dVJ4anFRQ1JYTVErZnVBaDNubmdLTTgxMDBuZU56bnFybG5abXJIYlhpc29YeTJMY0FIQi9uWFIrUjR3dExKR1c0YUtFRGhVdTBVajhOd05jZWI2OWpKVXl1cHljOWp6MXBvdnJva256WE9ldVQxcE9EZllTa2wzTGQ3Y1hza3JOY0hmSTM4WmZjM0h2bXFJbVVOaDRXYzl3WFBOUFc3bEhIeTljOU85U3RmeUVEZERFY0hKSkI1L1dxU2Ewc0RzK3A3WkQ0SHNDREZjWENpVkpNQVdybGkrY0QrNmNZNS9QSnF6SjRHMGkzdTRTMTNMY1J1bTRSUHNSMUhUMHgxUFg2ZXRZMzl1S2hrdXByaWFiQThzN2JvaFdVanVwWEdEbmtacXV1cDIwa3NJZTRhT0NMR3pHK1FEcWVoUEdmWWl2QnRONlhQWTVYdmMyTFR3dm9ONURQTmRYY3R2YndGNEhVYlNTdzZZSVBVZW1EbnRXY3VpYVBlbGZzdCtrNlJNcVBENWlxNlp3QndlbzU5T09mZXBkTXVyRzM4eUsxYTJqanVEbG9VUUVzVkIyWkJMYzU1T01ZcUNLVzNqblc1YWRCY0JzR0Zsd052WEdWSjZIMDYrbFExTk4rODlQUXBMVXY2YjRFTiswYVd6UWJDdWM3K1NmUWpJNkdyT3ArRE5PdEw0MmphMVpMZFFxamxKNDFYSUh1Ui9YQnJLaDF5NnNwZjNNNGhpYU5SNUtyRm5qazhubm5IUS8vclpkWENSVEpmN1ZMRldZWmNGWnNnZkt3SndNaklKL0NyVTM4UFgrdEFjWnQzdm9Ycmp3bmN2SzEwczlsNWN5RUdPS0FNT29JUUhjTUhjQitkUFhRSUx0WHQ0WnJlUStVcEttSUI3ZmpPUWY0OHR1R091UHJ6aDJNcWVRa010eXNka3NvSlZWQmVNRFBRL3hkVDEvV3BMdTl1R0JSTlFmeTBCQWRKVlVzb1g1ZVJ5d3lCMytsTnFiMHVDV3AwOFhoclFMZUNPMXZMeTNSNVZWdDhvVU1NOSt2SXpqampyVVNhUFpReElzZDBqZ29HamUxS1pZOC9LQjNIQlA0MXphNm0reHBVdkpXS2ZkalpUSVg2amNPb0ErdmFyVVdwYWcxcEhMY2FtQ1diY0NjRXIvQUJBS1FPbkdhem5DZHRHRWI3WE95UzNhUzR1QmJhNkxlM093eUJVVXVYd3FzMjlRU29MZFJucVR6VG50MGVBeFhGOUJNdzNEQmpkOGtOeWQzR0RnSG5ucDdWeW8xdlhEY2wzdUhna1pjaHJlM0c2WDB5d0hUblBmNlZEYzM5eXNjZ2sxSzlsbFpjRWJDRms5T252ejBxNWUvWnN6VUpMci9YM0hTVHlXY2tMUjJXcUFQYm5NcUlwd3hJNFpXeVFTQ01mZEorbkZWcDEwaUY1WVVnbmt1MmlRSXlKNWJ5QWpKQnlCa25JNTdZcWpERFpHeWlsZS9uRitVRFlNcDJ4akI2YmlmdWtBZHF6THlkRnRKbzVOVG1NUWtabVNSeVJJVDkxZ0FlU2VNOGNZSm8wY3RQdUtpam9yYUcxdTBXR3l0NTdXQ0lORkk5eUZFakFGY0tjRDNJN242NW9OaFppSVN3eTN5eVhCeHRMN0lqampQVVo2Y1pIYm5GY2JOYXZNZ2tTS01MdDVrZjVjQURnL3kvT283V09WRWtabSt5cmJzQkl5eUFGOG5xTS9lT2V1M2pGTDJWMDJtVS9VN0RVYkcyMDBMTExCZGtTRVJyS0cyaVE5UzNQY0U0UE9NRHYyU1JwSkk3RkdnbmpCaGFObzJaZHprbjVXNUJKL1ByakdPYTVmVlExaWhzSXJ5RzdnRGVaNTYvdk9TT1NNZER6ejByTkVVdDg2cVpKWkFqS1Vjb0YzREgzVDlEVnFuNTZBbmRLNTFqcnAwY3lKRlptUnBqZzR3Q091RjJidVRucmsrbExxVUdtYWZjZVFkTm1pbkp3eVJFY01WT051VG5IVDVlZUNhNUM3aGJUM0RXNk1YUDNwTXN6S080QTZEdURuUFhnMGl5WEx5QXl5VHRMRnp0WnVRZTNCNmRxdFU5TDNDOTJkTGVSYVBjV2NWeEg5dFFEYXVYZ0JPZVR6ZyttT3RXbTBiUjVMTjFrTS93QnFadjNic3UxU280K1VFRUZqMXh4MTRyQml1SlpYWXFaNDJJeVhqK1Ryamc0Njg5elRYV2VhNFdScDVONk51Q2JqeVI3blBQNDRySnA5N0RhME4rWFFMRGJHTFc4YkRKOHdkUVNEM09jakhQYjhhYVBDY3R1M25YRTdNaWdtUUVMbGVDTWdFODhZL0hIQnJHdnRVdlo1RUZ3d2xhUTdneUJRQ1BVNDY4L3JVUXVYaVg1UUNjNXhJL09EMkJ4Z2pqcFVxRlNQVzQraFpnMGttNEZzSlJoMmJHOWNIQUc0SGtjWngzNHh6VUt5SzR1WlNiYTJUYXFva3RzcksyQ1BtQ3Nwd2VtVHhWZDQyZTRrWkozQ2dmTUZZZ0hQdjlLbkU1REIyazNqWVVMbGhnZmllVHlQMHJaTm9Ha1R4WHQwdStleG04bmFWNEtvQ01qYWRwSDhQVThkQjlLcVg5M2YzRGVkYzZxb1lzTnBnbStac0FrRTdmUWdEdlNSdE0wNGlpWmdZeHREb29WdHVCNmY1NHFUN1JKUFBGRmVMQXhBSUR5cHN5TWNub0RucHlhYWxiWkV1TjNxVm81ZFZXWm1qMVc5YmJtUWlTY2t0aitmYzA3VE5SYUZuZVEzSVZnUVNzM1ZzZ25jUFE0R2FsYTBNaStleXF1VTd6ZHZvVG5QNFV5T3hobHNqSUo0WEtrb0k4Rld6Nm5JNmMvcFZOcHF3dVZJc1dOMVkyZHo1bHpieGhYd1hkRllzQWY3dVRqdldnL2lQVElycVNWNHA1WW8xSVFESHpjWTVVOGY0Vmp1Z2oyeGpaTUF1eDRnV0RBZ2V2T0JVRThEU1Nvc2R2QXFxaWtSN2p1OWN0azlUa2RQYXMvWlFjdWFWeXVaN0k2S2J4aFkrWkhjV3VtdUMzQlhjcFZpZmZCSTQ5OGNuaW4yMnUzK3VUeTI5enJsdnBFZWNSSHllQ3VjaFM2L1FkZ0s1bUtMN1hJcEVDcUFRR0NNQXFqcG5BSlA1MUhjd21PRldnajZaMzhZeWUyT3hyUlFnbXRETnh1ZERySGcrUFY0RERlZU03SmdoSmc4eVJ6R3VmUUFZQlBwaXNPMStITU5wSXNoOFY2UjVpbmNJMkVtQ1I2WUhJcXJiMzBsdnRhU01QSGtncElEZytvcnBOS3ZQRDkvKzd1SGlzRzZiWmc3eEg4UWNqOUJYWEdxNHg1ZWh4em9YZk16QTFId1pESzl6ZWYyM3A5eEt6RmpBSGxEa0VkaXk0ejlUV05CRERhTExHMGNpcHVKalFqT1QzL2xYcHI2WjRlZHNEVjlHTGRsTnlXWDhHenVINGlxMG1rNkhKOHJhaG83a1pJRFhXY2U2c0QvQURwT3JwWUl3UzFSNW5KTlpxQ3lSZ0RHM2JKR0cvWHQrRlNQRnBjbHZHTXEwakoxV1BiZy9RZGE2U2JRTk91SmkxdnFsb3lQeTZ6dmdLYzQvd0RyOGZoV0ROcFAyQzVjVE5GS1FvQ3RDUTZBZGVEbkJweG5GN05sdUV1dGoxcC9oN0sxcThzY25uYld4c1VGQ3d4bkl3VG4weFJwdncvanR0UUNhbXM3ck1Oc0xSdDVSRGM1SnoxN0VjZHZTcE5VOGNXNXVEdGE3aVlnbDJMaEc2ZEJzQXg2NU9ldnRVZWcvRU8wdVlETHFrY1VWeENpQVNzb09UeURqSExIa2RCMk5jVVhLMmhyTDJpanIvd1RTWDRlMnYybVcxMUs0dWpBcWJsazh0Y01jOS9jZjBxQnZBTnBiWHR3bHBmSlBJZ3pzSkc0ZXB4Mnh4NlZQWmVNclhVTGx4ZlRDM0NNQkcwNzRMb0R4OHlyd2NEbm52VnUxOFErSExPd3VuamFTSm1jeUg1QWZNeUI4dTdibkJQUDQxbTkzQnV5L3I1RVhxcDNlNVZoOEdhTkVKWlpZemNMTERzRFNBUmVXeFBIUE9EeGpuc1RUb1BCZHBaM2xyQmRXMFpoRTI4YkFaR1pCbmhzREFIMHgrRlUzOFk2Y0lVZ2l0WjFDZ3lNNzR3Sk1jN1NUejZESUdQcFQ3N3gyeVFCclZabUpDbFk1QXFnREJ5U3dQOEFMOHF6dkw0ZDdmMTh5N1ZlblV1TjhOclA3Vk5LczdLbWR5UmdBWUJ6MFBwLytxaTU4QmFXYldJNFpicUtOV2NMS0NXNlpPTUhIdjBGWWRyNDYxSlBQVjRZSm01TWFUSWNJQ1NlbTduay9YdFY2MDhWMmNER2IreVlQdE03RnBEQmNjWnh4Mjc4a1p6NlZjRTFMVi9qL3dBQWwrMjZ2WXYvQVBDS2FHUExhS0dWcDFiWTBCa1o4dHo4cEk3WkhmQTY1cW1QQmtMcERQZFc0aWpUT0pyY2hVQkIrNlYvcjNxTnZGTnJiSXNiUjNNOGhPVzNmS3pIb0FRRGpuZ1o3VlMwM3h4ZkJacmNXeGlka0w3RVg1WXhqaG1Wc25ra2ZnQjNOSlJjbTM1Ri92RnN6VlBoVzZzbmxhS01QYnN5bU5JMjRJNTU0NVZ1Y1k2R3J5ZUZMYVdkQTl1aU9FRWlvMGJJT0NPcDNjOG5ucDJyS2Z4aHF5aTZ1SnJPM0ZzQXhVdEtRUndDRHRQQkdmVG5GVTVQR21yM2tJdlZoRVYxQ0ZSa1VsaGtqZzdEejc1eGo1aFZRVjI1ZW13djN6VmpwOVYwKzZCamlOckVBMGkvNk9vWVJvM1FNTURHUHArSU5aTS9oYTdhSkN1b1czbUNRTHRhRG9PN1pQT2UzNGR1YW9yNHY4UVA1czBpeFROUGp5OTBUQlVVREJLN2lPZStlYzFsVGFuNG5udTN2Ylc5UmtDNGtReTdsQXowMk14NEhIYW5LbkcrOS9VZE5WRXJiRy9ZK0VZNTViajdickRod0FXVmJiSWpZRGo2am52NlZNdmhtOWRiS3gzMnQ3WUJ5L21GQUdPRDBCSElBOVA4S3docFd1UlBJdHpxY05uSHR4TXJNMG9ZS0QxQit2ZjF6VFlkTzFZelBGSnFpbXcyS0VtV0E0YzVPTUVZNTU3Wnp6V0w5NVdVdHZ2TlBlVHZlL3lPaWo4QVF5T3hTUXh4elRPV1c0VkpWVlJuQlVnNUdlTy9UcUttVHdqYTdESGN5SXNxU0lDMXRibEl5R3dNWnlSeDh3ejdETlpXbTI5NWFhUzZhWnI4a2s2T3loZHJwRUY3QVpCK2JtbWFlYnY3ZE0yc2FuTThtOGI0TE9NdVhBWG5jRkdQNHNIako5ZWExVW9xS2l6TGxxdHQzL0E2Wi9BMm1mWVlvb296Tkx5UkpEQ3E3eDE1UElQNTgxejdlRU5NdUx1OWpsdUx5MDhrNURPRndUa1o0SDNRTTQ2MHJXdW8zTjJmN1AxVmtFcktuMk82TzE0UVNRRUJCUFRiMDRJenpqUE5LVzB2cnZUTlN0N2k0dWplSFp0ZVIySUcwOUZHTUVjakpPYXFwS04wOXZteDA0ejF2Sy8vQUE1Y2s4QVc2WERSUjZ2SkdWUlhBamszTWR4SURINWh1QXlSamdjbjFxK3ZoalRkTjA5QUwySzRLcWN5U3VGVXRuZ3Ixd2NrY0Uxa1M2RGMyTm5DbzFKNVdtd3U1b0diZWVuR0d4anBnZ2UxUTZWcGxyckV2bFN5ekVSeEdSdnRDdEZFVk9BcHdRRDdqNXNjVm5KM1dtcS9yMEtYTzFkeTBOaTM4TzZmYTNHelVMeUJwSmdyR0tKaGs5T0dCeG5QWG50U1JlRk5KdWJ1Q05JYlJTaTdFajgzWUpzY2o1Umpubm5pczJ5MGVHL3VYa3RtdTJSUnNab0pSSUEzY2dNd0lCNTllMUpiZUcvS1pyczMwaVIrYjVUeWJBcW5CenVMQW5uSE9PM1BYRkhMZGVYa3dhYWVzdGZRMExqdzFidmRKQkxEYndPNFZWVzRsMmVhRk9lT09veVB5L0duemVGdFBpZUpDU29sa3c2b01rRHB1UnVlYzQ0NzU2Q25wcFZ2cU56SHFWcmUvYWJtMWxMRUdaU3dJNkxub0Q5ZmJQY21TKzAvVUwrQ1B6ZFFubGFMWlA1SnVRZzJBSE9NQUhkejdmeXJuVmw3dDNmK3ZRZk8yOTdkeWplZkR1MmpzUDNFdHdibFpPZk5USjJZNUl4ajY0OThkYXJhWjRNaDFLVzNNbjJwWW1VdThrc2UwQWV1U1BsUHNmYXI4MGx6TEhITlpYVi9ia2ZLek5kbVFsampKQ3RnSDhlMktiYnk2bEhlVzEwWnIvQ3NJNUZOd1dMRUFnbmFTUnh4N2RLM1U0dTE1UDhBQVNWUlJlMXlCUGgwc2wxSzFyZHdTUVoybzZObG5YM3gzL0tvYjd3TE90dEhEcDEra3R4NXVIaWszRmxRc2NNUnpnQWpIUWU5ZWdhZllwWlNZaGdrZDlnOHlWZ0J1WUhsanpqSnlmOEFHdVZ1Ylc5MCsvdXRSc2IrNmkzeWwyalFCd0VKSklZRW5KNUI0NmMwM1VpbkdVbjdyMk1ZVlp5YlNleGdOOFB0VGt0eGNXdC9heUt4OHlhTXVUbkdjNUg1Ky9GTC93QUlUY05ZR0tDNWlhOHlSNW1jQmhnSEFQYmc5RGlvTHF5MXRwbHUwdkpsQ2ZJanh5dW56WUF6c1BSbXovT3NlYTN2NEhiZmQzNG5Lano0d2o0QUhUZG5nNFB1UjA1cWxKU1ZrOWpkeG51VzUvQkdxNmZQQ0xtV0MwUmxQNytWaUFDQ2ZxRFdmY2VIdFJpMDVIdVZndGtNbXhMbzNVU0s3RDFCYnVBZjByRTFPNXZwTDhtV1dVNVZTVVZ5cW5qQUlYb1B3ckVtZVdkVDVrcnNxNUlZblBYL0FDSzZJVTVPVitiUVVwTkx6TGR4cU5vOS9MRTF4RE5GRmdtUVNFS1JrQWhjOHNlZjByTGl1SHU5YmF6czVGZU41V1dCMytUY09kdWZjanQ3MVhtMDJja08wUkNudmpyVlo5Tm4zQStXd0JQQnJ2aENtbG96aXFUcXQ3RjYwa20xRnBJN2FOM2NSczVBQk9BQnowcDlxejZnNWpnVml5amVlT2dCNXFLMUdvNlBkTjlndVpJWGxpS095TnRCVWpsVDdlMWRMOFBJMjB6eEt0ek1YUXJDd1JrVldDc2VtNEhxUHB6Uk54U2JURkRuYnMxNmxVYUhmdjVaOGhodVlGZDNHNGRNajJvZlRMcTBjR1NKeGprYlZMYnUzYXZhTEc5MU82aVZMaXp0WmhHb1Rha0lsQXl3eXg1K1lrSFBIK05SNnBFckswdW4zZW10QUczdkJPU09uWURHUmp0OVRtdk1saTVLVnJIWW94dll6WmZDTndyU1c5ekZDOHVOcXJKeXVRU0FSeUNBUmo5ZTFWN240ZjNkaHBpdmJXdHRIY094TE1rdVdYSFFyempIVDg2M2RjOFFQL2FIMiszUm1KVU1zaE9WVVl4aGVNRUhuLzYvYUc0OGZYMGxpa0tXZHB1ZU1ieWpFSDV1VGpnNE9NOEhOUlRxSmMxM3AwQnFxK1ZwTHpNdTA4R1RhZ2p5a3htVUtvUDc5UVh3T2NESFU3U2VwNjFDbmhMVWpZUXRERkVHZVhadUVnR0R6NjV6anVCajh1a3RwNGgxTzJpanZJYnZUb2dIRWNtMkVBcXBJQktqSUJQQS9wUnFHcmFwYythaTMwTThNaEJXRzNpN2c1QkJPVG42SHRRblpLK3BwNzNOYm9XMDhJelNYY0NKckNTRGdYTWdqQVpaQjJ4ako0d0I2OFVnK0hqM0V6elNpUm81VU9KWlpNQmZYZ2RQeHJJMC9VRFkyenB0bXR0VWR0MXdiZytidWhZRW9WeURnNEk3ZzlmWVZyalYya2VXSFVFdkxsbFpRM2x5RTRqejk1bEhQVEhhb2xMbGxhMzZBMU54dW4rQm9hZDRMdHRPdVdtdWJxSVEyN0ZuU0pzcGdkTWdrbjd2L3dDdXRIVVBEZmgyL3dCUHVOUnRwTisxWFpFWm5JRFkvaEE1QStnTmNSZVhDUnpQQnBpM0VGa2QwdTkyUG1TSGFlQTJBVC93TDA3MWJGdGR3Skc4VXR5c2hVRzNEaU44S1A3b3dCM0o1eWZsenpVd2xHTW01U3VudDAvRW1WT283U2NyRm01MHkwbHRQT2svMWpQc1JvY0szci9FUVRnWjZmb2VhdTZmcDF2cDdRV2tPbXdQTUpTWkc4c0ZrWEtnRXVUMXgxSEo2Q2t0RXZXdDN0cEpaWlp2T0pra3dCdVljRENqOGVSeitkWjhGd2JlWjVSZlhXVVlMdWxDcjVZNUlMRXI4eEtnbnBuZ1VRYWxHeWY0c3VWMmJWNVorSHJjWFpuaHRiaU41TjIxb2dRUXg1SE9DTVo0d1QwSHRVME9uYVZOSGJpeE1GaXN5YjFaUUNvT09Sa25xTURnamozcm5KTFc2L3MrZTdDeE9DdTVwTE9JTnNHY3NDKzBnTVEzVHR3YzBhWkZwbXFqN1dMVjRaSkdHK0o5eXR6OTRwMmJBSEJiK1lORTZjclhaQ1habTNjMittVzM3dVI0cm1WSThOTWtPNWtJNU9PZWM0STQ3ZWxRV2R4Wm9sd3pScEVzc0xLRldRS1NuWm1VRU1DT2Y4aXM2empTSGZjU1d6dXNaS0lESmdLTnA0UFVrbGp3UU9PcFBZMzV2Qk9uYWtpYW9HaFc4QVhIbUJXM1k0WlNXMjRJT2VRUGYyclAyWE03cVJjcGNpdE1oMC9XN2FPT1dDVkdlM2ljdk9yVGtnUmdIcDVtU3crVUhBUFROYWkzVmpxRnZpQjQzU0ViWWJtTmlBQ0R4eGorSmUrTWNtc1I5QnN0SHQvT1VlVVdmS3M3bDhqR0NjZ2NkK3RVTHF3amNpNWlubWEzWTVoZ1lqR0FOMzN1QU1jZ2pnajlhY1pSYmFYVHFOeFV2ZVJ2eGFoYVFSMmtTUVF4S3VGbUtSa041dWVyWTZuNWNEODYwbXY0VmFhSTJubjIwdUE5eHNLaGo3WjZZeDFQMXJCZDRiRWxiWVEzTDNDbVJITElTaURrcTN6YzRIMU5aOG1uMmkzN3phaGZ4aFN6TnRCS1pSK0ZJN2pKOXUyT2FGRzh1YnIzRGxUVjJiYWFoWU5QR2oydG5HTnpaY0VLY1pJR0RqQlBvZXZVODFmc3RUczVJNTVyV0oySzlHS1p5RnlTRkp5VzVBNDkrQjNyaTMwaTBpQVM4dVZ2R2hKTWtTeE52eDJ3TTQvSFA2OFZjL3NpMHVZZk10UHN5eWJWT1o1R1ZvemcvS1NwK2JnSHNQNFIzcW8wNHIxRk9LYTMwT2tuMS9UWmRKRWx6SGJmYTVBWXdpdXNKSVBPZHFNU01mWHJqbnBVaWE3UG8ya0dIemJDOVMzVVJpTjJJSngvQ0RqbmpPTStuZXNqVEZ0SmZQc05XMC83Uk02QWJvSFllVmxlTnBLOWM0SFhqSDFyUG0wN1M0Ymd1c2tsdk15TUFyUXh6c1dCNWJIeWhlQ2VQYk9PYTFsSlMwdnIyTWxUanFudC9XeHVSNitMcTJoM3BwdHJHSkFCRDVoVVI4OEVMM3dPL3RVSzZ6cDY2aEg5azF3K1h5aXd1cGpqWG8yUXJjSHFlUldKYTIybU1JcGRXdDdoSHlTMER4ZVhraklCK1hybkI3ZmxWcTZrOEszT3JNbmxMNVRKdldOQVFPNEs1VWJsN0hwaXM0ZTdMci9rVktLMld4djJmaXp3Nm91TFh5ZkxWbkxtYU1pSUZqenlSOU9TYzFEYzY5Qkk4WUpUSVlzZ2tVL0twNjl1djB4WExYbDc0VnRyWm80ZE9YeWQrR1NZa25JRzBNT2hiT2Z1NTdaOUJWYVB4R05QUzlPbndRalRtS2dXb1FrcmhSbGxMWjJqUEF4MDQ5NjFuUlZYWHQ1Q2pHTVhkTDd6cXBQN00xWFRqZVc4TWtjc2JoTis4aU1rWUJ5ck1EZ2ppbUhXTE8ydm5oa1hhVytUekk3bFlpMmZtNUM4ZmovalhNaS8wSnJFUjR1cExsNFViYXN3S0lTQ05yRHVPRGtqOFBTa2d1TkdoaDhwN2FRM282YkhPeHllT01jLy9yckZVYk81cmU2dHVqcUlmRXNGNXAwc0x4Ukt6VGVYSThSR1RqREhJems0ejE5aldoYWFqb3N0bVkyZG9wR0NtUGZLd0V5NU9OckZ2d09NbXZON1BXcmlDK2xTNHRJNDdjY1J0ai9WWndDRDNQSDQ4OTY2SzQ4VlJ5YWpjdmNXR2xNMHR1c0VzaU16aVFnNURjRUgwNXhucDZWY2NPa3RYK3BNbzlJbzZ2VkhGcTBZMnY4QVp5dUVrTWpTTG5IUFBCQjQvSEhIV20zc1NXdWx3Q1Nkazh4a1FTZWI1YmJtSHpISU9DdnI3ZHE0V1hXOUt1ZGFkbnM0NFlZZ0ZZUU9BemowR1R5Q2V2WEZOdjd1eWpndGpEcFYzRlo3cy9hcHR6cStld1h0a2pzYWwwWXVkN2FpVVdvcE5uYUo0ZHRwN2I3RkhFNVFxUjVrbjcxWElHQVZma0RIVEh2MXFySjRLMCtQN1JKQmJ6MnlxbnpKS0UyaGNZWXEyQWNjZFFjWUo2MXg4V3JXdGs4RXpoWkl5b09GRHhzRzZIZ042ZWxPdS9FRm5LSWtoMUs1ZU5JMlVaakpiWXh5VTVicDc4MDFDY1c3TjJDMHI3blMvWU5OTnRMcFV0ajVnalpESVZSTjc1eUNmbTZBRFllT1R6MHF5ZkNtbmhBMXRiUTNOdkVSNXBReGtxZWVyWkpBT1J4ZzF4RXQ3YVJ5Q1NSbU1lNVdKbTV5QjBBL1AwRlcxdnRJdU5QbS9zKzR1RWtqT1NTUExMWnhnWkJQY0RxY1p6akZXMCtXNVhLKys1M01IaC9UN2l3WnJDeGwzc0ZiYk93Wk5vN1lYZDB6MnhVRmo0VVo1aE8wdGxIRktTMFRSeHg3bzJCNEJ3Q1N2VWRlT3BGWXVuZUtMNjdzSFVUM1VMaFYrYk84dGc0NE9SdDdjRHIrTlVkTWVYU2tqbWt2NW9KWjIvalVoRkdlNTYvalV1L3pFb3lTYXY4QXFkZEtHc1VqaHQvdHNiN2VzcUlFYm5xQ0FEbi9BQUhGVTdlNG1TK1Q1cFdXUDk0WVRnb2M0endOd3p6ejZZNHBMdldyL3dDd1g4RnhxaGRuR0VWUExkby9xR0hJUEZjdDUrcDZXRWtlejFUY0NUTGN5SVZ5eEF4aHNkUDVWbTF6U3ZEVXFuRFMwdHl1ZkV0L2JXNzJGbTgwcXV1Tjg0RHNPTVp6am10U0xUdFRnMHU2dTdwWW9kaFZVRVVSZlBYNXR5SDd1ZU9ldmIzMExDVlJhaVN6MXlWWHVKbURPMXVpaDBHU1FGVGxldU92T09tTVZPbGhySW5XOHRkVW1LVEVFb3FBYnNES0VFOGRlT2xhUmxGcTYrWU50YWJGT08wdWZ0T1JMSmRvVktKQmEyekVJd3hrY2pnZHlPdlFWV3U3SytFOFZuQWJ1MFRjOGdJaVp5allERUt1VGo2Ly9YRmJWdmJYK20zVWJ5b0pMUzRoZVNXYVNUbUtRcnpqSjVKS2c4ajF4V0w0ZzFxdzFlNmdEWFBtSmtpZVpJeVpsQU9Dc1pIQlVrNXh6eGpwM1VHMi93Q3Z5N2pTdTdMVkZYVDdQVkxPRzRqTURTRWxZYmtsbUFZSGhjZ2RTT01kcTNOUzBQVWovcEQySmo4dFN6TkxnL0xqYVVMcjE1Sk9PZW9IRldoNHI4UFdFQzJkcG9wU0pkc3NlQTZaZk9ReFA4UTc1NlpyUDA2L3VibEdSTk1XNnNUT1JJWjNiNU4zTERJWmVlTTVOWEpSYnZmOFA4eVl5azlXcmYxNm1NSXIyeXU3aExodkpDNDNSU2t5SW9HVGdna0RvRDAvRG1wN2lLQ2U2ZTR1TmRNS0w4a2FGbmVOY2c4aVFaUEdRTWRSNm5GV1ArRWprbWpoanQ5SWllS0J5alN6c1pHVnVjWXo5MWNBWkE0SGM4ODZPcStJWWJKWXJWZE9zcmlZcWh0NUxVL0xIMUpEcU9tRGpIdDN6U1VYZlJJdWN0ZFZxVTdXOXRyYVNON0hWYlpvMmNBc0VjdW9LNGJibkhQR0F3OVQ2Q3RKdFgwR0M1dVZodklaWnZLWmtuYUV0dGJEZHNFNUdNNXgzclBqOFJhTGN1c2R6cGtkbzJHU2VPS0VONXA2bGdUamFjK241OFUzL2hJNURjTmVyRGRtN1ErWENZMlFGamtnYmdCd01ja2RzOTZLbEpMMDhqT3psdnVRemVLTHFUVHBYZUtmY0Y2V2tPd3NjWUIzQWpISHBUTGZ4RnJkNXA5dmFXME13bWtPMUZkQjVnQXl4RzQ0NVAxNzhjbXAyOFQ2NmsyNFc5cTk4NExPWXJjRmlqRG8rT2hBQUhQUVZlc3RFOFNQSlozRjYxcUZsaEd4Q0dKWXI5MXlBU04zT1QwQnp6bXRFb3hUbDJFN2JTU1FhcDRmMVM5MGkya1RUWmtkUVhmeUpCRzhlTnl2dUI0SkJHUmoxNjg4NVJtMWEwdjduVGt0THRGYU5tVkdKS2pHQ1gzZEFlQjBQdFhVMittZUlEZmkwUzQyMmlSeHUwVXFnYlN5NGJhUWVlZXVQUWZpbzhPM00xbzBFV3FNRk13aUs3Q3hiZDEzSDA0UGFzUGFRbksxUGIxQ00wbDc3TTI2c05ha2lndGJwNDNzcmtveHVJcEVTVlZKNXdWSFVsc1pJeHoxNzF6MXBvYzgyc3d3M2JYYVFDVFo4MXV4VWVyYmh3QU1EOENEeFhweitGYnFPZU9TSFc0YlZZd0l3VmhVdEl2WU0zVW5QVHJXSzl0QkhNMGMrczNSMUdGeXF0R2NSak9XTEVFQWNrazhkTzFhMTE3S1B2YWZkY3lwVkZLNmpyOTVpWEhuV09wS0xIVXJJaU1Mc2R5VDBiUFh0d01kczVBRlFDOXVJcGNKSlpMTzZiNUpmSVdOMlFLcnFTeDRUZ2c4RWV1QWEwWVBCdG5kWE0xeFoya09wV2J1WW5kWkNzb2ZiOHpuY2NmUWdIK3ROajhHYVk5eVk1VXVKWVZmekZtVDVXQ2JmdWtmeEg2ZjNUOURNWThzVkdWN3Y4ZFB1Tm5PRy9ZNWE3MGpYemN5emFsZExDNGpDZ3lTcW9LZGw0NDcrM1d0QmJDTFJuRzdWdDdPaWh6WnVDR0djZ25uT2VPbnRYUXI0TTBCR21uZWVXM0NGVThxUmxtZVJBUjkzcmc1K3Z2U1hscm9hd1JhaExvY01Wa0dTM1V5c1ZQUTRMN1J4emdaSkk1N1VUWE0wK2ExeHhxWFZ0LzY4ekRoMUJKOVZhT3oxeG9KcEF4WHptMmtzU01mTUQwR0QyNkhwVlBWTkJuc0lZRTFLNGlrdHR4VmdvZVFKd1RsY0REWit2ZXZRckh3WjRma01zazFqNWN0d0Y4dFpFRzZMZ2NZUFEvNTcxVGgwN1M0dDhkNXBjelNJQUdtMnJKeWVpN1Z6Z2RTT081cS9aOHI1a1pxdkZ5ZGp6cTFzOUhqMUpvN3ZWSFMzaGx3d1dGMWRoakJ4aFQwNTY5L3JWbHAvRFZoZitlazF4ZHhibFZUTkd5bGNuazRCR1JqK1h2WFh3K0h0SXZMNjZOdnAwazl6RXdtVjFLcUNwN2JDZm13ZlVML0FDckl2ZkNkdnFHcU5wVTloUHBvWlRORkkwcWplZXlyMjk4SG9UMXJWcFNYSzcvMTVqVWxkdFA4aXhiM1BoUFRkTnU0N2llMTFTNjg3T1JBRlVCemdoVDF3QVR3YTVTZlRkRnVMZUo3VVgxdjVrdTBnT3N3VmVDQ0c0d2M4RU5uMjlhNjdSL0ROc0libTVlYTh5cFNKSTVJa1JwRzdrWkdEeGdna0R2eFVMZUZMU0RVMWdXSytudEdrS1R5VFBzRWJyem5lRllGV0dSMnhqM29kUzJsN0V4U3U3dHN6VzhHNnhiYUVOU25DdW03eWtnbUkzZ0hPR0hwbjB5UDhhcWVBdGNuRVV6MkMycUU1ODRPQU1mZ2Z4NEdUWFoybDM0aGt0cG9idXhobmhqd3NjU0JuTERnRmlWemdnTUFSalBQUWMxZnVkTjBueERhV3BFdDNickJHYzJtMHJ0VUFqSFRqbkdEeCt0WnhsVWlyeVd0dS84QW1KeWFldmYxT0NrK0dtdUM1OGxaYlM0aWVNU3RKSGNjanR0R2NaejY4Q3VYbjA5OU11NTdhOCswV2p3aGdRMFkzWndjSFBUcmdaK3RlNjZMYzJtbGFiTmFXVnpKY3BGSWRodldKeG5KeG5IMS9INjF6OXo0V1hWZFIrMlhjQ3BidExKdkZ1dVFGWCtNNTRCSnlQVHVNMWZ0MHJYNmt3azd2bTBSNWJZMmNwQ1NHQjFSUnYzM0RmTHNQSUk2VjBrZXZhclk2SDlnTUZ0YzJ1NEtGZlBHZVFVQi9FOThmbFhhWEhoK0N6dGZ0VVduWEV6V21ZeCs4WGZqamFBRk9NY24vSndOcVhRZkRzUGxUeFJlWXpTL1A1aExaeVIxQkl3S2lTNTVQbXRwM2Y1R2pyUVNXbC9ROHJ1SU5YbnRHbG1zWmpaSStVeEVDc1RGZWdZOGpQWEhJQjYxemNtanh4aHdiYWFaK1Frbm1oU0Q3Z0E1cjZNc1kxc0E5dFpTQ2NMS3hFZWNCRkpKeHp3ZWMvNUZZa2dWNVpyMktHSzJubmwrN0lFa0tFY0FzRHdNNEhRK2xGV3JHaEZQOEVad3FLYmFhUEZMUzF1NEpGRTlpSllmdU1rc3UwTVR3Qm4xcXpaYUJmU1JTenRFRWFJOHdHUUVzbUNjajE2WTl1SzlYRjdienphV0JiR0NPVFAydVZXeDVaVmg5NXNFSExad001clN1UmRUU1RRUnkrWGE1Ylk4bHY4QUlBV0FDakl6dU9Ud2YxcVpWYWpoZW5GUDVtam5acTU0c0xwOUUyL1o5MXVGR1RKSWhQbDVQSUtuZy9TcTg5b2wzZlJzYnRZNDVCNW1WNFhCNzQ1d09meXIwVys4RnpQTExlYVpyb0xSdUJKYnlRbjVnYzRCR2NrNXllbklyVnZkQTBDMTBMZko5bmVlS0VDU1F4cERKdUFLbkpDOERudjJyU000cU4yN01KVGkycmZrZVhqVDU3Wi8zVWxyY2tjUjdCdUVnUFE1d0NEVDExUlhpRU1RZEFwL2VSaVFuY1IxT1B3cnNMcnd2cWtEdzNXbmFhQkJCbG5XU1pXbEI2amdERERIVWMvMEdoYitDOUsxUndaTHo3SmVzbm1JcUhHTzJIWE9TQjY4VkRhdjcraFVxa1VyM3VjOUpHNDFxMDB2K3c1TGN0Q1doVjMyeVNrWkJiS2s4ZERnNDZBVjJWaG8razMyblROTGIzODh0bVZNMXNXWlNIUE9BdWNmalZPMC9mUzNNMHZ6eXJPd0R0eXdBY1lHYTdYdzR6U0tHZGl4YTJqeVdPYzh2V2VFbXExUlJ0WkdXSms0UXVlYzNGbTAxeVhqOEtXTU5xSVNiZHBaR0FBemxpeHdRV3lCMDlUNjFCWVhnc3BwTGVTMXQ1MmpMbVB5ZmxLSzZnTXFuSFA0anRXanFrOG9nc0NKWEJhOW1Cd3g1SG5OeFhReW9zVTdQR29SdDVHNVJnNCtUL0NyeE1wSjN2c2F4YVVkVVpPaDZRLzJpRHpiZVZiWkxielMxNG9La2s0S2hnZUIzR1JUNTlPaW11NFdzYldXQWdBWGNkc2RrYmt0eWVQbFlnSE5keFBid3RkekV3eGsrV295VkhUSnJsdGRKaHU0dktPemRkbFR0NHlOZzQrbExFZnVxZDRtRUtycVR1ek0xQzMwbUNhYUZZTlNXU1NaVk04OEFLRVkyN2dTUm5QVFBYOUt1M21qalQ3R1UybHBiWVdVK2JjbU9QeTl2bzJPY0RqR1IrZFZMdU9OdkRzVWhSUzhaWFl4SEs1Zm5CN1ZaWUJ0T21WZ0NwbnlRZW1Rb3hYTkNvbTBtdDAzOXhzNHRKYTlTTmRVdExEVFRCTnAwMEVMR1NTSmhGdU80SGtqMTVQc01lb3JHRXVuUmhtaXU3d1RTU0t6T0hTWlZ5RytZRUtOb0pZa2tIUE9CakF3Uk96dzNhdXhaVVB5Z25JWDZlbGNQcmQxY2JicTMrMFMrUjVyRHk5NTI0Q25ISFRpcWhWbGZrajErZTVwR25HMXowTCsxSTVMQ1ZSY3U5M0lodDh4RlZtZFNUeUNNN3V2WEl4elZ1MzFGcnE2dExYYU13cTBua1R3K1ZnQWpCRGJ1RG5JNUhPUFN2S2ROa2traUJkMlk3Z09UbXVsWkZpMDZLV05Ra2psOXpLTUZzSGpKNzlUK2RhTnRRYWVxUTVVWTgyblU2MkhWWnJEVmRRSWluU01GZGswakVyMEdBVGc4YmllMzU5YXpiZnh2Szk1UGNYQzI3bUFNR1JaV0hsODQ1R3prY1Z6Ynp5cGFLcXl1cXZBZHdERUE4QTgxemFTeUdCc3lNZVNPVDI0cWFWQ201T2FWbVM0Syt1dlE5Y2o4WjI5emRReTJGaWt4amoza3lxUTZxZmxJVnZxZnl6WFAzT296YWhCZVhWbkZid1NDT1JVaGVVZWFTZHFrbGljQXFlUngzTmM5cDZxWWxKVUU1OVBZMWN2NG80dEN0REdpb1RBNUpVWTY0L3hOWHBLWHZMWXFORlFmdXN2VGVMWllMbTFzMG10VVVKR3NpUktXQUlQSkdlY2RENjV6VWNQaU9lRzkzWGZuWFVNcENNQk13MkRrRGpHVGpQcitWYzNwcnREWnp0RXhSaTBlU3B3ZWpVeHlUQkU1SkxHWTVZOWZ1azFmc284OWh3dHl2UTZ1UHhMYzNFMW5IWlh0cEZMRkM2RVR4a1lZL01GWit1TS9VZlNsUGpuV0gxSklIS3Y1eU5GTERZMjRFdWVUdXdjOGdkQnU1Mjg0cms5VWpTTUxzUlZ6SEhuQXhuZzEyL3c5Z2hmVUppMFNNVmdWMUpVSERZWGtlL3ZXNmpab2lwR1BLNVdEUWxsdTQ3MTVaQkdZbVZsbVVnaE1aeHZIVlFjSGtaQUlBN1ZkYlZOUXQ5TnRaclNTRUMzejVjcHR4SmxTeEdCbmtOd1FNWXpuODZFaUtWZU1xQ2kzVXloU09BTXJ4aW81clczajhIMjl5a0VTM0FaZ0pRZ0RBWlhqUFdsYTJzZERPVWJ0dGlhbjRwMUpOU2hmVTRXaG5RcExHMWtDRTVYcHllUnlNZ2dkTzNlTFZQRXN1cHhJa0Y1RUVRc3F0TkdWWlNNWlpTTy9JL0ExV01zaE9vL3ZHNHVaQ09laHlhMk5LdDRaTlZmZkRHMytqQThxRHpoS3psSzd1eTR3VWJXS1VUNmhORERKRUZXVjNhMzJ4TTJRR3lHSjNkT08vVHB4MHFwQnJjbDNhZjJjVjMyeS9LOGZscUJzem5KSnhudDM3VjAyanpTblJ2RUg3eC9ramwyZk1mbCtVOVBTdWQxdXl0SXJiUzJqdG9VYVNQTGxZd0N4eU92clNVVktQTWFSYWxOd3RzYU50ckNXV21TV3NjVXI2VExjRmxsaWxDc29HMHNWSGJBSHIzRlVZUEVrbHBxOW9EZkZiYkoydGJUa0tZOTJNc21jQTRBengrZFlsOUdpQ1RZaXJqeXh3TWNZckJzNVpHYVZHZGlxc0NvSjRCNTZVMHVaYWlsQlFmZTU3Syt1dGF6WGI2VmY2ZlBLU1JoeVVaaUR0Q2taK1lrNXdSZ0gxR0txYWQ0c2t2TFpyUFVMcFlyaTRrZFdMYm80aWNqNWNjN2NaNTlhNERKT2l5Z25JZkc3UDhBRis5bDYva0s2T3loaWowZTBuU05GbSsyeC92RlVCdnZyMzYwVkthVWJSZGtZUWhGM2JXcGQxUFVVdGJHMG10TFJKclR6dHkzRVZ3K0kzM1pLcWNqS2taeXZUSUhwaWxrOFJXcytreld3V1ZybVYyWUZwV1VEa0hBM0UrM1E5NmcxSTVndDRqL0FLcnpKVHM3Y00yT0s0dTYrYXprVnVRcXliUWUzSTZmbWFqMmZQYTdObEdMamRyVzUzTnA0bmxiU0xTS1g3VXR0KzhFazl0T2NzbVR5aEkyZ2c4WTl2eEhNNnZxY054ZC9JcmdLcDhuejVneklwNU9XeVMyZmVxM2hGRm0xU0dPUlE2ZVl2eXNNajdwN1ZZMWUzZ1hVOVZWWVl3cUI5b0NqQzRBeGowcFArSnlQb0NoeSsvRWZiK0pkWUVrVWlHSXhHSFpIRzRCUTUvSHJnZTNTbHZmRU9vVzBqK1RkQU5JdXk4aWtadGo0UFZSMEIrbzYxbjNhSkExcUlWV01HMlJqc0dNbkxjOGQ2eXRRWmhxTVNoaUF5cVdHZXArYnJXMFlKUGxTc2tOUjJmYzBvOVF1NHRTQmdsYUdWeUdqMnl1d1EvUmpudDY5NjZWdFZ0aktnbjA4eVhVd1ZsbExuYkwxQkRqa2xUMHgycmtMZVIvN1NrYmUyN3kxWE9lY1pISDByMENCVm0wZk1xaVF4cDhoWVoyOFo0OU9hVldWbWtUeTZYTWYrMnJoOUlrRXRqQ3BpYmI5cUN0dVE1d2d5R3h0QjQ2WXh3YXFSK01KdHNKWndrakVBeUs1UmgwR0RqakdmVGptcU9qZ085MnpnTXpLeFlua2s3VDFwRlJQc3VOcTRHNGpqb2NHbE5SazdTVndpbnl2VS8vMlE9PVwiLCBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELy9nQStRMUpGUVZSUFVqb2daMlF0YW5CbFp5QjJNUzR3SUNoMWMybHVaeUJKU2tjZ1NsQkZSeUIyTmpJcExDQmtaV1poZFd4MElIRjFZV3hwZEhrSy85c0FRd0FJQmdZSEJnVUlCd2NIQ1FrSUNnd1VEUXdMQ3d3WkVoTVBGQjBhSHg0ZEdod2NJQ1F1SnlBaUxDTWNIQ2czS1N3d01UUTBOQjhuT1QwNE1qd3VNelF5LzlzQVF3RUpDUWtNQ3d3WURRMFlNaUVjSVRJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXkvOEFBRVFnQm1nRkFBd0VpQUFJUkFRTVJBZi9FQUI4QUFBRUZBUUVCQVFFQkFBQUFBQUFBQUFBQkFnTUVCUVlIQ0FrS0MvL0VBTFVRQUFJQkF3TUNCQU1GQlFRRUFBQUJmUUVDQXdBRUVRVVNJVEZCQmhOUllRY2ljUlF5Z1pHaENDTkNzY0VWVXRId0pETmljb0lKQ2hZWEdCa2FKU1luS0NrcU5EVTJOemc1T2tORVJVWkhTRWxLVTFSVlZsZFlXVnBqWkdWbVoyaHBhbk4wZFhaM2VIbDZnNFNGaG9lSWlZcVNrNVNWbHBlWW1acWlvNlNscHFlb3FhcXlzN1MxdHJlNHVickN3OFRGeHNmSXljclMwOVRWMXRmWTJkcmg0dVBrNWVibjZPbnE4Zkx6OVBYMjkvajUrdi9FQUI4QkFBTUJBUUVCQVFFQkFRRUFBQUFBQUFBQkFnTUVCUVlIQ0FrS0MvL0VBTFVSQUFJQkFnUUVBd1FIQlFRRUFBRUNkd0FCQWdNUkJBVWhNUVlTUVZFSFlYRVRJaktCQ0JSQ2thR3h3UWtqTTFMd0ZXSnkwUW9XSkRUaEpmRVhHQmthSmljb0tTbzFOamM0T1RwRFJFVkdSMGhKU2xOVVZWWlhXRmxhWTJSbFptZG9hV3B6ZEhWMmQzaDVlb0tEaElXR2g0aUppcEtUbEpXV2w1aVptcUtqcEtXbXA2aXBxckt6dExXMnQ3aTV1c0xEeE1YR3g4akp5dExUMU5YVzE5aloydUxqNU9YbTUranA2dkx6OVBYMjkvajUrdi9hQUF3REFRQUNFUU1SQUQ4QThWaEp4VXhrS2prVWlLQUtaSU1qclhIdXpuR0Z5N1ZZaVRJcXRFUG02VmZpd0tVM1lCUExPS2NCdEZUQTVwR1hqbXNlWVpWa2ZGVnlDOVNTcWMwc0tEUE5iTFJYQWpqdHZtemlyMGNLZ1U0S0FNMDFwQU85WnlrNURHU1d5dWVsVWJpenh5QldwSElEMXBsd1ZJNG9oT1NkaFhPZmVNcWFqS24wclRlSUZqeFNOYkRHUlhXcXFMVW1abU1Vb09LbmxpSzFEdHJSTzVTZHlSV3lLa0JxSmVLZXBxV2lHaWRCa1U1aUFNVkdyNEZCYXM3YWtDYlNlZ3BkaEZUUXJ1TldERUtUbloyQkZFS3pIcFR2SWJHYXZKQUFlbFdmSUcyb2xWc015UWhUclQ5d0ZUM0NBQ3FvNjFTZk1yaVk4dVRVTHR6VXBUaXE3cVFhcU5nUWdibXBrYXF3cWVMclZTUTJpY0dyTUJJcXFRUlVrY2hCckdTdWlUU0piWU9hZ0taYmtta1diSXdhWGNEV0tUUUVxbllLclR5N2pTdkpuZ1ZHcTVxb3h0cXdJT2QyYXNSVEZSMHJSMGZSSjlhdmx0YmZhR0l5V1k4QVZlMTN3eEpvYnBpUVRSbmhtVWZkTmEyY28zdG9hUnBUY1hOTFJHRVdadXZTblJ0c2F0WFROQnU5VG1DcXZseFo1a2NZQS94cnU3UHdIb2Eyd0U3U3pTOTIzNC9RVTRVSjFGb3REU25oYXMxekphSGtxUyt0RE5ucFVRWHVhTTgwV1J6azBSRldBNEZWQlM3em1wY2JnWGtrNXFaanhtcVVaSjYxYVRwV01sWWFLdHhuc0tqUWtFR3J6b0dGVm1qQ3RWeGtyV0FrM0VyeFViNXpVaTR4d2FWd0N0U25aZ1FlYnQ3MGhjbnZVVXd3YWJHVG10ZVZXdUlzS005UlUyekk0cUVQVXlTaW9keGxTNGhKNUFxZ3lrSHBXNnlLNHFyTGE1NkNycDFiYU1hWmxVRTRxMjlxeTlxZ2VJanRXNmttVmNZSHArN05NQ2MxSUlqNlUzWUhZbWlrd1JWeFpOMVVJNDJ6VjVFUEZZVkVpQ3doT2FWNUNCVEFjY1ZISzJCV0tWMkJETkpudlZZTmcwa2o1TlI4bXVtTWJJTEZ0WkFlS1pJTTFFbWFtSTNDbGF6QXFIZzFMRWVhYThSelFGWlQwclIyYUtlcUxZNU5HR0J5TTB4QVdZVnBSUmdyMDVyQ1Q1U1VVR2JEVklyOGRha25nTzdJcUZWT2RvQkpQUUNpNmFGWVVjbk5XYlNLUzVuamdnUXZLN0JWVWRTVFZ5ejhONnRleGw0ck53dnEzeS96cjBMd0g0ZWcwSXlYMnBiV3ZHQldKQnpzSHI5YTBoUmxOMnNiMHNQT2IyMExXa2FLdmhheGFOM0VsM011WldVY0w2S0t6TDFKUmJTU0U1SjVPYTYrVDdMZWJpeEl3ZXRVTlYwY1NhWGNTMmttN1loSlR2WHB4Z3FjT1ZJK253bnNxVVZUWnpGdGR2aFdMRTQ0QXJhZ3ZIK1g1dmV1VXRISmZhZWdOYnR0a2pjUndPSzBwUG5SN1ZURFJ0c2VTTTlOREROUUI2WGRYbGNwK2M4cGJVakZTTGlxWG1FVkxGTHpVT0xGWTBFQXhTTkxzUFdveEo4dFYza3lldFpxRjJJdkNmY0themJqVlJId2V0VGhzODBuQ3dEOTJLUE16VVpKN1VuTkZnRWtHYVNOY1UxMzVwb2MxYVRzQTZWaUtoU1Z0MVBmTFVKRGc1TlVySmFqTDhNbnlpckdWYXFpZktLbFZzVnp5UUU1alVqcFZhYUJmU3AvTTRxTnBNMU1ib2R6UDhqRGRLdFJ3QXJ6VDlvSnFUTzBZclNVMnhFVElGN1ZHWkF0T2trNjFTa2NrMVVZMzNBc0dibmlvbVl0MU5WOS9OU3BnOWEwNWJBSVV6VE5tS3VLcWtWRkt2SEZDbDBBaEJDMUxFMlR6MHFzM0JxV0k4MVRXZ05HaWtBWVVTVzY0NEZFTW9DMUtaUjBybWJrbUJWVkF2YXIwTGpielZaOGs1RktHd0tKZThnTDl0WlQ2bGRyYlc2N25iOGhYZWFINFV0dE1oRWx4R2t0ejEzbmtMOUtyZUJOTFQ3TStvTTJaSE8xUjZDdXluVUxIeDFJcjBNSmgwb3FVdHoyY0ZoWXFLbkphc3g1Snp2Mms4ampGVnpNVlhJUElOVnIrUXhUYnUzZXE1dVE2NVg4YTlOTkxRK2twNGZSTXVDOGVObXdldFNSNnJMRUpRc24zeGpGWkwzQTI0UFdxa2wwRWNISU9EbWlVMVkxbFFqMVJiczBqanVTOHNSem5vZWhycmJLNGhtWHluaFRaanBpdlBiN1U1SkVjcjhwNmpGYWVqYTF1aHc3WWJ2eldWR2NmaFpNNmNxMmw5VHlsUnpWcUdEZjJwa2FjMWZod3VNVjVOU2R0ajRCc3JQYWtkcVpIRVZhcjhqZ2lxMjRBNXFJeWJRWEpDZzJWVmRlY1ZLMDJSVVpZRSs5T0thSkVVWU5TZzRwb0k3MDRFWnBzQ2RGSnFVeC9MbkZOUThVNXBjQ3NYZTVSV21UaXErTVZQTEtDS3Jiem10bzNzSW1VQVU3ek1WRUhHS1l6WlBGRnJnWFVrelVvNlZTaUpGV1ZmTlp5aUlrSko2VXc3Z2FsVUEwT0Jpb3VCRDVwV210TWNVeVE4a1ZHTW5yV2lpdHdHdkxVUk9hbU1lZWFhMGVCV2lhR2l1VGcwOUh3YUNudFFxVmVoVHNXa2xCRk9kZ3kxWFZjVTVpUldmS3JrREdvakhOSWVUU2lxNkRMZzRYaWxYT2VhWkhJdU9UVW04ZHF4ZHhFNi9OVWlSSzl4SEhuRzVnS3FpNEM4QTFQWlNDWFViY1p4bVJSK3RTb3U1ZE5jMGtqMlhTN2RiUzJqamlVQkZVREZUM1RBb1NEZ2lvTFdVcEFGUFBIV283bVlNSytqaEN4OWxDajcyaGozNDM1SkhOWWhab215T2xiRnlUdVB2V1ZPQjh3TloxdEhjOXloRFN3eDVVa1E1T0RXVmNCZ1NjNXF3MlFjVkRLTWl1T3BVME5wMDFZWWtnWkFDUHJVTWltSnQ4WndQU25vTUUwN3JrVms1cG81bFRPVEJBcVlTWUZVOXhOT0JJRll1Tno4enNXSGtxQm5KTk1MWk5PQzVwcFdDMXR3QnB3em1wRmlGU0dNQVVuSkNLNWJGQWt3YUpGQXBxSVdQRlBTdzFZc3BLYVYzTkNRbkZTbUhpc20wbUJUWmlUUzdlOU9sVGJUVk9SaXRQUUNKbU9ha2lHNDB2azVOV1lZZ3ZXbEtTU0M0cXhmTFVic1ZQRldqakZWSjhpczR1N0VPam5JNm1udk9TT0RWRGZnODA3ek9LMDltSEt4V2tPNmdTYzFBN1V3TWEwVVMxRFF2aVlZeFJ2eWFwcStPdFNCNm5rc1M0MkxJd2V0QkFxSldKTlRiY2lvZWhKRVdBcHJOdXBaRUlOWDlCdEJkYTdZd3V1NUdtWGNDTTVHYXRKRlJqZHBHdm9uZ2Evd0JWdDB1WnBWdFlIeVJ1VWxpUFVDcmR4NEFtVDViZlVJbmZ1SFVyL2pYbzF4SUlVREtSMDZDc2U1dWtrSktuREQ5YTdZMEl0YW4wRkRMS1VvKzhlVWFscDE1cEYxNUY1RVVZOHFjNUREMUJxc0pxOUsxTzB0dGNzbXRMZzdISHpSeVl5VmIvQUFyeTJSSGdtZUp4aDBZcVI3aXNLbExsWjUyTndMdzg3ZEhzV1ErYXQyVGJMeUJ4MURnL3JXWWtnRlhyR1VHOGdIcTQvbldNb3RIRkdMVTFZOXNoZjl3R0hwMHFqY1Q0SkhTckNzVmpHUFNzdTdZNytPdGU3ZmxqYy9ROFBDN0lMaWM0cWhLK1ZxV1E1Qjk2cU9hOCt2VlBZcFUwa1JQenpVYjlLZXg1cGpIam12UGNyamtpRmVEUWZ2Wm9QM3VLWXhJTlR6YUhNOURsRmhQZWxhUEFxMENNZEtna1lDclVtMmZsWlgyNE5TSTJEVWVlYVVaRlcwRFJiV1FBVTJTWVlwYld4dXJ4d3NFTE5udlduTjRPMWhZZk1XRU54MEZTb29haEptRXpnbXBvZXRNbDA2OXQzS3pXMGlrZjdOUGlSazZnajYwNVdzRW8yTkNKY2lyQ3FNVlFXWEhXcGhjZ0wxcmxsRmtqTGxGNXFvb3dhbGxuQnFIZm10b3AyQmsyTVU5SEhTcSs2bktjR2hvUmJJeUtwM0FJNlZyMjFtYmhPRzVxS2JUNWNrWUJyT01yTTBqVG05VWpNc2RQbHY1d280WHVhNnBmQ1NHM0gwNjB6UjRmc29CZGNHdDMrMFNlT3dyc3A4czFkbnY0TEsxVXBxVWpBajhJeGpPN0ordFo5OTRhTWJZaE9ENzExVXVwSEdBYVpBelhFZ0xHdE9TTDJQUS9zYWx5YW5Jand2ZlBIdVVaL0NzdWF6dWJhVXh5Uk1EOUs5aHRaWUlrMk9vRk5uMDJ6dnMvS3YxcHVrMXNlWGlNcjVQZ1BJNFZPN2tjMWVDL0puRmRuZStHN1dOeXdVWnFxK21RTEVkb0hBcmxuVG5mWTRsbGxaNm5JTUF4eWUxYWZobVJZdkUrbXNTQmlkZWZ4ck12RThtNmRPMmVLcmlWbzVGZEd3eW5JSTdHbEZkVGdzNFRzK2g3MXFDUkJnQ0N4Ym5pdWJ2NDRsWTQzQWowcXJwbmpUVHIzU0lSZTNJZ3ZvaGhneW5EL2pWQ1M4YTV1SE1zc2F4WitVbHdOMzB6MnIxSTFJMnZjK3J3bFdFbzNVZ21sa1I5d09mU2t1dmg1ZjhBaVMzYlY5Smx0NUpHSDd5Mlk3WHlCMjdIUDRWWk9vK0hyU0wvQUVpZUF0amxWeklSK1ZhM2h2eEZZdkk1MHRwRmpqUHpaR09mV3M1S010TGw0djJXSmg3SlNYTWVTYWxvMnBhUFA1T29XVTl0SjZTb1JuNkh2VGRMR2RWdFFjNDgxYy9uWDB0QnJlbjZ4R0xmVUlvWkQ2U0lHVS9nYXJ0OE8vQ2QwNGVQVG9JWmZ2SVkyWmVmVVlOWk9tOWp3NVlTZEthNWptcEcyeDhkcXlydDg0NTVyV3U0L0tMcC9kSkZZaythN3EwckkrNXdxVDFLY2pITlYzT2FubDVGVlNUbXZLcXU1Nmw3SVlUelRXUEZLZXRNYnBYTzFvWXVRdzlhamtQSXFYdFZXYVFiZ0t6T2VySlJSZ3V4R2NacDFucDl4cVU0amhRbjNyczlQMFMyazBvTTRCZGhYU2FEb1VPbDJabDJnbnJtdXluVGt6ODZwNEtjbW05bWN6cG5nbGJZZWRkTnVicmdqcFRydlNMRXpEYWk4ZTFiMTdxRFN1VkJ3b3JCdXBTSkR6WFNxY1V0VDZYRFpSQlE5OUdyWXRhMlNyc2pCSXJxTGJWSW1qQWRGeGl2UElyb3EvTmFTYWlBbkJxNDh2UTdKWmZTY2JKSGJHSFRMc0hmR21UN1Z5bmlId3JiVFJ0TGFnQWpvUUtvbldIamJoalhRNlBmaTdqS3VjNUZaU3B3bm9lVmk4cVVVMmp4KzVWNEozaWNZWlRnMUNaRFhTK05OUE52cXZtSXZEK25yV0xhYVRjWGJBS3VCNm11WkxvZk51akxuY0VybEV2bWpOZG5hK0VJVmlEVG5KOXpXVnFtZytUTC9vM0k5SzBjR2xkbzJlQ3FxUE5Zd2c5UDNZcHJ4dEU1UnhoaFRUVVdPUm8yTk4xSXhFSVFDZXhyVGE2M0hkaXVWakpXUlNQV3VqaVV2YmcrMVN2ZGRqMzhubkdWNFNOQ0M2Vmx3YVdSOGRPbFpLT1ZhcjBlNlFZQUpOV3BYVmtmU1VKUlNzZ0xrbXJOdmROQ2VLWkhhU2s1SzQrdFY3bFdqYkZKODBGekcvT21hZjI1NUdBSnJXdHJueTQ4bHE1bTJWNUNLMXRwRWZKN1Z0UnFTa3JzbXBHRHNHb2FpOGprQnNDcWNNNVpTQ2MxREtwTXUwNTVxN2FhYkl4REtwSW9mUEo2Qkp3VWJkRG5kUTA2ZTR1c3h4azU3NHFKTkpNWS9lam4wcjBOWVk3ZTNMU0lPQlhENnZmbWU4TU5xdVBVMXp6cHVHbHo1UEZZU0VKdW85Ym1UY1d5UnlZV21lV0t0UzJVNng3Mk9UNzFsUE93SkhjVW9wczhhcFRrcGJXTERxQU8xYkhoRzc4alZYZ3poWmt4K0k1cm5ETXg2MVkwK2RvTDZDZFRnbzROYVJUanFiWVdibzFvMUgwWjZOOXRrUmp0WWdnMTBuaDd4VVk1QmEzTGtvM0NrL3dtdU5uT0p5dzZOeVB4cUlTRld5RGdqdlZ5ck9KK2pUdzFLdFR0THFkdGR5WmtrSFhKUE5ZczdaWXJVMXRjdGNXaXVUMUhKOTZxU3RseWE3S3RUbWdtVmg2ZkxvVlpCeWY1VldicmlyTTNMZzFBdy9TdUNXck8xN0VKcGo4Q3BXNjFCSXd3YWhvd203SWhsazJyaXFyY3RVam5OUjV5YXlhc2VkVW56TTZYU21mN05HaHlNRVYxTXQxc3NkaFBhc3pGdkg5MFlwa2txeWpidTRyMUl4Y1ZZOCtqU3RHS2EyTXU1a3c1SU5aczh1NDgxdm5SbXVFMzd5bzdjVldtOFBrSm5mV05UbXRaSHB2RlVrclhNRXZUbGxwYml6bGhjcUZKSHFCVDdheGtuNEFJTmM5cWx4S3FscVJNK2E2ancyeXFtNWpqRlljbWpYa1kzZVdTUHBVc1QzVUZ1eXBHd3gxTlhSNW95YmtUT1Vhc0habWw0bk5yZHlMMEpCeldiRGRRMnFZUlJ4M3JKa3VXWnlYWWx2ZW9tbVorQlE2OFZLNldwelU4UFJwNjJ1eld1ZFhkZ1FEVVZuSThraExjZ2p2VlNDM0xrRTEwRmhZZ0RKNHJhbktWVFZuUjdEbWpkbzVpL3dCR211YnN5S01BMVIvc082TGxRSzlDYnlZZ2R5NU5OajhvdHUyQ3BkRjMzUEVua3FsSnlaNTQrajNjYkQ5MlRYVFdOaEtMVWIxN1YwaXd3djhBTVZBcXZjM0VVUzdGQXhTVkIzdTJhWVhLWFNxTnhaeks2Wk5MY0ZWWHZYVmFYcEJoakJrakJGUTZmY1JDYkxDdW1qdXJhU01MbmJXMEtTV3FPK3BRcXdNSFVXdDRJenRISTdWeXNqL2FaOEFZcnFOZXQxOHBtVWo4SzVHR1RaTm4wTlkxbmFTVE5hU1NqNWw4L3dDaXFQVTFkMDUvdEJKYXFWeEhKY0lHVmVLbnM1UHM4Snp3ZlNtcGNzcmREbzVITldMVTlvaHVCZ2drVnFXMTNGWng3WEF6V0Riek8xeHU2NU5UNmtwOHJjSzNoTk5PU002Mkc5MUkzWXJpM3ZDVlBHYXNXWGhPeXVManpTaWxpZXRjVlozcnd5ako3MTJ1a2FtMkZJTlZGd3FISFZ3dDQ2RSt1ZURMZVMwSWhYYTJPQ0s0clR2QUFNN203TzQ1L0N2VFcxTW1QREhOWk54ZGt1ZHZHZlNuN0NMZDJja012OXBLODFjNDYvOEFCRnF4MlJLQWZVVldQdzZtU01QSElmeHJ2SUVCTzk2dFRha2lKc0dNVmJ3c0pGVnN1cFZIWlJQUHJ5MGxzeERITjk0SUJuMXhWQjI1cnBQRXNxM0N4U2pxcElybHBHNU5lWGlxZnM1OHA3bEp1RkdNWDBOM1JaUzluSXY5eDZsa3h1Tk04TEo1a1Z3cDc4MUpkRFk1d09hNm9KdWpGbTFHV3BTbWJIRlFzdzI1NzBzclpQdlZkbkpGWVNWamFjN0RuYjVhcXUyZU01cVIzNHF1NTV6V2IzT1N0TzVHeDdVMERtalBOQXFIcXppdWRZdHhGT0JuZ21yRnZZZVpLR0RuSHZWalROQWNSaG5BejcxdXdXTVVBK2NpdlZTdXRUbHJZdUMwZ0ovWnJTV29WSlJqdmlvNDlJWUhiSWNpck1sM0hDTUpnVlJmV0ZUUHpWWEpFNG84N1doZC9zbTBVWUlXcm1uNkpwNnlCeXExeTgydEV0dzFDK0lXakgzcU9WQ2RLdExabmE2aHAwTFc1RVNnL1N2UE5XYVcxODJNUmM4MXJ4ZU1CREdmTk9SV0JxR3J4MzB4WUE0YjFyT28wdERxdzJIcXgwa2pqeXpOSTI3cm5tcDRWeWFXOVFKT1N2UTFKYmppdkpsRzBySGRSajcxbWFkaEVIbVZhNlNSSW9vQnRPR0FySTB1TVFJMDBucFRiaThNckVxZUs5R2sxR0dwM3VMcU8wZWhkK3p2Y2ZNcEJGV1Bza2lSL2Q1OXF5N08vZUk0SjRyV2gxQXN3SEJGYng1Wks2TTNTcUxWRlNTWm93UVFRYXlMaVlzNTVydURwOXZmVytjQU1SWEs2dG9keGFzV1JTeVZqWHB6UzBLcDFvcTYyWm14VEVOd2VhMXJPU2VaMVJBenMzQVZSa21ySGh2dzB1cEV5M1V2bFJMMUhjK3dyc2tqMHpSSUhXMEtCd3dHMEhKWURxUzFLaFRuYThtWjFjWkZQMmNWZVJ5ODJsNmxjV3BQMkc1Syt2bE5YTXlhUE1sd3dFTWdJT0NOcHlEWHBIL0NRT3FuQ3BJckRvZU1jMWJ0L0VjeHRWYjdKNWFZd1dMNFU4L21hM25RVXR6bWw3ZU9yZ3Z2T0cwK0RmRUlWakxTazdRb0hKUHBWM1VmQkdxdzJDMzBmbFNxV3hKSEd4TEpudWV4SDByZVc1dElybVc2QkFaeWVRbktnNXp6bnJqak5hY0hpTVcwYTR0MWtqR1ZaUzNKSDEvR204T3BLekhLcGlJMmRPSndFZWkzZGxGNXMwREFlb0ZMQmFTYXZjQzF0d01uN3pIb285VFhvY09xNlhOYjdibWZiazQyTkd4UDZBaXFDVGFUYkYvN1BlRXM1M01FUXFXL01BbW43SkxSYkNsaUtyVFRnNyttaHk2K0ViT3ltRDNGdzF5UWY5V0ZLS2Z4em4rVmREcE9uVzAwbmxRMnlxZ0hLb3ZUNnNlZjFxQzZ1NC9NYVJ4Z0RvdWVwb3R0YjNjUmdJcW5rTDNxb1U0eDJKZEd0T0YrcHIzdmhXNmQ5MXBOQUl1L21PZmxQcHdEV1BONGUxTzFQbVNRK1luOTZKdDM2ZGEwYlhYcEZrQlVoc0hvM1Q2MWRPc3h3eDczY0VnY0pqT2F2bGExTWxMRlV2ZGVweDF6ZkNNYlFlbFpNMm9GaVFEVzNyV25SWDl0TmUyZVVtVEx2RU9RNDc0OUQzeFhHRjY1NitJbEIyUFd3L0pLTjF1VzdpZnpvbWo2OFovR3NPVS9OaXRPTjhTS1Q2MVF2SS9JdmpHM0dHL1N1R2I5cXVZakZQbFNPZzhOU2VSYzdPZ2RDS3MzNHhPM29hcjIwUnQ3dENCOXhzL2hXcnF0cjkyVkZPMGpOZHRPSDdybDdENTR4a211cU9ia0cxamtWVGM0TmFOeEhnN3F5NTJCYklyS3BEUVU2bHlOM3FCbXpSTTR6VUpmaXVLV2pPS3BVMUhocVhkelVJT1JtbmJxU01sTTlXbTFKWXZsM1lyS3V0YkNnZ05YTjNXcXM1T0RXZEpjUEllU2E5T1ZWSXhqaDB0emF1ZGFaeVFHSnJQZS9rYzlUVklIMW9MZWxadXN6b1VZcEZscnQvNzFOVzRkanlUVlhCSnF4QUVFaWgvdTk2bFRsSmx4SjFobXVDTm9KRlcvN1BtRWVkdk5ML2FDUk5sTUFkZ0tsVFdUbmxjaXJjSVh1MmJSbEl6cGJKNUd3UmcxYnNkTVBtamNSZ2RhYzkya3hKWGcxYzB2ZXdZdFVLbkRtSzVYZTZJNzk5dUlsUEE2MW43c2NWZHU0ajVqTmlzNlE0TmMxWnU5enVqN3NTUkg1cTdhejdYQnJMVnVhc3c1SnFhVldTZWhjSko2TTdDeXY4QWMxb3phakM5dVZkUVRpdVdzeWVGQjVOYVZ6WlR4MitYQkFib2E5WlZHNG5MV3AwbkxWbGl6dkloYTNXeDlySVJ0R001QjYveXJOUzVZdHV6MWJOUVFSTkNERkkrQTdaQngzcU9aWGhRZzhmTmo2VmhLbzByczNvVVlKdHJxWElaMU1nSEorYkJJSFQvT0sxR3VXU0F3TXhKeDh4M2ZwWE5SekZOb0FBeDFJNzFiam4zREdjMDZWYTV0VW9jelRMclM0QkdlMVFwcURMaFdiR09EVU8vSTV6eCt0VTVPR3lEMXAxS3Jpcm8waFFpMXFhZjJrN3o4MlJqQnJNdXJoZzRaU1FWYklJTkxISmdFRS9qVmVVN25WUnlTUlhQWHhGNGFibW5zbEZNdFBQSW05VEt6N3VyTWM5eUtuczVDc2ZCNUpxaGNObVJHN09DZXYrMGFzUXllV3RWQ3MzVmFleUpoQk9Ga2E4YzRRZlRyVUZ4ZitaOHVTY25Cd2F6cHJoaU1aNDlLaWlKTWd4eWM4VnBMRTY4cUlkQmJzNi9UcC9KZ0QveERuOGUxY240bTA2YlRyMHppRXJiekhLc3ZLaHU2NS9YSHZYVDZkTVkyVmdNaFBYdnhXcmZKYVgraW14dVZjU1NuZStSZ0tEeUN2djMvQUVyZXZSOXJDM1U4ZW9wMDZsNHJjOG1FcHF6cmlDV3l0TDVQNGwyUC92TC9BUFd4VUUwQnQ3aVdGaUMwYmxDUjBKQnhXMXBOc05VMCs1MHQ4QXlEZkN4N09QOEFHdkxvcHFUajNKeENsT2szMk5UVDRocUZoYTNTYzdrQWI2amcxMHRyYUMrMDE0Q0I1a1hBOXhYSitBTGdyZDNXaDNYeVRJNVpGUHFPR0ZkNmx2SnAxMnMzV004TVBVVjZkR2E1Ym5renhUdGErdlE0ZSswOW85eUJjSHZYTWFoQVltNmNWN0hxbW1KSmlhSlF5T01nMTU5cjJsbFhKVWZoNlVWRkdTdWpTbmpGVVJ3c3h3YWgzZGF0M01MSklRd3FvVUlZMTV0U0dwTTI3M0hnNEhOTHVvSzhDbTdTYWx4QzdSYTNGam1selRBZUtVR3A1enNRL0pwd0ZORlNLTTFTYlpvbGNPZ3FwTmNZUHltcEx1YnkxMmpyV1V6a25OS1Vuc2preFdJVVBkUm9wTVc2bXJrTFo2MWtRdm1yOExZeFVLVFROTU5WNWl6SzVqWUVWMWVpcXNsanZ6elhHM0VuQXJUMGJVWGcvZDd2bE5iMDZpVlN4MlFuZWZLYmw4cXFEV0RMeWF2M2x6dlBYT2F6eWNtblYxWjJ0NkJHdk9UVTNtQmVsUkZzQ29KSkt4NTFEWU9aUlJwVzE4WUprZnFGT2NWNk5iNmhhNjFwSVRBM2JhOG50YmE5djVHU3l0WjdsbEdXRU1aY2dlcHhYV2FIb0hpYTNtVmhBa0NIcXMwb0g2REpGZFdHcnR1eldoNStJbENvMDc2b1M5Z2RiMFJFOEprNVBwVlc4enVUSkhJNHhuL1BldWkxdlQ1NExpMmFWNG1rbVVqOTJTUUNNZGNnZGpYUFhqQmxYSDNjOFZWYnFlbmhaOHlqSkZUTlBSc1ZFVFJ1eGcxeEtmS3owa3kwWDNEbW8zYmltQitLWkk5T2RkdEZhSkNOSmlrUnQwNmZYTlFGcWRHZm56N0d1YU03elJnNTMwSkpUbnlQOTAvek5UYjhMbk5WR1BFZis3VHQzRlc2bHB0aFRsWkVqdmsxUGFETGdpcVdjbXRLd1ViZ2V3cThPM0tvVmUrcHZXNzdGR08vVEk2MW9ySUlVbXVDaXlaWGJsaHdHT2YxL3dBS3lJNUNBSEl5MmVLbDNNL3k1K1grdGUvRjZIQlVwWE9LMUFBYXJjcU0vd0NzWTgrNXFlSFVCWlI3a09ISElJcGRkaUVlc1hCVThmTHlPL3lpc0taeXpjbml2SHFTZE9idHVjTTZqcHBuUjNEeTNiUitKZE1JRjdic0RkUnIxeVA0OGVoNzE2OW91cTJuaUxSMHVJaU41VUNSUDdweFhnK2s2bk5wZDRzMFI0Nk1wNk1QUTEzbWszd3Q3eE5UMFVCVVlBWE5ubnFQVVZwVHFjeXYxUG04WFN0cXR1bitSM2NGeWJTUjdLNC8xYmZjSjdlMWM3NGh0MVhjNFhqSFVWdDNVc09wV2l6eDljWngzQnJuTHU5M29ZTGpQb0RRNjdpN000SXpsQ1YwY0Zxc1FMc1ZBNUZZTG5CNXJyTlF0U1pDQWR5NTROYy9kMlRBSGc1RlM1cG5vUXhLYUtXNGNVN2NNVlBKWXNMWkdIWEhJcUZJV0k1RkhNbWFMRUljRFVpcVNhWkVtN3JWeEVBcm5oRnlQV3B3Y3RXSWtYclVoQVJDMVBWU3hBSGVtNm82UVd3UUhuRmRhaW94dWJUYXB4Yk1HNmw4eVExWHpTTTJTYVZWWnVpay9oWFBZK1pxVkhVazJTeEhtcjBiVm5xcktmbUJIMXE0bkM1cGN0MmRtR25ZV2VUTEFWWnRXd2MxbkZpOHRYNER0NjB1VjN1ZFdIcTgxUnMzdE50RjFPNkZzYmdSU09QM1paY2duMFBwVnE0OE02cmJEYzBNYnFlaFNWVG44TTUvU3NKWEl3UWNFZHhYUmFYNHBtU1A3TGZrelFubzUrOHA5ZmV1cUNoTFNaMzFKMUwzZy9rU2FKNE4xWFhiMVlGalczVE9Ia21JRzM4T3AvOEFyMTZuWS9DN3czcHFMSkxDOTljS09sdy95ay83b3dLNFQrMklyZVJXQklac0VOMit0YVIrSnQ1YndtRjRvcms1eXN6RTVDNDZFRHJ6M3JkVUtVTmR6aXhVY1hXYTVYWmRsb2Jlb1dsMXAyNkd5czQ0YmZQM0xlTlVYOVA2MWtDVzRTUU16R05zNXd3cXhwdmptYlVsVXpRUmhHNHdwd2FzeVhkdGZIRzdZYy9LakRGZENoekpOR2xDcHllN09KamEzY3RORmJseHRkZDZrajBJSE5jeGZjUnhqMTV4NlYwMnVvVXRvL2t4azRERHB6WEszamJuQXovK3F1U3ZwSm85M0NKT0NjU29hYjJxVHFLamIxcno1Uk8xc1p1eHhTTTNGTmJyVVphdWFWekp6QW1ub2NFL1NvaWFldlEwb3JVelV0UnpINVY5aFJuaW1zY2dmU2pOTnJVZk1TSnlhMHJFajVzOUt6VXE5Wkg5N3Q3bXVuQzZTUnREVTJZczR5M0Eva0t0V2k3bngvQ0JtcW9QU01ET091YXZRS1k0eWVwYmdWN3NER3BzYUUzaHF4dkxOWjV4KzhkUTM2VjU3NGswRCt6c3pRNU1lZVI2VjZpK1VFY1RzUjBVQURKL0tteWFacE40aGkxQ1g1RDFRdUFUK0hiODZ6cTBZMUU5TlR3YWtuWjgydHp3dENXY0tvSkpPQUFPdGROcEdqZUltQ1hGanB0MjRIUXJHZjhBT0s5U3NyVFNyRGFiRnRJc3dtVldTZDBMZ2UyQlVWL3JJUU1rZmlhYVNRSEcyMnQvbC83NkxEOUJYTFR3Zks5emtVSlR2QzIvay8wUnplbCtLSkltZTF1b1NreW5hNk9NRUduWGx4QnFBT014dVBYb2FMK3pzTlVKdUpaNVV1c2N6dTRiUDFBQXJHTnZxRVlPeFJQRU9qcjMvT3NzVGhxa2R0VWVaWHdOV25MM1ZjcjNUUzJ6YlhHVjdHcVUxekU2NXdNMU5kVFRBRVNRdW9ybkwrNmFLUStVbWZZMXhKTzlqaG11VFY2R2hKZUFEYUJrVlZqbUJmNWx3TTFqSFVaODhvS2FOUmthUUFyZ1ZvcWNrWmUxVDJadm91TVZPb3pVU1ZlczRETEtvcmVqRzdzZmRSV2hvNlJwVWw0L3lxYTA3N3dGSk1vbWNrcU9vcTFaVHRwc1k4dmcxUFA0bnV0dTB2a2VsZWo3T05yTTVLcm5LV2l1am5sOElXRERIUWpyVTQ4UFd0cGpiR0dIdlVvMU1PN04wSk5UUjNtL2duT2FpMEZzanZoaFljcW5GRkRVdE5zTHEyQVNNSzYrbGMvZldLeDI0V05mbXJxTHVNQWJsNkdzd1lrdUFwR1FLd21yeXNqbnI0VzhIeXJWbERSUENsemVNSkpGSVhyVVdxMkFzTDd5VnIwWFRyeExld0txb0xZN1Z3dXJ3WHQxcXBsTURrYnVNQ3JxMDFHS1BPaFNkSk81bFNLMFk1cElTV2JBNjF0WDJuU0MwRG1OaHgzRlp1am9HMUVJdzZIcFhQYlV1bFg1bWpwN1BUcGYrRWU4OXlXS1NFWTlGSUg5ZjUxbHUyM0l5U3Y4cTdqU3ZLa3NaN2RoaFRrSDZFVnh0NUNiZTVraWNFRUhGZGRTSExGV1Bib1BWeGZRcVIzVXRvKytGL2w2NE5hQ2VLRlJnWlZJSUg2MWt6amJ6MnFsTW1WcnoxaWFsSjJpWllpa3QwdFR0RjhaV3VGSUxnOXdWcHR4NG4wNmZhWGppa0lCQTNJTTF3RzhyK0ZPM2hoV24xK285MGp6b3VLZW1qT3prMWZUNTJKTmpDRDIyTVYvUWNWRVZ0TGpCaVpvYzhIUHpEL0VmclhJck1WUEJxN0RkblBXbjlaaFA0NG5aUXhMV2lrL3Z1ZEMybVIrWHVhNkdUMlJNL3pJcXBMWnFwK1NiY1A5cGNmeXpVRWQ0MkI4MVRmYU4zUFRORW9VSkxSSGZDVGU3dVZHVmtiYXd3YVRkd2Fsa1lQOWVvTlZ3ZXRjVTRjcjBCeXN5VE9hVWMwd0duS2F6WlVYY21Xck5zK3laVFZRR2g1eEgwNWF0SU96dWJxb29xN09sODZPMytlUndvOWFyeitKSVlKRmVKQ3hRaGwzOUNmcFhOejNiTmxuY3NmYzFtRjVidTVXQ0VGbmNnQURrbXUyV01sdEE0TVZqWXgwVzUwcitLZFd2TG5iQlBJWldQVlRqK1ZhbHRiVGJCTGUzVHpTSGxsemhSK0E2L2pXbnBIdy93QlV0TFBKaVJaV0dXTE56OUtxNnBwdC9wS2o3VEhoVzZNcHlLNktVWnBjOVc0WVgyTTNaeVRsMlJuWGJ4bWI1WTBBOWxGYWVuL1pwRUJlM2lZKzZpdWVra3kxZFo0YTBscDhTemNKNzBzUFg1NnIwME96RlNwMDZUY3VocDI3MlFYQnM0RngwSWpBck0xdVlyR1REK2xkRGZOYVd5YkZBSngxcktzb3JTNnV3dHd3QzU3bkZkNzk1YUhoUXFSdjdWSjJPSGVlY0hKTFlyTjFFQzRBYmFvSUhVQ3ZkVThOYVJQR0RFcW4zSE5jSjQ2OE1XMmp4SmN3RENTa2hnUFd2SXhOSnhpNVh1ZWZtZVpVYStIbkRscy8rQ2VTTkY4eHdQMHB0cmJDUytRTUJ3YzRxK3lBc2NIRlM2ZENHbGxsSjVUZ1ZoVGxkMlBtc0ZCVHJ4VDdseU1kQlhSNlRiQlU4eGhXQmJMdmxWZlUxMGtzNjJ0bUVIVWl1N0RwSlhaOTl1cklXNXVjN3NIZ1ZqVFhlY2dHbTNGeWR1TTFWaVI1cEFGR1JWeXFYZGtFb3hob1dyWWxrZDJKQTdWZXRwUUd5VFZPZGhFcXdqR2VweFVQblk0QnJDVTFHUjA0ZVZvV1pzM0Y2aFhhS3BMTUZKSUFxZzl4Z2RhZ2E2OURVdkVLOXh5cXdqdWFjbXAzTWNtSTVDcTFaaDhTM0tGVmZhMk8rMnNFeUU4c2FFQUxaTlpQRnp2b3pCOHNuc2Q3WStKcmVaaERld28wYmNaeDBwbW9hSnA5ckw5dnRTTUhzSzVJTHVUSzlSVitIVXBHdERBekVnZE0xMXF1bXZmUlN3VlAyaWtsWTNOSTFJUjZqNVJQeXlqR1QwejJxUHhSYnFKa25Ub2ZsYjYvNS9sWFBDNGFLVkpVT0dSZ3crb3JxcnhoZjZZR1RsV1hJeWVuY1U2RmIyOEpRZlE2S3NWR3NweE9Qa081YXBrZFJWdVQ1U1JWU1QxRmViVldwblZabVhIeXVhaVY2a3V6OHhxdUIwb2l0RDV5dEpxbzdFdTdtbm81QnFHbnFhR2doTjN1WDQ1VHhrMWJTVElyTWpQU3JzWFNvVGFaNjJIcXRsc0hQTlJOOHBZZmxVaW5nVkRNZWgvQ3RKYXhPeWJzcmtpbjVhY0RnVkNoK1VDbmxzRE9heFpVWjZEbmwyRGpxYXJQSmpuTk1lVEpKUFdvSkg0b1J5MXNRUjNNL0I1cnJmaDFZeHBxRGFyT3VSQi9xOC8zejBQNGY0Vnc3bmZJRjk2OVAwV0piSFFvWThZTERlMzFQLzFzVjM0T2twVkZmcHFjT0RnOFRXbEo3TDlUdFpOY2xhTnRzcEJQZXVkMUhVek5iTmFUTnVSajNxbjlxSVJ0eDQ2aXNTOHVHbXVBVVBBTmV0VXFKSTlhT0NoRFpIVmFUcG1qM1VLMnJvQk5uSWtQV3RmVURMcHRzWTRvbTJxUHZnZGE0MVhNYUt4T0NPbUszMjF1NG0wWmNPV01iRGRudUtoUml2aFZqanhWR3BHYWszekp2cVlkNXFVd2JjNnNNK29yR212cFdsM0J5UHBYZTI5OWFYOXY1ZHhER3g2OGp0V1ZxUGh1eHZmbnNYOG1UKzZlaHJLckNvL2hacEhGUWcrV2NiRlRRL0ZGenA4cWhuSlFua0Uxb2VOdFZHcWFSYmxUbGNrbjhxNU85MCs2MDJmeTdpTWowWWREVTkvT0gwWUFIb2VmeXJrcnpib3lUM1BMenFqU2xRZGFCeVRMeVJtcGJOdGtVNUhlb21La25pdERSTGI3UzdxQmtaNXJpbzM1MGZPWlZHK0lYby95SnJBaFpkN2Rxa3U3enpISnp3S3BtUVJwVUM3cDM5cTZaVkdseUkrMzUrWFJibGlNTmNTajBxL0pPbG5Gc1FEZVJWWHpVdFkvbHh1cWtaV2trTE1jbXJkVDJjYkxjaVRzOWR5ejVoWWxpY2sxRzhtQlRjL0xVTWpjVnlTWlVxbGtNa21QclRJMzV5YWhjODBNMkJ4VVdQT2RaODEyV3crNDFiZ1RjYW9XL0lGYWtUQ0tQZWFkT041YW5maG56TG1aVjFQVVgwOVFFR1NhTlB2RGN3YnoxUFdzblZaemN5RTl1MVd0SitXTEhxSzJtN3JRNEtlUG5MSDhsL2Q2R3VYelhRNkJlaDdaN1p6bGs1WFA5MC8vQUYvNTF6R2VhbnRMcHJXNFdWZWNjRWVvNzFoaHF2c2FpazlqM1pTNWtYZFVoTVYwL0dNOGlzbCtocm9kVTIzRUVjeWNqSFgyTmM3SWV0ZFdLaWxLNjJabFZlbHpNdWVUVVZUUzh2VVI1TmM4ZGo1K3JyTnNLVWVsQm9YNzFCSzNKNCt0VzBQTlZFNjFaVHBVTTlHZzdGcFd6VVZ3Mk1mV2xWcWd1VGpiOWFmUTY2cy9jSmxicFNUUGdCZldvbGZnZlNtU09DNTlxa3psVjkwUm02MVhrZW51MVZwR3Fvbzg2dlYwSmRQaCswNm5CRi9ma0MvclhwRnpPcTRBNEhwWEErSFR0MXFDUXFTSXlYSUhzSzZhNXVkN3NRZU04VjMwYXFwUmJmVTlUSTRwVXBUZmNubnU4cVZISGFxd3dyS3Y0bXE0ZmMrZlNqemZuSnBTcnQrOHoxM05YTDBsd3pEYm10SFNad1laNDJiZ3IzckJEbGpnVmNoamxqak9Eak5hMHF6bEs1ejRweGNMRm1PNU1YUTgxcFdkMDRaZm0rdFkwVWVUeWU5YlZuYmhRR3JvZzVISGlLbFBsMU51UlYxSzNNVXlCbEl3Q1JYTVgzaCs0VkhoSDNEeXBycnJPV01BQXNLbHVMbTNDZ0VqTlRYcGUwaTRuem1JY3BRbFNqc3p6cVB3bEl3eXdOYm1nZUhSWXl1V0hYSFd0dHI2RlRoUUtQN1JqN0FDc3FXRlVIekdXR3djcVQ1a2p5TjJNajRxd3JDRk1EclZRT0U1N21uaHNqT2E4OVh2Yzl5RlMxMzFFa2NzMlNhUkcrYW9wRzVxOXBXazNtcXpZdDArUlNBOGpjQmFGR1VwV1dyTXZhTnkwSXkvRlJTZEs5STAzdzNvMWhDclR4ZmFweHlXYzhmbFZ5NXM5S3VMWXEyblcrN3BsVUE0L0N1eFlHYldyTitXY3RMSGtEbkJwb0RPVHRCT1BRVjEyc2VGN1JXRDJjNWpCUEtQemo2R3V5OFA2ZnB1azJJZ2loVjJjZnZaSEdTMy93QmIycFU4Rk55NVhvYzBzRlZ2cXREeXExR1NCV2pjSm0zQ2c5ZXRYUEZXbkpwV3FOSkFBSUp2blZRTUJmVVZrSk9aVTVOWXFQczI0eTNONFNVVjdON2xlNXRGOGdrWXB1bkhERlIyRkZ4TVFoV202YU1NemV0UmRTMk9CcUgxcURpYVJiREdqZHppb2kzelVnYjVoWEsxcWV6N1EzdE5sRXNiV2I0K2NIeXlmWDAvSC9QV3NtNVVxNUZQV1FvVlpTVlljZ2pzYWt2U2JoQmM0SHprN3NEZ04zcnNoTG5oeVBvVlYrRXdwVCs4TlI1cDB2RWhxTTlheXNmUHpscXg1TktwNzFHV3B3TkZoS1dwWVU4Y1ZhakJOVkkrZ3E1SHlBYXFNRDBLRHVTb01DcWx5MlpBUFFWYWR0a1pQNTFuRml4eWVwcHpqeXF4ZUlxYUtKS0c1eFRHYnJTS0R1Tk5rK1VtbzVOTG5NNXV3eDJxdTdjMUk3VlhZODFVVWNGYW9kSjRSZFliMmU0Y2NMSHRHZlVuL3dDdFhYeFE2ZmVyKzlpdzNxaHhYRWFXZkp0TTkzT2EyTGErYVBqUEZkMUdwQlI1Wkk5ekJVN1VJcE96WnN6NkhGZ20ybGI2TldIUGJUMjgyeVZTUFE5alc1WlhwbElEZEJVOThVZUU3c2RPQ2UxVlZvVTVxOGREcWpVbkdTaTlUSnRJbEh6TlZtVzdpUmRxakpxZ3prOERnVkdUVVFxS09pT3FWSG0xWmRGNXNPUW9xekhxTEhqTlk3c2NBVTZJa0hPYTZQYWREa2VHVW1kSmJYWjY1cU83MUREY0dzbGJnb3ZIV3E3eXM3Y21pVlN5Q09FamU3TlpiMHNjazBxM1IzWnpXVWt1enJUSkx6YjBxZmEyV3BvNk1ZbWJwTmpiYWlrMHNzeFV4dUFFQis4T2YvclZ1ZjhBQ0p4M0d3V2QwM3pEcEt2ZjZpdUswKzhhMHVzOVViaGhYZVdXb05FUEtZNEJIR2E1cVhzN1dramd5K05QRTAzL0FETGMxOUs4TzZibzZMSk1JcnFjajVqSXVWSDBCcXpMTGIyMXdHc29vNFlpT1ZqQUEzZXRac044WkJzYzg5S3pZNW1TL3dCbTQ3WE9DUGV1cVZTRUV1VkhwMDhGR0dyTjAzQkJCejE0TkkxMXRRZ0hHS295U2ZMVmVlNHltQlZTcmNxdWRrYUNZUEtacHdTZjRxMmJlY0pGMXJuRWY5NXgycThMak1mdldkS3R1eXFsUG1ScXpTV2QzRVk3eTJXZEc0K1ljajNCckExRHdiNU1UWE9tU0dTUHI1VGZlSDBQZXI4Uko1SnJVczVpall5Y0h0V2pqQ3Q4U1BQcjRXTGZNdHp5bTdWa2RsWUVFSEJCcDFyOGlEM3J1L0UvaHRkUVZybTBVTGNBWkk3UC93RFhyZzVTWUdSR0JCQndSNlY1dFdsS2xQbFo4M2k3NGZFUms5bVdpM2VvdCtHRlhiVFRydS9LeDJzRHl1M1FJTTEwV24rQW1sakw2amQvWjNIL0FDelJja2ZVMGxocHpkb283dVp5K0U1d05sUlZyVEhTZWQ3R1FqOS94SG4rL3dCaCtQVDhxN0cyOE4rRnJTSXRxTjlNVlU5ZDRYTmNINGprc0YxeTRHbEt5V2lzQkhsc25wMXo5YXVkQ1ZCcVRLcllocFdzVXIrM2UzdVhqZFNDRDNxaXhycVM4Zmlld0xLUU5XZ1g1MC81N3FQNGg3K28vSDF4ekVxRkNWSUlJT0NLbVNWN3JZOHVwSlMxUXdtbktlY1UwamlsWGsxQmltN2x1STlLMWJPQVNSbHljNDdWa3dqSkhxYTZleWdQMk1IR0JnSE5ieHNsZG5YR3VxYTFNWFUyQ3VFSDFOVUl6dWNLTzV4VDlSa0p1WDkyNjB5MVV0SXhHUGw1ck9Ydk81bThSelN1V29Jek5KZ2RDYWd1Z0ZtZFIwQndLM3RPdFBMdHpLM0JBckQxQlJGS1JuNWlhYXM5Q1pWMDlDaEtjY1pxTkFaSEFIVW1oK2FtdDAyZk1lcHFXN0k1a25VcVdleG9wSnNBVWRCeFY2MHpNNEdlS3lRM05hK21qRFpOUlN1NWFudlVLamJzamVpWHlZOTNRVlh1TGxwVGpQeTB5ZTRMNFFkQlVCTmRVNmxsWkhyVVlXVjN1T0xZcG9PYWFUeFFoNXJHSHhJMmxJVisxS2pVc24zUlVHY0d0cXJjWGN5VHN5d1dwaGJGTTM4Vkc4bkZKenVnbE8ybzZXWEZWV1lzYUNkeHExYld3WmhtczdPYk9PcFV1WWNlaWFqRGZ3cmMyMHNZYVFBa3J4MXJzZFNqeEx1WHFCWGFOYk5NQ0VpYVE5Z0Z6V1RjZUZkWnVTVERwOHplbkdQNTF2Vm91TVdscVJsVkNsaFZQbW52MzBPYWhtM1lPY0dra0pFcXVPdWFzMzNoM1dkTnVZNDdqVHJtTnBUaEJzSjNIMEJGZExaZkRmV3JxS09TNWxzN01NTTdacGNzUHFCbkZjY1ZVbXVXeDZrOGJSakM4NXIvQURPY2tjOWV4K2FxN3ZsZ0s5QW04RytITkpSZjdhOFNMNWdYL1UyeTVZL3pyQXVyUHc2WlFiRkw0eGorS2VSZm0vQURqODY2WjBLczlFS0daVWFtbE5OcnZiVDhUbVkzekl4SGMxZWpobXovQUtsK1A5azFzdy9ZYllBeFFJbU9qWXlmenAzMnRaUHZkYzF0U3diaDhVaW9ZbVQwVVNsQ0NNQTFlamI1dWxJV1NUTzdrWjRZZGFmRWhBNjU5NjZZeGNSU256YmxsSEpVcXg2aml1QzFqdzlkYWg0bVMydGwrV2JEcy9aQjNKcnV6bGNISFNzYlZMMDJyTXFjTTNmMnFjUkNNb3B5NkhuNHZCeHhVRkZ1MW5jNmFMVmRJOEthT2RPMHVNUGNiZHIzYmRmY2l2T2ZFUGlhNmxKaGdka2pQVmdlVFZtMFpiNHlsMkxZOTY1VFYyYUs3YVBIR2VLOCtXTTU1T2xUMFBEeEdNbzRlVG9VZCtyTEVNalRXamxuTE1QVTFueU4xcUtPODJLWTkyMEhyVFRJRzZObXBzK3B3dkZjK2pZK0s0a2dtU1dKMlNSQ0dWMU9DRDZnMXN5WDFycmE1bjJXdW9ZNWt4aU9iNi8zVy9UNlZnTWNjNE5LcjRCT09hZGpuZGRRZDJ5elBGSmJ5bU9WQ3JEc2FqRGxUL0txMzJ1Y0RZWExKbjdyY2dmVDAvQ3BsdXdzZUdpR0QyQnBPTFFsaWxmWFFzeHlnT3B6ME9hNnVLL1JkTTJqSEM0cmpZM2ptSjJxd3hTdnFEQ0l4b1RqcHpTYWIwQ3RWNWttWExuYlBkZ2pwMU5YN0pZNEVKSUdXNU5jM0hjdXJnazVyVnRFYThKRFRzaWpxcWpyVXloSmFGMEZLdkxraHViYzJyUlJ4N1F3T1A0UlhQelBMZVRNNFVuK1FyV1d5dDRSd200K3JjMDJVRHNNQ3BVdVhZOVdHVXpqNzFXWHlSaitUNVp5eHlhWGR6VTh5ODFDcUZtQUhXbXJ2Y3dsVDVKV2lXTGVNeXNPT0szWUU4bVBrY21tYWJZN0lnekRtcFpXK2ZBNkN0dVhramM5bkF3NnNYcnpTRTRwQWFheHJOdlM1NnR4UzFDSG1vaTFPUnFLYjk1R2JrVHMyVkZRdWNHbkZ1S2lrTmROYXppUTVDTStCVmQ1TW1ra2VvbE9UWEpmb2N0V28yN0ZpUE9hMDdhUUxpc3RUaXBsbEsxMDAya1RhNlBSRjhTYW5ZZ3JiM2pvdmNZQkZWTHJ4cGZDWlpHQ3NWSE8xaUFheDU1eUQxK2xaTnhJV0pycHJWbkZPeDNTdzFGNnVLTlM5OFo2MVBLN0M4ZEVZL2NWanhWRzQ4VWFyY0tWTjA2WjZsU2NuOGF5cEdxQXRpdk0rczFPNXlWSVUwOUVYRm1kcEM3T1dZOGtrNUpxNUZldW94dU9LeVZrL09wRmJpbEhFU2k5emFuVXNySTJ4ZHM1QkpxVmJoaWV0WThjaDZWYlI4MTFReERrZDFPYVpzeFhSSUNqdFZ5eHVSOW84c25rMWh4dmhoOWF1V3JiTGhKU2NZTmRjS2paZFNLc2IxeGNKYlFsMzdkQjYxd1d1YW84MGtrakhvTUFlZ3JwdGZtQXRvd3JBN216a2ZTdlBkU20zTnQ5VFhQaTZqazFUUEl6REVmVjhPNXJjMi9Dcys2UmxZOG1xdmlXMkNYbS9IV29mRGN2bDN3VW5yV240cFRJUndLOGQrNWl2VS9Pbkp0dHRuR1hLQlpPTzlNUlQ5NnByc1ljZlNuS29FSyt0ZW9uN3FOT2EwVUt4eEZUWWZtQm9sNGpxT0Y5dWFTV2hOcnhHU0RiSVJUcFNDaWdVeHp1Y21odnVyVjIyTkxiRnJUd1dsSTdWQmNKNWR4SXZveHF4YXFVaU1vT0RUTlFIK21PZlhtcFV2ZXNheWszRlJLeS9lRlg3TzZFTndyWjRQQnFIVG9CYzNxUk4wT2MvbFdscUdtcERDV1RxS1UycjJaNkdEb1Z2WnZFVTlvdjhqVTM1SEhTb1hhcy9UcjNmRjVUL2VYOWF1Ty9GWTh0blkraWhpbzE2YW5FZ2w1cVhUWVBOdTFIb2FyeU56Vi9TTWlmZFd0UGM0V3VhWjAwNkMzc3NqZzRyRnpWL1VKeXlLbFp1YWVJbHJZOWpDeDVJYWo5MkthV3BwTk4zVno4eDBPUUUwcXRUQ2FRSEJwSjJabHphbGpkVWNoNHBOM05Na2I1YTZlYThTWlMwSUpEU0owcGpOazFJblNzSXJVNCthOGlUTkc2bUUwaGF0R3krWTNwWkNTY21xTXBxZDI0cXRNYUswcm85YW85Q3RJYzFXSjZpcDNOVlhPR3JrV3A1VmVWaEE1RGdWYVE4Vm55RTdnUlZ5TnNvRFRrdExtT0hxWGswVzFOV1luNHFrcHhVNk5SQnRIcVVwMk5DTnNtclVVbkdEMEZVSTIrWE5UbytEWG9VcDZIYW5kQ2FoT1pJVlhQM1NhNDY4T2JnajBGZFRjbklOY3BlY1hiZzFuUFdwYytZNGlkcUNYbVhOR2JaZklhNlhYMTgyeVUxekZnUXM2TjcxMVY5KzkwOEgwRmViaWRLMFpIeFc1d1Yzek5pcFg0Q2lvcHVidjhha1kvdkFLOUxvaTMwQ1FaanFxT0t1U01Bb0JxSm84cnVIV25Gamk3SWphRnNiaDBxTTlCVnFLVEs3VFVFd3hJY1ZTYnZabFJidlprcXlGYlRibXBOUi80K2Z3SDhxcm5pSVZhMUJUOXBiNkNvMmt2bVB6STlQazhtN1dUMEJyV211eE5FUWU5WWljRTFZQklGS29yczlmQTRxVk9rNExabFlPWVo5eTlRYTE0NXhKQ0dGWTBuTG1yTm5KZ0ZTZUtxU3VybVdFcnVuVWNPakxidHpXOW9zQllicTU4Y3lEMHJ0dEF0d1lSa2RxdWxIVTlXaEwzbkpsUzdpY3laQXlLcStUSi9kTmRqL1p5dnlSVVVtbktPaTBUcHFUdWQzMTlMUkhKR0NUSDNhaFpXWHFLNmVlMDJnL0xXVmNRYmM4VkRvb2NjVTVHU1RTYnFrbVRCNHF1VGcxaktGalQyaE1EU1NINVRUUWVLYTU0cHA2QktXaFh6ODlUQThWV0IrZXB3ZUttTE9XbkljVFRTYUNhYVRTYkxiTmh6VUVoNHA3TjYxRTVwejFQVm5PNUEzV29KVnFkNmhrSEZZUk9DdHFpcS9XcG9HNHhVVGptbGlPR3JSNm80SVBscUY5VG5GVEpWWkdxZFRXYVBYcHk2bHVOdWxUQnFxUnRVNGF1bWt6dGpQUVNZNXJsdFdYWmM1SDhRcnBaV0djVnp1czh5SWZjMXA5czhQTzBwWWQrVEcyTWhEcjlhNnFTNEIwcHo2TFhKV3cyeDdxMG52TTZZNlo3WXJscjArZVN0M1BoM3VZZWQwK2FtWGwvcFZZY3NUVWtKTzgxMk5Ha2xvUHVlMUpDK1YybW0zRFpiRlJLY0doSzhRVWJ4SmZ1eWZXbXpZTW5GTmRzbWtKelZKZFNrdW80bk1TaXIybzhYY241VlFVWndQZXIyb0hONUwvdlZEK0pDWlZRakpxY0VZcXNUam4zcHl5Y2RhYlZ6cm9WRkZXR09Nc1NLUkhLWnA2anFhaXFsMk1lWjh6YUx1bnl0OXJWQ3U5V09NVjY1NGUwdGhicTJEakZlYWVGN01YR29LN2pnR3ZlTktnampzRnhqcFZRdmM2YVZTcEJlVE05N2NLS2dlTmF2M2piU2NWa1RYQkJ4Vm5SR1RZMmEzUmdheHIyd3lDUUsxVmxaalVwakRyeUtvNllWSEU0Uzh0V1RQRlpUZ2cxMjJvMlFJSkFybHIyMk1iRTRyR3BEVFE5R25WVWtVUWFTUThVaDROTmM1V3VUWTBjdEN2bjU2bkI0cXVUaDZsQjRwSE5UbHF5VE5OSnBNMGhOSm1qa1hMZTVGeGJxNDY5eDcwOHR4V05wMC9sdnRKK1Z2NTFxazFwTmFsNExHZTNvcVQzMllqa1lxTW5Jd2FIT0RVWmFzYmFtazVqSHFNSERDbGRxaUpxMGp6NXoxTHNiOFZNSFBTcUNQeFU2dlVPT3AxMHEraG9STlZoV3FqRzNOWFl4bEdjbmdWMDBvSG9RcTZFTXNtWmNlMVllclpaMUE5YTA5eGVZZSthejdrZWJjZ2RjVlQwMVBKekdvcDBtaHFwNWRzYytsVm1mTUJGV2I1d2tPMGRhb0hJdHhudlVRVjFkbnlialpqWStocWFGZG9OVjA0T2F0amhLdVFwbFdVNWtOTXBXT1dKcEswUm90Z29vcHpFSEdLQmo0UURJZ1BjaXJONGQxeklmOXFxdHY4QThmRVEvd0JzZnpxeGNQdW1jbnV4ck4vRVJMY3JNT1B4cGxQZnRUS3RGSWVwd2hwbE9iR0FCVDNDZVdNZGFDMURjMmZEbDRMYTRBejFOZTA2SmVDZXpVWjdWNEJaa2ljRUhCRmVtK0dkYlZBc2J0amluQ1ZuWTdvYzFTa24yME81dTF6bXNXZFBtcXhOcWNiTGtNS3o1TDFDZW9yVm8yaEJrcUJWTlRDUmNkYXkydkZQUTAzenlSd2FEUjBtWExsbFpUWE9hakdweldsSksyT3RadDBDd05KczBwTnhaems2aFhOVjJOWExwQ0hKcWkzV3VXcEU3WExRZ2Y3MVNxZmxxR1E4MUpHM0ZaMk9hTXZlWTdOR2FhVHpSbXBhTk9ZellzZ1pIVVZyMjgzbVJnSDcxVXJDeW11bkN4b2NaNjFzWFdqdFp3TElqWllkUlc3VjJlWGxrYTZsS1VZKzZWcER4elZjdFZnamZFSEhQcjdWVWs0TlJLRmowNmxTK3FFWnFqTFVqR29zODAwamduVTFKMGZCcVpINXFtcDVxZU1rNG81ZFM2VlZtbEJsaUFLMXBJL0pzUDhBYmM0RlZkTHRXa2RPTzlhbDd0TjJzSzRLUkx6OWEzdW9ST21waXVWY3FNNk8xMks4eEh5b3ZOYzJia0xjczNwWFllSTdtUFR0RWl0Vi93Q1BpYjUzOVFPdy93QSt0Y0x0eVNLalJyVThyRjRqblhLRTh4bWszSHBUcFQrNVJmU29pakR0VDVlaS9TblphV09EcWhBdjdzVk03NGkvQ2hJOG90TW5HMEFWTjdzaTkzWWdvb29yUTFDaWlpZ0NXMUdidUVmN1kvblVzMytzYjYxSGFmOEFIM0YvdlpwMGgrYy9Xb2Z4RVMzSVg3VTNGT2ZxS1JUelZGTFlEU1VwNjBsTVkrTnRzZ05hMXZkdkRLcktheHF0cEpsQjdWRTFyYzdNTFY1YnhaMUtheElRQVNjVllHb0ZsenVybllIM2dWcFJLZkxxcWMyOXoya295WE1pOHVvRVBnbXRXMXVoSUs1WlZacE1ZUFd0N1RveUFNaXRGSzdLbEZjdXBySDVxaWFBdU9sVzRZU2UxWGt0eGpwVmFISEtTUnl0M1lFZzhWZzNOczBiSGppdlFybTJCWHBYUDN0bUNUeFVTamMwcDFMNk00MlZTRFNSbXRPN3ROaE9CV2VVS211YVVXaW5DejVrS2FTZ21reldiRzJkYXFRV0tpS0lENmlvcDVmTUdPMVV6SVNjazgwR1hpdEoxZExJK2hwS0ZPUEtrUXRDcVNGbHh0Yjd5OXFxM2xrVlV5UjhyVnBwTW1reTJQbE9QWTlLeWpXNk04bkY0SnR1VkQ3akJjWU9LaUpBTmFONWFzK1dWQ0Q3Y2lzcHd3YkRBajZpdDQyZXg0TmRUZzdTaTBTQmhVMFVnQnFzTm9YbHFVU0lvemtrMVMzTW8xdVU2K3p2WTdPME03RWJzZktQZXF2OW9oTXlzY3RuSjl6WE9pYWE1S3J1T0IwRmJsalpSUm9IbUpQZm1va20zcWE0YWpVeE0zeWxhNzgrK2FXN3VTY2tmTG50V1NoK2V0clZycGZLRWE0NTRBckRVL3ZhcGFvak1hVk9sTlU0ZEZxWC9rTUdNRE5aODMzd1BTcGhOdGt4MnFLWTVsSnBRVm1lZEc5eXhISmdEMkZWNTMzdlRsUHltb1Njbk5WRmEzQ01kYmlVVVVWWm9GRkZGQUU5b1A4QVNVL0grVkRFYmo5YVd6T0xnZjdyZnlOSTNKUDFxSDhSRDNJbTYwZzYwTjk2a3F5Z1BXaWlpZ1lWSWpZVTVxT2xCeFNZWHNYck9ia0ExdjJjaXNBTzljbkcreHdhMmJLNDJzcHpTWHVzOW5BMSthUEl6cjdQU3hMaHdNMXVXK24rV0I4dFZkQnVvNUVVRWl1cGppREx4aXRyRjFxMGs3RkJMYkhhcDBRRHRWdnlLWHljZHFWamljN21mUEhsZWxZZDdGMXJwNW9pUldOZVc1NW9OS1U5VGtieUxJUEZZazhlMWpYVlhjUFhpc083ZzVKeFNrcm85S0VycXhqc01VeXJFcVlxczNCcmxhc3pPb3JHNDFSTm1vMHVoSjNwZDJlOVRLS2JQWjl0R1N1Z0o1cFFhT29wQndheDVRVWlWV3BXVkgrOGluNmltS2FkVjJkalJPKzVtNnZheHJiQ1dOQXBEYzRGWWxkSHFIejJVaSsyYTV5dWlpL2RQbDg0cHhqaUx4VzZOeXdpaFMwU1FqTEVjMDY2dmdpNFhyVkdLYlphRG5wVU83ZXU0OWFqbGJkMlhWeDZvVUl3cEt6YUk1SkdrazNPZWFqTFlmTk9iN3dwaDYxdWtlTTI1TzdIRDVuQm9rKy9RbjNoU1B5NW82aTZqa1BCRlIwOWVHcHJjRTBCMUVvb29wakNsSXhRcllwMGhCQXhTRmZVa3RQOWFmWlRTRTB0c2NPK1A3djlSU0hwVXZjbDdrVDh0U1VyZmVOSlZsb0tLS2NGSkdhQUcwVVVVQUZXYmFYYWNHcTFLcDJuTkpxNXBUbTRTVFIxR202bzlvNm5KMjEyVmw0b2oyamM0L092TjdhUU90V2VlMU9NMnREMnJScXh1ZXIyM2lDR1EvZkg1MXB4Nm5DNEhJcnhkTG1hSS9JNUg0MWRpMXk3aXg4K1JWOHlaenp3eTZNOWYrMFJPT29xcGNSbzZrZzE1ekQ0cm1qeHZ6V2xCNHVqWVlMWW91akgyVW9zMXJ5MTY4VmczZHNlZUtzeitJNFhIM3hWRnRWaWxQQkZGenJwVGEzTW01aDJrOFZuU3BpdDJlV0tRSHBXVk1GeWNWbFVpZFVtcG9wYmlweURWbUtjbnJWUTlLV1A3MVlOYUhOVHF5akxRMDFmTlBCcXNuU3BmU3N6MW9UYlJPRGlrZDhjVWkweC92VmIyTlhKcEVkdzJZWFgxQnJueDFyY20rNmZwV0dmdmZqVjBlcDg5bXp2S0pJN2Z1Z3Z2UkVlQ0tqYnJUNHU5YXRhSGt6Zk10UndIelZHL3dCNDFOVUwvZU5DSWp1SXB3MUt4K2MwaS9lb2I3MVBxVjFBSDVzMDVpTy9XbVVyZGFBRW9vb3BqQ25OMEZOcHpkcUJFbHZ3WkQvcy93QlJTL3cwa0hTVC9kb0hTb2U1TDNJbSs4ZnJTVXA2bWtxeXdxVGNCR2ZXaGY4QVYweWx1TGNTaWlpbU1LS0tLQUpZSlRHL3RXdkVmTVFFVmgxcmFlVDVhMGJIZGhLMGsrVW5aRFVaQkZYVFVNZzYwejBXN2xPUWNWVFppcDROWFpPbFVwT3RUSmFuRlgwR21WdldsRnc2OURVZElhVmpqOXBKZFMwTDErNU5LTHZQZXFWRk5vcFltb3VwLzlrPVwiLCBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELy9nQTdRMUpGUVZSUFVqb2daMlF0YW5CbFp5QjJNUzR3SUNoMWMybHVaeUJKU2tjZ1NsQkZSeUIyTmpJcExDQnhkV0ZzYVhSNUlEMGdOekFLLzlzQVF3QUtCd2NJQndZS0NBZ0lDd29LQ3c0WUVBNE5EUTRkRlJZUkdDTWZKU1FpSHlJaEppczNMeVlwTkNraElqQkJNVFE1T3o0K1BpVXVSRWxEUEVnM1BUNDcvOXNBUXdFS0N3c09EUTRjRUJBY095Z2lLRHM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzNy84QUFFUWdCbWdGQUF3RWlBQUlSQVFNUkFmL0VBQjhBQUFFRkFRRUJBUUVCQUFBQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVFBQUlCQXdNQ0JBTUZCUVFFQUFBQmZRRUNBd0FFRVFVU0lURkJCaE5SWVFjaWNSUXlnWkdoQ0NOQ3NjRVZVdEh3SkROaWNvSUpDaFlYR0JrYUpTWW5LQ2txTkRVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmc0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaDR1UGs1ZWJuNk9ucThmTHo5UFgyOS9qNSt2L0VBQjhCQUFNQkFRRUJBUUVCQVFFQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVJBQUlCQWdRRUF3UUhCUVFFQUFFQ2R3QUJBZ01SQkFVaE1RWVNRVkVIWVhFVElqS0JDQlJDa2FHeHdRa2pNMUx3RldKeTBRb1dKRFRoSmZFWEdCa2FKaWNvS1NvMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvS0RoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1TGo1T1htNStqcDZ2THo5UFgyOS9qNSt2L2FBQXdEQVFBQ0VRTVJBRDhBNmE5dkxxME1rV3FUd041cTQyV2ZERGpHZDM0ZEJqT1B6eTlVMUdEVHJOYlY3aEwyeW1PRElRV2t0ODR3eXlIcU9PaDZjWkpHYXFRM1FhOWs4MkpaUk5rQUhCK1poMS9Xck10cHAwbGdSYTI4L21uR2NTZnUxT2VtZlUxNC93QmRsSk96K1hrZWtxU1Zybkw2cjRkTCtINDlmKzF4VE8wN3g0Q2xXZFFjRnZ6eHdPeHJtWndKb1pJdHlvY0E1SjlUWFMzbDJiYlI1dE5FU2VTOG5tS3JMbG8yeWVqZFNDRHlELzhBV3JrTHVObXVnVVhrZ0FHdStsVWpVU2NkamxxcXpMTmk4WmtRTEp2Sko1eFhUYVZOSllLczhZQ3hoV0RPdzRCL2h4bnFjbXVZdG9uV2J5bWZQbHNNZ0RqUGV1dWowKy92YktOcFhDd3FNeEtNL3U4ajczdmtmWEZjMk5xS0NXdGgwWXRrYWFIZEcxUzcrMGd1UXhjc2RycXhJeG5udjFIdDlLNkh3NUhjU2FmY3BIT0NnVGU1TWh3UUR3RzUvS3FYMk9SdEs4dVNCWkRidDh4VEp3by9pSHR4MzllMUdueFA1YndTUnZDcy93QXhkdUNlNEhIR01xT2ZXdkxWYU1uZVczcmE1MTJhMlJPYis5djlZYU8zTVlraExNRjhzQkUyQWsvTWV2QVA1VmN1dGZsUzh1bnNKbzNTWXE3VHhLRjdad0IyNjQrb3FLV0NLTzNWckk3MVlBTjgrMXNjWlU1NEk3aXNpSXdUcE9vaGVFeERhLzdzaFVKeWNEcnh3ZWUxS1ZhRW8yaHYxWk5tbnFhbHJxajNDcEZzQmtFbnpTYmdPdUFDUFRHUGNWTnA4TUVzRDdpc2s1VFBtT004ZCt2VTU0ck5FVnBCQ3NjMjFDeWJSSXJGbExlK08vNmMxcWFXcGloZUp6RU91Q3crVlY5eitQVDNyZ21rcnRHa0x2Y1pKcGRqY1dzMGt3Z2pSRXlERW95TzRPZnBYT05lMjhjTnZFckx1bWNPSEtiVkk2WUxkdTUvRHRXcHJjazJtNlpxTjJaRVhlbzhrS1Q4b1lBZXZyMDlCV0ZQZFdiNlpBOS9KSGN4M0lNYlBiZkswYmdBNHgzeGsvalhaaDZWMWU3YXYraG5WMzBOblF6L0FHbGVib3RzWWlCV1VoUVl5UjB3ZTQ3a2p0OUs2aVRDVzRkakRFVkNzR2Zibm9PbVNQNTlxODg4SzZ6ZWYyYzJsMkVJbHVaSm1jU1NLQ3NhZE8vdmtrbjJycDdYUmJXNGprZlVyeVdlYUlFdENoMnFRT2dIYzgvVGp0V1dKdy9MVWZNN0piZFdPRWx5azE1ck9tUXA1VnpxQ3pubEdjcVNTckU1NFA0ZCt2TkpkK0x0S0dyMnR5azBTeFJJeU1NWUdEdHdNYzQrNlRXbllhSnBrRW9mK3pyUlVjaG1MeEJpZ0E0UE9lRDEvSDh0Q1RUOUpsamJ5Yk8yZG1BVmhzWEM4ZGg5T1RVd1ZGUWN0YkwwQnZVVFRkVnM5YUlHbVhNVFNBWk1aYkFJOXU5WGRTczVoYWI1WlNDdkFSZVMzK0Zjb2ZEdWwzS21TS043VzVqYmFKYmRoR3dJNjlCZyt2SXBJZE04VDI4aGZUOVdTOGlYZ1FYNjQzWVBRSGtIQjc4VnZRcTRhZE4wbmU3N3YrbCtSTW9TVXVaR3VsbExjWGxwYUtCdCthYmJnQXFGeUFEN1pOTmV4dTdlL0V0MFNkaXIwVWs1ejF6OUt5YkR4dUxmeEN4MWUxZlQ3Z1FpSERjeGs1SnlENkg4ZWxkeFlTVzk1YkxkU1R4SEl6a1NCZ0IzNXF2cWtaeDluRmU5MzZXWVNxU2pxOWpuN2lTYUNSYmEzbDJ6eVpjUElNckdtY2JpTS9rTThuNkhFTTlwRzdZbnVaSkZZWks3Z3U3SnlPZXYwd2VNMGpEVWRVbXVXczdXR0dDNmwyMjkxSUNXV05WRzBoQmpBSkxIay94ZEtYL2hIOVJoaExQcUozWndQTGpBSFgwT2E0S2xMMmVpa2swYVJmY05OaWtlVnJmY3dVa2hWMm5BQTQvREpISDFOYTE1WTNUb3l4T0V5MlczZ051SFBGWTFucDJyV3JyTGI2anVZUGdvMENsUU00enh0SjlldjUxcmorMG14NXVwV3BiL0FLOVQwLzc3cGZ1OWVaNmpkNzZGbExhYVcyaDh4bHd5QU9PaHBndEVqVmxDRWRjalAzZ2ZXcXJYV3JRUnNDMXJkRGRnR1BNVGRld080ZnFLaWkxeU1FVFhTeVdxdGtuemx5dkhxd3lCejJKRlp6VVhad0JLUkhxVWw2SVdoc1kzWXIyWEkyY0RwajZpb0VhNVdJUnl6TjlwSStYYmx1Y2ZyLzhBcXF6THFadVRHbGdRSVdBTFNJT2gvd0QxWXFPNWsySkN5Z3RuR1RnOWVtZW5VaXNiMlhMYlV1MTBVcjYwZTZkNGxsYU12OThNblFBZE1mMXExNXlScHQ4cVJZMlhhU0FlTWRLZzFIN1JMYm1LTjBqTWhERjI1TGV3eVBTcHBaN2hMZllIaU1Canp0T1J4eGoxeU92MDQ5SzJVWTFMYzBoMmU1aWF0cHQ1YTNFTjVhSjV0dmJNc3J4SncvR2VjZTRJSDRWUjFEU0xvYVhQcVYyN0c3UU00V1BrTDB4dVBxTS9UMDlhNkY3MmN5V3VKWXpCdEFIKzQyRG5QR2V1Yy95cWxxc2N3dDIrenpxaWdNOGliQXhsQkh2MDcxMFFyVGpLTUwvUDlPb0szVXFXMTBvUmJReExIR1k4Z2RTVDNPZURrbitkVzdWNEkza0UvSEJJdzJjSG9SV1cxMjhWb3NPMGVmdEc1Z295RGpwVWRrYmgyZmRHMFVxamVJaVJsd2UvMHpTblN1bTlpbEp0cmxORjlUanM3Z3hSZ3A1aHhoL3V0L25tcTVuamRKWlgzUmxRTTd1VjU0QXFXVFQ1SjhHWlltS3NDQXpja2QrZTFRNmxBYmU2aVlXdVk1Q0NGY2txcEI3RDEvR2xCVTdwTGNIR1VaTjlCcXA5cFF0dkRyR0EyNVFTY1pQSTl1UDVVOFdFenI1OGtoZnpFQnlPZWNkODQ2ZEtsc3NYVnhmR1M2OGw4STBlVXdjRE9SK2RXRSt6UVdmbXZMdUdSdXlDUTU2OERzT3hxcE5yUkdjWXFUMk1LTFg0clNCYmU2a1hNYjdqdVlZSHVwNjg5ZVBRZEtkUDQwdXAwbXRyQlpydTNsYmNSR2hBT2NIazlBUVR6OUtqT2lRTEZHOXE2RjRsTGh2TFQxNk53RFdsWWVaZCtZcXg1ZU5jRlRqTWJkUjgzWWQ4OSt2clhwd2RPNzVFMnlIZDc2SE03dFVrbW5obGhpdGxLbG1XVEpJd3BPTTR4enpqMUpIc2F4cnBwSVdXVlV5b3g4MmVoeURYVTNLWWl1NVN3TWUwb09wQTI5QVBZbnZYTlg4VWx6OW50b3ZsSkpQelY2V0dueksxcldPT3JHMnhiMmJMaHlpZ0RjU2Z4NS94cnVORmE5dTlLakVOdnZFU1l5RkpQR09UK2Y1WXJoWVBPTDRjWnlveWZjY1Yydmc3VVlkVnNuVVhpUi9ab2dXVW9Od0F6Zzdzai9JNXpXT05wODhFbnNhVUpjclp1VzBua3pLOHlORTVYNW5kZnY4QUFCQjkrL1QwOWFwekpGTUcycUdQUUhIRGZqeC9rOWFrMUc4dFdqbUxPbDRJOEt6cmdNTWZkYkk2amtEbnAweldkRmVoYmpZZHJQTmd4eGdna2s5RFhnVG9PTHZHNTNSa210UjdRU1F6ekcybEJXMlVtUkNwQy9VWkhQVEdQYWhkdHhDNGVXT01DUGZMNWo3a0djampwNkdyTnZyTTVpSVcwYWRRUzRVbkJLKzJQZXMzV0x1ODFLUVNXTmtMTXpxc2NwSjNBS0dKQkJ4a2M3czkrT0txbkJUaytaMk1wV3ZvaFo5cVRoYlpneVNMOXhVK1ZHSE9RZTJCNy95clZzTFVsc3p4dGNFcjBKd00vd0JjZTlXNExPMmVIeTQ0SkZWT0FWSlBzRDlNVTJ3MnpySk5HK1FUdGRXWGxUL2Q2ZlRuMElyQnpjOUk2VzdsT0xpY2o0NXVmK0pTOGNpc2o3MUdBY3JuQkpJUDRDdlA0RHVaaWM4S1RYcFh4SVYxMEdLTGFOaHVRUVZVOEhhM0ZlY3hadDRkenFmbUpVS2VNNC8rdi9Ldm9zdWFsaDdwZFRncnBxZXA2QjRUMDlVMEtPYTNZNzNKTGxVN2c0eG52MC9PdXUwNktHNHcyVEZPbzZua3NjOXVmZXVmOE9XL2wrSHJTQjVHKzBCZDBqQVpVQW5JL1E4K3VLMVlycFk1d2tiTWRuR1ZVZHlQNjE0K0ptNVZaVzdtMGJKSTJiT1B5cHBZbWdhUElDN2ljNUdBRDZEaW1YZGs3cm1HUm9sWGxvMFlNZStDRDFISS9URlU1dFdkR21TUXNBcTdXQVVBakdNQS9uM3E1RGVRYkI1dStWM1VIazVMWStuMXJqYWQ5VVdwRkUyMTFiR014U0UvSmwyYkdSak9jTCtGV1o3NEMzWUNCdkxLNTgyTUVnREFOUUxkU1NrUTc0d2pNQWh4MEE1NEI2OENvNTdUVTd1NWxleGdiRUp4SVp1Rk9jL24yUEhyVlJweXF2bFVkVFJ0VzNMTnRhV2R4YXlpWkJjeFN4akViREk0eGtZUDBxaVBCdWgzTjR3amdsV0tNN25pU1p3cE9PRnhuanFUeDdVcytvVGFaTEZHR1NhYVg1Tm95TUgxK25iOHEzTE5VMDJFQU1ESzJaSlNjZmVQWCtkVlNsT251N0lIYm9VcDdTNjAyOFNUU0lKUEtWQVpyZHBjaVZlbnk3dWpqNmpQZnNhdDIydFdkeXlobWx0dCtWV09lTm95eDl0d0g2Vks4Z2RCTHZieWx5d0EvVTQ3MVJhNU54RExITmJqQmlkMVNUZ1lBenRiMFBVODlxTmFyV2wyS3k2bW9KWE1URkJoaHhXZGVCN3UwbGlobldHZmFkam5EWVlkQ2VNRVZCcGx5OGxqR3NabGxoS1pFcEJKUDFQK2VuSnBxNlZEZTNNbTI0ZUxlRkpWQ0FlbVA2ZnpyQnhTbHE5aTFvVytGdGVaZGtxTGtuR0J1N25IcG4zcW1adk5pK3psdkwzRWxlTytPdjhBbjFOV3BiVjQ3WUNJbmRub2VuZjhheklKbzc2Tm9ab3dqS2dYYzdaSXovRmsrNEg1ZTFacU43dGJJcU1sZTVQWldFVWN4bFFJci9kTDdldjE5ZjhBUE5PamdsU2VaWk9DVHZHMG41bHgxQXgvbithUW9sdUhNenFJVjVqZCtjSEhmUGJucjI1cTdiQlo0bFFzUklIUEljWlFxZTJQeS94b2FkM3pPNktsSzJxTUNFU3lsWmlIOGlZa3EwZ3dPQ2VRZTM0OUtiNWx4S3dFc2pReUw4ckZtVTVIVDhSejZlbGJzc2xzUURKRXN1MTJBSVhKN2pPUFE4ZXZXcTBObEdxZVlzYUxFQ1dYYVFRZmZweC85YXRuVWl0YkRYdk15QzR0THJUYlh5cEhRUElxeU44NVU1SkdNZEtqbXVHYWVSV2J5dkxjcXhZZmVYSERESS9Tck1yVHgzU3JQS3NEc0N5QUtDUmpHVDcrL3RVYzBsbEs1TnpQRzdsY0ZaTXBqOFR4aXRlYm0xYXUrLzhBWDlhQTRhNm1kSE1YdWdZNHkwTC9BSG1KSHpIdndlblQxcXhGYXF0eXMwTHBGSTNFaURrK3BINWdVWDBXbldVZHZDcngyNnl0dkc4Z0VIcitQWHZXakZaeE1nbktCMWpIeXNBRi9Xbk9wWko2Nm10dE5RT1NwT2M3SENrSGduLzYxVlh2VUVoanVDMFlPY1NiT1AwOThVMks3amFkbXhFNDNiU2Q0QjR6eUJTaWMyczR1Tmt4S3RrYjFPTS95SDhzZlNwVUxPelJtL0prVWRsSlBOSktpSElQRWpqQzR4MUE5ZURTM2w0c2tFTnNJWTFTUE80cDFrNm5taTMxZDl1SHVYTVpVa1I1QU9HSkl6NjFYU2RwQXhLN0F6ajV3M0hKNTkvOG10M3pLVFNXaG1tbXRkeW9MMnppWHkvT01NZlRiTUNwWHZqa2ZyVUV5VE02eVFQRE9JMFloZ3dBZGV1Q1IrbWU1clFnZG5TU0pRNEM5Q0YrOFBiMjZWVjFTd3RKTFJycVdOWXA0enkrUWhmMVVrY25QQTl1T3RkRktVVkszL0IveU9lVWJvWkpOYTNYaGt0NWZsemJRU1FSc1lGdWZmUC9BTmV1ZmdMdnFzVEFZQ29SajBHS21lQ05ZWFZabURxTStVOFl5ZDNVN3VPaFBwVU13a1c0Y1JPNnFSbmp2d2NWN0dIaHlKblBOdDJ1V1kvOVd6bnVTZjFQK05XdE9rYTJuMndoSkpIZ01UZHNaNTQ5K2ZmOGFvUW4vUjNRY0ZUait0TG84OXhCTE9zdVVtdFpWa2FYZGc4OGNmeno3VlZSZjE2a3gzT2lzWHZVVEVkbDlwY3VKQTVHYzR5Q01aNS9IMHFxdHphUGVwRmMyN0pIR2Qwckttd3hrZ2RjOU8zYXRTMXRCY1hLbzJ2YWpHb0gzbHk0UFAzUmdaNUdlYXJud3JibTZjMzJxVG1DWEtxRmpPK1hQUTVaTVo5UnozT2E4eDFJOHZ2eTIyV3Y1V092bDdHemUyZHZhV01WeGF6elRBTGtDV0xheEdPTnBHZmZuMkhYcFZmUllwTmlsY01KRHVNVFpJNjlTRDA1SFQweFdkRjRNbTB4MGswRFVieXpsTERlbDFLQ3JEam5Dam5HUjB6V3FtdmF0cERDSFhMSllVQndMdUE3a2ZQeTd1dlQxNC9McFdGV0VhaWNxV3E4dC91S2pwbzFxZERCQXdnaDNBcUlqdFZFZkdWeU9LZ21tQllyYmhRTWNSeGpMTTNmUEhURlo5eHFOc21vRzJQejNLWkd6NXM0T1BtQXdSajNCN1k5YXQyeUVUTTZ5NTNIQjZqOU85ZU5LUEw3ek45V2NMNDh2R251N1MxWkRFcnA1cjVKT09vN250ZzhjVnlCVTN0eXFJcENEQ3hqcjN3QjlhN2p4MXBWMXFkNzUxdEdHOGhBZG9HR1pmWEg2ZmhYSjZkWTNVV3FXVFQyOGtTUE5HVjh4Q0FWQjV4Njk2K3J3VTRMRHF6MVI1MVdNdWZ5UFRMbVZvb0EwY2NhRUtJeDhoNTdaK21LYkVKVnVZLzM0Q2duYUNPUHo2ay80MCs3WkxtSldVbkpiQ0lUa2dIblBzVFRFZUpNdWUvRzRkRk9ldU8zYXZDdm9iY3JOR0NXeHVkcm9DNUFKdzVHRHh6bkl6VG10bkl3U3NhN2ZsM2R4dDRIYzlUajZmaFZVRzV0b0pJeW01V1k0Ykk2YzQ3bjFwL25UWU1hUGphRGtIcHlENit2cldUdWgyVnRSeW9MZUFMYzdUNXkvSW9iNWxKSGJyMDU1NmNWYzA2NGtpMDkzdUh1SkVrSGxDUFpoMVUveGMvVTU0cUsxU1NTTmxsQ3M3S2RoempJUFFmMC9PbVFTcmIzTWR1c0pWamt5UnYzMi8zUjM2ai9BT3RSU3FUak84VnFhV2k0MlpWVFNwbm5qbGtUay82eVZseVFDRDdIb1QrR1QwcmNobVM4U0krV3cyQUg1MUc0NDc5T3BxeGJSUEw4dXdDQWc1ZkE2RC85WDZWVHVtRnRQbU5GRzRuNWw2WUhQSkE0L0dxclFycGF4LzRZbUxqZmNacVVraUJGZ2xFSlp0clB0M2RzanVQUSt2NFZXTjNJTkxpbWFVU0ZmbTNxT2ZRNVVIMDRxY1NzNmk0U0ZaVk9HOHd2a2ozQXdSMnFOTHlHM1VDZDJ5b3lGays4dzYvNGZwV1NkdExGM1FtblRDS040Vk95UE8yTmNqa2pqY1JucWY4QUNwYmVkM3VtMlpNeGpBZVBKd2V2USt2UGYwcXZhZ3E4cUxIL0FLb2hvMkF4dUIvWDB6OWFuYUszZ21NMFlJbmx3Q3hYUEk2NDlQVS9TczZzbHp1NVZ0TkNkcnp5UWNwam5KeU91ZWF5emNCOVIyMnl0SVVRdHNRYmR3T2ZsNVBQL3dDcXA3aTZuTW0ySkdEenI1TzA1WEJHU3BCN2RTYysxVGkyU1dWL05lTjR5Rjgzbk9TRVVmOEFvUmJrRHRXMU9oQlJsSk5mZi9YbVJ6ZDBVQmUvYVRoNVgzZ2c5Tm96Z2QvWHQycWRiSkdHWTd4WXZMWDV2TkhBK2h6d2VUanFQYm1xazF0YTJsOUxQQXBkd1NGai91ZjdYUE9PdnZ4bjFvc0xDNG12cHplTHRYSUs3WDRaY2RlditmU200SmF4ZWcrWm1qQ3F3cmhVK1JWK1dScGlSamdmMDdqRkpkeHlZamdSUTRuWUUrckwxYmdZN0RHZmVyMGF3UndGb29kNFhBT0Z3TWRBVFZTNmhIOXFRVHJNc1NORkp1amZLZy9kNmZVNDZVa2xVYTVJMmZuMUdtMXVZZXYzTVNhdllZa0FWbGtXWnM1MnI4cFA0MVZmVDVKTmIvY3FzVEpCbDFjallwWW5hQ2ZYQ2trL1R0VHRiVmIzeE5ZUXBrYlYzdXkrbWM5Y2RmbHJkMGxMWmJPU1dhSXMwekt3SE9XWEdNbm4wR1B4cnBvdEtNZWwxL21XMjBqZy9GazZIWEVqdElsdVpCRXBsL2RrRGRnNUJBUFFZNml1dXVZYldXM2p0eEM4U2xWVjBFaEt1dzZrSHNEK0ZjeGV3M1RlTG11WVlDRWFVQS9LRDhtTU1NZHNqSStwcnFacHJoNUFxaFRieklwR3hRU1R6a0U5UFRwMHJxeFZaeWhIbHQwWk1JNmxKTFJZcGZzKzFZZ3VXWFAzTUh1Zm9UU1hUd3dRbVlNUUZRN0hHQ2hiSEhIWHJqRldaVW5oY21SRkJ6aU01T1N2SFE1L1h2VksvalNVd3hBbnlzQ05BK2NnZCtQcHU1OXZ4cno0ZTgwMnkybjBGTVFqVkxhUWdxdUZ3aDRCNC96K05VTlFzQmJ5RXhveGpmNWhJMGZKUDU5YXZQR2xzeHR3cFpHQ2xaV2JNYWpHYzllb3gvOEFYcDJMU1MwWnpKSzBXQ2M4a0x6L0FDNS9TdEl5Y0hmZTVtNEtSamJKck9TTzB1aWk3aHVqZmVjT1ByNmpwaitkUlhjb21raDAxd2Rpc0pKaGs4QVo0cnE3K0hUZFlzd1lXRFF6S05qSjl6UHJqcU92YkhOY3A0ZHNwcmt6TktqdGw5clNZUFlEQTZmcFhiVGxHYWMxbzErWmhLTFRzVjdxOGgyM0Z1MFNHU1RhWTIyZ0ZDQnlSOVJ3UjcxbXhzMDl6TktGekdpZVdqRG9UMU5XSk5PbFdTYStkQ3VDVkp6eHVKNVB2VkpBMEY0c0NPM2x4RExESEJZN1QvaFhyME9YbDBkem1rM2ZVc3hLVldSaDh1VG5yN0QvQU92VzdFOGtsdmNMTmFGOTQyTkpDb2JBNmpqcWVlZW5lc01NY1NLZXlmeXpWdlNnc0Y1SGZSeHl1akVyTEVyQVo2amozQkhyMXJERVI1cmRHYVFhUjBPaFhjSGsycnpSVHVZV1BtUnFwQno3ZnAxcllsMWJUOVRtWVF4dEdpeUp1UjAyc0JrWS9sWEdOZFA5b2U0amN4U09jaEFNWUl4MUhmT0tzdnFpWEVTeWVTc0YwUDd1Y01jNS93QThWeFZxSFBIUld2cjh6ZU1rbWp0MnhkRjQ1R1VwR3JDSkpGQkpPT296M3owcUxVQnBadEkxdklsVXF4L2VSa2hRTWRndlRnOWZldVZ0YjJWNHNOYzdER2NsR1kvTU1aeG5CeG5GYmxySkJlMjhpbnkrVXlwaVVaNUk2NS9Pdk9jS2tOTC9BTmVwcnB1RVIwMjV1b1pwSWx1SFFGWUxxUlBuUFg1VDJ6MXgvbkt6eUczdXg1d1V4bHlvZU51bU9tZjVjWi9LbHVMR3kyeHY1VHVUOGhWT2VuUWo4dmFxMjkxa1czMlNHS2JoWkpPb1BVQnNkVDcvQUtaNnFTVXRkLzhBSXFOOW1YWkRETGJSc3NJOGxpQmh4a2s1QnlUOWE1ZldKL084VzJsbzBPeUJHTHJ1eU01WDVzWndNWkhiajh6V25ieDZqRGVTQ0taSmJYY1c4c3ZnZzQ0QUhUdWZ3ckgxQ3cxTk5hdDd3VE5kK1Y4ckFxRmFOQ01ET092Y1o5dWEyd3NGR283eVd6dDh6T1VtMXNkRWhVWFlFck1oWEhsNU9ReC9BWlBmNlZKTForVE15TkZsaDh4VU5rRHVQNUgxcXBZM1MvWkMza3Bsd0ZWMzVhTWpyanJ6ejJxUTNDSWN0MEpPR1BHNDFGcFJabkthZlFudGx6QUlaWkNDL3dBcTgrMlBUanFPZjUxYXRyYU1Yc2Nic0ZVS0czN3VwUDE3OWNWVmp1MFRQN3RDZWM1YnYrUHZrZC81VWwxcUFhZG93NUoyZ3FWeHdTT093cWJOa3FYVkd2YnpXMGx4SmJ4RkcydnRMRTRZQUhQYmdIajBxUTJMVFgwczBVaXprNCtZcmo1ZlVIOGF5bzQvc1JIMmU1TGJ4aVF5TGpHZUFPcHp3T2Z3clZzcG90RWsrMVhFVWtpWEM3Y2dmS3ZKNlo1T2Z6cnJvMDFPVFV0dDIxMllwVGFXaDFDV1VTV3NZV0pjb20wS1JrWTdqRmNEcU03NmRjVFd6NzFQbUZrQTUySHNNanFPM3RYZTJHcFFYeUw1QWZHTzQ0SDQxemZpR3p0cHRUa054ZU1xdHNCVlI5M0pJNU9lbzZqOGE5ZkdVNDFxTWVSbUZLVFVuYzVtSFZ6Y3lpWjdncEVpcnRLZ2d0eWNkT3ZlaUxYSkxpWVdrMGFTaVZzQjkyM0dUMXoxSE5XSmZDeVFKZUZ5Ym1WZjlRRUEydmtrNUp5TTRQNmo2VVczaHVPRm11cDVFaWlVQXNGT0RudU1qb08vNTE0bGFGR0tjbkxYOFRwU3ZzWEh1VnRVU2Eya01rYU9FbHdRZUQ2L1RybjZWSmZUaExJc3pCd284eGVOdWVPUm4xSTNkS3k3clRyYTV0eEpaekJMZDBZa2JtTzRub2NqSkk5aFNhWHByYS9EOXJXVzVab3p1QkVteE1aUEk5QmxUMkI5YTU2V0ZWWDNvM2R0OU5UVno1VVhZOVZqdVpKby9LbEhrU0ZTV3d3NzlNZnkvQ3BZcEpwVk1jVW9FYlpHeVFEdjN4ejdmbjJxcGNUbTJ0N2UzU01OTWppTlV5RnlwT1FjOSttUHdxN09vNXcrUXBJeWg3ZWxZMU9WUzkxYU1wSjIxR3FaVEc2TVBKdU4rR2FNZ25yd2NuMUdLWVpsZ0N0REk2UW41YmhUMVplb0l3T01lbWVtZnhGaG1tTWpSa3N2QUVaR0RJZTRCOWUxWHJlM2d0OFBKa3NCd1dYa0VFNTU2VWUxVk4zaVMweTNaM043T3BaNHhMYkhrc3c2QWREMTVIZWhqQnFHcldLS3A4dVVGakZrQlY0QndQZkkvd0E5YXlabFcxdjhZWXBjTmpZZHdVWjV5RlBUSkdPNDVINDZYbFNOZjZiY3NpeGtYSVJuRFl5R1ZzREg1VjI0ZXBLYmpDS3VudVp5VnRURThUM1NXM2lDNFcxaGRERFp2d3B3QmtZNUE5Q3dPZjhBQ3IramFZUkhMWXJPc1gyYU1idWQyRkE3WStnck4xT3pmVlBFZmlDV0dWcEk3ZEVpS3NmdkhLZ2duMCtRMDNYak5NWjQ5TmhLTEt1eFF3NmU1enhYb1ZxVktFN1ZOcjdEVXBOS3h6L2h6VXhxT3IvWmJoVlRNWkl1TG5ia0VmZFVIZ0RuSHIrRmRaYXhwcHEzVC9NcXlLVnp0NUIzQWs5ZVB3OU0xejlwRkU4VTF0SGFlUUUyckkyZDVMZGVDT25ZNXlPVHhqbW4yTm83WFRLazVlNEp3M21uS3RqcHZIcGpIZXNKMUtYTnpSVnJmUFExMTJiTHNqcElzdm5TUXZ0UHl4cDNQcVRuQUhTcWlyRlBjUkdGazJpRm1TTWc4SGp1ZU00UDBwWjRiaXprRThQMmI3UExJQThNYWxRU2NBZ2J2MHljZTlOdDF0dnR6a3lmWm5WQnRqWVp6d2NManIxSUg0Vnpja2J2azJOYjMxWTlJcmRtd0pTNFFsbWpjOEtEMDlxUmxnbGtOck9BSVEyNGVXdU1nODllZjVnVkZMYXkvWS9ObFZzdkp1ZmJ0UEhUQVA1RGpqSTk2bGlsbk1UeFd6Qjhja0dNNUFPTWs1d1JqMnlPYWlTZmNodE4yTWZRbGxnMVNmVHRMYytSR3BaaklBMnh3UU9udU1lbk9hMkxHYUxTbzcxVWxrZkZ5d2x3QUFDY1pHT2VBUjF6VU9nalRVUzdsc29VRzVTcVRiV0cxKzMzZUQ5RGdIUE5WNGR5NmRxanNwbWQzQmFVa2NGdjU1ejI3MTZOU25HcGZYVjI5Zm1ZeGswalV2dFYwOFdLK2JERE1rZzRSMEM1SjU2NDQrcDlLNFJoQVh1TGkzaWRJMVk1V1JzNC9IOFAwOThWMHVyaHhwbjJac01xYmRqQmNGbEgrejlUajhLNTJCRk5uSmJnZzdtK1ZndWVwNjEwNEtncVVXMDl6T3ZQbmRyRHJPMm12cmN2Q0M0SUtzM1FlL05iZGpZeExhL1lsZUtKc25hb2JxdzQvRW4yOUt3dklNVUVzUFJNZkpsZ1J6MUFwTk1sdmJTRVNYTEZrd0ZCSStaTUQxL3owclRFMDV6ajdyTTRTVVhxanE3blNMcTdzbzU0NFdIbE1JeXc1MjQ3RWR2d3JIbHQyamQxWXRISkdXV2FKeHlDTzNQVEFGYnR0WmVmWUpNVmFkcGdSdGQ5MjdPTVk3Yy9qV0ZxVnMxamVQaFpJd1FXVXljRURzVGp2eFhKUVY0TkxvYVZGYlcyNWIwdVc0dDRaNG80NFpqT1YzYmg4NjR6MEo0NkVqbmo4aFZxMXVvb0NKeXJwR0cydnVVN1IrSFluL09heUxTNGFYWkdSeGdMbGZRamdjZWxXRjh5NWllTW5NWTdNdU1INjFsV2pLVHRMWUl5U1Z6b0liMktaWCt6U2JZam5JVmQyTWUvVDF6VGRUbGpUUzM4NXpnWXcyenBuK0lmbCtlS3diVkpvbGtuYVhDcGdzeEJQeW5wMC9sN2Q2WkZMY2FneXpTbVVScTRaRVpUaHNIN3hINC9oWFBIRHBUNXI2STJWUnVLc2FEMzg4N3dIVUVOaUZnRzUxSjNsajF5UHdIdVBYclc5cGtjWmdaSXA4N2dTeEF3VGc4NU9NazQ5ZWF4YnEybmxXRHppVEE3WkFteHR5UFhGV3JhMyt4WG9sVnpJQ09jdGhTdlluR2VsWlZ1V1VMTFFxRGFidWFWbG8wUzJzeXlUTTdKSnZEZmgwSTlLemRTbFNYVUJEYnhyRkNxQUVvZXJEcmo2MW9RMmR6SmFNYmNtS1ozMm1ReUhES2U1R1BURk1mVFhaTGVINWl5eDdXVXFNWnpqcWZ4K3ZXb3AxUGljcDNGVWh6V1NSSFp2YnJ5cUtjYnZuWWdaeDI1OWNmblZXYVVRbG1SZGpBYnhJVnprZGVuYkFBcVE2WmNLWllwNEF5bDlvY25JWGpyNjFJMm0zS0w1U3VEREdNa3FlV3lPdnYwQi9LbXFsTlBjeTVKTldhSXJlUUV2STg0QklPNXM3bFBiOC9TdWwwenhCTGZOYXdwc1VLZGl5dkh3ZlVmWGpyWEp4d2JIVXlwaFNDQVJ5Y2V0YkZuYzJrZHNzRVdtaVR6M3pJeGZsRjQ0WEFHT01uQjR6WFpocHhwemJjckl3bEZ0V3NkSkRNdHE0LzRtVzVBekswTUl6dWJuSUJIY2ZoVlVhZzE1ZHlpSGZKQ1RqZm41Z09jZzkvOC9TcUMyTWMxejU4TUV2Mlp3ek9jNEpPT3g3RFBKNTlhemJ5eXVIbHpieXNtM3FXTzFPbitIRlJqTVQ3UzFPT2k3Nm1sS25iVm5RN21PU20zYXZZRDdvcXM0ODZNQWtIc1YyZGM1QlBQMHF2WjJhd096K1VTY1lZSVBsYkhRMU1rSVJ5dVVqdzJDUXZJNzgxNGtrb3ZjNmxxUUxCQkEwUzRLK1dkcVlPQU9PQmowcFJzMC9VZ1BLalJMckFMS1FBR0F5ZnpHVGpzYyt0TnVIQWxETXBNWU9SSUR1T2ZUSHJSR1Z1aVVaQkVBVlpjdUNyWTZFZWh5UHIrZGFLOXJ2YnFQVG9RNnpiM245bzJiV3lzRUVuNzBoZHdJQVlybkhZWlA1aXI4dW55UEdrS1N5Z2tIZXk0enQ3NTQ2ODlSNm1peU4yMGtaV1RCM041bThaTEwwQTY4ZHFoMUhWUHNVNlJxQzZ1TUVBRWxlZXZ1UFg2aW9jcHljWVIzUUJLeXZHQkdua3hRa3J1WUVBbjFIR1RVOWxmeHlLY0lGa1pBeHl4eDZkZjZWVG1ua01JbjhveHlGaXFZK2JCUHlrNEI2SGo2ZW1hWnAxcmN4WFV4WnlNeHFvaTZBcWM5VDljbjIvR3I5bXBRYmJGZm9XN21LRzhqY1RLWTJKQURnWnd3enRZSDF6aW5tOGl1Tkxqa3VFVm5nWVNGRkkrWW9jN2Nuc2R2NmcxR0xlUnJ3c1lrOHNSS2NvY2dISnp6K1Blc25WTTJRdUNXZmJkUnZJdThnYlNGOUI2Z0QzNDk2Mm9KcHBKK1pNa0w0YjFPYlVicTlGbkpIYTJjbHg1MXljQXM0L2hqQlBRZGNuMzk2citMYnEzMHp5cnVWL09obFlLSUF3NXh5VCtIVDZrVlo4Qnd4dzZWNWVjR1dSNUN3QkpHRHR6OU9QMHJsdmloY3hUYW5iMjhMN2toak9DT25KOVBvQlhzS004VGlVcEwzVmN4bEp3aTJqYzhHczEzWjNkOGtKaDg2VE1PRy9nNUhPYzVQeThuNjFwaFNMZytUTEdDcWdQbGRnYm50endjZEs1N3czcDE5Rm9jTVRhaE5BREdyaU5WQzRWdDdEbmFlT2ZYcWZ5MFliT3pTUkxpWHpKR1IwUG1TT1pOcHoyVW5BOWF3cjBmM3pkOTl1cGRPVDVWY3UzRnhaM0I4dTR6OTB2TTNtbmhUZ2NqanI3REhOVkxGSkx1NjNOSERPQXJBR1huZXFLcWp0emtaUDQwYW1XdnJlUlkwUmk2Z051R0JHY2dISUI0NlpHS3A2ZGNIVHRTWmdYbTgwT0NJMitaV0xER0dIVTRIZjBQRk9uUnB2M2Jtdk03YkdyZldNdHJHYldWRWgzcnZqV01ad0NNOEVlbE1zTk9rdTRqTXcvY09DQzZmS3hPZlR1TTBYVjZIdGQ3WGF0TGdodHA5ZjRjNTRCSTlQZW1RM2x4YVFQTXJrUmtFYkR5VHlDQ000OVQwOTZ4bFRVbTFUZHZVYVZ0WkJIWmlPYnpvN2d0dVVjSjh1d2pPY2Y1L091ZnY3ZWFYVUJiUmhjUElHRzA4c09weWVvcmN0UWhVL3ZKQ0hHMVhmSUdlbkpQVHZUTkpzVnRKMmxCWTNBWC9XWjM0ejA2NDlLMXc3NVozbTlDSlJ1dERQMVkyZmtOYmtTV3QzRXdWN2FaMlptNXp1NUp5UGNldFlBa2tqamsyeXZuZTNBT0JqaXV4MWlWOVJnbm1uQ1J2R293SkJ5MkJ4ZzVQVG11T1VMNVpaUVhEc1MyRHlvNS84QXJmblhyWWRweGZLN25KTk5QVXJ5NmhGRktrckRhNWJKS2daeDBJeitOVll0UWR0OGF1VWxRbFFYQllFZlVkUHlwK29XOGJCQ3NUTXVNRm1jSVB3ejNxcTltTGh3Tmx3TjJXQkRCd08vQXdNL2dhN0VrMWRtVGJUUFIvRHR6SnJHa0N4U3lXYWFORjNUeDdZOXBMY0FFWXpuMS9uVWZpQ0pIMUdRU0piK1dWRUtDTUJpcEFHUU9TVHo3L1QwcXQ0SGlOcEU4Y29MdzI3NXVKRUpWa3huQkI2NEdlZTNROUsyOWZ0YlNLL2UzMDI4RnlRZnRFUU8xbElPT0ZJKzkzNDl4K09GU1BMRDNORmZVMlVtMnJuSkhkYnlMS2pzbXhodXgxWEF4My8rdFV0dlBObVMzam1Wa1pTNkF1cWdqdjI1NEJ6Z2o2aWw4UlRRVFhVZHphVzV0SXBVeTBTdG5wd2YxN0gxcUxTcFk5VGFXU2FjcTF1cS93Q2prRFpLcWdaQlBVOUFjSHY2bXVhVk84ZFN1dWhKcHRsYzNrSzNMZ2lIY0FxQUViMkF5R0l4MHdSajF6V2drS1NMSjlvaEpac2x1U0NUMndRZlRzZU9QejFrbVdXNGVXVFlzOGpNWkVVWUNTcmtyeDZFY2ZsV2RieUFxTGhia1BJKzRtTlRuWmtuSEkvcnpYbVZadVRiUnNra2kxS1U4bUNKWFlpVEpJUHpiai9DZXVQeVBUOGhVRXhpdjJaamxrSHpJaE9TUFg2ZTN0VWtkMW5FRXpLck14WldmNWNkeitIRlBuUVBJdTFmSmFNa2hlZDJNWndQWStoK3RjNjAwa1c3Ym8wcmFZU0k4YnE4YjhFZ3NSam4zNTc5Nlg3YzBGd01CWkZiQ0RMQUhQWHY5YXE2ZmV6U092bnhzUnlCSzNHTVk3LzBxeXQ2V3VKZnM3SktGWGFWYjdwUE9UajE2Vnl5aFp0TkdpYnRvUHVwcHBsUjIzUXlJZm5LdDFYNjBxRXZFd1NLUndQM2l1cjREZnJXYmVOSkc2Z01JdHpCMFpqZ2JNK21mYzFldEwyeVpWU1daQTRiZ3N4Q2p1T244dmNWU3BPeVVVTlM2M01wbCt4M2J2Y2JnUytWRHJ5dzlNanZXOG1sMnQ4eVhNZDNIRzZLSDhrQVpIWTg5Q1A4YWp1TlBodkwxTGVTNEVwREt6cUR0eHpualBiSXhXelkyRVV0bEpIYnlFRmlXREVuQTV3T2Z3eFhkVDVuZU50ZjYyT2VwVFVWY2dqdVk0eUZpd2lOa0FFZGM5K0tqdWY3T1dXTzRsaUFtWUZWYnpPRGpxRDdnMDJlMSt6MjIwN3BCa2g1RklETHpnRUEvaFdGTHBUeFFiR0JqY053KzRuYVBVOU9wSk9LNDFTOTdjWFRVMTRwTE80UlFyK1FybllpTm41bVBYR2Z3TlBraW5sZ052OEFhSlV4Z01FNEJHZlgvQTFIcHNrUG0rV3NUUE1uRDNCWGduSFRQUFU1NzlxMEpiZDNIeTdWREVzd1hBQi9yWE5VYWpQL0FETlk2clV3bTBseGVEZGJ6eUEvS3VISkdjZE1kT0JXekRCSGJ4ckRpTXpKaEdDa3RnWjV5U2VPUDg5cXZJN3FtQnQ2a2xRdUFQMXFoZTJ0czVZeUxnT0NTeEhKNzlhVHJjM3V0Z2xZZ24rUm1tM0lZZnZJQ2NQdkdPT1FlT3ZUQjRxdE9MK2NFUnBHRUpCODFTZHc2WXhrZGMrM2FyWDJkak5DNk1nZ1JHalpSL0d2R09lMy93QmVwbmUxNGhjcXFIZ1pPTTg5Qit0TlNzMXlxNVZ1NDRTU1NiSTRzUXFoSFlOdUhjSDhhbWwyekx1a2tNY2hJNUJCNzhBMUEvbHhJeXgvdTNHVkpENEdmejRyT251bzdpZUpYRzVpK1pObUNRVjlNOGRSejlhSXdjMkZpMUl0MEppb3c2RVpZRHFvR0J4eGo4RDcxbmE2a2R6b1Z5SlJEdU1Sa2hkczVYcHlmK0JIdHgwcTI5L09ieFJEaGdyRDkyc256RUhnNTR3TURINDFnK0t0V21YU3BvWlkxU09WbEJJZkxEQkI1R09mODlhN3FGS2ZORm9UdGJVMHZES3lRNkhwN3BjQ09RWlpsMmdIbGlRYzQvenpYRWVKN200dmZFazhhTUNvbENCMEFVdWVBUUNPV09mZjhxMnJLVzRrc0xRUEpLaXJIOGlKR3dPQ09Nc0IzOXE1ZlI0VGNlS0xXZWZPMFMrWVNaZzJNWkk5NjlUQ3hsQ3BVcVNkN1hPZXE3cEpJNjYwbnZYRHJHWkZ6dENxN1lDOER0Z2tqbnBWMjZtMUI3WXBKSkhzOHB3b0NEZDdqUFBIMUErdEVVU0xjU05hR09SSGs1YU5sY2pqakk2RHAvUDBxdHFrZjJOOTBya0JtQWxYTzFoa0hwNjg5eG44YzF6ZTBsN1N5VmpWUjAxS1N3eXd3eXBjWENPWkl2M2F5Ym5PY2duNWUzVnNFajE0NzFOYlhSZ2dsM1JHS2RMY2dLaWNaendEejZEdm5ta2Z5cGRKRFhMeCtjc1oyL1RQQngxL0tteFpNc3hSdlBqRVlKWm1JTGNuMUo1eWVPdGJPYWV2WUdyRzVQYnhYRVpsYTNNaGI1eVFBQnlQYlA4QW44NnpycXdXN25LMlZ2YkxnRUZ1blBvZWVmd3BsbGNYc3RuQkRHeXhLZytWeUFjOXUzdDZpck1heHRNYlh6L0xEaDBjK1hsdDNIWWpQclhGR25OU3NucitCcDdyVGJKUEVKaDBtYTB0Sm9kazl4QVpaVlhMZ0RjY2ZkOWdlZWVwK3RVdEJ1SXhMY1JYRWdEUlB0VWtFaGgzR1IzcTdiNmZZZ21hL3dCSW1tU0pQMzA4RWpnSXZjSGF3SSt1TVl6bXNheDA2d2ErMVRkcXMxbGFXN2xFYVBhd2tCTFl6dTY4TCt0ZXZLbFNxUVVsb245eU9WT1VYcWRIcUZ0Q2ZDOTdxQkRKS3lPWVVqSTI3U2hiREFaUFFnL2ppdk5yU1l5M0JMQTVia1pHT3dIOHdhM0x6VVpRVzArTFU1dkpWV1ZSZFFoVEtDUFFqME9PdWZUdFdGYXF4bGVZbmh1Zzdqbi9BT3VhN0tjSXhUc3JHTTIyMFdOVHRsdUxGNUNUdmpPUWZyeFdYWlg5M2J1MFVEb3NTcVpHM25BUHlqL0FWMFNEZGFzcEdjZ2svbFdmbzFuRk5IZXpEeTFkSjlxc3lBa0RucG5qMHBUbkdFSHpFMmJsb2RiOE03MjR2WHUvTGlaN2gwMkU3ZHNhZ2c1M05uc1A1aXVnaHM3YU9TUFRyeUpvTGRzamRER3F5eHlBdGdnOHNSa2taN2RLNDdRTG0yc3BrV1cwTHhTb3pHTkdLRTVJeGtqdjdBRWUxYXdlMnZkUmx1amVTMnMyVHZoRWVGWWJlUVQ5Umc1R08vdFdQdFVrdVhRdEx1WkhpN1N4WW9sNWJOY1hGdVhZK1pMRUVaU01iaGtIRGV2YnBWT3h0Y2FTdDlHRzJ4N3pjRlVKSlVuSllmVHJnK2xhUGlLNnVob2tjY3Nhb2JhWVpqS0JONnNHemtWQnBzZHBjK0hXaHRMcnlabmtkWk0vZENGUnd4SHVQODhVbTFPRjlpNDc2a1QzRHd6bFk1VE1ycUdqYzlWSTZqMzZqL0lxN0hJSXJZMjZReUJMZUxNcFRKeC9keDI1T000eHhUYjlJVjhPMnBRbno5NnF5YmR3UnV1UGJnbjYwK3dpa2FHS2FVaFJJcXlNZzl4NmZYSC9BTmZPVHlTdGE1c3RYWXJhMWVNSkxkOXFPbk1vRWpuZVBvY2pIR2Z5L0dxbHBydDYwbm5YQ3FkN2hlU1RoVHhnWjcxb2VKTUJMVWd0aDQzUU1yY01NTDJ6bnFPL3JXTkRJNDZSTDVhOHM1R1N4OWY4L3BXdE9sQ1ZKSm9YVTY2OGtrVFRveGJ0c2ZkM1BiOHZjZmxWaXh1SVpJWFNaVU01d1pIVWtBdGoyL3lhem83a1hFS3NnMlE0RzEyNTc1ems5aC9UcldqYWVVaklaakdDZzJxNVlkTUFmNS9uWGxWWXFFYk5hbTBXcldJcm02am5DUXFGQmZkKzhiZ3FmWUhzUHpOV3JQU29yMlV3VzhxdVNGS2dPTm1lUWUvT0tqdVpiZTdubUpmYXNFWUxLZ0dUempHU1BXalRtdVlwdnNpRkZXVUg1OW1EZ2NnWlhuL0pxb0s5bmF5SWxheHAyRVRXUm1DVG9pcVFvY2N0dEdDQUQ5Y2UzUGZwVjIxdk5TczR2bGtFZ0lJS0JSa2dkVzI5ZmMvV3FzbW5TVFJMSUxkbHo4cFhZdUNSMTZrY1lIR0IzcGJScFpKVUVSa2Z5R2Z6QXhaUUNjakdNY2RmODlhVVpTVGZLWlNYUmpmdE4wMG0rT0VrYy9LVkFLNEhwalBUMXBxMjZTVzBnRzBkQ1ZIY1l6eHgxcVNlNGw4ODRBREt4VlFwK2IwT01jMCtDQ3pHRmRzTXgyRGNjWi96eFhQenFEMVEwaXZDdHhDWGVIUGxaQVVyd1B4OStSVjE3dDRMZFVuTUxTQVpKNkJqN1pISi9HbnM3aUlGWWtBQSs0d0JCSHJVQUpnTE1xS0N6Z2dvNHgwN2UxY1VtcHl2WTJTc1NwcThMeXRGOHlvQU9YWGtrOXNWVHZkVWEzYmRHcXN6RWJRQmtrNS9sM3FDNXZvWTdobzVBQklZdytGR1dZa25qZDJQeW5ubXE4VFRXOTA3bnkzTXcyQjFCK1Q2RWRjbkg1VnBHaWw3elJTMFJic3RYamxBWldBa1pWK1hjcDRKNDR5S2w0ZTdTVDdORzhoSkFjTndveDB3Ty9IV3NXOW1pYTZqYUlvamJkaXVneVMvVWpucDM5eGsxcFM2ck5EWlJHR09NYjhGMkM0Sks5ZTU0NjlmUTEwS2t1Wk5iTVVwSklzZlkydUkyKzF6dERDRmJidGpCSlBQYzhEcjJxS1cwdHJYVUJFSUlBUUJzS2taY0RuQkJQdDFxb21xM0QyeVc3ekdSVlVmTWZsQVBVRFA0RDN4OWNWRE1UTExibG96NTZOSWNFRXRJZHA1NUFBNmQ2NzFUU2lraUU5Ym1sQmYyNzI4L2tFTE1Ua293d1FUbkhYb09uSHI5YTVQeGxNdDFueXBZM1ptQlpZMXhnY2taUDRISDEvSzlZQzRlVlZtY1FvNVlPZk1HY25uUFlBL2lhbytLR2lnc1ZnaXdUSE9vM2Q4NGJuMzRJNU5hVTFHTlpXRTFkRTAxKzBPa1N2RFpxQkhEdERSRXNRU0FvSjUrblNzYndtaGkxV1NWcENqcEdTb3h5TWtEK1c3aXRQeFJmczJqc2doV0ZIMlkyamx1QWM1L0NzL3dsYnJKYVhGMUt5cVM0alZpT09uUFA0MXJHeW9UazF1WXlmdnBIU1dkdkk2U3Fpb3orWklGZkc0TDg1NHgrSVBIclRyOWhIYVlOdEdoVEF5bUY1SFh0bkhIK2V0UVc4aGFGZ0hWVkV6dDB5T3B4bnIrbFRTeUNlNVh6NWRzYXB4dVk0SEh6WjljL2p6K0ZjTGwzNkd5bGJZekxTQXp5U0pNcVJ4SW0yWExjSWNudDlQNWl0aTBzWXJtNG5oamVGUWtKa1ZRMlNUejcvbDErbmFpQ094bGlKdEczaGwyc0dIM2NuSlBwNmRlbUJVMEdvU1dWeEtZVlJaTHBQTEo2OERrbmpqOGpSN1JPYWNscDJOTE54YVc1aDI3enRacGJBTVpHY3hESUlJeWNMejI2MXEybWlTM05uSTZYQ3FrVGJHVmp5U0EzMUhicWFydGZMZFg1dDVZMW1MeXFkL0lPZHVCOWVoclpnMWlIUzlPTUd6NVpaTXF4UDNjYmhrRHAyOStSK1hSU25TNXJUWG1RNHlXeHZXMCtrcTg3M0R0YU5qRWlNcER1Q080SEFCejArbGVXaU8zR3ZYVUZxbTkydVI5alFydVUvdk1ZSXlPeDkrbmF1dWZ4SGR6MjhkcElpUnFZZHBDcUR1QXhnbmQ2RUUxeXgwNFNheWt3TzJHT1JYM0VaeGtBOFk1NEpyMFBiVXIzVzMzSE1sSytwdWVJRnZMcUh6QkFpbUZSRTQ4M2QweHlBZWVnYjFIdlhEV3JCNFN3eVdkeXFqOFNmNlYyVi9mV3p3TThseTBqcWpMRXhicXE4ZER6OVBwWEdXTWJNZ1lEbFMzOHovQUkxZUhxS2NXMHJFempacEY0ekxIQVhMZkxzSXdQVTR4L1dzalNFa2U2SVdWNFl0N3RJd0dSSVA3cC9YODZ1WDBaL3NxRll5TjBzdlQ4RFZXM3VyelRvemMyOXVzMFJmZEtqTGtBWndQd3ozK2xiU1RjR2x1Wi9hMU4zU0xHT0czdHByaTlLdExONWFLWEkzS1NWQngweGprZE1mbFhkckhEcUtYWmtpbGp2NGtWWTd1SlJ1ZHNrQXNEeDBJQno2VjVycDF3THU2VFVMbGZObWpZTnNVbFVCeHdCL1A2NXJ2WTVvZFJ0bzVZbmp0VVdNZ0hCOHhpUVQyN1pIWHJYbnVVNFR0dS9sYjArWGM2SXhqS0pqZUxyelU3blRaRTFxM1NXV0NRZjZYRG5hUmpHQ29IQko5eDArbFp1ald5eFcwNGxIbHlSRldWZ1BsS2tIY01Ec2NZejZuclhjZlpycXh6WjNLT2hsQmRDZnZFY2phd0hmT08vYnZXSFl5YWJKYUlyUmhwdGhWaU05Q2VUMDZWbFZ4RTRSOTZQWFczK1hRMWpDTDFUTWpVcmlKNUluWlRBQUFEdVBWUU9PRC9nZXZlckJ1VmswcUpMbG1qS3hoZHUzYVZQWUhQVWNEdDBINWExeTBXNUNaVmFWRS9ka0ljaHVCa1k0UEdlS2hjUGZ4eUdaQUxoVC9DMkNxOWdvUGIzNjFrc1FuRk94YWpycVlkNVozYldzTjBJaTZCUzZvWDVVSEJ5RjcvbldOTEhmVG1hMlNLNGttaEc1aDVHNEtQWDhxNjAzZHhZcmIyY002QkVYNVFVQklHQ01rWjUvT3BXbnRZV01rODhrYitYaHBGWlJnSG9NbmtaT2NEK2ZGYXh4TW83cS9ZYnBjeXVqSzBPNW5qMGN5Q1hNcXlzaUJodDdEdCtZclV0WFV3M054aFNrTzBCbHdRYzRCSEZjak5ld3lMSFloUXFzZVFBZTU2OXUySzZiU2JHS1BUWmRQMnM4TW1IM3g4TXJEc2M5dXYwcTYzTEM4cGRmeUlpOUxJaFc5a2ptUjlpQ1psVmw4M08za1lCT1BZNXJxdEhzSWt0SkRxVnc5eE5jZ0RiZ0JPY2xmVUE0UHJubnJ6WE9YRmk3TzBnRHRIR2dCeU93UEErdUJpdE9XOWU2Yy9hR0VTYlNWQ2ozNkFkcTU1VlZ5ZTRadE02cDJsYU5Zb0JLTUwxVURISDkwWkovcFJDYmNSeW56R0xTNExBRS9ONkhIVHBqbjJyTzByVTRIVlBPSG1iVjRKYkJJNDRIOWZyMXArcDZsYjNFdVF2bHlCQUJnSDVjSDJQVEZjeWd1VG1qS3o3QmZ1aXBkM2NrMTAwclFzWlNRcW5aeVFNOC93QmUxUlFUeXl1OHhnRWNhbkdXNkhqZzQrdFZVMU1tY01OcUVmM1Qvbk5Oa2t1THRWVjhSeG5KTzQ0QjlzOS9lczVSYmQ1RnhpeTFQcWM4YzdlVmIrY0FwS2hzQlNPT1J6NjFDOXhlUnJLWFVydklJR0ZPMGJlZ3dQYjlUVlA3V3NpZmVNMjBZS0l2SHJuM0ZQRW5ud0R6a1ZRb3d1T3JkdngvejBvNUl4NkdtK3hiZ25aeXFwQ01rWUJKREg2ZXZyVGJxV1NDZG1rWDVBUGtWZ0JrK25wN2o4YWJzbEVmTW9TUTdWQVBHQUQvQUo5ZjUxUzhSWDF6WVFSTEhFWkdjOHlNeEl6N2UvVS9nYVZPRG5QbGoxS1R0dUswb1NSaTRrQ0syNHlZSjY0SEI2QVVDZTErMWVYSkFUSTBuektGNjhGamh1bWM0eitwcVhUN2tDeE80NzB1RndSSWVSNmRzNDkvMXJQMCtTVzcxQzh1U3pLdnpSSnNLbGljcXBZanQ4cFBJcnFwMHRXM3BZbHRMWTZDMWhqTjBreDJtWXNPU1MyMDg4K3VjZ2lvOWFqWlpvWkkzWUZaT1pzZ3NBVUpJUGZIOHY1b0p5a2pYRVUrekxFc01jY2c0SlBmMC9BZGFYVUx5R2F4dG11Wm5MaWI5NXQ2Z2VXM1EvWEZXa3VoQTI3ZU8vRVgyZU5ZNUZ5N01nSkxjQUVrK2gvUDlhNWZ4SmJ5MjhFY0RxSXlaRmM4OGs4ajlNZnI3MTFjTnZFK3BSUlJUTVVhTjFSMUlCSFE3Uit2OHV3cmxmRmVZOVJzNFV1STVzbjV3cEJ3T25PT2g2MWRHL3RVa0VyV0t2aWU0bS9zbXl0NVcrWWdzUm5wakFINlZiOE4ycUo0ZmpsZGptVXUyMFlIUTR6K2xZT3NSelQzMXdXWUtGeVlvODU0SEpIdDM0TmROWlF2QnA5dkdTUzBRQ01oendRdlBIR1BXdHE2NWFDaXU5ekJhMUcyV0xSWTBkMVlsU0hjU2NZS0hjZU9mNWUxUEJEYmtrSUk5V0hlcXNaYVlzY0Z2M2hPVllBbnYwNTQvQ3BKV1JHVTdjci9BSHdBUUNEeDErditlM0JLTjJhMmU0OVpaYlVQc08vQ0VmSytDRC9od0txMmtzOTFJMHo3RmtEaDJWampQeTRPUHkvL0FGMDJPNUVkdlBNc243dzdoczNBa3I2NFBUbjBJbzBlQnJxNGpoaVI1aXlxcFZYT2VUMzc5cysxYUtuWk1FMnRoMTNnUEhLbzNxZ1pqdUp5RjlSK1BRVnVhYloyY21rbzkxR2pSdTZNWENrdWlyMXdlZ3p5UHdyUGxtTnRQSzZUUkVRZ3d4N09RVGc5UHdicjBwOW5yR29hZHA4bHBESWh0MlVNc1RIbGtZOXVlUU1uajBPZTlkZE5LRWttRGQwVVdsbTJuY1k0NFZ6dUtPUy9PRHRMWTZZK3A0NjB4YmtXMnFRVzZzaXhOSWhEdVNRdVNPVC9BRnFlU0NKTGlPT045L25LdUN3d09RTThmWHZWRFdiT1MwMXVPMXQ1STNrUUl3SXlvQS95SzBwY3NwODB0a1pTMDJPKzFQUkxEVjdVelFRTmJQTktxU0hZeFU1SVZpdi9BQUk5TS9sWG1LQXhiMkIrWDV2ekpycm4xN1diTFRBc2wyMDYyNU01M2M0ZnFNbjB5T251YTQrSWg0V0M4RXAwOXprLzFycmhVcHpUY0VadUxqWk1ndVoxRUZzcEhCa1lyajB3Ui9Xb2lHa3NiaUFiV1JiZFdQcVR1QjY1OTZtZUJOa2NwSitVQUFIMUlOTzAyRnBkVThsSXpJTG1BeGJSbk9USGdkQWZYOUsxZXhDM01PTXl4N2xnZGlyY01kMk9QY1Y2OTRWZ3Q1ZkJWaHF5dS8ybURPNzVnVitWL21VK3BLOGdFOXpYa3RySDVWd3J0R3p4QS9NRVlaSS9sWHBmZ3E2c2JhMjFHRldrbXRVd0JHc0xjaHNIQkk0QkdHNmpuM29uS01kNDM2MzlCd1Q2TTZmeFBGL1pFMGNwdTJra3ZEa0VjT0NveDYvZHdmNmQ2NDc3VkpHMDBPUS83d3NGSStVRFA4cTFJMk1tMUxjbVNYZDFZL2RJNm5xTnZPS28zdW4zTVYyeTdSRzRVbDNJeVhPZlgyLy9BRlY0VmF0R3ROdHF4MlU2YlN0Y2QrN0h6ckdwWUU3aURqSnovQ09nSCtGRnpMSmRsV1VJWDNGVkIrODNQclNRZWZkV1FodHdaM0Eya3lZQ29lT29IelpGU2VkR0VqVklTSm8wMkU1SUJJSEp4MjcxenVMVHYxS2ZtVUpBMDhEZ3ZHd1g1LzNpREp4MjZjbXFrbjJDZVJJcGtsRHlKc1JnakVEcjArbFdMaTQrMDNERXhpSTlPRzRQci9JL25UYmlkTFdKSjQzWGdrSDVnQ0QwUDQ5ZUs2VW5HMXVwbnFub1c3M3d6YXpReVhCdUpKeHlXbVhEQmVEOTREcnlWUDhBd0dyRTR1bzlrc2l4T3VWUkpZZjRnT1BYMDlhUzB1N2lUVEM3d3FValhJWlFmbDlSK0EvU3FGMVBKRlppT0dRTjgyN0JQUWR1S3lTcVRhakozTkpPTzVyd1MrZGJUaGtDcHRPQytRQ2ZUSUgxNHFKSUluM3h3dUpIQlhhbUNUbnZnRHArTlVOTXZaUE9TT0NZQ01zUTZrbjVzRDI3ZHV2ZXV6MHRGakxUelRRVzdzMytyMm5hcFBRREhBNEhwMy9MU0dIczJST3BIc1lJMCs3WENlVVJ1QVBtRUVsUVRnY0Q4ZStQeTRudkxHRzRoQ0dRNThvb1cyN2Zwd09BZWV1VFhRWEp0dlBUekhKRWZSK09BZUQ5T2xRYXhwNzNkaDVzZHVrZUF3RW81TW5wajJyS201enZ5NlcrWW55cXh5MXFxNlhJSjdwRWZBR2NZSjZjZnJubW14SmNhbkg1MGJ0R0hZa1pJeC9QamtWZWhqOHhNeUlzamJDdXh4d0NEamoyOWFqaXVwcDR5RWpVSVdZL0ljQk9UMitucFV1VGZUWTBhY3BhbENHd21nSlprbGtmQkJDdm5ucmtkcy9YaitpQ1dTTUZTR2psVnNLcEkvOEExbi85ZFN2ZEFDWllzbVJNRWMvZVAxL0tuM0RrV2x3b1FBbk9XSnlTUU9Eam44NnA4eitKRkpKTFF0d0l0dXF1emtFWkgzaGh1K2VwNHF2cU45QUxNU2lPU2M5VlZGNEhHTTgreDcxU2p2cEROYzdZU290NC9PUlNRUW82TUIzd01qMTZISGFvTHEwbGU4aWo4eDBYWXFxNk1BQnVIQVg2RHZqMkhORWFOcCs4eE9XbWlOL01xYVJid1hOc2l5L1prTzBIaHNBZGVjWnp6eHh6V1I0Zk4wTE5RU1VMc1R0WlFNS3JyNjQ3SHIzcTg4MEVkbEMwaTd6dFZkeHlOeEE3RHQwUEh0VlcwaGpGcnVpNDhyY1BtUHFReDYxYXFlNjlPdllocG8xSW9ET2ZMamtZb3hCQVpzWXdNSHZ4MHFDN1I1VVJGSkNCbndPcEFDc2NjanJuRlZwZytuM3Njck9QSjNMZ0JHRzQ1R1A0dXY0ZXRYb2JwR3ViZG5BaitZbEZBemtrSGsxS2NvMms5UngxV2hQYldMVGZaREk3bDNjY1NuaFFFYjgrZ3pudjdWeWZpaEFmRkZ1aUFLNnF1OTBHQm5kbkk5c2MxME41ZVR5Zjhlc0R6TkRJaWo1dHFLMjdHM1ByejIvT3VWMUtTNWZYSlpieU5JMlVmZHlTRGhlbk5iWWZubFBubDIvclFKV3RZeXdyWEdzUnFIZVdXN21DS3pOdWJadXdUbjFJR1BwbXU0dWRQWmxZUjNMb25tS1MrVDhxa2NxQWVCMXpYRCtITjAzaU9PWjhueTFhUTQ3ZkxnZnFSWFo2bDVyMnNrd2xjUlNDSnR3VWxjaHVlT3RhNDNtOXBHQzdmcVpVTlUyVS9zMFM0a1NlUVNDUW96c21TUVdJQXdSNkQ4elRJWVlaSXlCSDg2a2drc1RnNTlEK3RLYnRpajI5eEtpdkdVQ0hhUVQwQUk1L3p6K0tyNThFbHhGTkNZWlhJazVQQXlCbnAvbm42MWhaMmVwczdHWTZCRWRsMlJZQkxFbnF1ZW4rZldwOU1ZejNLUnhoRkVnQXdHNHp6eVNEa1l6VmExYTJubnV4Y3lQREZ5U3dYZDM3OS84QVBhbzlPZXlpbWtFOGhDTHlyb0FCajFJN1YwdU9qOGlMRjZkb2xpZGxZTTVuUGxxcFBBSFVuMEhUL09LMEgwYlUzMGVXK0ppVnJac21OUW9ZRFBKT2VTT1J4eFZJeDJ3c1I1Y2JTeUU0REprTTVCNUo1UEgvQU5ldEc3ZTVYVFptaTJpTEN0Zy93c0N2SEIrbjUxSHRJcVM5MHZrdHJjc3JlRmJpS0dQZFpRR1ZWa09PQU53QkpQdHozcW44UW9yRzQ4VEltbnB1SmpSSlBMVEc1d1NCZ2Q4amJUQ2s4a2l4elB2YWRpQ1FON1lQUWpIWGsvcFdmY0tKTlhpTWpGU0psRGJRTXJoaG5IcU1rNDlzVjA0YVBKRzNmYzVwdTltYityZUY3bHZEeDFBeWpiSUYyYlNNTURuUE9SZ2pHQ0NDT2E0aU4yQmJiamJ0R01kT2dyczdpK2h0YldXMGE2bGtSNFYyb2ZsVlc0SkJCSjQ0NFAwcmxENVN4K1hnY0VENmNIL0Q5SzJvT1BMeXhXaEV0WGN6WGxkNVpJditXYWc5K21NNHA5dE85dThVOHVDb0l5dmM0UFQ4cXFpTmtlUjJPZVdISCtmZWx2bW1rdVk0NDFaaVFTRkF5ZnZIL0N1dXllaGxkbFM1dUZTL204dFF5aHp0YkhVWjRQTmRsNEZ1Yml6dkxtQ0tFZWRkUWh2Skp6MEl3VC8zMGVPdk5jMzVGdlpPWlhaUE5jWlRkMEhPTzJUK1B0Z2VvdWVGTGp5dkZsbnNuWGRJM2xrb3B4ODNIVTQ1NUIrb3JLdkhucFNTN0ZVOUpLNTZYYVFQTWJvSVZlVjFFcGFYQWM1enlPb0dEa1l6K05jLzQwTXNpUUxZM2tzOG9qS3E0T01LY0hxQm44L1N0NjZzN2VIVVlwbldWbENsV1F1VytZOUQxK3Zhc1RYTGVOV1l6UXkzTURLQWR3Q2hteitZT2ZldkJvemlwcnFkOGxlNDNUSUladEVoOHFlNFc2aitVa0g1d2VTUVd3YzU1NituYXE4bDBSZEJVdTVKbVVqS0tReGY2NEhidUtvMmR2ZFFPMXBCNWFXYytKREtISTJESE9WeU1uOHF2Mk51cXl2dkRZK1g5NGR3SVhPQWNkLzArdGRUakhtZXQxL21RcjJzVXRRMW1XM2tReVc2VE9Wd3NTcVFlcHlUNkRINmo2MURIOWxpZ0MrV3JIZnVBd051MGpPQ08zYnB3YzVySThTU3oyK3BTSVhES1FQbVhnTU8zNlVza2pmMlpIUEdkc2lIeThna1pJNmZvUlhiR2xGUVZ1cG1wZTgxMk93Z3ZZazB0UE5KRWpJVjhzY2MrNUdNMW5YTjdiUnl5U1EycXRHeTh4T21WSUhmUHI3L0FOYVpwc04zZFErYUNpcUhaUjVrZWNBRWpxUGNlaHFvenFrdTF4amEzQTIvZTZmVHY3VmpDakdNbWFOM1JzNkxKTDl0RFFRS2l4SXh4Q2VUMzZrL1Q2VjNzTTFwREExdGJ5R1dZajU0M3dXVVpPTnJjWTR4eWMvclhuT2xSR1NmeklSaFdHUnVHZlFjay96NHJxckczVzZpRXN0NEZsVjlwQUlCQ2pqR1J4Mi9Xc2FqZE9YTWlYQlBSbXBjV3B0MkVHOEpHTXFWRFpiT01FWndjMVhqbHY0NDF0WXkwaVl5dU1uWU9mejlzVmZ0YjIwaWhXRXhKSTI0cXhJeWVTY1pKL3hwODhja1BEeFI0TEg1bFlaR2UzRmVaVWJnM3k2bFJzWTh5WFAybHlMWmxQVmhnYmdNQWtuMjVyTWdkM2lMekl5d01XREZodDR5Y0VBZHVQcnpXMDRkN3h2S2tJVlF1ZmwzSGR6MDU5TzFZMXRCTTF4SkRKdmp0VUxvM3praVRPUTMwQVArZWFxUEswK2hwZnVRMzluZFJSQ1BZSmQrVVhHRkl5T01BL1NwSnJPNS9zKzVpTzVNZzQyeFpZNUlIWTRJRldyNjVnUzJ6YVNOSkxFZzVHN0pISG9UMjQ1OWFTZTZFRnNTN0tGa2NibUgzV3kzdjJOQ25PeTBMY1ZZeVpiTnJQVVJQYlhmTG9JU2lLUVRrRUhJejI5ZWFxd0ZsMU9CbnY3bU0yOHNXRWQvbGtJSXlweWVjNTdIQXo5YTM5VHRtdWRPbGFRdElBZk0zSndSdDY4QS9YMHJtWXIyR2VWbWxGdE1ueXNYQS9lZkwzR1JuSndPMzhxNnFUbE9Ma3pPVVV0RGZTMmUybGx2TjZORkpieU1xTW9CaWtiSkcwZHM1clAwMkc0bHQ0NGxZczdRbGlRMlNQbWNFanFNa2Jhc1NYS3BhWE16RmtMUjdpcFB6b052Qyt4NC9UdlZPMHU1RXNMVW1UYTBxUGxWWHRua2UvREUwNGMzS3dhVnpVdmtielVNaGJja3lNU0Z5R1BweDllbEpxQ3Mwb1ZVZVBZb0NLVzVKT2V1T2dISitoNjlxbU1TckM2Sk1aR0s4czRBSysvOHZ5L0dxY01zbjlyekZGT2NDTWJSeGpyazU2NXova1ZrbTN0MEhaUkx0cThrT2tUNGRrOG9BcW93Vllxb1AxemtIK2Z2WEwrTG5adFRsa2NBTTBQSUJKeDFITmRROFVuOW5UR1p3c3JSc01FREl5Q09NZTNXdVM4VjNRdXIzekIwOGdET2V2WC9BQnJYQ3k1cW45ZVJuT1NhWlI4SkZVMVdXU1FFNGhPQXZmdWYwQnJyNy9WditKVUxReEtWdUlIWlpPZHdLak9jZXZCNzlhNTN3Uk1rRjFjeXlNaXFHaitaczVISkhHQjErYnZXenEzbTNtbFJQRGN5UnF0dzZ5eCtYaklJT0dJNi93QVFINVZyaUlxZUkxNlcvSWlqcFQwSzl4SEJMdGtVSzBydkdVRzBnWkgwNmNkVDdVc0gyaTRtY2xSTDVhS2R1UG1BNkVEUGJpaXkxaTdzYkhUdkpXSjVaU2ZPTDVZN1EyUGx4d09NZmpuOFpiRzNsbGU2YnpkcE1XN3pBUXUxbUovSTVCT2VPaHBjclYwelc2TWg5SzhxSzZhUzdSVE9yZktnM1krWVlKUFRxTVZUc29ZVGNpM3d6Q05NeXNNRWtnWmIxQndNbmorbEVsMUxiM0pqamtPRWtkVHNjcjFQR1BwZ0VWZDhQM2JuVW9HdVpXbGhBZUx5NURuS3VyQTR6M3JwdE9NRzNxUmVMYXNhRm5ISkRCSERCSVkyYVdOSGNNQ05wWiszWGdLZjhLbjFreXhhVkx0V1NSVWRkamVabkc3QTJuL2dYT2FxNmVqeTZoRjlvQlZ6TkgrN3huZHRWMmJIVHIvVVZxYXljTlpXeWhXSzc1R0M4YmtWRlB6SDY4L2dhNUoyVlJmZWF4ZWxpaytwcmNYVms5dVFMYU9UTWFodm1DN3NnRSsyU00rMVo5OVBISjRqa2JZTm5uZytXU2VGM2RPT2Z5clI4UVRXZW5JdHBiMjZySEpJWlk1a0o2azVJR2Y2MWdQRXN5R2NnaHR3eS9wbi9JL091eWhKVGdwVzAxT2FhYWRqdTIwbDIwU1NlRzJVYm9mTmNwZ3FxN2VPU2V2QnozcmhabEhueUZBY01XK1U4K3YrTmVpMmhtdHZEMDIrNUVrVG9EeVFPUFgzL0gvNjFlZG9kakkvWDVqay9YRlo0Uldja09vcldLVWhXZlVGUnNjbGx3RDFJNmYwcXBxdW95RmhCQ1FpRmNzVkdDY2tuQlA0MXAzZHF4ZEpsVlFJMzNGczR5YytsVUo3WlB0VE04SWNNeDNIZDBIYnAwL0d2VGpabk03amJ5MWtYUWROdS9LTGlUekVZa0U5SDQ3KzUvS3FOdEliZTVqbmlpZFhqWU9wenhrSFBwN1YxOCtteDNYdzlNMElKK3l0NWd5L0l5NUJCSDBPZVByWEZEY3VDYzdmV3NxTlRuVWwyYlJOUk9MUjdWY1dnZlM0N3VFbWZ6VkZ4R1pHNUdNTURqb09NZEJYUHp1OTdhWHFiMmFHU1h5MFhkbmtMbmdlbklQRmFIZy94QmRUZUVvN1Y3VlhsdDFhTU5NTUtJOERCUHIyR0IxeFdjakkrZ3VzcXBETEZjeDc5cTRPRDl3NTlNZS9hdkdVSFRtMDFzenRUdkc1azZQTThON1pXclJmdUczTGh3RDVoNTVQWEpKT2UzNDExSG14dktZYmlKK2R1MHFWeW80T01Ea2pJSHRXQzE3YWFicXB0WnJxTlpBM0xkUm5QQkpQR2V0YU1qS0o1OHNOeUxsaU9NOCt2WHNmeXAxMDVUVXJkQWhVYVZqbGZGMGtaMWtseGxKVURMN2NZNTkrTWY0MUJORWs5akxhUU8wamJsa1VEbmRrRE9QcC9qVnJ4dmJDS2UwbXhndEdWSUl3ZUFQL0FLOVlOdkkvbE9OelpkY0ExNjFCS1ZHTWtjL1BhYlRPMDBONUUwVk4rU2tiRlNDTVlKSEg0YzFrWHUyTFVYVHpHTGVjYzVVRW5rOXVCMC9UMHFUdy9MSmVhVklaSmpJNlNyOHIvTUc0eUFjOXZrTlU3cUpJcnFVNU9QTUtaSFRnOXFpTWVXcEkydnpSVFIwbWxyQjludVpBTjJOb0N5REJKT2NBQWQ4QWZ6clkwKzJ5aGhVZ09EZ01jNFQweU04KzFadmcvd0FuN1JOY1Q3SE1ZQVZYSEFQUFBUQSs3aXQyMG1VWDB2eStoQlZSL3UvVHIvbjE0YTByTm8xdWpWMDZ6Z1d4anVHaGtkc1p5VVBPVHdNZmlhZi9BR1hjM0cyNGxZTGo3c0NFRVk5RG4vQ242ZmRUVFdzWVE4SU1BWUdmUW1ya3hqZkNzNkZ2UlhJcnlxMG01MldpSk1DN2xqZ21VckRzT2NEYWM5R3lPdlRqUFB2V1plYWpKYVdEVExIdkV0eEtpTW4zZ3hPZWVPUi9obXR6VW9vSW9oTkNFY0t3RWhDaGNEUE9jZTJmek5aTjVidzNlazZsYlRsYlNOWldJSjZ4bkN0MDlQbXhuanJXdEdNRmJtWFV1enNjOGw0akxMRGRGek9xNWtrVmh6Z2pQWTU1SS9LcmN0d3ZsYWZBc1JEL0FOb2hTUjBJM2RNL2hXUVBMdHJXYUpKWkdaemtGZ05yQW4xejFCQjQ5alZpQm5HcjJ1ME15ck96cU9UenowcjA1MDB0Vi9XZ09XaDFWeXpSUnlPZzJTWStiSkdEMjl4LzlldUIwZ0dmVUkzdTMzTXBkdVd5UVFoS244Q1AwcnRkUVZyaXp1bUFLTWtUTjhuQU9GNHo2ZXZyWEkybW5mMmU4ZDI3QUtoV1RnRTRYdm5wZ2NuOWF3d2pTaEs3MVlwSnRvNm5YNWJlWFJsS3hndjJkZ0NRQ1J6d09lS2dnZ1cybnQ0WUo0eUNmS0JrQXpqYm5qMnFwcWtpbTB0RXQ1OWhua1V5Ujdzc1FSejEvcFZ1ZU5vbmdtOHVVTkc2QlNHM0RuY0JuQUFBemlvVVdvcGVwVnk1YVNUZVJFaU0vbksrd2d1RkJ3Y0hCNUI0QjkvYXEybVJyY1hNamxTNUNLaEo2RDVSMnoxNHFaclJaN1M0ZFE3SzBvY2h3U0NmdmMvamtWblFXODhWMWRCSE1hck0yNUNNNE8wSEdDUWZ5OXFsSk5TczlSUFUwWlpZTkt0MisxM1VYbUpubFFlbmJJeGc5dWh5YzF3VjlNenB1NUlPRnovbjZWMG1yczBXbDNBa2ljQXJqNW0zS2VlQU05Q0s1bStWWTdLMENaK2RXbFBzUzIzL0FObHJzd2tiYXZ1WTFKV2l5NzRibGVNekhZczI3Y3Zsa2taT0J0UEgrMEIzcmMxaDJpMHkzbGhUeVVGNGpoVmJPUVdiT1BYci9Lc2JSb2xpdFlaVEpJclBHN0w1YWc0WVB3VHo2cm44SzA3aTlnUmkxMXFJbXlkeGo4eko2OUQxSEhwVHJLOVM2N2xVNCs0WjF2T2l2Yi9hSTFkVXVBVkNmZlFINWlBdlE5ZVBldDViaVJwcmFDSStYRFBIKzlMTG5ZcGJMZlRHRC8zMTlhNWhyb05xQ3lTQUdQUDNSZ0JnTTRIOU0xMlBnOHdTU3htWUF5UEUwTFpIM1RrTVB6Qi9Pbk5XMUhGbkRhektScTg0WFpHRE13VUp5QjgzUWVvcTdac29HSENxRkN1TWpPQ09uMTYvenJMdTRHT3BjSGZpWWpDRGo3M2F0T1dGNFFJVzVVcWVGT004OXorTmRiUzVVaksvdkd4RHJGcW1wMmx4STJFUmc1WkNTUWZLVmVNNDU0UDYwUlhsdE85K1kzUDdxMms4a045NDVQVDhWSUdCeldLUDNhQUVLQjZBVkZMbU4xWk9PQmtmMHJCMElQYmN0VkxQVTdIeGRwNGgwMkYyRzUza0dKTThIb1RnZlRITllVR0UwQ2VQekhCa0labEs0VWtNUndlL0Evbldsckt5ejI4VVVNSmRXYmNTclpVSEgwSFBGUTJzTzJ5bWd1NFhFMzJWbWpIWGI4MmZ3LzhBcjF6NGZsalJVYjlRbmR5dXpwOVBrVy8wRWJKUE1na2hFY29qTzRySmpxVkhPZmI2SHZ4NS90ZnlaSTJHMGh5Q2VtRHVLMTJta1JtUHc5YlhsbkVETW9ZVElySDk0b0xBQWdkKzRQOEFqWEsvSTF4TmpsR2tjLzhBajJmNjFXRmRxbFJKM0NwcWtSM01UQ3paVTVac0RKNXFsY0lCZUdYZEoyR0FSajd0WGk0OHBGM1o2Wnlldkdhb1hxdUxxYm5nRmNEL0FJQ0JYb3hNR2IyanBOZmFOTGFRbFk0SERxUTY1TFo2L1Q4UFd1V2xrbGl0bzVMTHllTWlReFIvTWhIMUdjWXh6WForQWdrdGhkeHRJSW1XWHFUd1JnSG44aitkY2I0aHRqcC9pTzhqQkFQbTcxS0U0dzN6REg1MXkwSkwyODRQMUtxdHFDWnZlRTlTZFBEZXJscDJNOFRxNjdtNU80YmMvcCt0ZExyMm55Mk50WitlRmFPY0xGSmhjWVlZWlFBT3ZPZVRYQTZEZXlQcXNkcStIVzVkVWZJRzQvTUQxNjE2WjR0aW1id3ZjSjVnazhqYk1tMEFZMm5Kd2ZZWnJueE1GSEVKL3dBei93QWtYU2Q2Zm9lZWVKdEl1WmRYOCsyaFV4elFwS0JHTURHM2svOEFqcHJmdHBaWnJaYmlWblNTU05jNE9NTmdaNHgwSkg4cXo5ZjFHV0t6MGpVMExydWplTWJIeGdBKzR4MEpwdWxhODBscEdyWVR5bTJqQUdRTzM0ZHExbkdwS2xHM1RRblJTZW92am1XTzVzcmVRTXhjT01nNDRHRCtmVC9PYTVHM21NTEFqUHRYWitMWlFkSWlhTldSdDZuNXVRd3dlYTQ4b0dYTFlCOWNWMTRKcDBFckdGUk5UdWpkOExSYm1tanlFeXUvY0J6Z0E4ZnJpczNVcm5aUDVhTVhDdWNNVGt0M0ovV3JuaGxpWnJwVWNLckpzM2tmZEJ6azFsM1V4a3YxakJSbDNBRW91QWZ3Rk5LOWFWeTFMM0VrZGI0U25raWU5WG5LcWhJWHFUODJmNS9yVzdHcmYyalpRSXdEeUpKbHV4Q2tkRDM1NS9BMWhlR0djdmZTd01wQUNLd0k1T2R3NDk2MjdOSkpQRU1IbEFFcmJTRldib3JGKy80QWNuMXJ6YTc5NlhwK2gwOURwTEo3dU9KMmdVakVyQWdEbkc0MWVpdXk4WnlyYndjTjZacWpaekpER3pTU0l2N3hoazlUeWMxWVRVOU9ubTJKS1paUWNmSngrQjdWNUVwM2JVbDl4ZDBpUFVTMHRyTmh1REUyQXZKSXh6WEw2eVVtMC9Vb1o1dktPOUN6TjBHRkFQMSs1MDZtdWp1NXZLUXhORnUzQTU1M0U1K25yelhNYW9WRDdXaGU0YVNOSGVKbE9IWWZMai9QcFhaaFZkMkJ1eGpOYXREcGlYRUJNOElVNWtaZGo0NmNxVDZOa2ZYZzhWYXRyUmsxdlQ0U01qOTRWYmJ1d09jY1o5cTJKNHBiVHc3UERPZ2dZUWdpTlNvVWpnZmR3Q2Vmcno5YXk3QzZKOFl4Z0psVmlrSXhnZ0FzeDlQY0N1ejJrcHhrMTB2K1F0alMxTGRiMk55a3JOSURFellBQ2dIQjdIc01kNjVhRzB2Wkk3eFdsVzVRUkJGWkdCNjlEbnYzNjg5YTdieElDMmx6U2dGRDViSWMrNDljOFo5dld1TjArd2wwK0s4UDJsTnpKeXFTY09BQ2VQWG5INDFPRmY3dHNjcnRvczM4a3N1Z2FQSVZKS01RNUJ5UWNnSDZkSzBybThoaW1qaktFTVpGSWtMN2l2ektldGMvTGRpTWVXNWRMZU8vZDBJNitVU0RnZnJpcjE5clduVDJoUGx5ZVlvRFJrTDA0NHprOWovS3RaVW5kSzJsMytJb3lYVTFYMUtJeDNja1pmQU1MRGRnODd5RDlPdFpnazJYY2tzcEtJN0dUblB6SERBOVQ3RDg2ekpOYWlNU3hrR1BjQ2pzTW5JVVpIUTFYanZwSlFpU1I1alpqbkErNmV1UitmNkNxalFhVEU1bzF0VzFPMmZTVGF3eHVYWnc3TXpjWTloL09zQzVmY2tJMmdGWWgwNzVKT1QrWS9Lcjl6YTNRakRTUnhxZ0lIRFp6N2oycWxkQWJ0d1BYZ1pIUEFyYWxHTVZvYzlkdllsWjVGc0lZWldPd3B3dWVnSkovbWFxZlowVVlWMkpPTnVjRWY4QTFxMm9MU3phM3QzVmpKSTBZM29tZXY1WUIrcHF5a1ZyWndiYm5uYzNFUU9melBjMDR6U3ZZYnBTc20yY3pHNURZMzVKT05oUE5YbzlSMVMxdTFWWGt0VWNnc1lsM0VFRHI5ZU0xcUN4dEpGQmp0NG9UazRjS0hiSHVHQkg4cWRjNmZIYTJZbGkxQ1dVQUhlTUNNZGVtVnhWdWNYMEJSYVc1bHcyb2tsRTNueUhIemplTTg4OGRzOXYxclFLUnZDZDN6RUUvdkQyUCtlTVZXVnlZRTRJUTUya3NUK0ovR2x2WnpER2JZT0N5Zk93R1RnNUEvclVYYlpTc01ubFdSVmRsQ1pMY2p0ZzB5NFFHTU9wR0NldjRDbTNhdTluQVJrRUY5emR2WC9QMHFhemgrMm0zU1E3SVdJd2VnNm5qOGF2U01lWmtKT1U3STJydThsVUM0aGtUY3NySnRRNUl4amtnOUJ6L09wcldTN3VyZUdWUUpNeHpJZ0F4amp2eDZpckhtYVBwS01pMmtSZHllUkdNajFIVGl0RHo0aEVxV3hqaGpRSFB5N2MvVDg2OFNWVlJTNVlmTm5aR04rcG4rRnI2VWFUTkJLQ1ZhUmdvUEFVWUJ4K3ByRGVIWmQzRVZ2eWlPVlhIWVlHSzJkQmFGYktVTWpPNGtadHFnazR3T252WFB5M215TVNvZ1Y1WnVGSnhqSk5kdUhWNjlTeTdHRTFhS1pVdlpudDNoQzlXWElKNlo1VWo5QlRwbTNxN0VjN0ZPZnFLcjNUdEswSkp4dFlsRlBVREk1L1NwN3NoVVVCZURFblBmT0s5TnJRNTA5VG92QWx3SUlia00zeXlzM3lqbllWQ2M0OTkzNlZMNGwvc1dTOGpXV3dUZlBIdU53emtObGVkb1U4RW5nZW5QUEhWbmdkL0owcTRkRDgvbm5nQTVJMmlyL2lHd3Q5VVd6YlVTaUpBeFp0L3dDN1ZnUUJqSTZjZ1Y0bFNjRmkyM2Rlbm9kMFlOMGxaR0JGNFprazE2M3ZVTWNGc2YzeWxGQ1pBSUlVQWZ4Y2pKd0J4M3J1WjR2dE5wTGJTUjc0NUV3WTFZa0FFWXhqL0ExNTA5anJOdERKQmJ4WHJXU1NISGt5ZVloOS9sQjlCOUs3L1RiMks5MHEzdlF5SkpJaXNRVnpnNDU1SjY5YVdNOXFsR1NsZGJhZmdUU1VFMnJITWF4NGZ1WmZDNHQ0NEJKTkJQOEFLcUVncXB5Ty9iR1BwNjFCNGQ4S1hTNmZldGR0NU02RUdLSTR5Mk9wQjNmVWZoMXJwZFB1TGg5UWtpbHZGZFNTd1ZGeGprRUErdkhwWE9MY2ZadkdEeVhEWEN4dXp4bzBvWUlNNU9PZXhQT1J4eU9uWjBxMVpxVk82Ny84QXVWT0NhbDhqb0wvQUVxMHZOTmpzYnVNU3pSSVFpZ0JYWTQ0d2M5ZjByeSs4MCs3c1hFTjFESkd6ZG1IWDZIdlhvT3RhOVlhZFkyOGtxVFRYTGo1UUc2TUFNOC9qNzFhMGpVTkkxN1NQdEI4cTFsamI5NzUySFdOaWNEcmc4K3ZBNVBvYWVHcjFzUERubEZ1TGY4QVZ2SWlwU2hVZGs5VGlOS1EydGhmZ3d0aDRtT1NoN0xnSDgyTllpUnQ5ckRETzFEako5UlhWWGtrOTNlWHNObk5KYzI2eXNzUTgwdXVHNjRKUFE0ejdZNTZWSGFhSll3eWdYYzF6TFBLQVZWUUZIWDZIajJyMUlWRnJKN3M1M1QxMExmaGliN1BIYzlTSm5pT0ZHZW03OCtjMXFlSDdxS09LN21kbVNjeitXZmw0S3FxNEEvTTFuN0lkT2kyUXl2Q0ZJVDcrNHFRV1lad01kU2ZXb2REanViZ2kxaUVhS3BNa2tyODU1NkFIT1Q3OXY1OHRTSE56TmRUVlhUUjFlbTNFZHpEL3BET0dia2dZT01rdG5wNzkrbWFoVlloZTdJV2xnRVI0d1J0T2VlUWVsVzdGSWRyUXNIanhnc1dJNmtjWVA0WXhVODJscTRIbVNxRjU2bm44NjhxVW5HYlhjMmNKVFFyb3JrT2pxTUFidDVIWDYvaldacUVrZHZQSDVWeVViY1c4d1NjWUIzbk9SeHc1L0VVeWU0U3lKVVlBSk96Y2VTZmM5UFQ2ODFuWFU5ckxmMnhYNWcvTHFweU1iV0JBNEI1elhUUXB5V3ZRaHhSYXY1QStpWExKSUdCUWdaNmpEWkJKQjU0QXJuWmRaZ3RmRU1zeXhPem92bElQOW9PRzUvTEZhdDhmT3QxV0lQQW93Y3F3WDd1UmdiZlVaNitsWXR4cDlySmNtNFVxbXpETVZZNEI5K3VjL2hYWlJna256ZFNaTnBFay9peS92bThsV1NKQ2NiTWJnZXd6bkk2NHJJVzV2cFZBZ1dRaFY0Mmc0eGsvd0QxNjI5UHNkTGhZU0pHN1BFeDVkY3JuM0k3ZjU3MDY3RnNaRWprZDRmTEpWcFBMSUJIWVo1L3JYUkIwNCs3R0pqSlRhdTJZODRudUdDWEVaamxVNUpCenZ6NjlmVDlQZXBvckJwWXg1aTRiYnRHUFQ2WXJURVZ2YndxN3g3eHlBaE9XL0gwcVo0NUFpeHBFUS9MSGFwKzdqdi9BUHFGT1ZTMnlGRk43c3BXVWRyWkhIRWpyeGh2bGJJeHpWMkJEUGM3NVlnU3JaOHZHTjNIUW50eC9LcTF2NWx2YVBLeFZtYzkrQXVNWXpub09mZnBTVEpxYzBvbEVidElSL0M0MkVIc1Z3TW5uMXJubDd6ZXAxd2c0cFgrNHZhc2txNldqZVh0akRLRmJQVSsxWUVva25LUjI2TThuT1F2SlA0RDZWclh0bmN3NkZKSmRUdEpNSERMR0N3WEdjZENPdk5XTkdhUzJzRVFSSjlwbDVWVUJ5Ums1MzRIK1JTaEwyY0xyWFVLbE4xcWlUMDBLV1liR3h5N2tJZ3h1SXd4UG9QeHpVbG1VdnJXSzRsajJsMkpVRWtnQVpINS93RDFxdUhUTk1tWlEwTWNqQnN1Q3pFc2NaSUhidCt0TWtraHRweWdWSVk0eGhRdlZSVndtcGFMY21WTnc5NitnN3kxaDRWZHFuK0lOay9ya1ZSMUsyZG5nZ2psTENVRXN4NEg1ZlNySW1OeXU2SlpXVDd1N2FkbzlzNHFIN1RMQmNSbll5eEhnc1FTdjVnZlNxU2tub1pYaHN3THlXc1lpaUxxcWpBR2VsU1JhcmZwS1dkbzMyNFpOeURucHlUamsvV29aN3FPVGxzL01PQmlvNEdMcnd1ZHVWSTlSZ2tmcm1xOW5kWGtnVTdPMFdXWkxuN1dXZVoxVnllcFlqMzZuM3hXVGVYMDl2SUF2N3lKb3lXY2pHZmw0NkRqT08xV0xtUFlIakNsVHM0N0FjNVBQNTArMVFYS3VnSHpvMjRqYnovczg4OWV2NEdtMUdGcFBZdUxsUDNWb2IrcXgybGs4Q1hNMjVYWm5rQkhUc0J4MDk2bmh2N1RVclM1Y2JZbHQyK1hiM1VFRUh2bnArVlZ2Rkpoa3M0eUNWa2k0VlN2WEpKUE5aZWdJM2xYY1FrMnJJdXc1T0JuQngvSTF3VThQQ2RKVHU3ci9NYm00enNhZWh5N1k1NUJMc0N5Wnh6ZzUrbGN2ZXRKOXFuVEhFVW9LZ0RnSGQvTEdhMjlGdVlvekltRk8vYjk4NHdBZWY1OXF5SlN6VFNTU2tzOGtyRG4yK1grdGRsS21vVlpQdll5bks4VWhzbG9XYTRsa3dYUkZFYTU0R1RqTk5tS1NBS1dPNFkybkhXcDVibEhSdkxiZUdIejk4RElQK1A1Vm5uR0dDOENNOForbGRTMk1qcS9ERXRyWjZPNGVVR1V6WkFIQjU0eGswL3hPV3ZkSG5SWmRxSkdHRUkrZG1PUjF3TzM5VFdUYTdJOUtqa0dHYkQ1OWlyWkg2VjBiNmRGcUdrM01NY201cElqc3lmdk1WejllclY1dFdsR25WVmJyYzZGVXZCeE9QMGZXTHpScmRJNVpqREF3Wm9pc0t5RXQ2WnlDT1FPTS9oWFc2SmZYRDZLRU4xRmNLR09WajRDRW5KR0RqMTZWNXQ1ODhmSG11T3dBWThWMGZoRFVtaHVaN2VRaDBsVC9sb1NkdU8vZjYvaFhSaWNPcFFjbHVZMDY5M3luUlROOWwxZUlDTFlaVkozQlNObU9BTTU1ckk4UmE1ZlhGZytuM2RtaXlRWEN5SmRieDgzM3NISHFRUDBOYWVwYXUyMjFWUUdDRDk0UXVDQjJPUC9BSzFWTmV1OU4rdzIwTXNUeitlak50aVJWZmZ4dE9jZHVSNm11T2pEMzRPVWJ2OEF5TjViTkpuUDY1SkhjRzFFWE82TGVjSHV4LzhBMVZteUF4d2xGZGdyWUpHZUdQYml0alQ5Q3VMbUZKcmlSWWtRWTJ1TU1WNjhWcXo2SGI2YzBjN1JUbVlZS2hYVnVEeHdNRVpyMFBhd3AyaGNoVTVUVngvaDJ4MjZkQkxISW9PMHlTYitBdnVlRG50d2VQenJTZ2x1NTdlU1dLNDgxUTJEd0VHQng3WTY4ZHFpc2IrSkljZloyYUxHeGh1QUtqM0lHQlNsNFB0RFc5MEY4dWFMRWF3REJBR01rZ2puajAvU3VTcTIzZXgwVTdMUWl1NXJoTk1JWU5MRTVHNUN5OGp1UFhIQjVCL25tc3EydjdpMXQzaHQ1Vml3Y3FHYmpQSGM4SCt1ZUt0MzhzdG1MV0NPNlEyNy9LeWJzSGIyeVBybm1wb05Na1NFVE5hUENWQkxCQnU0NmR2ODRKOUtxTTFHUHZkU25EbWxvZGJvMG5tV01NemdTU0NOU3pFZERqb2YxL090Qm5reGhVREZsT0NnR0s1Q0hWTDFJanRLL0lRdnplbWVEN1U1ZFV1eVE3eUtBTWJ2bC84QXIrdGVkVXBTbEpzMzViS3lMK3JTd1FTUEFZU3pqREVxYzgrNHJrN256WHVZV2pYWVVmSjR3Um45YTNaYjJhVlE4ZTFtZm9BbVNQcmovUFNzNyt6VWxkNUV5a2dPNWl3L1AvUFkxMFVQM2ExTXAwcFBabENadjNqTkllRzR5UVRqakhYNlZidFZndkcrelJsb0lvc1NaS2JWWSsvZjlmU256YVk3SU5qbjczekVuS24yd2VQeXBrME1jY01abmxDeG5xQW9JSUgxOWYxeFhRcHA2STU1VXB3ZXV4SzlxSGVTR0tlTHpnY2tCREorWFRIMUpxZXppYTM4NlJ4Szl3allEek1GUWZRWjlPNDcwcVhOcjkrd1ZJRmtVRnZsS3FTcEpQVTg1eU9oSFNvNFZlVlB0RDNTSkdHMnNGeUFPNElQWEhVZmgzcUc1V2E2RzhWQzZmVXp4ZXZZWHhndUJDWG1maDBjN1VYUFEvbFZ4ZFErMXhzSUYyUmo3MG9RWVlkL3ZIK2grbE11bzdYN1dsMkx4RHRYWmpPR0w1NXdQOE0wK0tacGxIa2FhazB5RmlVWmYzWUI3bGhnNTR6MTZWYlNsRk8ycE1YeVNhVDBIU3pHZmI1U3h2c1lsUE1IdDFJK250NmVsUEY3Q3kvTmRPOGlyazV3Q1Jqc2VlOVFUWEVVc2x3bHpxVVZtcTdjSkhIZzU5QU92K0ZRMjBVRVVodkZoTHd1TVBJeCsva2VtTy8wbzVGYlhmOEFycUxuYmxwc1hETjU2TEhGSklRUVBsS2xnQ09weU91QnovOEFXcUM2dWJ1TzJhV2JiTEh1d2pCZm1CempPQjA5S3IrYmJwSWs0VXlTcXZIQlZZcy8zUm4zL1BtcEpMeVNRTTdrbG1PNGxzTms4NFBQZmsxY0tEZXR0Q1oxMHRucUpwMHQxQzNtMjkwaURLbGxDN3V2MUdBZjFxY3g2WlBjRGRic25sSGFXa1B5c2ZwMDRxbTErOGtCaUJZdXg2QTR6NmNWZld4RU5zcG5rMlhKd2R3WUZPU2NaeC9uSW9xS01KWGIrNFZOeXFSNVlvc1Mza1VrU1J5T0VqQXlYUVlVRDAveUt5RU54ZFRlVk9teFVYY3JoOGhoMHdEK1hGUnozbCtHYTFXellUSXh5WXVmbFBYam5ybnJWcXdlQ08zUlppVURkVjNaMm5QUVZVZEhzWnlpbXJNbmpqanN6RzBSUVl6MnovT215TzdQNXNaUHo5Um5OTW1uaEJPRGtkRk5WVnVveG5KNUhvT0RXOEx2Vm1NN0xSRDV0d1ZsemhXNE9mNVZjMDU0VzJyTmJCWTN6NXJqUHo4WTUveitGVlRQSEx5b1BQT2NWQkt0MUlyUlJ6QlkrdVIxL0tpcFRWUldZVTZzcWJ1aloxRzl0cHJQYlBFMGdYSENFQWs4OThlOVkxbk1xM2JpQ0prU1FxeXF6bHR2YnIzNitsTERMSmM2YjU1WGd4OG5QSEhYOWFoZ1dWWFZveGtCZWNuT09SL2hXVk9tb3BvMGJic1hkTEVKdUNaTUVyOXpIY2Y1eFZhL2xCWm1qWEttUjlvUFhHNG5wOUJUN09LVTNHeEJsZ0RrYzV4V2JmWHJRUEZzT0pFWitnOWYvd0JacTR4dk1VcktKU3QybGpTWUttL0taYmpvS2xnQm1kMkpPM0l5U2ZZQ3FmbXV4Y2JpREp3MzU1cWRMbFZqQzRPN2R1T1B3L3dycWFNSXMzTE9OZkoySEpVQXNwSi96MXhpdDJ4MVB5WVVSaTIxVUNnNDdEK3RadW1RWEZ6YVc3UndLOGJBZ3N4NmpKNlk5eCtsYTlqYVBiN2dVamNFZ2puR0IrUEh0WG5ZaWNHbW1kbEtrM3JZODZ2RS93Qk9tMi9kTGtpbjJkeTFsZHhYQ1lKalBLbnVPNC9LcHJ5MW1rbVo0WXl4YVZrMmpyNmorZGFsbnBWanA3TEpkSWJ1UURMTG5DQTl4anZYWTVMazFPRlFsejZGOTRKSjdNZlkyWjFJeWo1NnJ3ZjZkL3lyUzA2eGZ5OTdYVU1ickdYWXNNWTZjZy9oVldUVXlVWDdHaXdRS05xUlk0VWQrbFc3TzZDU0xOS29aMSs2VU8wOCsyT2V0Y2JqTjAzYlJuZW5GVFhWRDI4bVE1ZFBtaUIzTTU0WTl6VlMvdlpqTGFYcGhNekkzeU9yYlFwQno4M0h2L09vdFNtZTN0cEpvV0x3cTJHaWtYNStlNEk2MDNUdGFodUlOalE0alZHRXBiakk0d1IzN0g5S2xRdEM3Um9uZWVqM0dZbmZVSG5CVHlyaERJd1JpY01EZysvdjc1b2U1OHk1aWlYRXFmZHlXeGxobmtuMTZDcG9iTzRpaVo3T2RITElWUW93eWZ3YXMvN0JlbThNdjJHUnA0UVNWVmVvejk3SGYrbE5XNmlrbmQyTG45b1hrYXlXZDdaeFNRdVMxczVqeGhWUFBPT2VNZjRqb2RDeDFBWDROdkd5RndRWENrRGdEZzkvVTFMQkMwdHREOHBSL20ycTNBYk9TVGpCR1NNZGM4WXF4YndSV2dLVzhjTzZRc1hIbGhkZ3llQnQ0UDU5SzVLdFNNazFiVTZJUWNkYmt3SFVqYktxL0w4ZzJudjFIOVAxNXBrc094MmVPTXJHT0drSXp0NkR0K05TaVNXS2RXVjBuQXdyRFpnTm5IT2NZSHVQclNORW4ybnpZMVZFeVhCUmN0azg1eVNUajlPYTVFN081WkFJM2xjdHRLYlh3Y0h0L1UwaUJYWWdybG9Ua2d1UmtaOUJ6L2tWTmJ4eG1aajVaWWdFWlRPQ1J5U1FjRTBpeEc0TEFnQTdjS0ZUWm5CeDNKOStmYXE1dFIzRWl0UWNCUkVBclpiSUdSMTVHZUtodTQvTUtrUUJRcTUzT1FjTjdaL29jMWNhV0dFN0luWmdvQ3NDdVc0SDNzNElQVHQrZWFTUXp6cTIrTUZsd3h5M3pIUGJKNEF4N1V1YVY3aXZmY3daSTJ1Ym9STE5Pa1djYkF1U09NY2s0SDU5TTlhZ3ViQ2JhWUE5d2tJd1NGYjVzbjhQbXppdDZhSlpMYzI4aUxDdUJuY2VTZWhJSzlmdzQ5NkxkbXNKUExNaWVVeEMrWkpKa2pIc1Y0L0RHYzEweHJOSzZNNVFUTWVQUjBpMDJZcFp6YjJjTWpTamtqL2FJT2VmWGpGWnJSNm1rSXRuMVFwRUhJMlJvWEl5ZUFQeEhyK2RiYnpxN2xJcnlRN255ODJXSUk5QU9QVDhLcTNkNmxyRjVEU0FvYzdFWEdENnRsZXY2OWV0ZE5PcE52WFZuUE5SUzdGUmRPc1pieFFybmNjRXl5RUZpZU00SFQ5SzFWaGJUcmVXMmFlVXdoc3VvbHk1SEh5cWM0eWZZWi9uV0tiKzBzN3lLU1dRQVlJVWdraGUrYTI3ZlZiSFVWRnUxeXBkdmxHWENoaDNwMWxVc25xME9rNDNhME1kL3dCNHJjODUrNkZISDFQYzBQcGVwRzBkNG8wWlVPQXdZRXQrQXE3ZHd4Mk44VWdVUG5uSzhnL1EvblZlNHVCamFONmNkTVpBcnJpM09LYVp5U1NqSnBqYkRTNzJJZmFMblltNFlHNG5yM0hBK2xKWjIvbjM2em9JNUdHY0s4eFVaSDRET092V25pOG44dktYckZRQXUxeXhYNkVWYnNibXp0d3N6bUQ3VXpmT0NIMjR4MUJ4d2VLNTZ5cUpOMnZmc2RORjAzYlczcVIvWlp2dExKSzBrK0RndEcrNWQzUFFENitsVnRaaGpzN25ESk5IQmdiWGtRa01jYzROYkcyNFMzamt0YkQ5MnhMaVJuSGNZd2VCMSt2WVZYdTl6UlJRM2swTGtGais2WGhPbkdlOVlVcWtsTzUwVm94Y2JJd1V1b0hiN3diSFFacGtrc0tzU0FQYmlyODl6Yldxa3F5OU1nRHRXTkpmeVRaOHNoajI0eFhxUWZQclk4dWE1TkxrN1hvYjVHSzVQUXAzcGt4a2pBa1NaaGdkQlZKazNITGRlNUhXcG10WmpFcmlRcU1kem4rZGJxS2lZT1RadGFlMzJUVHpIZFF6U0F2aFFoRzl4bnIzMnI5ZldrYU5aTlVSUmlCV0pVZVo4NFRLOGRRTTFYRnl0anIwcklBRW5Ib1J4blArZnJUYmlSM2tTWC9XRU1NN1RuUHRYQWs3M1hVNzI0N2RqVGpSRTFGaE0zbkFMa1BHUXVUeDdjZmxXY0xhQzcxR2Fka0cxR0kyRW5nNS93RDFWYll6dGZlWjVRVnNuWU1ZejFxcllzOFp1L09WUklXTzg5bTkvd0NWT0NjZGZJVStWNmVaalhJRWNzanh1QnNrSVVEcjY1cHFJSkdKSGJyVDcwK2RkU3lxZ1ZYYmc5S1NOZ1FTbzZxSzdGZXh5OVRyZkRidC9aYWhzaEJrQTdkM0djLzRqTld0UWVlR0k3QTBoNDJnRElmbm9jRDY4OFZuYUx2WFNZcFVFZUUzTDh3Sk9jOWoyNFBwV29MeUVnSmNPcnk1SklCd1FQWGpyLzhBV3J5SnB1cTJsMVBYakpRcEsrOWloRFlQTkVzMTR5dzNTc1NvaFVZQU9QbEk3OU8yT3RCMDJaSDg0UU04UzhGZ051MCsrZWxhMXZkNmRibFRNbTFnMmM3c1kvUFB0MC9yV3BlM2YyN0NKaGQyM2V1NDdQcngxck9XSXFSbW9xT2dsUmpOWDVqbVRDR21RUlFQNXJjbjVTUmoxeFY2MTA3VUdMdUZUcDBMOVBlbHZHYTNYTWE3bUdmVEovMmowcTAxeExhMmV5ZU9UZXdHNGhHMmovZ1E0NlYwT2N1WFRjd1VJMzFlaHpzalNSTTZUU01kK1EvemRENjB0emFzSWZLMHkzRnhIdEhtRUhFaDVQOEFEMzZkaWExcm9uVTQxamtSQ0JuNTJYN3g3QWR4VlcyajFTTkJIREhLWUVKQ0xJdzViMTQ2RG9NKzFLY3RGSWNGZHVKUXNybEdBaWhEaGlQdVlPVi96aXVoYXp1WUVReHhBTTQybk8wZ1pHYzg5L2NWaDJWdkpEcmRySmVXWmh1bllNekp6djdjZ2NFa2pyK2ZXdDYxWjVDWm9XbUxINVd0aElRVndjbmcrdjErbGMySWx0eTdIUlNpNHR0aXZLbHcwWWtKbGtVRGUzUkZ4em5QdjB4MTYwNkNPQ05XbGtiTWpINWM0M0hJd0R6eDN5S2JMSjlwY0NPR1NSWS9tLzFtd0E1NUgxL0twYktKbm1CYTFhSGI4dnp5c3lNY2tjRFAwSTYxeVBTUFkxZm1PdUdRbnkxdFhaNCtEa0J6SURnbk9PUWY4YzFBbDZUSExBSGpEam5JREFLZW1NbjNBSDQwOXBKSXBmdVNrY3FwVmNLRnp6Z0Ruam4zcHBNbTFvemJsb1dZZWFvNm9mVURHUU92eW4xb2l0TlF0cFlXS1pacjNMUWlOaVZiQ3FqQmprNUp6ejNIK2MxTEE0dmxsM1pqSnlSdms0SjRHRDE1NmR2WG1rYzNMVE9qd0ZDK0JoZnZGVDJidmdBZlRyU0phdzIwWWx0MFozRE1Cc2JEY2RlRG5qcDNQRlRKcDdiaUVmS25hNnl4dGdJUnh0ejFHZDNVL1FWV2t6SGFrcDVSV1J2bTNFWTRIb3ZmbnVEMjRxNUgrOHhOT3hqNnFyZEh3ZTNPYzQ5NmdnamdOMFVaMVpkM0tNQUNjZEJ0NHh6VnAyR2lTS1V3UmlhYmF1MDVERmlXR1IzVS93QlBXcVVOM09KWG1pVkhMS01qYU11T2grOXpqOHhWMmVJL2EwaUxqNTg0RHg3RDdkc2ZuVVY3SzF0Ymh6SEU3ODRZSmd2M3puQS8rdmlsR3oyVzRNekRjU0xpYTRWMVVISWlhUldVQTl1T24wNzFXMURUN084Mk1MMzV4d3VGNjlNREhhckllTzZpMjNDb01kQms5eUQvQUVxckJORUxoaUxiWkd3d1hYc2V4eWZwL092VVVKUXRMcWNjWEdmdXZZcnorRTVKbFpkN1NsUWNjaGNIc0d6MC9IODZxd2FQTmFlWXFSeHZOakxFT1BrQUhUMzcxMXNjYnJhUnBHc0laeGtnU0x0SDVkQmpweG41cXlMZUtTMnY3Z3lNanl6UGxXaitiYjdBL2p6OUtkSEUxSGVMWk5XalRWbWtZYzkwc1FYQmNLRkIzT09meXFHMnVwYnB5cXR0UWZlZGhoUi85ZjJycXIrYUM2aFZMalk4YXNDR2NaQk9lY2lva3QxZU9HMHM0YlV5NU8rVUE3QXVPbVR4akhPQlc3eE1ZclZHVWNPNSs5Y3hvNEZGdjU0bmFUY2RvT01JUFgzSjZlbFQyZHpaVEZwTnBtREhZcURQM3VNOC9ROWNVbmlhV2MyYWkzaFNORUF6NWFZVVo0UDB6eFZIUUpMZGJDU09WQ2t3YitJSGtFY2ZuV3EvZVU3c3hiVUoyaWRIcUVadTlKYUMydTNTUlZIeW1Rc3ZBd1FNWTR4NlZoSFR0WHNyQjU3aVR6WUVPM2NIKzRQb2VjSElyUnNMeVNSRGF3Mmtrc29PVm1XVGI1VWZmUEgxNm52V2lMM1RKTFl3elFiSEw0VnZNT3h3Ui9FUFhQdDM5dWVLOHFPa2RWYzcxN091bGZTUng3UytZbU03eDZkS2h1RGNSUks3UTdFN01CMCt0ZDBtaFdEeUt5VzhQeTRjcUdBSysvSUpIUTlSVFpORGd0WTJnbWtKM2tZS3FTVGsvZDl1UHpxbG1WTk95Um04dWx1NUk4L2ptbUpEcER1WFAzZ01nZTlXYmlDK3ZYMlFUaGdCbkFPQUI3MTJoaHRMVU84U0xHeXJ3ZHV3QTg5VDZlK0tiR2t0cDU0dTdWVWQxRGIwVEJqOVNUL0VQcWFxV1BiMmlWREw0NzgzM0dUZGFTMTFkUjNhMjh4ZnFGRFozY1o1T2MvbFVsOUFJcmVKMDRWbEtnWTVHUGZ2MXJZMHE4aHU0Z3BqTUpBQ2tKa2h2UTlTZTNweGlvZGNMR0F3c3hmeWlOcHp5QVIzenpYTkd0TjFGQjlEcG5SZ3FibEVyVDJpVzFwYVhNU0xHemdNMjBuT1NNalBYMFBTa2xnRWVwT3lLY01PY25QRzBFL3FhbmQxbThPcGpleGpqREx1a3pncmdIQ2pvTUhyVFBEZG5jNnRxSlJVM0JVK2ZQUmVUam4xNlZ0U2JhZCtsem1ySkpwSmIyTWZWckpWaGpLcUZCQXdBUHZFazVxZTI4TFBjUkxPMGpXOFpqWEFaTXNXNzhjY2ZqWFRYR25DeHVyV09XSjJ1QjhxRUFFQnZYSjcrbjFOR3FXbDJpRERNWXh5ZG5UUHYzclI0cUVMUnZxekZVSlN1MGpOZzAxYk96RnBGT3pqZGxqakROL2gvbm10U095MEczbmlDMmd1bklDdHZuQndjREpYYndSOVR6anRXU1dLRXNSaFNQbUFKR1JXMCtoek5iK2RiSXlTakJBamY1VS9FKzNXdWVyS0QzZS9ZMmhDYjA3RTgrbGVIcmlOcDMrMHgrWHdVaVZteDdjOFo3OWUxVXJlMXNwRjhvUnpCRnp0Q3lndDErbE92ckxVSW80NVUxQTNEcXhWMFY5dTArbkpwYk8zdk1TTEt5UXVDQW9ZQjgrdlE0ckNFb3doZHl1YVNoSnl0WWUwa2JXMDlwNUV4bHlENWlMdmJBNXljWUg2ZHFuc3JxTzRqZ2crZFVRQmZNa1FnRHAxcmw5UTFTVzIxcExlQ2Q0NW8yM093R010MjZlMzg2MExYVXAzZVRjQkd1UHZCbStidVRqT0IrVlc2Y2xxbm85UVRUVm51anBMZ1RXRWdpbW1XUzJmak9PUmp0alBvUDFyTnZTWXJZUEZJb1Yyd1YyODQveWVsVUpkU2xpMDU1WHQ3ZTRoVmxVeUYyM0FudnRCeDNIUDZVNmZYVnZJVXR4a1JNTTdpRDFBOUI3MFUxUGw5L1d3T0t2bzdFOXZxYnJOQ2hSM2xEQlFTQVRrbnF2R000K3RYTCtGSklNd1dTM005eU1NV2lDY1o5enlmeEhyWE9TTUZrMnlzNkVjQlA0czQ2MXRhVmZyRVlvSjdiZEpoU3lMRVMwZWVRU2NnanA5UGFveFVWcE9LMUNnbnFObGluU1V3eVNGbWZEbFFBeGlQT2VnNzVPUjZBMDlRaXJPcW5JSjVNaTV6dVBWV1VuUGZwd00wNlN6Z04zTmN4UmlJeS9OdkNmTUFlTWNIcm4vQUQwektiTzNzbzBObkNYWk0rWk1jdDZqa1p3TzNhdVZ5anlwZFRkdlVrV3lta3hOQmhvOENONGdNbE04REEzRHY5YWthMWEzbUlTMVRkaytibWNoaU1kZU03U2ZhbncyaVc5b2pJSFc2bFAzdzN6TU8rTzNib2NIajg2ZW93YWhQR1NsMFR0UURaNWUxbHpucWVlZTJSZzFrbmVWcjZlWkNiYkhBUTNXNXJpMll5QWxFUXZuR2NqbHZYK1ZSd1EzQ3lid2lDRjJDcUpNaHgwNlpia2ZYM3FTR3ptdUxWWUkvSjJ5QUdab2dJeW1PdU9jSHQ5UFNtczBEV2lXN1NNaFVsVElKUVNNZHlPY2UzMHFyMjBUTDhrTkw3R2tsMnlwc1lieWtLc2tuWEF5Q0NQd3F4ZXZmM09ZeEdZQ1J0OHpLbFZYMHp1L1RtbTNUNXRWRTE1SXEvd0hKQWZ0a2V1ZmVtRUdTMkN5QzR0V21LN2o1bU8zVmxIOHNlblNoTzlta0x6STdxSm50WXZMdkJqK0lLaktWR01aQUI2L1hGVTRwb1o5c1N5cEk1REtINWRoalBHTzJjOS9mbXJjMFl0YkFYQndBajUyeWphRGtBSHFUNmRLV1pvb1dkckczd0NTM21ScVNvOWVtT2VuNjFjWGRXS1RzakhmUjdWcDBaMEJrUTRabVk0YnVPT25USEdhdFc4YVNKY1F2QzN5bGxDTXBVTURnYlFjL1hrZHMxWmFWMG5sUzhqQmtWdHhZZ25QR1Q4dVNRQUJSYXg3L0xES1FBV1pjcGp2MXdNRDhUN2ZTdFpWWk9ONUVxS2pzUTNsakV0a1o3Y3hlZS96Yk43REhma2NlblgycXJEcHF0SUpYbVJHWlNvakVvM0puRldycTRMS0laWDJ1U3dmNVFtU01kQWVTS3B3UzJndS90SGtKdlBCQndTMmZUSUI5Q09LdU1wcU9obktDZnZNZmNhVE84TE5reVJLU3FlVTNJeDJKLzhBMS95cWtkOWxacmJXOFJnYjdyYm00ZHoxUFBiQXE5YWF0RGZsMGRTUTBtd04xeGtualAxNy93Q0ZOdUlrbjFkV1I0WVlMRWJ0c2tlUS9HVG45ZVIwcTRUbW55elcyb25UU2pveW4vWlZ4ZTgzTjhWeXJBK1ZFTUtNWTlPZjg4MVJ1OU5mUzdNR0tiWkJHVGlPNEFETWV2QjY0L1QrZGRCQmVTK2M2R1B6WkprM1JsQ1N2VTlPTW44TUQrVk52NURjTDVjNTNRSXZMa1p5Um5QMDcxY2E5UlRTZXhuT2xHTWVab3h0TVJadE5XVVRHT0tRNUlIRzc2bWx1OUNsdm9CS3Qwc1NSOTVCaGZ6SFUvUUNwTk8weTVsUVF4WEtSSnZQbHF5OGxjZGUrT25Tck41ZHhhWGIrVmZ6eXl3bzNsN0ljTUc2azQ2ZC9VZm5XM3RIenRRZnlPV1ZLYXRKclJsZURUTlgwUzdlWFRqRmNPWVBrZjVTeHp4bFZKeHgwNS9LdEZySVdzVUYxTGV6SzIxZk5TUmdHSkhYa2NFOXY2MVV2eG8vMmxOUmVLYUdiR0VTTmdjRWpvUmdjZ1ZQcDAwVXpPOGtVYzBNQ2VZRmM1WUhPQWR2cHdSWE5VY25IbWZ6MC9BN0tTakp0SjN2NTZHdDluczc2RlprM3VISDhUZ0NNOXVBZS92V2RQZmlUN1BEZGlaRlpEbDBQbTRJSTY3YzRIOUt6dGJ2WHRyUlJhU29zWklhZU5GNGtQcUJrZ0FjOENzNyszUEtPMWpKaGV5L2VRK3grdFRTd3phNW5yMjdvYnJjcjVkalN1Yk84dEx3M1ZvMi93RGVGU20za2s4WndTY2c4Y1o1cHN1cW5VYldaSi9zME1nWWhZMGcyRWhSanFXengwNmRxNnEzU1M0ZG5FZzhzb0JFekVobE9PVDZmcjYwelZQQzloTkpHOHAzUzR6SjVYQVlkc25uOU9hcW5WdktNYWtkZWovcm9YV3NyOHIrUnpta3ozdDFwSnM0Yk5aNDBkMUo4MExqZGs4NUI2ZXRkTnBWNzlsc0xmVDEyeCtYR0FaUWNESjZuM0pOSlpKR2s0aXNvWTFqMzhSSW95VDdEcTMxcloxUzRsdElqRE1rY2psQzIyTmR4VVZyVXFRaGRMZG1NTDFHa3hvMG0vbmhFcXZEZEdJaHd1UVBNUFVBSHA2YzFtcEpQZm00OGhIdEpiYm1aVCs4WlFPY0FldkIvT3A5QzFDQzJoa2dobGhCTC9PcVNnbmdaNTV6MHo3ZGFxVHpXODkvY3ZaSjhremhwV1U1RWpBWUhIdFhtUlRxMWJTV3E2blZkMGs3UFF6SnRMbjFhOVIzbGRZVks3NTJ3ck1jODRHTUg4QlYrNXVMNlkzRUFtYXpLU01zVVFsQ0dVRCtJN2wrYkk2QVk3VlBHcGtpWjJiTE4wOWFXWFg3dUhUV2tFMW9VZ0FRUlN4c1pHYlAzZHdJd09uUDUxM1ZJdUtYS1p4ck9UMVJTaTBpL014UzRsY0FLRDV1YzdoajNxSzR2dFFoVjdlV3llVlUvd0JVeURHUm51VDFOVFcrcnlYYXNkdzNLTUZjL3dCZTFRSFVwNEptbWxUemtiSTJsdVdQT1B6eCtsRUtVNHQ4eitSTTZzWkpXT1ExaUc0L3RHT1NDM2Rta1VrcVQ5MGcrdjVmbFcxcHRwYnpRcjl2akRYQ25JMmxnRCtWVjMxYWZVcGtubXRvb1VWeWlxbzdIMVBmcFRudXBiQzZXT05TeXVkeTU1R1BUOEs3Skp1S1J6eGFUYnVUNnJxOWpGZVhPbnJieWlRUkFibUc1UVN2NmRSV2RwOFU4MGNmbFgwZHMrRDg3OERHY25ISFdqVUZaN3p6SjIyZWVTZDZqUEhRRCtWWE5MZ3N0TWVNWGUrWVNzR0RnWkFYdjBwYVFqWmJscThuZDdIUlRhVnAxcHB5NmhQQTkzYmhkeG1ZdXAzRDhPUjdFNHJOMG5WN20vMUIvTnRSdDJZQ2s3Y2R4dEhYcDIvR3QvVUpvb29aTGV5dXQybW5EdXJjNGJQSUh0d09LbytFekhQSGVSMjhFQmhFNGNlWU1Eb000d1FPd3J6WEpLbEtVdGZYb2RITzc2alp2SU1VVVprYU1odGh4dytNOEFuazRQdnpnYzArOHQyc0lvMkI4NXNmY1Joc0M5aWVQcjJyTXZKR2cxaVNFS0ZkbUcxSVNXWEhyejY5ZnhyYXRwbU1FdHUwYnlLQ3BZb24zTWpxRG4yejdWbk5PTm5jdTQxWEY4SXBac0pzR1NYYll3UHJ0SUk2RUhQV3BJcDhSdWl6ZmFnV0lDQkVWVlBYTGNaQTlQWCtlYmFTUVhrc3g4cVNGWTEvZS9KNWhmSEp5U3VCMjdWb3czRWsxMjJJa2hpT1F3OHYvV0RBd1EzVHR6VVZJT0t0MC9yK3RCTklaL3BBcy90TWNNY2x0R0J1TVk4dmVDT2M4Y0VjZnJUclM4VFVFTVgyZnlValhCU1FieXlkc25wajhhclgwVDdTYmtUcmJsaVRBaWpCNll3VDEvRG42Vk5hV0VrT29mYlc4OTBpUUJGaWJBVXRuQVpTT240MFdqeWVZbjNKYmk5aHRqSEhCSExQTHU1V0UvZEE2L0tPQjF4MHF2WlhzVHdTc3dtYUl5NTNINUEzT2NIT1ZiSjdjSDYxYWdpdllwcG0xTkJJdWRzUVFqT1NlT1FlY0R2MjlxeTVyZEpMN2NMcVZSbkRRc2hibkhBNUlHS1VGQlhqK0pTU1pmRXdtdkdpM1d4ODMrL2NLQUIzR0NPVDlQeXE2c0RpT0RaTUEzUmtTQlNDZmNramp2MHljVm5wZHpSRmZzK21Rekx2SUxiOE51SjZnTU1EcWFsbXM3eVh5VmVNU2dqZmd5Qlkvd0FOcDY5T3gvblN0YXlXbjRrdGFrTHBHWkd1amR3U0ttNVVSTU1TZVJnQWZTb3J5RzlnWkhFcWhaZ1AzYlJsbFBHVG4wNitvcTJzTnhZeWZhQkpGREhrL3UvS0xTNTZEdDhvSHY2Y1VrODl4cTl3MXZLRWxqQU1aalljTmpITFlJM2ZsMXFvM3ZkN0R1NzZGQzJpRjIxeE1WakcyUGhDTXFlRGs4Tm5CejF6MnFucGs5b0l5clJtY2hTV2NZQUFHUG1HVGp2OWZhdFMzaWpTZU1wSkdqWUN2Q0FUajhEd0JrZGF0ZVhpTXNJaSt4ZHBPQ3U4ZFR4Z0FpcmxWU3VyRmFyUXdyYWRKMmdiempIc0htRnMvTVBRWURjOXV3NjgxYzFBeVd0dVhnczQzZVZnQVNCaGdSMUpCeWZwVmlHQ1BZTGxSSmV5OVZ6SHlxam9EejZqdWVhcitWYzYzTWJkNEVoTUhMS1RzSjdBWnlRZnI5ZmFtNUp6NXVpRzU4c0gzSTdXMW4zZVNyTkRzVWJ6R01Ldi9BdU9jVkpKWlEyYjdJWi9OeU56TXU3Zy9qL242VkhGSFBBNGd1WTV2S1RKVjJrK1ZUbnFPM2I5YWhrU3prbFZFdTVaVllFbFZJd2hHRG5PTzNIclZMV1craG5WblVyUTVVckx6L3lFdVZqdTFFUkpDc2NxUXZjZjUvR3EwbW13djhqYmlzYWd0azV5QWU5T21XTFVTWTRyL0JSZm5WZHFrbnQwSDlPYXNTNlFZWTEyM01oSitYR3c0WnY4TTlzVnRHWEpvblpuQldoVWRsZTY5RG50UnVyUzNsamhrVHpXa3p4eUZIQkg0OWYwOXF6TFRVSkd1NEE1TW1IV012dndRcDRJUGJyM3gxOWEwcHRBZ2kxYnpidlVpTnZ6RWJjYmpnWkF4bjg4Zi9YMk5QaWpmTXVsbExVUWdEekZUSkI5RHh6MDYrOWQ3cXdoRFRYOGdvMEo3UFN4cUpZYWNBWWhwM3lzcWw5N2xpQ1J3dzV4ams1eC9Tc3VUdzVwMEVtKzRBa0NzVEpNOHU5c2V1eGNjZmQ1NXFpdXFYbDIvbVNPd2dCM2V3QUdPQjZZRmExckd0MXFFQmVXUklXSEtvQ3JuaklISXhqM1BwWEZ5VktkMjVIYkdjWlBTSnFtV2VJaVI3YVh5c2NTcmxRU2VnOTZnZ3U1WmJyYnUzdUFXWlNjbkE2OXZjVmV1WjVOUnNGbmU1ak1BKzhJME1aVW5qUEpPVHpqOGFqMDNTNDdLNGx1SnJyZEk2RlVVakd3Y1k3OWVPOUVzVmFEYitMdHFRcUxVdFZvaUxTRTh6V1VJVjFKWTdKTUVyR1JramR5UHAxNm1xSGovVWIyN3RRa09uelFzckJaWkdVWUsrbTdQVE5XVE1aSTBmSlBsRWJramJxYzlhdFgxd2pobzVVTHhOSHNaRzY3Y2MvenJWMFU2aXF2ZEdTbWxGeE9JMFMyZTJVM2Joc01BcXZrWU9ldUFPZTNVMTArbjJjbDFhczlwYXV6Wkd4eHdBY2V2UWMrcDlLZ0dsMmNMSkhBODZ3Y2tSa2duODhjVjBtbjZ6RmEvWmJSWXRzUkFSY25rYlJnOU9weWFxbzVTYWJXNWNZeFM1WU16N2k4WFRKb0JjUXl4R1JnRzNnWVhwazdod1IvU3FuaUs3dDRyVmJlVVE3NXprS2Zib1FSWFhTeHBQTThaaVI3YmI4KzhaL1ByeFhIZUtQQThHcVdyMzJuek9zMFVXVVV5NVE0N2M5TTA0T043U0lsZTEwWm8xQ08xaEFtbWl5UU51RGxqL1dyRnBmV04zWk9wbUFjbkNoajh5bnQvS3VLczlKdXBUaHRxdG5iaHlSem42VnN3NlhKcGVuejNFanJKZGtnUm9venR4My9BUHJWdk9FRnBjeVRiM1J1YS9wWnM3T0M1SVVPeEN5dkd2WDNJN21xVnZiWHVzRVc2eGhZc1pXVUhuOE05TzlPWTNsNXBTUVhjc3JHUWxta3o5M0dDQUIvbnBWN3c5STl0WXZCSzJYaSs3SWVoWG5yV2JiakcvVXRjc3BXS3Q3cEU4MXhIWW9TekRha2J0Mkk2NS9VMUdZNWRPeTEzS0dkSDJxbU1LU09PQld0L2IrbjIxNGtvbkZ3d2NmSkdBZWVoNTZWVjF1WWVKOVpzN1I0bnRWalJtUnBBVkpCNWJwMTVBSDQxenVjK1pjeXRHMnJOMUZjdWhTdXRTdk5YaEZsQWdWUXdhVUtSa0w5TTgvaFd0WVdVbWsyUjh5L0VFREFzeXhFTU05dVNjRDZHazBuUWt0TjhYMkx6OVFLYjRRcnFBdUd3U0hKeUQwTlc0WUwwRjJ1NHBXdEppM21vMXVwSWZPTU1RT1FQWFBPS3hxelVvMmh0K2Y1bWtZOHIxM0tsdHErdHBMNVAranZHQnRRVGdKSm4wVW41U0NNZFBXcmozV3JXMS9HcUo1Tm9VQVZlOFpKNXo2MCsydEx1QzQreTJvQXRpQ1E4TWdaY0FqcVQ5d2owcG1yM2Q3ZFNRaTN1Rm5nUmRzaWtnUHZQUU12YmpOWVdVNTZKV3RxRjFIeks4TnhxalN2YjNFYU5DTUtZM0tnTmpqT0FjazhlNE9LMTdSN2VTS2J5cFpwWkl5Qis4RzNMYmM1R01jY2pnKzlabGhCYnkzQmptaWhNeFViUXo0SGM1SHZXN0RoVmtNd0FTUmNHU1lEOGo2bXM2OGt0bDl3NWFMUXliYWQ1bW5TU1JKdkoyNzBhTU0yQ0FjamNSeVBZQWl0R0lUWGRsSjVpM0VVVDdkeXVReXN2SEpiUEg0Yy93Qk0yMnVtbUx2WldhdERFNVZuM1p5M1RoajFBSkJ3ZTNZVkJIL2FIMkthYlVidU9aVUdQbUd3Qlc5QndDZndJL3BUWE5mVzM1aWNleHA2WmIzMEkzc1ROQU1pS1Z5UExUbnI2amc5Y0Q2MUJxVU1MaWE3RVZ5MGtZTzZkMkxBQWRSN0QzcUJMNjYreUV4bVZ3T0F4TzVHVTlzTHdjZlFZeUJVY1BuYW5ZbXp1Sm9FalVuSVpaSXk0NU9DVi93cGNydnpQUXBKcDNLOEd0V004a2tIMm02V1VQdE8xZHVDTzNVL3FUVjZVdkpQYno3b3BZWFpobFJ1T2NFNFkvVDB6MnExY1FRQ0g3UzFyYmJ0MlExdElpWk9QVG9jZ2V4OWFmRkJiSmJSWEZ4RytKQVcrZFd3VHp3TnJFcjdmem9iaGU4VUpUYVYzdVVMcWVkb0ZlSVNSR003aGxTY25zQ0R3T00vV25POXhKcGZud3ZJR2tPK1F0YUxoRGpyMDZZQTl1S3NSNnhKZFdzZHZHNklqRVJ5VHFwQVVIMXoxNjljMHE2dGU2Uzh5WFNiSVY0amRZK1hIcmpCQUJwdThiSklidTlHdFRBVFRKV3R2TW4xS1BLTmxvNGxJWTg0UGZIVFBYQS9DdCtTV0NLd2ZaSzZOSXdMTWtURmdNSHFjSG5uMEZac3RtbC9kU3lvaXFpTHdJMVVaeVB1bkdPS2swVXlhZWp3WFZzNGlaeURzWGVWSHQ3ZmhXbFY4MFU3NnJvTnB0YWs5aXNsbGF5enJlU0RlZVhrUVpZZGVlUDhhb2VmTVdrdk5OdjRwcHpsZGtmU1BrRGJ5dWZmL3dDdFU0MCtMV0pybExJdkRBcjVkSlh3em4wMjgvMEZGbmF6MnQxSEhKT0pJRmZDeEFqNUd6bFFld09hVGNWZHZmdG9CbjNzN3dyNXM4a1ltWmwyS1dabVAwQnd1QjYxUkYzY3lYVVhsSnNNN0VLcUhDKy9QdFd6Y0pIcUhpYkwyU3lzcTdFV2ZiSGsrNm5ITlE2MVlSMlRXOG90VEhQQ3piTGJZV0djWjRBR092UG9jVjBRYTBUVzVucmZjWWl4M2VtendScVdTUE1nYUtJa3ZKbk9Td09jOGdkaitWUnpwcnNja041S3lXN0xFRkFrSXpsdTRCNUorZ05Ub2JxNXRJNzFMaVJRempiSERrc2NqNWx4akM0STk4MVRrdmtXNlNTK1MvdFd6OGhiTEZRRHlTVzcvVGpudFNoRnVUMHYvV3Byek5iRXIyYXl0dXVJRE1pQU1XOHpwOU04NU9jVkhGSmN4Nm1zeVdpL0lxdWJlT1R5eXlzY0RKeHlmcjZmaFZxMzFpelJBZFBsbkxxeE9ad3JBay9sbnIwcS9IdnNWRXMxMUlrMHZEUkNJSGFmcGpIWCtScUpTbEc2a3ZUY0pLN1Vsb1o0MUNLRzllOUZyTWprL1BibDl4R2VDUVIwT2M4WTc5dTBSdXBiMVpKcktONUk3WTVkblVsbVlBSEdDT2ZibkZXYkc5Z041YzNLczhzMFkyczB5Y3QxNEhvQWFyeitJbXNwMWh0NHdKSjJabGtkczhkTzNYblBwMUhCNjFhVXJ0UmpyNXNoeVVVbTJQdGJhL3MxZU40WGtkK1R0a1hiblBZQTl2Y1pwNGxjUkJaUTVic01ra0UvcFdySGNycU1qV3lXYXhSeVljeWdjRC9EOHFyRzF0RWtRaTRKWCtOMDVHTTgvd0JhMnY3MTJjMDd0V0lvQ1VrTHJJSTVGR2VPUWZyVmxRazhRMzdmdS9OdFBmc1B6ck8xU1A4QXMrMnVIdEpSZE1nM2JkM1krbnJXWEhaK0pKNVlpeWVVMGczRExBa2pqakg0OU9LM2hLSm55Tm5TV2NLeHN4a08zYWV1TTQrdFVqT2x0Y0pkQkRLa2NnWlVrR053QjdqMC93QW1xa1dxWFJtWlpadk5rNloyRCtWUTNGN0Ziai9UYmhJL1RjZXY5VFdsNzZFOHRqMXhKTGVTd0NvUDNXM29oeFhFYXpmVzl6Y05iNlVvTzA1WmczeWoxNHdLcFd2aTZGSVlGczd5VFkwZklkQVNyRGdaK285UFNxNTFlSWlhUmlaTGladHU1VXdvSFQvUFd2THcxT3Fwdm1PcVVZeFYwOXpMMVRTWloxbnVqSWtpUk91NkpHMnNHd1BtSFBQUDQxTFkya1VPbEY0MmN6TVF6RjNMRlIxeHoyeFd4Wk9rVWNreTdRbUFXVmhqSFBVQ3NLeHVmUDhBdFRHY0RFNTJ1cDZyMC9wK3Rka1hOM1QyUk5SeGNWWXR0ZFFJSUVZQmw4MGJjanFlZi9yaW0zMXJZc3l0Y3hsNE1Fc0Z3ZTNISEFySDFXWjdhK2luaURtRVpJN0JpZXY2VnAzcGpiVDRaWW4zR1ZkcFRyMUgvd0JldFdySlB1WUxVcmFiQXF6cTlwYXhMNWIrWXFTZHdQWEdPYW1pOFNJdXMzTnZlV3BnVzRBd1ltd1VPMGNxZTNmMjVOUytFMUIxR1RlaFY0NGlWRGRRY2l0QzcwM1NudVhpbEVjVjIvS0tVMjdoam91QVNPYzlxNUoxSU9xNFNWOURyaEI4aWFmVXNMcUZqTmNxeWFoSGJTeUtBV2tJQXh4d2UyRDlPdWEwZlBWYmlXWm9tdDdoZmxCamVUWktSd3A0Skg4NjVMVmRCaGpqU2VCbmtpVEN6UWI4U1JzY2REL0VPZTQvblc1WTJ0dWJlTnJLWFVJeVR0K3orYWhWejdrSEdPZXhGYzFTRk9FRTR5ZjlkQ3J1VDFScFhVMm8yMmxwZmg0MmtaZ3JyYmp6Q0FPU2NaejdFZjVHQ3Y4QVp0N013dUlaWWJ4VDVoQkJYekIyQlRCSFdyMm9YRjdZb0laYnByUlk4NGxDQ1FJRHdPM0hQODZZbG5xOTFPczkxZFcrb3d5S0dSTmdpYm5yZ2o4Ly93QmRSVGNJeDVrN2YxNlcvRXF6anZxVmJKN0pyVyt0SXJlZTJkRHZCZkkzRVZyVzBNVWtNRnU0Zll5QTVSaHVVNC9pNXg3ZEQzL0dqZDM5elBkMjlsRFk3RzM4TVYzN0dYbkdCempyNlZxWHVxMnQzQk5idkRKQmV3S1ZaOXVRdWNjNDlENkVkKytLbWZQS3pXbC9PL2xjY25yWW9oYm1EVUFrSG1mWjFZcVQ5b1pSMEh6SEE2OWZ5OTZ0UzZsOXNMd3l2OW53Y004TGh2bHlmOWdISnhuR0NLZFpKNStsc2JKL3N4QU1lUVZWdDJCZ2c0eDNyQ2gwK2ExWjd5OHVJNERrUitVVXl6TG5uNzNXcmhGVDNlcUUwcjdHMnNrTUVLMjBaRDd3ZkxJWGNkM2ZQekQ2NHdCVTh0N2JXTm1sd2tpUnZKbEFIVEhtTmpyaGVuVDA3MVF0N3UwYVZ4YVNRUksrNW1HQUJIbHVBU09PNC9LdVZ1YmVTYldYazFHWTdkd1VRNTJmM2VTZXc2OGpuaW5ERCswbGFic2xyNmt5V251N25YUk5EdmpGeXFJR2NFdVdaMUl5TUhhblljY2pBOWU5UVgydHcyNVo0MFcvamlHVlZWSzdEMDVHTVk3Wnh4V05vMm9IU3RlaWlTUnJpMVk1VXZuT0NPZnhIUDE0UGV0Z2FmYlFUVFhtbnpTU2xIQlhlQUh6L0VRMmVlcDl6V2xTbkNuYm0xL3I4QWhKU2xaNk1aYnpXMHgrMkdKckNSRHUvY2pLOXM1eDB6L2pXb0xsN3J5NUxPOWhudDNPQU1sUVQxSUxFSC8wSDFxamVXdDFib3Q3YXI1N3F3YnkvTDN2bjI1d1AwcVMzRTl2ZGVjc2FXRXN3M0hHTnN2VElLNDRiK1IrdWE1M3kyNXY2L3pLbHE5QWpObFBkU1FSYWZwN3hBa1BMZ01XNFBJd1YrWWRPZzYwMFN4Q1A3SGo3TXBBWkF6TmdyN0RvTW5QUFRCcXJOYjJWM05LWDB1YUY1R3lzbU5oYzU1UEp6ajhNZlNyVVZwNGRpa0cwUi9hRmp3enlaZGlldVQ3NVA4QUt0VTR2UzcvQUsrWk5yVzBKWkRMYVBIdHQ3ZEk4Zkt3WGxoamprOWZXbXRQZTNtbXh4MmNyV3ArWm44cUp4azljbnVCMU9PUHBUUkxad2VRc3NrRjdDemhIRWNwamRCNmp0eDlSVm5VYmlLRkZqMDlKSW1rNExRWkRFREdjcjNPTzlRbzJhVFdvTnA5RFB0bzlWaUszUDdva1JqZE9XWXF6RWM5eCtIV3BIdTlVakVvaHNXYUpGM05JempwbnQ4Mjc5S3JqYkZJSEZuZHE0QlNKRlViczlTUUd6Z2s5eDZWWkVGN3FWeXM3UElqT3BEeEpsTm51ZXhKN2tWVTNIZVNWaXRlNVNrMUs1dnRNKzB5N29MZFpOaE0wSlYyVUhPTjNJUHA2MVJ2WXBaN0lUdzZhN1FsZzI4bmNTdkdPU1FEV3hMZG9pejJsM2IzRHpEbGM3QkdFN1pKUEovS202ZnJOekxlU3dTNWtWTWJValZVVUQxQkJKOU9PTVZhbEtLNW94VnQ5K2dKdTNLVjdIdytqVExORkxJbzZzN0lHUUhPZUY2NS9IMTZWWjAyM2lrdXBwMVZwbENrRjVKUWpFWTRLcUJqYjE3MVp2NVVIbVhkbE15MzhzWVVLWVdaVUE2cmtBKy9HYXdySFVZRVo3clVMZUZtWWJXVmw4dnZ5MlFDU01aUDVkYUlxcFZUYi80SkRhNkV0ei9aNjNTdEJiSWtjT040V0pRcFBVRVlGVWRSOFRPOGpKZG9IaFFDUmsyajV1ZU9lbzU2NC9Tck9vMzhWMEpZYk1oTFdKbHdpcjg1K2dQcFVjVnhjNlRDTHNXSTNjbHJpUUs0Mi83Z0FJeDYxMFJpdEhKWGZUVXArU09mZnhoY0JWaU1jVW1CZ2hjblA0Ly9BSzZoZnhIcXQwNFNGWFNNY0NLTUhua2VuMHJidUxIVG9MRXl5d2hXWVlDb01HbWVINTJ1N21HRGJoRUhUT0FQcFhjcDA3WFVUamNhamRuSXEyL2lIVTQ1b3Z0TmlJNGQyR2RvaVA1MTNiM3RqSnBNZDNFNkVKR1B1WllwMHlPeDdWZUVPbnJBc1F3eUtNWmJyNkhqdlZLNjB6U1hoWVJ3cmJ5TU1GNFRnTjlRZUQrSXJpclJqVXRaV3NkT0hrNmQrYlc1enV1YWZkenN1b2FQY1JSUTNESHpBb3k2bkhQVWQ4SDN5YXk1UEFseGRRQ1h6WGtrYmtzVG5QcjFxMVlUU1djalF3ellXUjl3N2c0R0J3YzllZWxkUzkzY1c4QTJydVZrM2JUZ2tFanFEK3Y0VjAwM09FYlgyTUswWU9Ya2NMSDRSbHRMZVJpMHZuakFIT0FCM3JiVzNTeDBXQlpFUEhCVkRsaWNWZk53N2Z2SlczQUVzUmpGWityVzhwUDJpS1FsRVVPcUE1QjduOGNIOUt0MUcxcVFvSkZRWC84QWF0bTl2QnVFTWd3emZkM2UxU1BvcWlGWTBXUU9tQ0ZVRUJsN2ozNlpwbW1LanNQS0g3b1p4dDVBcS9lYXVMS2FCd3dMYnNjSG5vYVQ4aEs3R3ZGRmRXRXRySmdLd3dyRHFEMk5ZdHB0aFpwYnBCSkpFeFVSazVRZjQ1clcxS2RrMDVOVFg1bG1ZcStCOXg4QTRQNEg5RFdycFZ6cGwxcGx2SjlpamttOHY1VmRQOVkyT1R1eGcvUTlNVmhWcjhsUG1TdWF3cFM1bW4wS0Z0RkpmVHg2Z3hsamk1SVdMQWJnNEpQQndPdkh0V3RGcjJrMmNMMm1xd0s3TGdicFlkNGJJOWV0VUgxNjdNUG1XOEJ0NDFITzRna2RPRkJHS2xOdlphaENHdTV6SGROZ2Z2SVcrZlBjTXB3UDB4WEhLS2xyTFJlVzZPMlNUWEswSzF6Wk84MXpCZFFUMk1pNEZxZUdUakEybnFmeHFlSFNyNjF2VjFLRzZEMkJUWWJWeUF6Y2NBY2Mvanp4VWNmaDJ3dFdpVjVXdHZOYjVROGVFWW5uSFRHS3JYR2h6SzBrQ1BCTkZJUzhhVzZtUUE4QW5qTzN0MnhVeDVKWHMvdlhUL1B6TSt5dVhwTGhOUmxFTmpiVyt6R3k0RjZTcFFEdDY5ZVAvd0JWUnk2ZGQ2VURGYlhVY1R5THRoamR0OFNuc0JrOVFQVWQ2aTBXMU5xVFlYTnBFcFp5MlpFWEs4RW5MSEI1QXppcEJkV1Y2YnpTTlF2UjltQnpGdVJTWXVlY0gwNTYxTGk0dmxqOEsrZHd0MUxkcTk5RGFSU1Mzbm03WHdZVkNsZ08rMDdqNmVoUDBxU1dhM0ZnTHFDOFNGcnR5ckk2S3BrUHFjbm42OWZibXNDMDhMTGZYRXFXbW92SEZIOTFvbitkd09NK21Pbk5RUWYycEhmQ0kzWVdPTG56YmlMZm4wejBJSEg0VmZzcWM1UGxscjZXRXJwN0YrL3Zic1F3UVJQYVJzaTh1cXM2dm52eU1ISXh3Yy80d1hUS3lxaFJFYWZDb0k5b1lEcmtyNmRQcm5wVkpKOVV2ME5ySklrWWNsVmtRQU02ampnTHljOU9lSzZYdy9weWFjelRQZHBLdnpBSzhRTXFuR0I4MlJ1QXgwNFBhdEtscWE2WC9ycVBudHFpdFlXQU5xd1M1UnBDTU5HWXNGdW9CK2JsZWdQVDlLcHhXTnplT0ltZ3RaOEFFck1vU1FZNjg3UWYxcllGbzkwTHczYkcwVEJZemtFTVBUYUIyN2pyK05VTkswUm9wSjNrMTZRamdoMCtZdDY1M0RnNEFIcHpXRUp2bGxLLzRmNURjekxuMGFYVFV1RFBDcmxFSGxORTdmTHVZS1Jra1o0WS9sVExHd2xsZWF6czJ2bG1IenhzWlNxcjA2Y2dFZld1a2ROTjFaRWlsODQzY01nd2lvcExEZ2NyZ2p2MS9YdFUybnhhZEJKUE5FeHNGWWNaa09Xd2VjWlBYNlZxOFJKVTd2Y3phWE5zY25wbml1NnNyaWVIVUxkaDVMYkdEakpCUHFjZTMvNjYyYnpYZExrczQ3cUNCWHVJK1pJZm1HLy9BSGV1T3g2Q3A3dlZMUzVhYVI5T1I3UzdqVkpjQUJtWWM1ZkFEQThqcDZmbmlYWGhPMWxpa3ViUkhzcGR2eVFvd2RCejF6dS9uNjF1blJuSk9TdDZiR2FqVWd0RG90SlUzTVQzVVA3c3lwNXFSdW9SbDZaNXhuSFhGU0paZWJKSzkzQUQ1eWtPZ1ppamdIRzcxendPZno3MWhhYkJKWnhsQkRjaVVoVElzc2U0Tmp1R0J4ejF4empQV3JGeGE2aGRYVytPOVNISHl0YmhqbGg2OVJYREtDVTM3MWwzT2xSNW84ekxkM1pKcWNNanhHUVNSdHRVU1NsRUhYbmtjakh1VFRyWm51b2o5bGVDRllmbGtuczl3d08vSkhQMUh2em1zMTF1R3pQSkdCYk01MngvTTJ3ajFKenorTldZMXVkWXRuc3JoTHhZb1VNa2tyeVlXTUFrZzU2NXdPbld0WEY4dW5RVGpicVdvV1ZMYVMxdUpsdUlEa0pKNXBjdm5uYVNBRDdZNjBXV20yMTFiSmVyTkpFWTFBV0lYQlNPQUFjYnR4NUJJSGJ2N1pxVFNyMkMydFpMZVM0azNGaUJsU1J0QXh1WWpHVHgxeCtmV3VlTnJQSk1WRi9IUEdXTElzY1paOForN25BVThHbEdEYmQzWW0zVFkxOVhzYkNXTTNrZDJDSWVaSGpHL2VlbkE3ODB4aHBuMkJvYmVWcG9ia0hESWdMcVQxQkh0eDZWbkpxN1EzRWR2Qm84am9FWU9rNm5hZ0hQM2ZicjI0NXJZMFpyaVI1R2plMGhhWWhkcmcvZTlldlBIWVVPazR4U2s3ZGl1YTYwZXhOWVdQOEFaUVkzZDZKQXk3WTNrVUtFSFlZQkFVZm5XVGZSMm92SEZ2SDVseEtBWGVGK0FQVUFIbk9mL3JWTHF0a0o0UkRjNjNGTEw1bVdDUWhWWWVoN2s4MW8yMmxtMTByeTQvczBNdHd1OUE4YkJpdnFRSEI2VTF5Sjg3bCtESWNwS3h5ZW14UzIycFNDNVQ3VEswWlVRc0NObTRjTWNqMHJUL3RHTnY4QWo1UXhXNGJFaitVVDFCL3J4VnV6K3lXVjRqdHFHSkxPUGFzWnQ4SU1namc4NXhuc2FxM1JzdFp2Skdtc21tVXRtTzhWR1FNZXlsajI2L2tLMGxLTlNWMnRGL1hVYW0rbXBqWGM4Wk1raGs4eFIwWW5tb1BDYWVZOXhLN2tZd2NFNE9PZjhhb1cyazNlcFF0S0poR09CczJ0azU5d01DcnkrSHBMTDVoZnpBcGdiVStYK2VhOVQyUzVIRzV3KzJmTW5iWTY3N05hVFJaSExFWTNra2tmVHRXVmNRUUpheXJKS1BNWE93b1NONDdNZWF5LzdGMW04dDNtajFLU1JVL2czQU4yL09zYVdkckM2ZUtZeVNzcDdzVFdNYUwxU2VwYnF4dmRxeDFWbEY1N3dqSzc5b1VISFRGZEZmS3NqcnlNSUF1NzFBRmNsb2Q2WkxxT1JveXFLTndPY2svNU9LMnBMbWFXYnpXTzBnNXhqb0twSzJqRk4zMksyclA1ZGhLSXNlYStGalhQY24xK21hV3lqbW0weDQ1eHRrVnNFQTgvcVBlbVBQSmNhaUpMUU1xd25vRDF6MXgvT21YZCtsb2ozRHNTMjA1WGJ5U2NmL1dxSmRraTQ5ekd0ZFJmU2JpU0F0dmozRkMzWTRKR2FsbUNYa29hSTczaStZaE1IYm5CeVIzSEg2MW1XM2grK25XWjRwak1Rdm1Lb1BNb3p6dEhyN2RhNkxSaEhwbW5lWE5wY24yaVppdStNcVNNZENRVGtkZnA3MWRhYWhHOGRXT2pHVG43eXNhdHZid3krSEV0SWRUZzg1SlZsTUxSNEtjY2d0bnVCd2NVdC9xc0VUd3JxVnBiL1lSR0VDeHdraEc5ZU9uNmRhcStYSGEvNlRiU2tTT2RvRXUwRnVPUVA1a2Y0MUpidzJoY1RXZW9mWk44aGFTM2RRTzM4SFhIMC9Tdk9mSzlYc2RqamIxTkhTdFJlRVNSWEVzTjRubGsrWWtJWnNZNDNGaU9uMC9HcTF6YVFpUzE4M2Fsckg4dzN5WlBBNDZkdXg1NmQ2cjZsZTJGdGJuVGtzNTNhWnM3a1RrRnV1R0JHUnozelZqVHB0REZnN3lTSVE1d3drak83UEhHTVpQWDNyR1VYRmM4VTlmSVN0ZDMzSC84SkROcXNMMjluYSthdytZNUdBbUQ5NGJ1MmVLeHJXMTFNWFFtYTh0NEdBd1RDRHVJejN3UU8xUlhWNGt0M0ZOYXd5UjJaT0N4VWhTZXhQT0NlZjFGYUJ1SVlJVmtjcWQzM1FCa3Q5Szc2RkdNRm9ySi9lYzlWdGFJMHJyU0pKN0tPK20xSmp1Y0NKQnRPMWh4dUFJUCtUU1dxV0xhZW5uVzZ6M2NQM055cVBNSkp3U01nSEdjKzFaZHBleDNNK2Z0RzBuT0VrR0NSNlVqeVJYRXppZFNoVWp5dW5COStSeGpJL0dsVm9yazN0YnNUQ1VuS3pMZG15NlpkSi9hR0ZhWjI4bWFDVExLNVBLL0o5ZW1NVnB4cFlhanFFeGE0a3VBcS9kd3hVdCtBeWZ4OTZwYUZhMjh6TmR5VzFzOXhFekJIZGlTU081QUJ4L09ybXZhcnA5c2lRaU1TWEV1M0xReGY2c0FnNUxFZE0rbGNWUnlkUlJTZC9MK3YxTjNkTXVhWllyQkw5cThscllJakpqeXhnQW4wSDBCK2hxbytvelh1dlRDMnQ0QjlsWEhteVQ3TjRKN1p4bjh2eHJKdHI2OFNWbDFONWpGSjkxcmE3Q2phZllubjgrMVd0SzBuVDcyOEVxYWxBazdQKzdVb1BNQXhra2tOei9TcDlqQk55bnJwL1g5TVVsWjNaTkxxTTRNMFYvYUM1dDVXMlBOdGtWRmJybGQzYjZEbnJVZHZiR3hZUGJUdGNXMGpscEkySTZlaFA4QWhWaTVzWXRPdUovSVI3eTNkU0p4STN5SjZrZFQzSEdSK0pxbjlzMCsxRFhpMnNaaUNoQVBPY2c0UFRCUFA0OVB6cXRIWlFXbjlmY09PMTdEOWJtczFzZnRGdkM5cTBSQW1nMmdEYUR3Y2pnOWVoL1NzaGJtUy8xRkRhckRHbms3dDVRTVE1NFlIMFBlcjhkMUxyaVBNOE1xV1dBRXQvTENpVEhvZWY4QUlwODJqV2YycFk5UG1jbGxDZVVrbWRwN3NlRHo3ZTFhUmxHbnBOYTYrZnlFdWJaYkRJMSt5M0FXK2wzUk9kNWlqVldDNFBCMmxUanIxVWo2VmZlZUM0djAreDJmMndUTUZ3OGdBaUEvaUl4a0RqNlordFI2ZFp5V3NnYlNyNlVxb0ptV2FFNUE5Q3h3T294Z0ROTXN2Rmx6YTNyYm9JcFlYYkJkTm9FZjRFN3NlcHFYNzdmS3YwL0RUOHd1N0JMZG15dnBJbHVXZ0JVSy93QzkyZzhFZCtNOGNISXBrOE5qcWpSZVJyYjNNZ1RhREtUdTlRUUMzcmlxTjNaNmUrcVhRdkxkV054OHcyVHNmS0IvaStiMlBGT2xzckRUYlMxUzNMekpJN09ueVpZRGpDZ242ZDhtdFZDS2lyTjNHcnVTZHJFbDdGZjIwTVlTZVUyek9RenhTZ0F4a0RhU3VPUU05QnlPMVd6OXBrV1MzVzdoU014L3VZUktBeE9DYzVQUFgxNjB5SFRETkMxd3NwbGFCd3hnazVCMm5KUW4zK25IZW90WXVOTHZybU5iZTIreU4wbUt3RUZPT1J3TUdzbExtOTFkUExZY2w3enVXZE0wZTR0L08relNJN0ZBV3kzQWZ1Q2Uvd0NIb2F0UFBhdUJZeTI3d05nK2NJMEczMDNOanJXZjlxMUN5V1pMU2FReDdjbWE0SkNxM3FGL0xzY1lxekJMYXo1dXIxL3Mwa2FmTklFTDd6NnFjWngwNC9RMW5LTTVTNTIvdUZlMmpXeFF1Rmp0Z2pXRUYwMEJPMG9qTXF2ZzhrcU1BRHFQOGFsamptbFNTeFNTMmtHM0psRDd2TDU3Y1o5T09QclZJWEV5V3NrbHhOOW90cFFmM1J0d0F2UEgzVnlQcWV2cFZTd3ZJOU9sRjVaSkhOQzY4aFEzVFAxd09jOWhYUTRTY2JMZGZtVmZXN0ZrZ2xzdFFWNWZKdTRVSndzZVJ0K294d2Z4cmRpdWhCWXJQSHBaaXQvTE82WlpqdktqZ0Q5T21lT0tMclNOTnVweE1HdExlNlpjS1JjQk01Sk9Uak9lZno2VmlXY0JTOFd5Uyt1RWhPUkk5dnZFUjlTQ092STYwclJyUXZmYmZmOEFSa3lrMDdNbjFMSG1ReDZoT3NvdVAza0t5Z3hoUWVpa2orSVo3MHVwMndFSy9hWUxpNGlLN2lxWEJCT080T0RucjZINjFMTG9kdGRZbWkxbWVhQ0VGYmhKaDVoWWRpT2gvWCt0VWZzTjFGZXdXbHE4eW91VmlNMGVHMjV5VGpuOWM5S3VMaTdPTDIzNkZSbDBhTE5qaE5QbG41VXZKOGdBKzd4Ni9pS1pOQzBTeGJaRWNNbTdudDdWRHBlb3dKYXl3WEFDRVAwNExaNkVIMCt0TE5yT21DUUZaMEJCKzZ4NC9FOURYcEp1OWp6WEhRc1JRdVd3cGRDY0RJeDMvR3FqV2tUWHJCVlVuY0ZaZXc0SDlhclhXdXd3Z2ZaZjlJblAzZjdxbjF5YXFRYWhjQkd5ckdVODdqM09mYWlvcE5GUVNXNXNlVE5ieUJJZ200c05vSTRQcitHS3JmYnBiKzYrekRmR0FjU2J1b3gxQXB0dmVYMDQybU5oc0FPVDBJNXg5ZjhBNjFSM2tWenB6UmFna2ZuQ1Fsc2REa2RlTTFtazByTTBpa3phTWJSK1Y5bmZZNkhydDQvTDhxeHRmc2IrN21hNlcxSUVnVlZST1FyWTVPQU8rUDFxako0b3VMb21LQ05JdDMzanljRDhhNlhTUEZjOXZCY1c5MFlyak1ZOHJ6QU1LUi9QL3dDdFV5aFZwMmtrRktVSk5vMGRNMFd5c05MYTNPcHh5M2trZkt5SGJna2NLRmJrZGZUMDRyblRhM050YlFYVnhhdEUwYkFtUWxza0U5UVQwSngwemoycDM5cDN1c1BKRmMzbTdKd3F1ZmxIYkFKR1J4MnpqdldsWVcxK29YVFo3NmVWVnRteHpsTS96T01nYzF4eWNxYmJsSzkvNjBPMkNhVnJFZDNIb2RtV2FWNU5TamxUZjVaWS9Ma2tiaGdqSHBXbjRSc05IMU0zViswYXNrVDRoQmszN1JqblAvMTY1clVJYmZTcG1hVkpKVVE3ZHlyZ0JRZXZwajZldGFHaVhhMlAyaHJTend0NEYrZFFjTWZUOGVmeHAxSXYyVGNHM2Z2c1M3dlJOZnFkbmFFQUNTVzBFRW9HRUlBeVZ4eGdqNjF6bml5MnN2T3Q5Um5tbmlsM2JEamN3SzRKNC83NXF2ZDMrb1h0dEN2MmU2OHAyS3EwVG5IQkdjNFByL0tzS1Z2dGR3YmU3dlhoYVBPd1Ric0FlbWVncm13dUdsR2ZPNWZKRXlWbWJPbWFqYlhOa3RnMTA0c1dnd2lzQ0FyOCszUFByVU1maEs2bHVWaUZ5a0laOXdrTEE3OG5qQzl1dlRpbStITEdLMXZwdFAxV0F5MnR5cStUS2dPMEVaN2cvd0Q2K0sxNW12dEVMK1c4Y2x2Z3JFWGQyMmdIakdEdUhweFc4NTh0VnhwUGZYeWYvQkJKT09xMktONzRLdjdlRkpYblVBWURTQTVDSDE2Zy93QTZmWlRYVm5DYlpKa2JISG1zbmZIUEhyOWF6N3JYZGQxYVpMYVc2MlJJZm1qaWxBT1Q2azRQZnBVczBGN0l5MlFta2tRcU9BbVQrR0NTeDZkNjBsR2JTalVhWVUxWk5qclM2dDdHNmE0dTlOa3VDelk4eFpTaUFqb1dJR0IrSXJYMGkxbnZZYnE2U09DSzN1bU85bzBYUG9jTU9DUHdQV283UU5hMkZ4WnZjTis2SjNveWJaTUVkY0hPZjgvalRXM3R0THRCZGFmZFRzVkF5anlIR0RuUEdRTTFsS2JhYWpvOXIvMXNQa3U5QXVqcCtqN2JKeTd6RmNscE5yQmdlaHpqSHBWdElMUFFvQWJJUS9iTGxjckt6RjMybkhHQU9PUjlQZW1XVHphcFBJSWxaNWtHL01xYlJ0R09BTTl6bjhNYzFlMUNHUzhzWTdPMFpOODhpbDFKTzNQVWRNbkF4bmpGUlVidW96Njcvd0JkaDZXOURPdU5UZlJKNFV1YlNON2FIRE9vNnlIMXlSMTYvbDFvdjU5T3Y0bW10NGJlM3Rjcko1aktwMyszVDE0Njl2d3EzY2FaNG0wNUZWYnFLK2dZWWtYYnVLai9BSUZ5UU9lLzRWUWZTTGlXU2Rna2dqdUhMTTRVa294NnRqZG5CNy8vQUZzVmNKUWRtMnZWUDlDVTA5U3NqNmxmd09iVzdpRU9NTWdRS2UvSzRQSGFrMHZVZFNzbWhhK2FWNGx5U1RDRmtaZTN6WnoxL3dEMTFvYVY0WDArOWpsTjNJa2ttU3dDbmF5NDdrWnoxeDFwMTdwZXhUYUpyTEFSZ0tJcEl4c1VIa1k5Zi9yMFBFVTNKMHYwSEhWNm9xejZ4cWVwNmt0cHBRa2pqZGR6b1Z5ckE5ZHpZT0Q3MHlTTFU0YmhubWtOdjVtUE1ablZsYmdER09lZWdxemVxK2xyRkZZM1JiQ2JwWkdPTng3QUtPblA1NXAvaHpScmk4aXVidjhBdGk0dDVYWWxvNHZtUTU3bFRuUEh0VlJjRkhtMHQ5NHBPMncyejBTVFU0cGJtemh6Y0xIc2RXbkRJK2VlTTlPUHI2ZTlWSHVFZnk5TVdPYzcyMllja2VXL1RCT09CK1lQdldsalUxdjVZTEtTTzhoZHNybElRUngwSTY4ajZmaFRmc0ZwbzJveVg4anNwSVVPb2hKUXVRZm1VamdISFlHb2xLM3hhdnBhNDArMnhETEZxR2tYQzJNSGxMR3dMUnZMeG5QWHQ2L3JWWnZ0TW0xUkJnN3N5Zlorb1B1T241WUZhV3FRbld0T2hrc0lFdlVRa014a0FLQVl5Qm51UjdqcCtGVmROc1k3NG1MN0JjQzdBSG1MSXUwN1FlR0xFOU9QNlZOT291WG1rdGV2ZjU2alcrNDJHQVQzT0pkWm5oTWJLNitiQnNQQlBvMlBxSzBkWTFtR3phM080WGtFdVFXRG9vVWc4RGtFZnJVclhOdHBxdklYaHVVa1lEeTVPaEhwbkJ4anJucHpXUnFjbHBLalJXclErYXdBRWFMdVZnZjRRUVQ3ZDZMS2NveWEwL3J5RnJKN2kyQTFPK2FXNDB4N1o0bmJtQ1Vvd0o5QVFSajZkT2F0V056ZjNyeVcxL1kyMWpBaWdLeXJuUFRnY2ozckc4TjNrVnBMSlpYU2RYd3NEbmFxc1JrNU9NNE9PMzVWdVhlcHoyVVJMNkxITlpUZkw1bHRIbGxKNHprSGRuMy9BRnFxdE44L0swdGRuL1c3RXBXVjdsbTEwbU9lM21naW10NXJiSXhNYmRaWGlZOFo2anAwSFdzMHkzT2lhN0xaUEsrcFcwYURaOHUxbFluSTdZeitPS3k0ZE5hTlpKZFB2N2RHVElLeFhaUms5bVBHVG4rUXJWc2RmMUsvdkkwc2pDYmxlc29IQkM5ZDNib09vclNVRnl0YnJyMHNRazc4eEZyT25YSWthNnNWbGpsY2xraFpHQlh1eEpKQXdlMzQxbGFNSlJxN1JhaGJSZ0VaU1FnRUllMmZYLzYxYVY5cTF4YTZ0Tk5MSTkzZHN1MlJJZ3hTUDAyanYrdmVzKzd1NWRRZHNvb2ZjRkpDN1RrZE9sVkJ5VU9SL0MrdlVwUjVuZStwbmFubzhGejlvbWlVL09CSXBKR1RucVQrTlljR2x0SXk3SXlBZTdWMFYyOFVkcWtkdmNpUlN4QjJua3FlbkgxR0tkYlF0REZ1S0Q4VDBydWhWbEdKd1RoRnNqMDdUMWdBRzNIcWEzOXNDcHRPRGs5TzU1clBEZ2ZLYzVKNHlLZUpIalpKUU9NNE9PS3lrM0l0V1JIcVdweldWNlk0NFUrZTNDb2V1UG1iT2YwcUsxbW1hNGphN0pkSEcwZ3J3bWZUOHF6dFF1MUdyZ2JsWXF2ektTY0R1S3YyMTVFc1lVc3Fra2JSMnpWeWg3bHU1Vk9iakxtVDJNKzkwZHRSdjJlemtWMkp5M3piU01uMHoyL3oxck9VU0RVNDBtaEwrVSsxNHM0eU8vTmRmcG1sYWU5MWVYZDlFcFJjQldhWGFDZjRzZStNZm1hUEVTNmFrVU10aDh5Z3NabmhZRVk5ODg5ZmJGUkhGV243S3pmbi9UTkhSNXYzaTBNYTVzcFpyamZhdytSRUZ5eW5PMVFQVnVucFhYYUJxOGx6cEZ1WWxuZU1aVnlxS1R4NjRIcjJOY3d0ckpNUExrS00wWTU0NmZVVnJXajN1aDZlNTBmVXBKWExicFl6R3ZscDNJRzRaL3orRlo0aUVaUVVXemVNM0o3QnFXdjMza3pYNldzcGdWd3Bkbzh4dXc0NTdBL1R0VnlIeFhOcVQvMmJkMlVlMTQ4RTdzNFA0ZWg0cUJmR2w5YzJrOXJmd3hmWm5pS3NJby9tSlBjZHY1VmxXbW5YY210U1JSVzd4aDAzSTdzR1Z4NjQ5K09LeG5oNmZMN3l0YnJjVVpYZXAzTDM4R21hYXNsNUtpeURHMUZYNWpudnQ2L1d1UzFDU09XYUcrdDlEdTdpSVNGN2w3aEEyNGRQbEF6d09lZmFueWVIRmdtV2R0VU1SMm5HTm9YNkJmOEFDaTNtdjdQVFhpamU1UnA5M2w0WENzM3FEMUF3UFdzS0ZLbkM4cWJ1MzZvY292WXRRbTN2OVVqaVNCN2ZUc0hhMkZBM2RRUVJrYmVuVFBOU2ExcDJvd1NJMGQxQ0lSamF5Y09Sbjd6Y2M5ZlhIRlZ2RE9uVzF2Sk9sK0lZQXAzSVpWeUFPNEFQQVBYcDYrOVhiNjF1Nys2U1NDNVJVUEM1QjV3UFljVk03UXFwUmVubVhHKzdKUEQ4MHhGemJUeFJQTEFRRzhtTEI1SEdNY0g4Z2F6N3NSYVBlUVhheXpUM2NianpvQ0NoVkR5dUNlVGpIUEo2OXFobWsxblNiaVZZWm9WMzhTY2ZPQ0FPaE9NakdPeEFvazFhYThWMjFDSnlWT3hiaEY0UCt5Y0RBNjlNaXQ0MDdTZFJhcDJKV3JzYU9wNmpmYS9GRkxjNmJtMkJBUzRpR0c2Z2pJM2RCMTc0cWdOTmp1TDRHV1JWRXB5Wk5tU2MvajFOV0d1YnNXYUM0Q0xCZ1l3cEFLak9QbVBJNHgzOWFpdjVZcnUyRUZtbHBBVkJMSWx3QzdaNHp0UHpjZXhQV29pNXkwV2hzbzhrZFVhbHRZYVFOVWhqbUVrNmtHTTcyK1hKNmNESEhHS3g5VVZXMXQ3ZlM5UDhwWWZuRWdadVQxeU9mdzQ5NlhTTGlXU0F4U0Jsa2lQMzVaQXJrOWdGL2lxM2UrZmRBdzIwOXZGY0preXN6NFJjWXljZXZRNCt0TDM2Y3JOM0lrbzdtaEhxa3NOb24ySVNTemxROG5tU0Z0NXh5QVc0SFBQYXNtNzhXM051VkpzN21aTjJGWVI1eWZRa0UxcDNsOTlra2F5bUVjMFRwdGRUbkxrZCtGQXJtcnpUOU5rRWtjbHhKRTZqNUk1R3hqdmdZNUlyUEQwYWNyeW5IOVE4b21ucHVxdmZxMGxsWVMrYnN3eEM0SlhPQ09QVDhUK1ZYTks4UHZQSkxjVFhjUDJmK0VDVGZqbmtCaHllZXg3MFc5MWI2UnBndXJhNXVZbzBHU3FIS3RudDA2WjZWV1BpRVh0d2tyU1NGR2JHQVFlZlRHUU9NZzhjbXRaUmxLN3BxeUlYTW5xeTFyRDNsaUlZclptL2ZTaEgzcnVKSHQvajlPS3F4WHVvNlBxOGUwMjc1UVlaazJ2Sm5xcFBmZ2UzYnBXd2w2c3hqZ2huRFNqSjJtQWhrSGJPYzQ2OGNWWG0wM1Q5V2tpKzF1c2MwVGtzTjJDeHh3YyttUjBybmhVOWsxR1Mvd0F4dThrMlZyM1VXdXRYUXZwRnJNR0IrYU1xcEo2NUxaR0RVc0U4VVZqSkJjYVZOYXJLTnBXSi9NQndTZUF2WVo2NDV6MU5RNlhKb1VHb1N3enlSWERQeGpjV1RqT1BiUFB2K0ZSeTMrblN6c3NOdWx2dDZ4TGxDcEE1QVA4QWtWck84K2o2ZC84QU1VWVhka0htdmFXc3NOdG1KWEFVeVFyaGwvM3VldlBwVkVhbmNXaGtnMUNlNGFLZG1WTHBKR0VpL3dDeVN2VUhIVC9JbTA3UVJxYnlYUG5jcVRqdmcraHdldFdwZkQ5NE5LUzRXVzNETkl6eUZnUWRveGdEanJ4bm5wVDlwUmpLMG5yOXhWazlOaUc3MG1LVzFTN2oxVXFDUUkvS2pHVzQ2RW5weDNKeFZDQlowdERqVHBBVDgzblN4Y3I5RGpGTzFHQ2E1bmlNRjYwWks1OHlFa3F3OUNleHFlenU3Nkc1akVqeHl3d3VHUHpZY2pqUEk0T1I2Z1ZyU2JVYnlkL3dDY2VWMlRMZW4rR0xQV0l2UDFHVUxMd3dTTmdjREhCYkk3MVZ1YmE0MGY1VE90dkVoTFJ2RzJSanBqQVBQNFYwbXE2NVp4TERjV01rSkxxUVVraE84SHIxL3dBL2pYQjMxM0N0NTVzc010M2RTTmtyRWdLdG5wem5QSHBnVkZPTldjM3piZEVUVG55cTdadDZEL1o4TnRLeUFUQXZ1UmtCeVBZNVBYbXFqZVY1OHMzbWZaeStDMXRDaUxnNXhnTWUvSFB2V2ZJQkhFMHNzTTlyc09HVGVRUG9jZXZyVjIwdklKcEZ1bldZUVFuNW9vd0FIK2hQSlA4QUt0ZloyYm5mY3FUU3NraC8vQ082dk5JazltdHcwTHJ1Sm1uVGo2ZWxGM2NYRnJHVXZyc3hFZklHOHpCSkhTdW0wVFdOQWp0WDhtNWxpbWZtU0s0Sll4OWUzVEgwOWE1WFY5TDAyNjFqekgxT2FXQmNsMFlNQXZmZ3Q2azBSY3BUNVo3THlNMUpwTjJPVjJOWXhDU2VOZ3FrZ0Jod3g5Yzk2Mk5QMWV4TnNpU1hDaGxCKzl4OUsxakVseHA3MlZ3RWt0MjZBait0WlZwNGYwaTAxY1JYb0RRU0xsQzduOTJSenpqcURYYzZzSEZ1Vi9rY1VhVXVaSmRTUTZocHpEL2o2VDVRTUhPS2kvdFdPYWN4MlozbEJ2OEFNSU9GL0R2OUt6OWJzckNQVUhXemlBZzNrSktDY1Awem5QcG50VHJHNnVkTEVyVzFzd1E3VHNkTTVBNDY0OWYxcDhxY09hTy9tWEdLVlRsbnNWN25UYmg1VWtRTkswNS9pRzA1SkkvcFRiV1h5aVE4cWdvMkNEelhWeWFoWTNUeFhFeU41Y2Z6SEFLSHAwSTcvbldQcjl2YlRhaThsdEEzbHpMdlk3ZHVDVGs4OXV0S2pYbE44czFZMHhHR2pUOTZESmY3V0VkNFNrSm5nbElJS2RWT0JuUE5kVjRhMW1HVFYxdG9vWEt5QmxDbkdNWXl4YjB5Qi9uaXVKaFJqRkhCYXh4dms3VElHd2ZiMnE3ZFFuUkM5emIzMHBVaFI1WUpWdHVRVGtqM0ZZVjZNSnZsNnMzaEpxbnl0YUhXZUptc0o5U2trRjB0bE9FQWRERUc4MDgveEE4Y0hGVm9MSDdYYVBOQmFOTWtnSzdnUXBJR1B1NTU3ZjByaVRmTmRYalRUeVN5T3Z5b2p0bHVPeEpycExUV0w2MmdFeXp0Q3IvS1ZJQkJ4eHdwUEg0WXJHV0duQ0NTZXY4QVh6Q0UxYXkyTVRVYk9LYVJQSVhMUmdobzJqMjdjSDZrbjhmOGE2Wm90VHR0QXRYdEpvamhBU1gvQUlGSnl2VG5qaWk5bXQ5VWdEeVF4d3ovQVBQeEFtR09lU0NwWWU1Nm1xVm5xa3NLdWltYU9PTkNxQ2EzSUo5K3BIcjFOWE9kU2NFa3RWdW5xVEJKU2I3aE8wNk1yWEVNa21DQTRHRUxIbklYUGY4QU9uaTZhemlpV0R6RmlDRmhKY2dNNEI2anB3TWo5S28zVnZmWDEyWkxnWERxVlVBN1dJQngyeHhqK0xqSFdyTmxyTjFwRndzRjlhUW1Kemg1RXh1NlovaVBYSFkxY2szRkpLNzdCRzk3dlF0V0xIVkVhNW5lUzZVRnRzTnZFNUp5TUEvWHFQVHBYVVcxL1lRNllza3F2YVNJbzJ4eWpZY2Nqb2Z4cm5vTDdUYmEvYTQwbDVvSlFuN3diU0Z4ais3MFBmdDFxcmZ5UjZsZHd6M2Q1SjVhS3k1Q2xsd2ZVRDNyaHFVL2JTczAwdng5TEdsbnk3bXpmNmkyb1JmTGJMZzV3T0R6Mk9mUWNkT3RZczhUM1V2bEpLMFpaUnhFL3dBclk2WlhPRFZ5NHNMSzMwZFJwMS9KSTh1Q3lPK0VWVG5xbzRCL0RQSDQxanczRFJYRFBBOFlmN29MeEFoQ1A3b0kvcFcxQ2xhTGNQeEdxa0xXdHFYcld3bW11Q3NVczhuRzNZV0pVZFFCenhWV1Y1OUoxR2MvWlRZN0l6dG1pQUlJUDRldFhsc0pJN0JkV3ZMckJSZ2NCUWk0emhlbUIxL1RGRjhrdW9uYXF5TmN1TmthYlFWWnV3UG9BVG1tcDNsYlJvTDlYMEk1dEdsYjdOTGJYTWx4SXkrYW5BUUFkY0Qxem5ya0N0SzcwQ2U5Z2FWQnVZaktLb0FPNzNQcFhSV0Z0ZHQ0YnQ3ZThqalcrczRERkZOdFdRRGpIUmg3RFByaXVPdURjSis3dmJ4cEhYNU9WUFBKNkRwV2FuS3BKS00xb1pSZWpTUnJhSnBHb1dzVDNONGxsY3JEdU1rWW1EU0VIcHowQng3alA0MXptczJzUTFDSnRNc3pIRE9oa0tUc1FEM0lYajVlVC9ucFdqcVZ6cDl2WitWYmZhZzVLN1RJU2laSFVrRE9lRGpCR09sTFk2dkQ5Z2lDOHlxTnJyZ244UVR3TStsYXhsTlhuRmIvQUNDTVczcXpJUnJ1Y3gyNjNCUkNBd1ZXRGhUN29UNjQ2VjE5cm9HN1M0eGNlVkZkS3hKYUUvSzQ1d1ZQOEp3ZW9ybE5mMDJZdkhPdHNzTVpVZ3NHQjMrM3RXem9sOUxhYVF0dXJvMHhKWlBuTEFlMlR3T2xaNGpuZE5TcE5GT2Fjck1kZEM4MHkva2UzMVpVaHcyNks0YmVZc0FFQUE4bkp6MzcwTHF0cGQ2S3FUWGdtdWl4TElWNDY5R0FCR1A4NXFwY3lRd1c3M21vMmtrazAveXV5eGtsdWVBRDA5T3Y2MExyc1VVSWdzZFBra3UyandDaERNZU00WUFkZTFacWs1SmU3ZHJyb3Z4RG0wdXh0MVBQZTJ6YlZqazh2Z3NJUUpFSHNjQThaNjFSRTBNOFFqdU1PMFlJYkhCNTlUV3RwY0U5amJ4Mzk3WVRXNnpzUkkrNHFWSmJBM0wyN2NqanBXbGJhTHB0MU05eDVjTFJiQ20zSFE4ZC9vSzZIaUtkRlBtVjB1M2NtemtyeFpGNEpudFpkUGxXYThWSGp5cFVzdktqR0c0K3AvT29STGEvYWJxYUdlYTdoM2JwVSswQllud01kR1A2RGo5S1JQQ21talZlRm1saEkzRXJLQjVUYzRIdURqNmlxZXQ2S3RwYmVXOC9tcTh1WVdsd3hISUdPZjhBUE5jOFhRcVZmZGVzaFhhV3BKSGRhZGJ6dDVtbG1Xem5YZEdkb3pHMysvdTNZUDBxS3dzN2pYNDVJb0ZXelRkZ3lJRDh2c0FjSC84QVhWeTBzOVZ2V0ZwSExiMjhJVWhuVzFRS3A3RDEvS2xzOU8xVkw2S3llenRubStaa21UQ2tLTWZOeDljRHBtdEpPeWNZdGMzcmY1Mkw1dGJzajFpMnVOS2ppZ3ROSmU0RG9VZTRrQmxDL3dDMXRVY0gzL1NuMlBoQ3lld2h1N2pVdzdBZ05JaUVBblBjZFJ4MXE1ZjZkcTF0Y2llV1Z5QVBsS0U3U09ldUR6V2ZMTnJnaW50cmE0TWlTeDdRN0RHQ1J6ZzRQMHJLRlNmTHlxVm4xZjhBdzRTcFg5NDZuVU5Pc3JwRGNRM0VFU01wTW43c1B2UHIxeG42ZzF6TjdwTjVhVCtmNWF1WTFBUzR0MDViam5LblBQWDI1ck50THUrc1pFczBsZnlyZHNQNWo3czk4RDg2dXphN2ZXOGl4UXJGSWhPRTh3bFNQYmpQTkNwVkl1MFdtaHgyM09ZdlB0RnpOTEpjU1BHNmtCZk01WUR0eC9oV3pwOXpxV2w2Y0lEY1cxekd4R0kzUWxzRTl4NmRhTk1hUy8xT1g3VEJHTjI2UkhSaVFQOEFaeC9ucFY4K0g3cWV6bGY3a0xFZ2J6dXlPZWNEbnJpdW1yV3AyVUoyWDlkQ0xTYjNLSDJ4WVljRUFnbm1zblVKWGZXTFozUTRmZDhyRHJ3YXZ4ay9hb1JuanpSeFUvaWYvaiswNXUvbWRmeXJaVHRVVWJicGlqVDVvODE5bWpHazBCeXp5K2N6UVJOZ0l4NFFIdHgxd01acXd0NUVkT3NJb3JqWkpBejVCSXlGTEhHUWUzSDhxMDRTUkZNb0pBVlNRQjBIR2E0cVIzT3FLeFlrN2p6bjNycFVmYWZFOWpuNS9aemFTM08zdDVwTG9TTEpiMjB5bEN5ZVc1QU9DT3ZYQjU5YWJKNG5zNGJYWlpXeFIzSCtzWUFsdWVldkpGZEF3SDJSaGpnNUZlZmFnQUx1SUFBRFlmNlZ3WVZSck9WMWF4MDFwT2xIUTZLeHViQ2V5V1NaNTRXM0ZpeUtBaDljOTgvalUxMXA4RjYwSDJDUlpibVZ0OGYybGlNNDlzWlBBL1FVM3dsYnd6V2R3SllVa0gyaU1mTW9QQlBJckRzeVk5U3MzUWxXRHVBVjRJQXppcmROcVVtbnQva0tOVzhFKzVadm9MdHBmT3VMYmF6WkVpRWo1ajNQSFUxUmh0THFkSW9ZWkNNc1R1Q2JkdU9NWjdqcFhxTnRERkw0TFl5Um81S1NOOHlnODdqejlhNUhRZjNuaHFKbitaaXpBazhrNEhGVERFUGxidHM3R2xsUFRheEVOSTFDMzhyN2JDaWhDR2FUcEd3STdrQTlSbnBWeWRiTy90SGpiWTgxdWN4YkQ4eSttRFV0NVBML0FHYzBmbXZzM2diZHh4ajZWei8yaWJHb0h6cFBrVWJmbVB5OWVsWlJxU3JMbWVsdXhjWXFOeTVkYXhyRElkUGhNZHRKR2dHNUFPdWU1NTdaNlpyUHZiUVJ6bzkxY1MzVzlTN1RPM1QwWDI3WXF4NFAvZWFsR3IvTUdaU1FlYzgxWXZZbzN2YndOR3JCSTVDdVJuYVJqQkZkZFBsaFU1SXBJeGxGOG5PMlhOQ3V0TXVaWW9Fc2o1ODJTalNybFFvQk9SbnZ3ZTFVTmZFZHZyRWl2Q3RxcXhoby9MSklsNTc1Nms5UHdxMm9DUUk2RGE2bUloaHdSelZQWDJhVFVMVm5Zc2ZzcW5KT2VmbnJHbEp1dWt0ck1kYlNOeEgxZTNlQVcwV2tKYlRaeEhMRytSbnRuR004OXFobDh1YTFaMWdQbmJ0cHd1ZHg3WTljOFZmOFB4Ui9iUXZscmpibkdPOWRCcWNVYTN0czRqVU84ZTltQTVadU9UNys5T3ROVTU4aVhudU9qTHJZcGFMck9rV09paXkxeTN1RUFQeWJrM0syZWVoNllOWHRHc1JadUwyMHVDWVpZeUFza1M0VWRpRkg5UHk1cHNrRU04QkUwU1NEcjg2ZzkvZXNmeHhkM01UV3l4M0VxQmxZc0Zjak9CeFhIUDNwS01OSEp1L1VxUzFhT2tYWEhaRERBVGNzRDg3RXJGc0hjNHdDZWE1VTNDUWFqS3pTdEk1SVpDMGdkbWM5aWY4QUd1ZjBpYVY3TVNOSTdQSmRiSFlzU1dYYVRnbnVQYXQyOFJmN1B6dEdmTTY0K2xkZjFkVVhaUGNWS1NmUVVhWkpxYnozTjFlR01rWlNPS01NRTU1UGIxSXJaMDdRSXQvQWthQi92Z2p5ODhkUmo4UDFybEV1cmhkWWdWWjVBUHRKR0E1NllGZWg2Zzdwbzh6cXhWdGg1QndlOWNlTXExSTJpbnVPeXUyTnVOSGpsc0d6QWx6Y0EvSzhoK25XcTl4NGRTNHRqSkJkVFJ6UkxrSkdpc1NSMkc3cFVuZzEzbTBIVDVaV01raktRWFk1SjVQZXVlMUM0bi90eTQvZlNjWExwOTQvZEhRZlNvcFFscStiYnlJMTJYVXVhRm84RCtWZDZoZHp0Y3hLUUlaWEFXSVo0T0IzNDZtb1ArRWV0VHJkM2ZHNGFLNUxpUkpJSEcwWlk0d2U1eDFHTzRyR3Y1Skk3d1NvN0xKd042bkIvT21hQXhsMVdCcENYSWJPVzU1QjROZEtwMVh6VFU5MTIvQUhHTjdOSFIrSTlRMWl5ZEhoaWxtczJUNWlzU3NBL29lTWdFZHp4VE5BMUMrdWJLN1NPd1MwbGdrSVlHTElKOWRvNXp4K3RkWEVTVUJKNXpWVmZsMVNiSEc2QlMyTzVESEZjV0dxUXF4OWk0cjEvd0NBSjNUdWNTMnM2cHB0NHQxZTdaWVpTTnp3U2JrT08yM0F3ZjhBT0RXNUJjVzNpYUlQS3JHT0luNVVJT2VuVUg1aC9uMnBtcVFSUGUzbStKRy8wWkc1VUhuRGMvWGdmbFZiVklZckR4dEFsbEdsc3BSTXJDb1Fjam5wWGRXb3hjT2RLMGwxUktsYVhLYXNjSDlsNmV3MCsxbUpDbGptUGwyN0RucFZDMzAzVkx4bjFDZXpsdDUyd05qemZNQnp3QWZwN1V2aEYzKzI2Z201dG9ZSGJuak9ldGQ0a2NZYkFSUUJ5QUIwT2FtRkpYbGZmdVU1dUR1anoyMjBlOWt2R2dmN1RBZ0dJeG5wazVPTVo3MCsrMHU1dFh0N2EzdlRicktTR0orVUhBSlBPZU8xZWdzcWxpU29KeU9jVnkzaWptOHRBZVJ0YmlvcWN5bmUrZzZkUjFKV1p5dzBhR3pXTzVNRUltWElrWlhMS1NDY01Qcm1xOXREL3dBVFlxMDhrZXpKUG1SL0s1UFlZNlZxNklTYnllSW5NWUdRaDZBK3VLazFKRWZVN05XVU1DV3lDT3ZTaFZaT2JnK3B1NEtNYm9vWFZzbW5BM2x1UGwyY3NNYlZmMi9Hc0tmeFQ0aWdtaUFtUGtqRzVFUUVIMTY1cnNmRXNhTGFRb3FLRkVnNEE0NlZ6L2lORWpqZzh0UW1VeWRveGsrdGRHSDVKVzU0M3YzTWFzcFRXanNmLzlrPVwiLCBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELy9nQTdRMUpGUVZSUFVqb2daMlF0YW5CbFp5QjJNUzR3SUNoMWMybHVaeUJKU2tjZ1NsQkZSeUIyTmpJcExDQnhkV0ZzYVhSNUlEMGdOekFLLzlzQVF3QUtCd2NJQndZS0NBZ0lDd29LQ3c0WUVBNE5EUTRkRlJZUkdDTWZKU1FpSHlJaEppczNMeVlwTkNraElqQkJNVFE1T3o0K1BpVXVSRWxEUEVnM1BUNDcvOXNBUXdFS0N3c09EUTRjRUJBY095Z2lLRHM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzNy84QUFFUWdCbWdGQUF3RWlBQUlSQVFNUkFmL0VBQjhBQUFFRkFRRUJBUUVCQUFBQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVFBQUlCQXdNQ0JBTUZCUVFFQUFBQmZRRUNBd0FFRVFVU0lURkJCaE5SWVFjaWNSUXlnWkdoQ0NOQ3NjRVZVdEh3SkROaWNvSUpDaFlYR0JrYUpTWW5LQ2txTkRVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmc0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaDR1UGs1ZWJuNk9ucThmTHo5UFgyOS9qNSt2L0VBQjhCQUFNQkFRRUJBUUVCQVFFQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVJBQUlCQWdRRUF3UUhCUVFFQUFFQ2R3QUJBZ01SQkFVaE1RWVNRVkVIWVhFVElqS0JDQlJDa2FHeHdRa2pNMUx3RldKeTBRb1dKRFRoSmZFWEdCa2FKaWNvS1NvMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvS0RoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1TGo1T1htNStqcDZ2THo5UFgyOS9qNSt2L2FBQXdEQVFBQ0VRTVJBRDhBOFpwYVNsb0FLV2twYVF3cHdvQXBRS1FBQlRnS0FLZUJTR0FGUEMwQmFsVmFsZ0lxMUtxMEt0U3F0UzJNUlY5cWxWS1ZWcVJWcERFQzFJcVU5VXFWVXBYR01WT2xTQktrV09yRU5ySkwvcTQyZjZETkxWZ1Znbk5QQ0dyTFcwa2ZEUnNwOXhTQk9LVEFoMmMwdmwxTnM1RkxzcEFRN0tOaDcxT0VwZGxGeGxjcFRUSFZuWlNGZmFuY0NvVXBwWGlyWlNveW1hZHhGVXA3VkUwZFhDbFJzbnRURVVIanFCNDYwSGo5cWdaS3BNUm12SFZaMXhXbEttQlZHUWMxYVlpcVJ6U1lxVXB6VENLb1F5aWxOSlRBS0tLS0FHVW9vb3BnTFM0b0ZLQlNBVUNuQVVnRlBBcVFGQXA0RklCVXFyU0dDcm1wbFdrVmFsVmFpNHdWYWxWYUZYcFV5TDBxUmlLdFRLbEtxVk1xMGhpS25GU3Fnb1ZjVktxMGdMK2k2VWRUdlZpSjJvT1hQdFhyZWhhZGJXRmtrZHZFcURHZW5KK3RjVDRQdENMYVNiSDNoMXIwSzBHMkZmWVZjUlNGdnRPczdvYkxpMmprUnh6bFJYbVBpencyZEN2Z1lzdGJUWk1iZW5zYTlhbVhkRXJEc2F3Zkd0a0x6dzFJMjNMd2tPcC9uK2xXOVVTbWVTYmZhbENjOUszOU04STZ0cVFEcEI1U0hrUEtkb05YcmZ3RHFqWFJqbjh1S0plVEx1Qkg0Q3NWQm1sMGN2RGJ5VHlySEVoZDJPQUFNazEwZHI0RjFHWUlaWGloM2M0SkpJSDRWMldqZUhiTFNvbW1TUGR0L2piN3pIK2dyWHRvaXhNamZlYm1yVVJPUjVsckhndTkwdTJGd2pyY1I5RzJBNVg2aXVjS0VjRWRPMWU4Rk9DTUQwTmN6cVhnU3cxSzhNOGNqV3hiN3lvZzI1OWFiaDJFcGR6eW9ybnRUU2xkUjRvOEt2b0RSdWtwbmdsNEQ3Y0VIME5jNlZyTnBwNmxGVmt4MXFNcFZwbHFObDVwWEFxTWxRdWxYR1hOUVNEQXFyaU02ZGUxVTJoNXpXakl1VFVaaTRxMHlUTmVQRlYzV3RLUk9hcXlSODFhWWlrUlRjVk95VXdyVlhFUjBVN0ZKaW1BeWxGRktLQUZGT0FwQUtjQlNBVUNuZ1VnRlNLS2tZcWptcGxYRk5SYW1VVkxHS3ExTXEwaXJWaUNJeVNxZ0J5eHdLa1pac2RMdkw0LzZOYnlTKzZpdFZQQ0d0WXlMSmp4MHlNMTFlbldEMjBFY2NCd3NhZ0VlL2V1Z3NaV0RBU3BqM3BEUEtKN0M1czVESGNRUEU0N011RFRWWHB4WHVrbW5XT3FXaGd1NEVsUWp1T1I3ZzlxOHk4VCtFcmpRcm92R0dsczM1U1RIM2ZZKzlEajFRSm5PS29GU3F2TkFXcDdhQXl6cEdveVhZS1B4cU9vejBId3phK1hvVVpQVjEzVjFsbUFZaDlCV2ZZV3dqc1JHb3dGVEFGWHJEN2dIb01Wb2lHWGwrYUZoNlZDV1NWdklLZ2p2a2NWUEgvR1BhcWkvdXBNbnFUVnRpUllmRWZDK2xaTjFxQVJpQmxqV2hkdnNpTGR5S3dwbHl4cUd5a2phVzVqdWJTM0FHQVI4d0hZMWJSbzFIeW44RFdGcHJIek5ucHpVOTNkZVdwQ0huRk5NR2krYnlOSkNyTUFlcHF4REtraWxrWUVIMHJrcEhjcHljbDYzTkRYWllzZlZzVUtXb09Oa1RheFlSNmxvOXpieXFEdVFsU2Y0V0E0TmVMT0JtdmJkVHVGczlGdkxsemdKQ3hIMXh4K3RlSnNNbWxVMlFSSVdITk1ZVk1SVVRkYXlSWkE0NHF2SU1pckxWRVZKTk5NUlU4dnZpbU9uRlhTbkhTb1hTcXVLeFFrajlhcXlSMXBPbWFyU0o3VlNZak5rU29XV3I4aVZYYU90RXlTcVZwcFdyREpUQ2xPNEZVVTRVZ3B3Rk1Rb0ZQQXBBS2VvcERIS0trUVUxUlV5RGlwYkdPUVZNcTAxUlV5cnhVREhLdFg5TStXL2dPUDR4eFZOQnpWdTBieTdpTi83ckNwYkdqMDNUSk15a3FjTm5rZXRkRmJ3cEp5b3czZGE0MnpuSWNTRG9lYTZ6VHJsWlZYZGpQcUtjV05vMW9GTVorWDhRYXZEWk5HVmtSWFJoaGtZWkJGVm9zTU9UejYxWVRnK2gvbldpTTJjWDRsK0hhTXJYdWlMZzlXdHM5ZjkwLzByRThFYU1iclhaRFBHVit5SVdLTU1FTm5BQi96MnIxVHpUR3BZREk3aXFsdkZaZjJySmRveXBQTkhzY2RDK0R3ZnIxb2FqZTQwM1lqdDQxaDNCeUZVQTVKT0FLcmFmZjJja3hqVzRRSGQ4dVQxcWJXdEthK2lBUW5nNTI1d0RXQmNhYTBLYmZKS012ZkZRN29hVnpvbjFpMHRaMml1RHRiSHIxRlNOZmFiSWl5YmdmUUExdzE5REk0VjJaaVY0NU5RSTB5akFrSStsVDdSbGNoM0Y1cU9uUmtyYzNBQUhSRjVOWlVsMWIzRGxyVU9ZejAzQ3ViWU14Sk9TVDFKcDhjMHR1ZHlTRmFsemJLVVRvcmVUeXB3M2ZtaWRpd0pQVW1zcXoxQ2FlNlZKQ0d5ZXVNVm9UdGpBL0dtbmNMREdJTGowVVZ2NlFwTm1pNHhsaWF4ckszYTZrQ0RnZFdQcFc5YzNVR2k2VzkxS09FR0VRZFhic285elZ4UkVqbVBpSnJLeHdSNlBDMldiRHpZN0RzUDYvZ0s4OXJmdWRGMTdXTHVhL210R0R6TnVPOWd1UFFZSnpVdHY0S3U1QUd1YnUxdHgzQmZMZmtLbDNreHJRNWsvclNDQ1NYaEkyZi9kR2E3ZTI4UGFIcHIrWmN6U2FnNDZKdDJMbjM2azFwRFhEQ25sMk5uSGJvT2dYajlCaWxaZFExNkhtUzJzMGt2bEpFN09laWhTVCtWYTl0NE0xaVpkOGxxYmRmK212Qi9McitsZGgveE5ieVZwVTNobTRMUnB0eVBjaW53NkJjM0VtWjVXOStjbjg2YVM2SURsMThDM1VtUXQ1Q1hIWUJ1UHJ4eFhPYXZwY21sM2JXMHNrVHV2WHkyeUI5ZlExNkJyMnQyZmgrMGV3c0hEM2hHRHQ1RVh1VDNQdFhuVW1YWXN4eVNja252UTdDS1RwelZlUkt1c3Z0VURyUWdabnlMVmQxcS9JbFZuU3FURVV5dE1ZVlpkYWhaYXNSbmluZ1UwVThWWkk0Q25xS2FCVXFpcFl4Nmlwa0hOTVFDcGtGUXloNkNwVlhBcHFpcGxITlNNY3ExS29wcWp1YWxYRlMyTTdYUVprbmdVUHlDT2ZZMXRoMnMyeWpaVTF4dmgyY3E4a0pPQVJrWnJwSUxoaWRzbktVcmxIUldlcU1jREpQdFczYjNxeUFBbXVXaGdCQWVKdndyU3RwU1BsYmdqc2F0TWxvNlZIRExqUFA4Nng5WHRkOFlrWGhrUFVWWXRwK1FwTlR6QVRJeW5HU0twdTZJV2pLT25hMUttSWJ2THAwRDl4L2pXdGRMSFBHa2d3eW52V0VJdGpFRlJrVnMyQTMyQkhvZUtsTytoVFZ0VG05V3NqQ3pnRDVXR1ZyRkM0SDFydE5TdHhOWnVRUG1UNWgvV3VNWVlZajBOWnkzTGpxaU51Q2FoYzVBcVdUcVRURVF5RlZIVEhOUXkwVzlLaUp1QkllaWl0Q1RNdHdJMXlhanRWRWNSYkdBZUJXam8wS3N6M2JqUE9FL3JWb2xtdFlXeTJzS3Fmdkhsei9BRXFXNWlXNW1XUjFCOHY3bWVkdnVQZW9EZUxHY2tjOWFpR29Canp3SzA1a3RET3ozTkNKWTR4a2pQMXBKcEkzK1V4STVQWXFEV2ZKcWNhZmViNkFWSEhxOFpiQ0lmYzArWU9WbHIrekxWMkplM1FrOWdNVTliQ3p0enVFQ0J2cFVZMU5HWEVTbG03bnNLZEZQbHNzY3NmMHAzUXRTWWhtSHpaQTdLSzg5OFMrTGJ5VzdsczdDYnliWmZrTFI5WDllZlQ2VnJlS3ZHRVVVRDZmcHJoNVhHMldaVHdnOUFmWDM3VjU4M1dwaytnMGlKam5KUE5Sa1pxVTFHZmNWbWlpRnFpWmFzTUtpWVo5YWFFVkhRVlZrWEJyUWRENlZWa1NyUWlpeTFDeTFhZGVhaGNWUWpLRlBBcG9GU0tLMEpIS0tsVWRLWW9xWkJVTVk5QnhVeURtbUt2dFU2THpVc1k1UlZxRzNsbCs1R3o0NjdSbXIyaGFISnFzcGtkdkt0NHo4OG45QjZtdlROQmVLeEtRMjhTeFFyMEE3KzU5VFMwS1BLWW9Ya1lJaUZtUFFBWk5hMFhoZlhKWTl5NlJlRWV2a04vaFhzdHBhV1VFejNkdFpRQ1orWFpWQ3MzNDFvdzNsckkyd255NU82UHdhYWlpV3p3MjFzTlEwNitqZTVzcmlGYzdXM3hNdkIrb3JlUXNyZXRldmdESEJyak5lOExYSXZKTHV4VHpZNUR1TWE5VlBmanZTbFQ2b3FNKzVpMnR5eUVZT0swRW5adW81SGVxQzJjMFQ3WlluUmgvQ3lrR3I4Y0w0eW96VWFvcGx5RzZrQjYxb1IzSG1ESVBJckVKS0hsU0RWaTNuQUlHYVhNRmk3Y3loanZIWHZXaG85d056UkUvZUdSV0pQSmw4Zy9oVW1uem1PNFU1NlZQUFpoYTZOK1lBa3IySUlyaHJtTXhYc3NlUHVzYTdXU2FNL01XQXp6eWE0L1dydTNzOVNhYVJodGJyU2xKUFlJRkNZNEJKNDRxYTJUOTJweDh6VkJmeXhQbG9tM0lSeFZxMFB5S1QvQWxSYzA2Rm1WeUVXTk9UOTBWdTIwWWd0a2lIOEl3ZjYxeThHcFc4ZW9LQ1E3Um5KQVBRKzlkSDU2L1pONU9DMzZDcWpKRU1pbm5BM01UZ1ZsdmNQSytWTzFSMEZGek9iaDhBL3V4K3RNVWJpRlVGaWVpanZUYnVVa1NETDg1d1BVMWJ0cmQ1U01JZHRTMjlrc1FFaytDMzkzc3RZbXVlTGhiaHJYVEdEU2RHbUhJWC9kOVQ3MWFzdHlXK3hzWDJyNmJvNDh1NW56S28vMU1ReTMvQU5iOGE1ZS84UjZqcmtvc2JHSm9ZNURnUng4dS93QlRYT3U3eU9YbFlzekhKWmprazE2ajRNOE9XbHJwTUdvRk4xM09tN2VmNFFld3ExZVdoRGRqRTBqNGR5U3J2MVM0TVhwSEVRVCtKNlV6V1BoMWMyeU5McHMvMmhSL3l6Y1liOEQwTmVqQWNVaE9PRFdpaEd4RGt6d1c0aGt0NVdpbGpaSFE0WldHQ0RVSkh0ZzExbmpxdzhuVmZ0YXJoWjhodjk0ZGYweFhLRWMxazFabHJVWUVaeUVRRm1Kd0FCeWE5QThPZUI3V0czVzYxV0lUVE1NaUluNVUrdnFhcitCdkR4WmpxMXpIOG80Z0JIVTkycnZObUZDaXFpdXBMWm50cE9uTGFtTDdCYkJNZmQ4cGNmeXJ6SHhuNFUvc2VSYnkxSmEwbVk0WHZHZlQ2VjYzS01waXNYeEZwNDFUUnA3TmNHUmt5by8yaHlQMXEvVVNQREpGcXU0cS9jUXZGSXlPcERLY0VIdFZSMTVxU2pHQXFSUlRWRlNLT0swWkk5UlVxRG1tcUttUUNvWXg2aXBselRFSG9LbmlpZVJ3aUtXWTlBQmttcEdkdm9NcWY4STdEQUYyTjVoTE42MTBGaEhBU044elorbGNwcE1kL2FXUVM5c3A0WXQzeVNTUmxRVDZjMXQyOHhRZzRCRlozczlTMHREc1lDbHRDSkJjSEgwcUc5MXUwbEFSeDVoWG9jZjFybnJyVTVYaEVZQ2dEMHFuRTJldldoeTFEbE44NnZjSU0yOTNLZy91c2MvenBoOFFhdUcrUzdKL0FWbnhzT0JtcDFDc09ncFhmY2RrVHRyZXJ5L2VtYjY0R0tSTHE4Yy9OTzVQdHhTS2lmU3BGWFlkeXR6NzgwbTJDU0o3ZVhERGVkdzc3K2ExZjdLdHIrTXZhdDVNdjl3bktuL0NzUHpDcmNya2VvcXpCcVgyTWlWWk9BZWxTcFdXb05kaUc4OCt5WmttVERyMjdHc1ZmRThVR29DMm1YeXBNOFo2R3VydlpyUFZMVEc0UnlmZUI5NjgyOFVwRktnK1V4M1Z1eEREKzhQcldYTXBTdGNUbFpIVStJTmFsT2xyNWJtT1RldU1kdWMvMHJFOFQzeXo2SWx5Q044aWdHdVpmWExpU3pTQ1Z0NFhnTWU0cU80dkhrc1BKTFpBYklwUXB6VDE3bWJtYmVrWDMybXhqamQvbVU3VG4wcXpxM2lBV2NKaWdKM1B3Q093cmtyRzZhM21BQndEVHJxYnpaSGR1cDRyVjA3ejhoKzAwT284THl4VFhDZVlUeWQ3c2VhNlhVOWZzNE1SR1JValhyazhtdUEwL1VUcHVubDA1a2tCQzFaMHUzVncxOWZZbGxmbEEvYjNySnB4azI5aWxKSGFXTXNsODRXS0p3cEdSdUdPSzM3YUNLMGorWDU1bTZzZjg4Vmc2TXlCQ2JhUnBHSXl6OWg3VnI3amdEdjNyU203b3R1NXF3SlpTeGxMdFJKdTRJYmxhZEo0WjhQM2lZT213WTlZd1ZQNlZscGtkOFZadDdpU0ZnMGNqQSszZXVtTXJFT0pYdmZBbWdNY1JTelc3bm9BKzREOEQvalcxcHM4V202ZmIyRzhUR0ZBbTllaEE2VlJtRDNjdTkzMitvRktBa2JCVTRBNyt0VnpkVVR5OXpvRWRKUHVubnJpbVNDc3lLWmp5RHlPOWFnUG1RcTNxS3BTdVExWTV6eExveTZuWXl4amgyK2VNK2pqdCtOY040ZThKM21zM0c5ME1WcWo3WkhQQk9Pb0h2WHFyQlQ4cjRwMWc5dVE4Y1NLaERGaW83a25KUDUwclhZNzJSRkhheDIwVVVFU2hVakFBQTdBVTRqbk5XWFg1cysxUXNvSEo3VlFqRjFmVWhaVHhSWXlXR1RWVnJ4V2tISkI5UjJySzFXNUY3cU04eW41Rk8xRDdDcTlyY2xaQ3JuSVBTc205VFZSMEo5YjBHdzEwaHJ0UkRKa1l1b2wrWWowWWQvclJaZkQvd0FMcEVTVWt1bUhWcEpDUDBHS3VCaTBMTDNQU2xzWmxpMVNPenlkenc1WWZqeFJ6TW14ODlLS21VVkdvcVpSV3JKSHFLbVVjMUdvcVphaGpOL3dycGxucU9vc0wzTFJ4cm55d2Niei9oWHA5cEZiMjF1STdORXN4LzB5VUtUOWNkYThwMEc5U3cxQVN5TVZWbEtrNDZWM2x0ZkE0L2VBNTZWRXBXS3RjMDc3VHJtOWhNVDNQbXFUa0JtNkdzV1hUcnJUMkN6RGFwKzZlcW10dTN1SlgrNHJ0OUJpcjRSNW96SExFR1Z1b2JtcHNteWs3SElPM09OdWZjVTVHeDBXdHE0OFBOdkpoZFF2WGEyZUtwdnA4c1J3MlBxS2psZlVxNklVa3h5VkkvR3JNY3FZNUpGTlN5WnVwcXdsaXY4QUZrL1Npd1hHaVZSeU0valVubW5idUFPQ1BRaXJBdFVpVU41QkdlaFBOV0ZzcnVXTU9sdkxnOURqclNhQzVuTmNBZGVLcFh1MjRpS0VrQTljSEZhRjVZM3BIeXd1cDkwSnJuYnFYV0xlWXEybkxJUDlra0dwYVlYTTF0WnY5R3VQS2xZeTI1KzZUNlZIcUdvUTM2ZVlqWmJIZnFLajFHNmFlTm9wN0tXQjhmTHU2WnJuOTVUaGZ5cEtnbStiWm1FbjBKSldWbEtZQXdlRFVPODdOdElWTGNyK1ZKampweUs2a2lBYkpVRWNVN2xud1IwcHlnRVk5cVVqNW14VEdTR1FFb3VNcWxhV25pNTFDN2h0b3dTWkR5ZjdvOWZwV2JGQTBqZ09kdVQrSnJvTEMyMUFLUnBTaGVNU09PM3Rtc3AyR2xkbmVXcVcxbGJMREF2Q2pvS2tFanQ3Q3Vjc0xYVW91Ymk3ODMxQmp4K3Ric01oMkRkMXJLUFk2RWk0bnFUbXAwTlUxaytncVFTOGRUV3lZRjBQanZSdjcvenFvSnVjRHJWNjFqWWZ2Sk9QUUdtbVN5ZUZqNVBJSTc4MXEyRCtaWkw2Z2tWbHMxV3RLbUFkNFNldnpDcWk3TWg3RHJ3bFhHS3l2dEx3M1BtSWNGVFd0ZjRBQk5jL1AvckdvazlSeFdoMDBOd0o0eElPalZqK0k5WCt6UUcxZ1A3eVFZWWpzS2p0ZFNGclpPaHlXejhvckZuM1RUK2JJY2tuTkp5ZGdVZFNvRUNRaGVkeDVOUTVDU0EraHF4SVFlUjM1cXMvTlFhMk5LRzhpTHBrZ1V5eFlQNHRsY2RQSzRQNENzMlBDdUNSMHAwVjU5bjFGYmhjWklLWS9sVDZFV1BIRkh0VXlqaW1LdFNxT2EzYk14NmlwVUZNVVZLb3FHTWtVVnU2THJyV0pFVStXakhRamtyV0d0U3FPMVM5Um5vVnI0aHMzeHR2RVgyWnR2OEFPdHEwMUJaY2JYVng2aHMxNU9CNjFMSE5KRWR5T3lIMVU0cEs2SGM5cGlLc3U1MlZRT1RrMWthajRpOFBXN0ZIdkJLNDZpRlMrUHhIRmVZU1hFMG93ODBqL3dDOHhOYXZoalJIMXpWVWdJUGtvZDByRDBxdklSM3VpdW12c1d0SXBvNEJ4NXNpWUJQc004MXVIUnJTMFVOTmNPejlsWEFwdHhldzZQYXJCYm9xTmpiR2dHQW85YW9SMzAweHp1eXg2azBhYkMxWmVDUUkyUXVjZE54elV6WCszdlZBczJDZVRWU1c0MjhGeDlCVXQyR2thLzhBYUpiaXExeElzcW41eWh6a0hJUDZWanRkNCs2Q2ZxYWdlOGtJNFFDczNxVWtVZkU5dGR0YXRjZmFJcGtoR2ZMOG9BbjhjMTU1Y0xESklXQktFMTZKY3RkVEVMR2p5TVQ5MUZ5VFdWUDRMMXUrWXZIcEtRbnNIa1ZTMzYwcWFzN0VUaWNaNVl3Q0hVNDk2ZjVQbUFNTUQxcnJKdmg1clZuWVNYbHpDZ0VZeVk0bUR1QjNQSEdLeHJlMkxSeUlzYjRYbmNhMWs3R2RqUEVBSFFIbW5mWkpIa1FJdWR4eG1yV3pERHRtdHpTYkJaUWpTT1VSWERPVkdUaW9jN2FqUmpKNGZ2cHJnUnBZM0xFNCtiYVFQenIwM3cxcGlhVHBxMnpxcGRqdWt4enlhbE02eUFGQ0NPMVQyMGlvTWxlYXBTdWFxTmhsellLZm5oeVIvZDlLcUxBVnprZEsyVVkzREJJNHdTZXdGWGwwVDVWZVJ1ZXBRZjQwS0Y5VVBtdHVjMEZPN0dDSzFMYlFydTRVT3dFU0huTEhuOHExR3NMUHprL2R0QzQ2SE9RYTBnelJwOCtDQjNGVkNPdG1TNTlpaGFhTmIyeDM4dklPak4yL0NtM2RzZVhRZlVlbFhYdVBTby90Q3NjSHIvT3RHbDBJdXpIejFGUStjME02U0llVk9hdlgwQVg5N0g5MDlSNlZseXNBd05aUFEwV3ByWGR4SGRXNnlSbkk3K3hyRW1ZN2lLc1dyZnVKaDJ6VlpVYVdYQTV5Y1ZEa05LeEpiMnJTVzhqSHVQbCt0WjA1Mm8zWWl1Z2VQeUNJd2Z1MWhhc29RN3h3SGJCb2IwR3RXVUdQSDRWQzFPREFyMTYxRzVKUEF5YVZ6Um9qbWNScG5QSnJPWXlTU2JsNHdhdnZEbjVwRyt0VkptQnlxakMwWEJJODNWYzFLSSs5ZEhaK0dvbEFOeEprK2dyVnR2RDlqSmhmTE5aVHh0T0pDcFNaeElVMUtvcnZ4NFNzWkJnUjRxcmRlQTIybDdXUTVIWTFtc3dvdDJic0RwU1J4NmowclYwVFFyM1hMc1c5bEZ1UDhUSGhWSHFUVmU4MHU2MDZYeTdpTXI2SEhCcjJYd3JwaWFWb1ZvRVJSNTBZZDNVY2xqenpYZENTbXJyWXplaHpNUHdrbU1PWk5WUlh4MFdJa2ZubXNQWFBBV3RhTEUwNWlXNXQxR1RKRHp0SHVPb3IyT0tWbDRia2RqVmtZWWNjZzlRYTA1VXlMcytjRlVrZ0RBeWE5cDhNNkZiNkhwU0ltR2xrVU5KSVA0amorVkpybmdMUjlYSm1oakZsYzV6dmlIeXQ5VjZmbGlyMTB4c05KWmdjdWliVjkyNkNsYmxIZTV5Mm9YQnU5VWtLbktxZHEvUVZxMmRvc1VRa3VQbFhzdmMwYVZvMzJlSVQzQzVkdVZTdEo3ZFJsNVRsdjVWTVUxdVUyWXVvWGpPZkxqR3hQU3FRaXp5ZVRVczVNdDA3Y2JjMHFiVDA0SGMrdFM5eWlBd2tuanJXanAzaCtXN1lQTGxJdlgxK2xTNlpieHpUZ3NQa1g5YTZTU2RWaHlNREE2VlVZcDZzbHQ3R1hmeTZmb3VuVFhMSXNVVUk0MmpsajZlNU5aeWVMZER1MGpsanZWamYrSkpQbElybFBIbXZDK3UwMDIzYk1OdWN1Ui9FL3dEOWFzZlJQRGVvYTdOdHRZOFJBL1BNL0NyL0FKOUtMMzJGNm5XZUtOY20xUzh0dEswbVV5cEl1Nlh5am5kN1Zlc2ZCS2ZabWEray9lTWhDcURnSWNmcldocE9sYWY0Y3RSRmFxSmJnajk1TVJ5eC9vS3RLMDkyKzFjbitWUktDY3J2VmdlTjNsdWJlNmtpY1lLTml1bzhLc1dsU05KUEw4MEdNdGpPQWVLaDhjYVVkTzFrdGo1WlZEQWp2bnIrdFErRzVnczZyMElQNjFtMVoyTTNvemYxRFQ1dEFuTWJUN295dTVUMEJybTUvRk9vaVJsaGxWVnp3ZHRkTjQrblJ0SXRKZytKWE8zQVBVWTVyenNkYVZPbnl0OWpWUFE2WFFQR0YvcGVwbTRua2FlS1Q1WkZKN2UzcFhyV242bGJhcGFKY1cwZ1pIR2VLOEJIdFhjZkR4YnBaWjV4TXd0eGhkbWVDMWFTcktqRzcyRGw1bWVuN0J0d1JtcThpdHRPRFN3WEljQU4xcWNoWEZhUXFRcXE4V1EwMDlURnVJWlNjeHVSN1pxRlJNbjN3YTFKNEpGSklHUjdWVGNrZERqMk5RN3JjcGFoQk9HekhKeUR4Vk8rc1dSUzhmSUhJK2xXQnNjNEkyc09ocXBlYWo1a0lXemxqa25pUHpSRnNGaDNGUTVhYWpLOXBNcXgzQ3Y4dUZ6VGRPdVVrdW94R1FWWTV6NjFUZSt0SjFXNWlPQVR0a2pKNVU5d2E1alM5ZjhBN08xbDdlUTVRVE5zUHRtdWVVOTdkQ3VaSGFlSU5aZ3NidUdJL05KTTIxVkZZV3AzUnU1RmpVNFVESjljMXpPdDZ3YnJ4ZEZjWTNSd2tCUVQrdjUxQmM2dEtOV2kydGhYeUNQV25kdTNtaHhra2RKR2hkbFNOZHpIZ0FWY2VGYmRDQ2N0L0VmU29kQnVWQzNWMndHSTFDSVQvZU5RWEYySjVOaXNPdlBQV2txaVpwZTdJNW5NallIM1JWZDBBR1RWb0tUd295ZmFyRWVqM1Uvek1teFQzZml0VTdsYkdORXBjaXRhMGl4aXExdmFNTWNWcFc4VEtlUlhnemFleHNrYU50SGtDdEdLSlR4aXFGdVN1TTFxUWtIRmNGU0xZRlhVdEV0dFR0bWlsUVpQUStsYldqUU5hV0VObE0zbWlOQW9iSFVWREZoamdNS3QyOG96amNNampyWHRaUzZzSk9NMDdQWTVhMW5xaXkwR3pKWGxmU2hDVlB0VmtjaW1OR001SDQxOUU0OVVjdHhDQXd5T3RZalRwZlh4bVlBVzFxY0tQNzcrdjRWcTNJY3dPa1pPU01aSGF1YXY3dElmM01RQ3BId0ZIcldjbll1S3VYSjlSdzVQR1QwSHBWYWErSmlPVDFySU1yTTI1aWNtbithWFVLb3lhemNqVGxHTzI1dlFWSkdoa2JDamp1YVdPMFoyeTdENkNyRzVZa1ZWR0JtcEdhRnJ0Z1FnY0FDblJTUGR5bUpUd2MxUWE0K1VnSEZYdERRdEpKS2VnNEZXbjBKWmkyM2dTelM3YTcxTm51R1p0M2twOHFqNm5xYTZUYVZ0MWd0NEVnaFFZQ0x3QlZtVnR6NDdWR2NuanRRdEZaRStaV2p0QzN6T2VQYXJjV0U0VVlGQUJQeWdacVJZc2ZmSUZKYTdBMmN0OFFySTNPa3gzYXJrd3RoajZBLy9BRjY4L3dCTG1NTjZoejk3K2RldjZ4RERkNlJjMnA1THhuYm4xN1Y0dTRhQzVJNURJMVoxRVJJMy9GOFpraHNybjVzWU1aQjZEdjhBNC9sWExIZzEyaklkVzhOelI4UElpNzFBNjVIK2YxcmpBcFk0SFU5cXFMdkVxTDBBYzlzMTZaNE90dkk4UFJTS1Bta1ptYml1ZTBIUkxaUUo3c0FuME5kdFozTnRMYXRIYTRBaTRLaXZMeDlWT0ZrYTBuNzFpekhMS1Q4amdIMHEvYnlUZnhOOWF6YksxZTRsSjVDanFhMC9zc3JZQ25BRmN1R29WcCs5RFEwcU9LMExRbkFHU2VCM05WWjU3T1hJSklQOTRDbXkyY2hHREpuMnFwY1FpMmpMeXNGWDFKcjJZZTFpclRkekN5SWJyOTJwWlR2QTZFVnhuaXJVTGFXdzN4alpkeFNqNWh3dyt0ZE5MZjI1QkFrT1BwWEkrSk5QanVkMDhERGVSOHdIOFFyT1V0VmNjbG9jOUxxa2hQbktjT1I4K085WlY1Y2lWZk9CdytjbkJvbVdXRmlDQ1ZIQk5VblZsNFBUdDdpdDRVb3hkMFlFaHU5MGdsTFpOQXVTOXlzaC9ocXFVR3dqM293NU9GSFd0VkZEVE5yKzM3aUt5RnRBU1NTU2ZyVjdRYlI3dTREM2t4M3YwOWgzcm0wa1NGczljVnQ2SE5iTmMvYWRUZjhBZFI4TEVPclZ6VklLRVc0bzBpejFEU3JPMXNrQVNaSFp2Y1pxMU9RTWpPNCtncWhwOTIrb3hJWWJJVzBHUGx5b0JJOWEwdkpDTGpQNTFkUFdKcWN0QUxpSWRtRlg0TGhHSUVpYlRUNG8rT2xTdGJCaDByNWVWbWRseWZNYXA1bTRZcTVheXFWNVhDKy9VMWp0YnlySW9CK1FWZnRTbTRLWHlmZXZUd2NhRk9uN1NvMWN3cWN6ZGthclhjY2NaR0FSanBWYUJMbVI5ME1VbTBuZ2tjVXJTcGJnU3NnS3J5ZU04Vk5jK0k0SXlxN3VDdVFSWHEwYTFPc3VhTE1KUmNkTEdqQVpMWmN6Uy84QUFSMEZNbDFKUWNCcTVtNTExSlFRcnNlYWJaenozMTJzVUtid2d5ZXd6OWE2T2ZvaWVYcXkxZTZ4ZG03WVF6TXFMeHgzcktsTFNzWFp5Y25tbjNFYzFySVZuamFOdlE5RDlEVVlrVTlEeldUWmFWaHdnNHp2NDlxMC9KaWlpUXhnWWRjNTk2ekVrMm5QVUhxS3VKTHV0eW1jN2VWcktVK1hWanNTd3RpZFFmV2wxZUVXMXdBdjNXSUlyQzFEV3hwOTliS3d5c2h3VDZWcFhHcGpVckNlY3ZrUlNEYjlPS1RxSmJrOVJ2bUFtdWswOEphMkNHUmdwYjVqazF3OFdxd0dWMUxmNnNaTmEwdW8vYXdyZy9MdEcwZTFXcG9iVnpvemR4RTVCelF0d001S0VqMnJEaFppQUFUVjZNdXFncS9QdlZwb1ZpN0pleDRJV1l4bjBLMVRsdVNlVE51SHRWZWVTWitIaUpQcUJVMWxwbHhkTUhaTmtmcWU5TnZzR2lFZTVTRzJlZDl6N0JuSHJYbXV2cGpVM25FWmpXVTdncDdacjFPN2dqaGNJbzNLdjZtdVA4YldZa3RZN29EQlU3RGdmbFdYdlgxSW1yb3ovQzEyUTdSRTU3YzFEZDZFdGhleXlzdzh2Y1dRZWdQSXJOMGU0TUY2aDZiamc4MXQrSy9ORnZiWEtNZkxZYkdIdjFGUzcyc2pLNzZGWkw1NUFJME9GcmUwZTVnc1ZKenVlVEFJOWE0bUsrYVBnZzFyNlhldkhld1R6Vzh4Z1ZzbGdoSXJsbGhtMDR0R2ticDNQV0lKb3JlQlFjTHhrZ1UyVFVjOEp3S3hWdjdGZ0drdllnemRpMU9NOFRmNnVVUDZZTmFTbEtFVkNPaU51Vk4zWmRtMUVSRGN6blBwV1JlM01sODRhUmlFWDdxMDJRbG1KSnpVVHRVTzhWdVVraG5rb3pBQVp6Vmk1OFBRWE1SQ3l1bTRZUGVwZE9oRWtoZGh3by9XdGFMbUpzMTVkZkZ1RStVdmxUUjVCcmZoL1V0TnVYUW9aSS80WkFPQ0t4MHRaSkdNY3E4WXlNVjduY1cwVjNiU1FTcmxaRktuNkd1RjFidzFiYVJZeVNKSkl6N3dCdjhBU3ZSdytPVlZXYTFPZVZQbDFSNS9MYkJHMnFEeHhWZDFjRXFDQUQzTmE4eTVrT1BVMXAyV20yZDNZYm9yYTd2YmhQOEFXSkRIOGkrZ3pqcjlLNy9hV00xcWNwSGJGMkFFcWdldGRoNFQwR0NlUVhOd29hTUhBM2o3M3ZXLzRTOENRWFpudk5TMDU3ZE40K3p4U25rRHZrZjQxcmFyYldlazNFY0R5UngrWi9xeDBxS2s1U1dpMExnbGNtZVJiY0FRbGxIb2VSU3g2cEdnQWtUZjZudldhKzlQWEgxcUIzSjdWTVplUnRZdndTS3dCRldrYm1zdU5idTN0MGU3QVZuYmhWSENpcjhUWkZlSGk2VWFkUzBkam9SYjJoaFVEeGtISzhHcFVOU0ViaFhFL01hRnRMaEpQM2N4SG9janJXUHEybUMxbTNRT1hoUFFIcXRGeGVoWnlzUis3M3B2Mmw1QWNzZWU5ZS9ncVU0MDFkSkw4Zm1ZemFiMEtjVVEzZ3V3UmU1TmEwV3N4V01QazJFWDFrZnF4cW5IQUQxYzU3Vk9scGtjTXArb3J2VnpOb25Pc1hGd3V5NEVjcW5zeTFCSlpKS3BlM2J5Mi91TWVQd05EMjdSRExSOGVxODFDN2paZ1AycE5zTEZWNVhoWWlRWUlySWwxK1MwMWRJcFpOc01pOGV4cVRXWlhoaTgyMmNLVSsraDZNUGF1VHZMczNnRy9HOURrSDJyRkwybDB5SlNzalkxNmY3VElqbHNoU2NVM1M5VGVPMW5pMzhIbkZZUDIxbVVLekhJNlpwcVRGUVNPTnhyUlVQYzVXWVgxdWFkbmRGVnVYTFphUmhYVTJ1cHJIRWdKL2hIRmNOQkl5TUJrWUp6aXRDMGxsbm1WdDIwTDkzNjBUcE51Nlk0eWFaNlZiM2NVYXhxN3FKbjZJRGtpdWh0YldGSXhKY01Sbm9POWN4NGEwcTBzNFJkelMrZmN6REpZbklIc0s2UlJKY0g1RUpIcjJvZytwdnVpOUhjVzZjUlJFKzlPbWxuZVBLWWpUdjYwV3RrVkdaSEgwRkdvTXNjS2hXejh3eld6aTNIWFF6MHVVN21QY0FRSzV2eGZjd1cybUpheUlXZTZZaERuRzBqblB2WFdxQTZqUFFpc0R4WG9VbXE2Zm0zNW50L25SZjczdDllS2Jqb052U3g1WUdNTXhJSkJVNUZkckRaSHhGb3lXVWNpSkk1VW9XNkFnLzRacmk1eGlVTmdqZDI5SzZYd2pldkdRZ2I1a2JJRlo3YW1Pek90MG40YTZaWU9zMTVLOTVJdjhMQUJBZnBYVUMzaGlRUnBHZ1VEQUdPbE9qbkVzQ1NEb3lnMXcrcGVNYnJTdkVqMjl6SWhoSndzWUhRWjRPZld0cDJ0b1dyanZGbmhHTzV1NDcyeUtSTXpEelU2QSs0cDBFUXM0Z3U3Y1FNVmV2NTJrY0ZuTFo5S05Qc2ZQdVdXNFE0VmM0UHZYSlU1THE1dEhRcExKdk9jWSt0TllFMWR1N0JyYjVnZHlBMVZ4ejdHc3BLN0xUTHRpU0U0T0IzclJpUDdrbXN5MkpDWXE3RTUybGUxZVJqYVNhYlc2TFRKczhWejNqSXFOSlU5L01BL1Exdmc1cm12R2o0MDJKYzlaQ2Ywcm53YmZ0b29WVDRXY0JFbm1YU3IvZWJINW12V2RLaHQ3RzNXQzJqV05SMUFIVSt0ZVhhU3ZtNnRicjZ5TC9PdTI4UmF6UG9kcEhjUVFxK1cybko2VjdrNmlWUlF2dVlVMTdyWjF1b2FyYjZYWXZjM0RnQlZ6ajFyd3J4TjRodVBFbXNQY014RVNuRVlCNkN0M3hEUHJHczZVdHpNKzBPTWxld0hwWEdxb1FiYTc2VTFLNFd0cWJtbStLTDZ3VVJTTjlvaC91dnlSOURYVDIycFc5L2JpYTNiUDhBZVh1cHJ6c25GV0xPNm50WlM4RWhUam4wTk9VRmE2SEZ1OWozZUhUSTd1elg3VmxYSXlSbnBVTVZucDR1dnMwYzhqc1B2WXhoZnhyR3NkU3VyOUJ1WXd0S2NSb0R6ajFyWXQ0VGE0dDBUWVNNa252NzFqT2xTcXU4b212d2JzVzd0bzdlUlZpa0xnOWVPbFkyclg1dDErenhIRHNQbVBvSzBrdUFicVMzbWtYemtQVDI3VmozbWszTDNiVE15eWZPQ3lqcUY5ZnBYaXdwUWxpWmFXUzZHbC9kM01zUHgxcXpBNFBMTmdlbE8xdkNYL2tvb1VJb0FBcXJGWHIwcGM4Rkx1VGF6TlJKSWtIUW1uL2FoajVWYW9iUzFrdVd3bzQ3c2EzSU5IdGdvOHh5eDc0cmV3T3kzTXRia2Q5MVIzVFc3eE1YK1U0KzhLNmFIVGRPakdER0dQdnpWa2FkWU1NZlpVSS8zYWJnMlJ6UlBITlptbGhiYTVXU051akthNWVWeHV5cElIYXZvUzgwM1N2c3pvOW5DTnlrZmNGZVVhNTRFMU95Y3pReHBjd01TVk1mM3NlNG9oQlFNcEsrcHlLN2l3eUtsRVp4OUQrZFg1ZEpudG5SWkluamM4N1hHQ0tsanR3T0N2VVZVcFdNbXJGR05NakNnbGozOUsxOUUwUy8xQzdTS0VFODVQSEFIdld6cDNoSzYxU3pGemFTUW9GT0NHNm11aDhPNmJlZUhMbDViaDQ1NUhqMmhGemdmV281cmdvbTlwT2lwcHFSbG1NM2xyOTMxTk51L0dsbGJUUEFiZVFPaHdSakdLYzJxM1gzMldOUU93Rll6NkxCcnQxTGN2S2JlUitoNnJXZG1sYUJjazdGOS9GRXQxRG1KZktCL09zOWRaWkwrS0NWaVZtYkdUNjFWbjA2NDAwK1hKdGRWNk9oeUt3Tll2UXR6REpHY21KZ2E4Nm02a3NRdWMxMFVUMWUzT1lrTldDdUhCck8waTZXNTA5SmM4TW9ha3VOWWpFbTFSa0RqTmUwbWpPMnA1ajR3dGt0dGR2STRWMmdTYmdQVEl6L0FGcWxvZDJZTDhEb0hyci9BQnhwa0Z4WURWWWdmTkRCWHdlb3J6Mk9UeVpWYkIrUnFob3prdFQyQ3kxU1E2WXNTdHl2ZjJyeXZWN2hyL3hKY1NaM1psMmozeHhYWDZKZnJKYU5qakNFa1o5SzVIUkxVWE9zMnlzY2w1MUovUEpwUmJkeWxxajF6VExNU3VrMHZJakFBQjlhMC9MVVRQS3B5VzRxckhJTGUxNVlMbm1xc3VzeFF4bEVVdTM2Vnp2Vm10bVhKd0dCVWpnMWlYRUl0bnh1QlU5T2VsUTNHcTNNcFBPd2VncWc4enMzek5uNjBwRkpHemJ5SktkcWtaSGFyb1haOHRZZW10SUx0V1hIeTlhMnZPVU51YXZJeGtKeWZMSFkxalpia3c0V3VWOGN0aTF0eDZsai9LdWtOMUZqZzF5ZmppZFpJYmZiMEFiK2xjK0RwempXVGtpYXI5eG5OZUhCdjE2MnovejBCcjBYVXRPaDFDMjh1VmNoV0RBZTRyenp3dGdlSUxYL0FILzZWNmx0M0tRSzZNZStXckZyc1JSK0U4KzhZWHFXbG90ckhnRTloWEFrNVAxcmE4VjNNazJ0VHh5WkJqWXJpczIzMCs2dXd6UXdzNklNcytPQitOZTFoSUtGSk45VE4zYkt2VS9MbW1TU1BFcHlNRTlxc3hzc1JKWWRLcXl0NXNtNXZ3cnI2Mk5PVlJqZnFldGVIdnM2WEx1c2hsbFFmTklmNUN0YVhVQytxTHo4b1FDdWEwdTVFTjY4R3dSc2c1QUdPdFdUY2Y4QUV4VTU0WlJXRU5rRlQ0amN1N0NPVytTL1JYTTZwc0FCK1VqM0hjMVRsdnA0TGxQTVZrZGVtZTRxMDE5NUZ1Sk9vQkFQMHJHMWE4bU1vTHR1aVk1VnZTcGxGSjNSQ0pOVGk4MmY3YXB6SEwxSDkxdlNtV2RsTGNQbEVMS09TZlNuV2Qwand0Rkp6SEtNSDJQclZtemoxS3lUeklOanhudDYxejFxaXBRdXZrYnhkMFdrTFEvS2lGYW5qbmIvQUphTVI5S2t0cnI3VU1YRnNVYjFGUTNnTUFKQTNMV01NZFR2YVdnY3R6Umh2WWtBQVVaOSthdnczeVkrWmdCWEtSM081aGpqbXRLRUtxR1NROEFaeldzc3dwd1dtcERnWFpwSXIzVVVpRWdDamtpcmhnODNqQTI5QlhKNkxmSmQ2NWN5STN5UjhDdW10Ym5rQW5wWFpScU9wQlNrdHpOK1JIZjZIRGRJQzl2SEl3R0F4VUVpdktkU3Myc3RSbXQyVWp5M0lJcjFlZlhaSTVtaWd0aklRTWJzOEExNTM0cFdZNnEwczZnU1RMdU8yczZsU201Y3NYcVJLN1dwdGVFTDlJYk43ZG13em41ZmV0OHNYeVFPY2NHdU04UDdlQ1J5RGtWMTl2Y1JyKzhKd281TlJHcEZ6NUh1VkJlN2N6Nys3SWo4bmJ0YzlhcXczc3NRTVlQSGVvN3U1KzAzTWx4Z0FNZUI3VkFyWXhubXQwV2EwY3VUa2tZUFhQT2FzVzJtYUE2SHp0UGlMc2NsbUdjMW4yMXZJdzNTRXJub3ZjMUpLd2lCUFFVdmR1SnE1bzNVOEduMnBodHRxUjQycXE5aFdQSmRNQnV6eWVsVW11V2xmTEVrRHBTYnk3RTloVFRHbFlsbWthZTBtZ1p6dGtVNUdlTTF3RnlDa3JLYzVydUdiMHJrdGRoOG0rWWtjTnlQeHFrUlVWMEpaYXBKYkl3VS9lUWpyV240WEJUVnJlWEErVldiUDRZcm1vamxoejBQZXV4OFBlVFBjQjVka1NxaFg1ZS9Tb2xwY3pndFRxWjc5NVRreVZUZVZqL0hWbHJPMGRnSTdzRUgxcTdCcFZvb0JKODAvV29Pa3hjc3g2ay9TcEk0SFkvTjhvOVRXNzluZ2pHRlJSOUJWSzRaRk9BQldVazBOTWZBSUlFd0dCSjZtcEdmY3Y3dC93QURWQUVrOUtjekJCa25uMnJtY2JzWStSK2ZRMXp2aWx5WW9jay9kYXR0cFF3NU9mZXVkOFRNVEZIbnNEMXB3ajc2WkZUNFdVUEN4LzRxQzF6L0FIeC9LdlY0eFhrdmhVZytJclQwTWkxN0FxWUhTdURNdjRpOUJVZEluRTZsNE5zWmRhdU5XMU80QzJ4T1JIbkdlTzljN3J2aVMzbFE2WnBNU1EyNkRCWlJqSXBuanpXTHFmVzU3TVRIeUlqZ0tEeFhKR055Y2pQMXIxOEpUYnBSbE45Qk4rOFJ5c1dmYU9tZnpwamdnNElwOGorVndCbGpVWlptR1NhOUhVVWowQTN5dnFpRUFCaEdBNUhjMVlaaWJpSmg2VnphVCtUTVp5M1gxcXphNnVzbDB3ZHVBUU9EWFBkQktTdWRuL3I3Tm84NEpIRlp1MTJSN2VaYzdlYzlzVlF2OVpTMWppbHR6OXpxTTVCcXNtdnczOG56RGVCMXllbjRWTDExRnpJdlF1WUpURVR3UmxUVzNaYXl0cGJ0NXlQSWc3THlSWEdTNmg1VTJWenRERlNQVDBxNVphcWt2bUtQNGVmcldGYWtxa09XU0xoTFc1M2QxcnNGbmYyTnBHRmI3VVR1UG9NZGZ6cUp0YzB5N3VaYldPVldLY01SMHpYbVdzNjVMcWQ2TGdJSWpFdXhBbkhIcjlhcVdWd1V1WS8zcGlYZU1zT29HZXRjUDlsNmZGcWVsR2luRzdQUjdrR3p1ZHArNmVsYUlpbDFTeSt6eFNlWG43eEhXc0c4MTdUcmg0TEMwWjdseDh2bmV2djcxYjBiVlJiWFhsczNRNElya1ZLY1Y3eU9PcENTNkZ0ZkRzT2d5ckxCSXhaaDgyVDFxZVBWbFVzRHcvWVZvNm9SUEVrcUhJeFhOL1pibDVETXNUZVdwNWJ0VzFPdldqS3lNZEVqcDdSTjhRZHUvTmN4NDV0d3YyYTRBOVVKcmZpMVMyZ3RWVGZsc2RoV0w0bnU3ZTgwTmxWWDgxSERCalcxR2xOVDVyQzNWakk4UE4rOUE5OEUxdVhzMnkzS3AvRWNHdVowZTdXM2Y1aUJuQjVyWnVMcEprS2c0eHptdXoyTUpUVTN1aUtiMGFHS3JTa0pHdVRXaFpyWldxYjdvTVp2WHN2MHJHT29HQWJJdXArOGZXcW5teVN5TTdPVDdWMFhzYVdPaXZOYXRZMVBsZ3RqdWVLeDVOVG11M3p2MnAvZHFqTVBrT2VmU3FqWFFpbml5Y0FuQnpVajJOZmNjYlFlVFVtL1l2SDQxV1Y4REo2MEJ4OTV1Rkg2MVlGaFNNNzMrNzJybmRmblc1Y2xDTnljR3BkWjFwYlpQTFVqZTNSUjJyRHRwZk9lYmMyU3d6ZzFTVDNNNXZvUXdydm5JejFGZFRZZnVMQkNwNUo1cm1JQ2Z0Qyt2U3VzMGVLT2VKSTVpVlZjOU9hVlN5Uk5QY3N4M2JLUm5yV2hiNml5RUhjZnJXSk9qd1NGVHlvUEI5YUk1d09EMHJMb2RGenFvOVNrY1lFdjRHbmZhVkp3eWdIMXJuSTVpcllKNDdHcmNkeVR3V3FIcWhHejVxTWNGc2VsUXlPMForWUVyVklTbkhKclJ0THdNb1NRQmgwNXJHVUhmUmp1VldiY0NWUEhlc1h4Q2N3Ui9qWFl2cE1NNitaYm5hZTZnMXkvaTIzU0N6ZzJnNTNNQ2Z3cVUzR29rMFRQV0xNTHczTDVXdTJqOWNTS2YxcjJPV1oydEM5dW0rUXI4b3ozcnhQUkdQOEFhdHRqUDN4L092UWRZdWZFOFduRWFmWWJJd0RrNSthczhYaHBWcWtVaUtja29tTGZlRjdDeG1sdjlmdnZPbGtZc1lZamdaOU05VFhPNnBxTUZ5UElzN1NPM3QxNkJSeWZjbWsvc2p4SHF6TmN6V3R4SU91WDQvblVhYVpkSkc3VElZOXB4dEk1elhaRnhXamxkb2F1Wk1rQUo0clYwZndoZWFtUkpPZnN0dGpPOWh5MzBIOWFqdGtoVzREUy9Nb1AzZld1dHROVDh3QWJxbkVZbXBDTm9GeGdtOVR6Kzd1OTB1MVR4Z1pxRzJtWVhKT2NaTlZHY2x3K2V0U0llNHJ2NVZZNUc5VFJ2cndyQ0VCKzlWYXp1R2lWaUd4bnVLclNTZWFlZTFBTzJNamtacEtPbGd1WHhLd1p3eDNCaG5PYWwwMjYyWC9KNHgwck84L0VYUFVVV2MyeTQ4eHY0ZWxITGRNcE0wdFFDUnpBcVI4d3p4OWFySTFPdXBsbmlpZlB6RE5RQngwQjVwUldoNjlHcGVDTkswbWtTVlRFeFY4NFVpdmJmQ3VrNlhKNGRoVjRZcFpaa3pLeHdXSjlhOEdqYzdnUWZ5cnMvQU92MitqYXU4bHpIUE8wcWVYR3NYUEpQcFJHTWVhOGtYaUl1cFQ5M2RIZjZacEZ4RGRYRnBJeE51a3BDRmprbGUxUDhRNlhmRkZOcW02MlJlVVU0T2ZXdWhoQmRmTlpkck56ZzlxaTFGYjJYVDVrc3dobEtrTHZPQlVScFJnbTRyVThxVTNLVnp6cC90a1l5TFJ4OVZOWjEzY1hFc2J4U0JnQ0NNWXhXdk40ck5yYXZhM01SKzBSRXEyZld1Vm0xdHJpNXpqaHppdWVNNmplMmhwSk9Pa2ltSnlwSFBQVEZiaWI1b2xZSGdpdWJZbFpDUFFrVnMyZXJ4V2tjYVNwdTQ2MW85RnNZUTBrV3piUzQzQUVoZXBBNlVpNFFFazlhc1M2eWx4Q3NWc1FBLzNnUFNxakg1Z1BUclJHVjFzYlhJTDZaMWpieTFMTVA3b3lhNXU4MVNXVUdPYkJ3ZTY0SXJ1dFBqU0dJeVNKODhuOFJIUVZnK0xySzNqUmJrTDk1c2NEcDcxU3R6YWt5dmJReUU4U1RRcUZhRVBnZGM0cUs0OFQzVTR4R3F4OGRlcHJKY2pPQTJSU1JwdmNxSzZlU0tNZWRnOGp5U2IzWXM1Nmttcldtc2Z0WXowWUVVMFFjRVk1cGJjTkZleGp0dW9iVFZoRTZuWmNEMTNWMU9tcy9sYkkyQzdtR1Nld3JsWmZsblBPTU5rVnYyaG1lMWtFVDdaTUFna2NWaFZWNGxVM3FkZTExYXcydmtwQ0pXSStabUhCckptdFk1TWxZeEdUL2RQRlY3SmJxVDVacFYrb09CV3Nsa29BYVNUUHNEWEtyMk9sMk1nd3pRNUJJa1hQYnJUbGNwMTZWcXZERW9KeFZONDBkdnU0cHVWdEJYRmptT0J6bXI5amJTWDg2d3h0c1k4NU5aNjJqcjh5SEk5SzN0SHMyZ2RMcmVPUWNBVnpZaW9xZE55dU5hc3R4V2VvMlRERndqQWRqV0w0MnkxaEZKM0xrSEhUcFhSdEl6SEpOWUhqSk02SXJZNlNqK1JyeThQakt0U3RDTXRybFZJTGxaeE9oZjhBSVpzK2YrV3lqL3g2dmRXbGVOREdRR0Jyd2JSbkM2M2JIb0JPdjh4WHZFaEJJUHRYYm1OV2RKcHdkakNrazFxVnBJaVl5RklINFZ4SGllRm9HTE92QkI2VjNEeVlCNXJrUEZ1V3R3MmVqVjVlRXFOVk5UcXRkSG5GemxKVHhVMWpmdEZJQVR4U1g2NWJjS3pwRHRKSVBOZlVLS3FSMU1kbVpaWVlIK2NVK0o4SHJ3YWJMQ1labmlZYldVNElOTTJzdk5kdlE0eDNTUTU2VThuZDh0SUZMRE9EOWFUSlZ5TzlJQlNQbXhTQTQrVmV2clM1SmJnR2xDZ2ZlUFBwVEtpbTNvVDVCaFVEcmo4NmpISEZLSkNZK3ZYakZOVHJqdlNTUFNpckpJc1Jua1ZxYVRxTTJsMzhONUJqeklteUFSMXJMVGdkSzNQRGVpTnJsNFltdUVnaGpHNTNicUI3Vm5MUkhXbW94Zk5zZTIrRzliR3Y2UEZlQkZSMkpEb3B6dElyWW1tUzJ0MmtjNENLU2F4L0RVVmxhNlVrZGxHRWhUaGNmeGU5VS9IVDNYL0NOVEcyWmd6RUtRbzVZSGpGVXAyamM4amtVNm5LdEZjOHIxaTlXOTFlN3VFT1JKSXhINTFtRDc2c0RubjhxMFl0RjFHVmZsc0ppUDhBY0lxbGQyTjFaUHR1TGVTTFBUY3VLeGkraDZ1TVZQMmE3b1pQeE8vczFFeHpHaCtvcEp6aVZ6MklCb214NUtrZXBwcGFuamZhTCtqai9XU2Vnd0t1bHl4T085VWJFckZhZlU4MDZVWGtueTIwVEgxYkZTM3FiTFJHbGRhdEpMSUxXRWdMRW9ERmU1cWhlelBjUitXNEJEZGpTVzFyTFpxWG53R2MvV21NZk1mSjllS2hwZEFTTUhVZE1lQmc4STNJZlRuRlU3VUZMbFZZWXllOWR0Q0ZISkEvS3MrU3p0SnRVbE53b0Q3Q1l5RGdaeFdrS3VsbVl5Z1pTcDgzQTdWVm40dlVBejI2VmNsWUp1YnNvUDQxWXM3UkxxMVNhUkFTcHpuMHA4M0xxUXQ3R2Zjak03WUhQV3Q3U3BOMExIL1lQRlltb0tCY3R0SXdlbGF1aUZER29KTzdHT0tKYXhHdEdXeGROa0xoZ1QwOUt0cGMzRUJCZGNvZXVLekdjQnlNOURWaTNrZFpFRzc1U2VSN1Z6U3VrZEYyYmlCcGtWNDhsVzVHS1ZZSk0vY0pxdERNTGVVaUxpTnVjZWhxN0E5eGNTL3VTQ2ZyWEpLby9rTkV0dHljRUVFVnI2SzZPWm9XeDhweUthdWxYalczbk9xbmFNNEhXcXVueWZaNzEySU9IWE5GU0h0S2JqSkRUTnhvVkxjY1ZpZUxvQ1BEc3JFZmRkVCt2LzE2MDB2N2VWc0xNdWZUTlV2RkVvazhOWFNIcmhTUCsraFhqMHFiaFhpL05HamtuRm5tZW12dDFTRmoya0g4Njk1TEJod2E4QXQ1Tmw0Q096MTd5czhIbEs1UDNnRFhkbkdqaGZ6TWFQVWltVXFTYXg5VTAvOEF0Q0JvYzdTdzRQb2EzalBieUp0RGpOVVprS25LZ2tmU3ZFakxrbGRIV3RUaHJ2d2xjVzhiUGNiTmdVbkttdUl2SWhISVFPbGV1K0tiZ3hhT0llanVRUHdyeXJWb2lyazQ0cjZ6QlRjNDh6T2VaQmZXS0Z0NVhKN21xUnRrd1FNMTBrOEFaVFdQUEVWYzhWMzNaaFpNcFJvVWpJUE9EVlpCdW16NjlhdTR3citvNXFySGp6RnEwekpxekh6S0VZRDBGUkVnbnJVMTZHYWI1Unh0RlZBNVVuSzFVVm9kTVdsWWxVWngzK2xTTHc1OUtyS3hCNE5XN1VMSkppUW42aW5LNTFVbXBPeUprR2NEdWE2SHc3Qk5GZE0rQnNLNGJCOWF4Q0dYbVBnVmIwTy91UmV0SDlvRU1aKzhUN1ZpMDJ0RGZFeVZPbnl2ZG51UGgyRS8yWEVxRENnVmV2RXR5bTI0dVVVRG91Y212TGg0L3VZb2hhUUhaREdNQXFlV3BsbjR6VkppMXhBeisrN0pwSnBIQkhEMVdycEhvemxBdUlISitvcUdlMGoxQ0h5YnlDS1pQUmhYSm54N1piUUVoWU1mV29wL2lENWFrUlFxVzdacDZGTEMxbXIyT1o4VDJrZGhyOTNieHhoRVVqWW83REZaa24rb1gxelZ2VjlSbDFXK2E5bEEzeURCQTl1S3FaVTI0M0VMejMrbFM5RGxla3RTZXdqZWVaWWt5UFUrMWRRcWlOQXVjS1BTc1RRa1VJODNyd0NhdlhsOHNNSlhwbnVUVVcxTllyUzVHL21YZDBrVWNiU003akNLTW5GUjZoYnBaNm5OYm93SVJ1UHBYb1hoR3pzYlB3MjErclJTenlLV2FRRUVnZW50WGxlcFhiUzZ4UGNBL2VrTlFrNVNGemFtcW5JNjFRMVpOdmx6QUVFSEJOVzRaZDBRWVk5cVM1WHpvQ2g2ZHFpTHRJSHFqbnJ2b3c5YWxTNWVPeFdGRGhXUFBGSmRJZDJQUTFGdEloTzRkRHhYU3JhR0MwWXk4UHpLYzlSV2hvampBR2VqVlF2UVZXUFBYQXFYU25LdWU0elJMNFE2anRRa2VLL2tWV0lBTldvNXpFUkp1M2JnRGowcXJxeTdiNXVldUttZ2dlNEVLSURsdUt6cUpPS3VYYzJ0SWpuMWE2Q3Q4a0MvZUlyZmZTV3RYRWxsY25JNTJ0L2pTMk5yRHAxb2lCc0hITlRHWUhsV3pYTXVYYXhvbXpRc05ZdW9GQW5Ubm9lYWoxUFVMSm9ua0NpT1JnUmtDcVMzQ2s0SnpTa1FOZ3VvSnE3WFZyaGM4L3Y5UW5GMnhqbFlFTndRY1ZZaDhRYWpMYk5aenlHU09SU1BtN2NacloxalJrdTV2TWdSVUE1SkFySk5yc1ZzTGtxRFZ0VTJrbWlOVXpKVTR1Y2orOE85ZTB4UitkcFZ0S2grOUVwL1N2RXNuN1FTQjF4WHJYaHk3bGowcTM4dzVqZEJqMnJ6ODJvdWNJeVhRMXc4ck5sMkZKZzJRTTFveFhvalRiTW0zSHFLZ1Z4RktHSDNUVWZpTFZyZXgwVjNJVXlPcEMvMU5lSFNvdWJzanJsS3kxT2U4UTM2MzE3aFNOaThBWnJrdFhnUjRDVmNGaDJ6VmE1MXJDeWlSdDBqTDI2RDJyT2ZVaE5Cc2JobDVVK2xmV1VLVGdrbHNjYm1tenBiQzcwM1hZZDlvL2t6NCtlSnUzMDlSVmZVOUlsakJmR1I2aXVGczdtYTFtU2FCeWtpOUNLOUk4T2E1RHJWcWJhNUlGd281WDE5eFhaT0hZeFVqalowOHVSdU9DdUtyb0UzWnhYUStJYkFXN2wwKzZUelhPcWFoQ2x1TnZuS1RxUWVxQ3REdzlwZjl1WGJSUElzVzFjbDltNnMrNWlrbG1pQ0x1K1h0WFI2UmNIVHJieW8wVlhZWmM5elJPZkxEVGNMdEhQYXBabXgxV2UxSno1YllCeGpJOWFoamNxdzlxdGF1d2ZVbmwzYnQrRG1xcWpQSTlhMWk3eFZ6cnBYdGRIYUh3cmVYZW4yZHhiVFI0dVUzWkl3RXEvUG91bGVGdEJhUy9NYzkxT3BBSyt2dFhQYU40bXU5UGdGc1pDMEkvZ1BiNlZXOFFhbWRRZFR2WjFYb0Qyck5LMHJGMW5WbEpTbVpYblM4blBGVzQ3aGRvTzQ3dTlad2IzNEpxVWNpcmNVemVsVmxIcWFBblRyNW1UVWtPSGZNaGJiMk9Lekl4dGtBWWNWdld0eW4yTmxaTnk5ajNGUkpXT2gxWEtEdTdFYllDcUZKSUJJK2FrYm0xSTlHOWFadUJWZVA0alVnNGhmUHRXVXZoUENxTnZWbDNUN3VPQ3h3M1ZTZVBlc3JVTDZTOGtJQklXbEJCQjV3S2pVSzhoT2VCVXAyTS9hdHF3MjN2YjYwUXBEZHl4cWVDcXNRS1FYa25WMERuMTcxSTZMMTZHbWhBRGtqbXI1bDFJVXkzWWF0REdRa2haQWY3M1N0UnBsZjVsYks0NmcxenNpb3g2ZE9hdFdzd2l3VmJDazRaVDI5eFVTaXBhbTBKMzBKSnlmTWJ0elUwY0lkRnlPQWNtcWp1SFpqbmdrMVlhVXBhNUE5cWJ1bzZDdVZ0U081dHc3VW1tSEU1WE9NOUtpbkphM0RFOGttbTJENHVGclJMM2JBWHRhQTg2TndjNVVWMDNnUzBpdTVwaTQzUEV1NVI5YTUzVmdXZ2ljampvYTJ2QW1xTHBkL0xLL0t2RVFhNTZxYnBhRnJVNm5VZE9kMUxINVFLb1dWbkl5dVMyUXRWdFY4U2lXVnNOeDJBckpmeFhOSENZNFZ4Nm1zS2NBYlNOTzR1bHNZekxMOXdNQXg5QVQxcFYxalRtSEY5Qi8zOEZjcE5xMXpPR1YyeXJEQlU5RFdjMW5ESjgzS0gyL3dyb2pGZFJjOWowTjd1S1MzSmhrUndlNnNEVlNDM0gyZTRad01tTnNmbFhDb2wxWk41bHU1d1BUMDl4V3hwMS9jMzZ0R2ovTUI4eTU3ZXRFNE5hclZENXpLZklsOWdLOVI4S1MrZG9xeHRnaEYvS3ZMSGJNbzlUa1YyL2grNG5Pa3JGRVNGSjVJb3hFMUNLa3h3VGNySTZ5RzYzYm9zNTJuZzF5WGoyN2tpbHRrTEhIbG5qOGE2R3luaHR4KzhiQjcxaWVQWW9OVjB0SjdWdjMxdGtrRWNNdmV2RnduSXNRbjBPdW9ueUhtalRFNUpQUFNtUnlaUFdvNXVHeitkQTRUbnZYMVNSeG9iRVFCVnl6dkpiUzVqbmhZcTZISUlyUFQycXpFRG5rMHBDTzExUzlqMVBSL3RNZUFXWDVsL3VudlhLS1FLdVd0eHN0Wm9EbkRqSSt0VUZQemUyYXlTM0JtbmFFYjBiR2NLYXN4UytabUtJYnBEeG4wcktabjh0QkdTQ1RpdXE4TDZPeGZ6cGVEMnJPU1MxWWtjdGYyVTFwTUJNY2tqSXF2dS9XdWg4WXhlWGZvQ1BsckwreVJwWkxPU2NsdWEwaEs4VTJkRktvbzZNcXhxUzRYcG5pcjY2Wkw1VXpUQXBzUW5JNkd0UzFGbzFxYmlWVmFSUU1NUnpWTy8xYmZGSkd2Q2tZRkNiZXhjcTdmdXBIT2s0T1RrVlBGSU4yRHg5YWpaYy9qVERHdzVCeFcrakNMY1dYSld5QnQ0Tlg5UGxKUm9qeUc1ckhFa3FpcHJLNGRaaG5nWnJPVUxvcXJVakpHdmo1Um5zMVBiQmdrNjlNL3JTT09BdzcwckFpS1VBNUJRMXp0bkZMVXA3OXFIMnFPS1FnbjNxTXVjRVo1cHFINWVPOVVvNk15c1dES1dJNS9PbFo4akFQTlJLQmpKb3lldFRZVmh4UE8wZDZseUVYbitkRnNZRXVFRnpuYTNVK2dwbDBOczdLcHlvUEI5UlZwV05JNkVyRFkyTTlSbXJERUcwNTlSMXFzV1Bsb1NlU0tuRGY2SGtqb1J4VXkyR1F6RDl4ajNxcmFuYk9wSjcxWmt5MGJESFE1cXBHMkpBZjlxbkhZRG9ycnkyMGc3czdqOTJxMm5FaTNsMjlnYWRKODFnTURJelJvNmgvTVEveERGWlc5MlFYS2traFlubkpxUEJQYXJDVzdQSnNVWk9jVnNSZUc1MnRHbERxSk1jTFUzNkloWGV4aExDU2NCU1Nhcy8yYmNyQ1pXandBTTROWDlHMDYvaXZQTnVMVnhIeU4yTWl0NjRqQmlaTURrWW9sZE0xalQ3bkg2YmZ4d1hBZDRnMkNPdGFXdmFZa0RMck9sbnl1QXp4am9DZTQrdnBWZXgwYk43STF3cEVTdGtBZnhWdlhQbFNXclcrMzkyVjI0cktyaUkwNTJqOHpXTks2dWNHSERTS3hIZXV1OE8zQlRUeU1uclhJenI1VXBYdXJZTmRCb012N2gxOTYyeFVlYWt5YVdremZNNVkxSFB0bmdraGY3cnFWTlZIdVVqSExWWGJWSXcyTUhQMHJ5VlNsdWpzdXVwZ1gvaHE3alo1SW5TVkJ5T3pIOEt4U3B5UWVNZGE3WTM2dDB5UHBYSlN4RmJpVlg2aGp6NjE3T0dxemttcG5OT01Wc1p5SDNxeWpkS3BLYW1qZkZkelJpbWFrTGNjMVhVbmNSNzBzY2cyMUxaeCtaTUNlbWF4YXNFamEwbXlXVGEwZzZITmRwcG9WTUJSaXVacy93QjJnQXJjMCs0Q0hMVnl6MU03bEh4aHB4dUNqb1FNSGsxZzZwYUxhNmZHSTVBUmdGaDcxMEhpTzU4MkE3VFhKWFVzalc2aCttT3RWVHZaZGlreVJKRC9BR2RLTS93akZab1NTVTljRDNOVzBrUDJDWURyczRySDh4c2ZlTmRNRnVVcFdkMGJGdnBrMDMzR1EvOEFBcWUrbDNNZWNvckRIWTFqQ1dSY0ZaR0I5YzFZajFHNVE4eUVqME5OeGxjdFZwSXNmWnBHNDI4ZE0rbFdJcldCQjB5dzcxUlc2ZmNUdUkzSGtWWVM0ejFBTlJMbUluVWNqUVYyQ2xjNDJrRUgycVFrTWpEMVEveXFuRk41bTVjWXdLdFJuNTE0NjhjMWsweUZzWkFKQnhVaUE0R0tydGNEUEs4OUtjbDN0eGhmMXJaeGR0QldMWkhiRlBWTWZNdzVwc0V5U2pjQnlPb291SmRpOGRUV2R0UnBkU0tjN3BNQTlPS2VqQ1ZRam5CSFFtcTI0a1pQTlBCNTY5YTB0b0psMEFpSUFqbFRVdUNiUW5wZ2lvSVpkOFpSajgyZUt0Si94NlNaNkQvR3M1RkpsY2pFVERQV3FneHY1OWF0WkxLd0hRQ3FtU0hQSEhXbkFFZEZZd1QzMXQ1RUtoM1lqRk0wdEhnMUdTR1FZWkdLa2U0Tld2Qzk0TE84Z2xZakc5ZDNQYlBOU1gvbFIrTXJ2eXNHTjV5Vng3ODFrMW93STc4U1JUN2JXQmlRYy9LdWExdE92Sm50MTg2TjBib1F3eFdqcGVxV2tOKzF2ZHFnNEczUGZpdFBYR3RwYk1OQ2dHT2NnVUtIdTNScEhRcFd1cEdPSm9pQVFmV3FOek1nUEFxbjUyMStEVFpuNzU2aXNaenRFMFMxRWQ4a25OUXM1eHllbE1lVEZRU3pZQnlhNGxCczJPZjFkTmw1SVIzT1JpcnVpbDVKREVoQUxDcXVxL3ZKQStPb3hVbWgzQmd2STJ4ejJ5YTlScHVqYnJZNWRwbldXMmpyd3pqZTN2U1gra082bDRsK2IweFZlRHhVOFYwTGFhMzNFbkFJclpuMUtLTlZNaENidld2RG5IRVFsZG83VktEME1EU0lRdDZVblVBZzlEVUhpdlRvUklzMEFDc0JoaDZpck4rQzkyTHlDUUFBYzROVnJtYUxVclkrVkxpWkI4eXQvRlhaU20rWlRJVlBWcG5ub05QVTRxTUduWnIzMmNKTWp0dTROYlZpTVlOWTF1UG1GYWNVMnpGWlQ3RE9oZ2x3QnpXZ3MrRTY4MXpsdmNuSTVyUVc1SlRGY3Nva011M0RDWk1IcFdYcktMSGF4QkI5YXRReWJsT1RXZHJFNE9JeVIwT0JWVTFxQzNLVUlMUXRHTzZrVlcvcytUSFdyRnEzRldNMXBkb3RLNW12YU9vNUZSQlBtdzNGYkdRUnp6VEdoamZxb3FsTmk1VEtaUUR3YzBxdVY2ZHF1dllvZnVraXFrdHU4WFVaSHJWSnBoWXVXVDdtUCs3V2hHY2xjZXRaRmdjWEJIWXJXa2pmS3BIYnZXVTFaaU1hUVlsY2YzV0lwTzFTM1MvNlJKL3ZHb1FPRFd3aTFaU0JXYlBBeFJMSVpIem5qdFZZSEhOU2crOUpycVBvT0pOUFhrYnZUOWFqUFhQYkZTWUlSUmpyVXZRQ1NOOGdFY2tWcVdyaWVGNGtHSFlZeFdRdzhzNUI0cWUzbWFLUlhCNzFFbGNSMFZ4WVJXMmxCVkEzNHl6ZXRjd3h3NXJiMURVdDhFYXEzM2h6V0V4RzRHcHBwMjFLUnM2WS93QzdQME5PZ3VtZlV2TllrdnVYUDhxZzB0d0RRcEMzamZRNHFMYXNEZXZGaC90YUM0bllKSDVmcmptdFZkYXQzaEJMZko5MEQxcm5kZjhBM3RqYlNxZW5YOHF3V3VwTnFBTmxVUEp6V2FnNWFwbWtaYUhWWGptS1lrWTJubWtNdTVBYzlhNWk0MW01dUgyUWpyeG5HVFYyMGptanpMY3lscENPQm5oUlVWS1R0ZVQxTkl5MTBOR1NiQUp6VkdlYmNkb1BXaWFiajZWUzNzMGhJL2hvcHdSYlpOZk1ySWdIOEl4VmEwY1J6S2VoQnFPV1FrNE5SQjhITmRVVm9ZTmFuZDZmWTJFaFNhNHVvMFljNHhVUGlxZXh1b1VndDVpNVQrSURBcmt2dDhwQVV5SEE3VU5kazk2emNYMExTVDFaY2E3TWRzSUZQeWpyNzFRa3V0alpqSlUxRzgyN3ZVRGtNTWswNFFYVTB2Mk1tbmptbVU5ZXRlZ3prSm8yMjFZU1htcW02bksrS2hvWnFRUzgxcTJ6aGdNMXo4TXZQV3RleWt5ZXRZVFFpK3haTWtjQ3NMVlpTOXd2emRCV3hjWEtySGdIbXNHN083RGU5S210YmlSTFp5WnhtcmU2czYyT0d4VndOVnlXcFNKdzFMdTVxRU42VW9hcEdUYnVham5jQ01tamRWVzhrd3ZXaExVR1EyYmszbWM0RmFTTU5uSnh6aXNxejRsM1ZwS1FWUFE4MVUxcVNWYnRmOUpreDNOVm1PRFZ5NXdabUo3NC9sVlIrTTRxbzdDR2JqbW43aUJ4VWVEMUo2MDdtcVlFZ1lrVmFqa01pamNCOHZGVmw1T01WTVAzWXgzTlp5c0JQR3ZtN2dmU28rWTIybm1wNFhXTzNiKzk5NDFTalpwSkN1Y2xqU2lnTGk0a1VBamxPZ3F0STRNaDdjOUtla2pSdDdpbVhBeTI0Y0JxRm93TCttc040K2JtcEhZTGVyanB1d2FxV0hFbldwYnAyRSs0akF6a0VWRFdvelJ2WjBmUmxpTFpmZmdEUE9Ld21pM2pCZkFIOElxeXpiNUc1eUEzR2FHS29DeG9qN3V3SWh0OFJ6S3Fqb2VjVnF2THgxcklTUXBJSDQ2MWFhVUg1bE9SV2RTTjVYTkl5SHlTWkZSeE5oVzQ1SnFKNU9PdE5qZjVEaWpsMEhjU1p1ZlNxN01ha2tiY005eFVETlcwVVN3TG1qemFpWTFHV3JUbEJNbE1uUFdndnVSaDdWQVdwUzJJenp5YXJsSzVpdlNnMGxGYW1RL05BTk5vQnBBV0kyNXEvRGM3RjROWmF0aXBWa05aeWpjWmZsdUMvZW9XTzZNaW9QTTk2ZUcrWDhLVnJBT2hKQnEwSDk2b3hubXJBYWswQ0o5M1NuYnVhZ0RVb2FwYUdUN3FvM2NtNXNWWVovbEpxZzdicEt1SzFFeXhBZG96VjVXeUQ5YXo4NEFGVzBiazU3MHBDRmtBYVlCbTJnanJqcFZlVmNQdERBais4S2RjdHlEMnhVRy81ZnBRbG9JZTJPTnZURk56K2RKdjROQkdlZTlVQllpeGpjYVhmdWZBcUZXNHhTc1NyQnYxRlRiVUN6SzVFSndhWlkvOGZTSDBwSFBtUU13N2V0SmF0dG5RMFBZWll1Z0JNM3JubW1BaVJDcDdVMjdZck9Uamd0bWtXVUl3STZHcFMwRVRXckJaQUNlYWZjdHVrYnNQclVDdXZtZzk2ZGNOaCtmVGlsYlVaS2pmTVNQUVZDenM3RW1samZray93QnlxY2x3V0p4d0tGSFVDVm5DZzVOT2p1QnN4bmdWUkxIMW9RL01NOUt0d1RRRjVtSFh0U0pMaHNVcktKSXQ2RG9PUlZZUGcxQ2lVV0dZTmtqOGFyT2ZtTlBIR1dCNjlxaWtQelZVVnFER2swd21sSnBoTmFvUUUwaE5CcHRVQWxGRkZNUVV0SlJRQTdOT0JwbEtLUURzMUtHNHFCYWxIU2t3SEszTlNocXJyMXFVVkxBbERVNE5VUGFuQ3BZeDByNFdxeWN2VWsxUkpWcllST2MxWVIrZndxcXRTcDIrbFF3RnVHeUZxQW5pcEp1MVJucFZSMkFjeEdBUGFrQkZNN1VHZ1JJQ1IxNjFMSElVUHFPNHFIK0VVSDd0SUM0REcwVGJEMUZSUkhESVJUYmNuYS9OU1E4cVByVXZRWXQ3SUd3TzRPZjBxTFB5REo1b3VQOEFYZmhUT3dwcllDVU55RG1uVE9kNm1vRjdWSko5MWFWdFFIeHY3L3cxVTcxUEgvUTFYUDNxcEFLUnoxcER3S1Z1bE1OTUNVVGxSakpGRGZOeURVQnFST2dvYXNOUG9PREZldE1kZ2NHcEpQOEFWbW9UOTBVSUdKbWtORklhb1FsRkZJYVlILy9aXCIsIFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvL2dBK1ExSkZRVlJQVWpvZ1oyUXRhbkJsWnlCMk1TNHdJQ2gxYzJsdVp5QkpTa2NnU2xCRlJ5QjJOaklwTENCa1pXWmhkV3gwSUhGMVlXeHBkSGtLLzlzQVF3QUlCZ1lIQmdVSUJ3Y0hDUWtJQ2d3VURRd0xDd3daRWhNUEZCMGFIeDRkR2h3Y0lDUXVKeUFpTENNY0hDZzNLU3d3TVRRME5COG5PVDA0TWp3dU16UXkvOXNBUXdFSkNRa01Dd3dZRFEwWU1pRWNJVEl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeS84QUFFUWdCbWdGQUF3RWlBQUlSQVFNUkFmL0VBQjhBQUFFRkFRRUJBUUVCQUFBQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVFBQUlCQXdNQ0JBTUZCUVFFQUFBQmZRRUNBd0FFRVFVU0lURkJCaE5SWVFjaWNSUXlnWkdoQ0NOQ3NjRVZVdEh3SkROaWNvSUpDaFlYR0JrYUpTWW5LQ2txTkRVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmc0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaDR1UGs1ZWJuNk9ucThmTHo5UFgyOS9qNSt2L0VBQjhCQUFNQkFRRUJBUUVCQVFFQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVJBQUlCQWdRRUF3UUhCUVFFQUFFQ2R3QUJBZ01SQkFVaE1RWVNRVkVIWVhFVElqS0JDQlJDa2FHeHdRa2pNMUx3RldKeTBRb1dKRFRoSmZFWEdCa2FKaWNvS1NvMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvS0RoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1TGo1T1htNStqcDZ2THo5UFgyOS9qNSt2L2FBQXdEQVFBQ0VRTVJBRDhBOCtXM2FLUm8yVGZCdHlwZm5QYi9BT3QrTk1qUXZlZVY1RzJPM1VNd0I0eHhrNSt2ODZrdmpOWlhTeG02SlR5MlVuWjF6L1BuYlJCaVIzUldMYjlyUy9Oakk2a2Y1N1ZuR25hdjdOclMvd0J4cGRPSE1qY2xjdkF5eHZ1TEJTR1BZdGtESS9wV1JOY1IvWUd0WkR1RHVnMjRPU2NqK244cXNRM3E0bFFzVmplVU1XSFZWWHVlMzAvR3M3WHJzUjNOdEpDeVJsRlRBUFJlRDErdUIrWXIwTVhWaFVoenhXcTAvQXhweGNYYm9aY3NpeWVKWnl2ekxqQVlnTGtqQXpqOGF0NmZhWE4vZXkzTTM3bUdaaXJ6WUFHekk0SHAxNitsWk5pVE5xUzlTY2JuYjhSMEZkT3RodUVFTWQxRnZNZ3dnZmtLTWZNVDBBemdZeDllQlhQZ2x6Vm5KN0ZWZEkyTlMxdmJKNzJZV2tZTVVaQ3hLakZBUjN4N1p4Ny9BSjFyUUNaMEJuYU1SRW5FY1lPVlB1Y2RQcFZhRzVpbHNSREZPaWVVQndyQU9DTWNCbEhIMTk2MW9kN3F1K05VNUd5VHpQdmo2Z2RhK3NwVWxHMTkrNTVOU3BmUXk3bjdDMDBVY1N1R1p5WFVFbFhDakp4ajhzOGRhZ0NvYmlXYUpZN09CMTJuYUJrRWRRUngySFUvaFYyNHNaNTlZU0dFbGJpSUJqSTdia0JPU1Z3UjF3RittUlQ1OUpnbGxrdTd1U1dVZVdYRUtuWmhsQU9PTWM4NHBWTE84bDMvQUNDT21oakhVakZlSUo3eUsrdEFQdTV4bGgwK1h2Z25ybitWUHN0UmdtMXFHZVZJekZjSXNiRk1raGw1QklIY2pqSTlCM3JTdGZJZUUvWXZrQzRrbExqSE9PU0QxQTVQK1JTYTlwa2Q3cEg5cFFPSXJpTUY0cEk4S1BsSjVQdDB4NmNWbFVVdVhtVzYxL3I1RkpxL0srcGIweUpMcXh1Q3lHRmJUOXd3SFRLQTVJeDlRYzk4Q3VJUW1mVnBpMDI0ck92bVNBYmdvQTVKUGZrc1B3UDQzN0RVN2pVTklYUmJRU25VTlRtTThranJ0U0pDY09SanQ4dVB4TldkVXM1Tk5paXRyY3BGQkM1alNSVkJkMjZuOE1FRGtucFdGTzlmbGt0by9yL3dEVDRHMCtwcjM4UDlxMlRMQ1k3dkQ3VkxBN1FjWitVRDZEUHQ2MXo1c3JlR01FTzBqc1dEb3FsQ29CT0JnWlBHRFhRVzAvMkY0N08zazh1Sm0zaVJ6d2NaSkxkem5wK1ZZdHdZZjdTam1NQ3ppNEhtT0ZPMlJkeDk4ZGoraDZWMFZISFJ1eEZMUzZXeFZzN2RJVkZ4RmFUU1NqTE9TdkNnZW5VOGRhMUwwcWJKSm9lRVp0cXErQ1hma2c0N0QzN0gxcFpkT3VJWmtaNG1nTTQySWlPU1FNK29QSk9mVHQrZEg3TW1rNmhGTGZGR2dBTGVZMGhDN3NqY01ldU4zYk9md3JCcjJGM0ZhYWZMek5PYjJtKzVaR2ppSFdrZ2x0QTVNWG5QSHVCVlJ1d01udjBiNjhWcXJvbG45Z1ovc1NvU1NxbEYyazhubnIwNmNlM05WdFBlRjlSaHVZc3hTVEo4cXNHWUtnWWtFbjF3ZW52WFhZWVdiU1RtTllFeVNvQndjZC9YL3dEVldtSDVKSnpTM1psVmxPTFVibk5Mby8yKzFsVzVlYTNnalVFSHpzc3hQNDR4NkFjVndIaVcydDdWN05WaFZWWGd1clpMRGo3d3p3ZjhhN3ZVSTdXNnZHdDdWL0xUQ3F6bGp6MjVKcm5QRmVsMjhPaUM0aWNPcXlqbkhYa2cvcmpIMXJtekNrcDBwU2piUTN3OCtXU1V1cHgxdGRQYUxlUXhneWlXTm8vdjRBVTRPZmZvT0swUERVNHR4YzVnYVFzQUFWVUVyOU0vaDBxanFrQmg4aTRRS3F5SnRZS1Ixd001SGJxSzFmRGtpV2xqUEt3M0hjTndBN2U1N0QvR3ZuMDdOWGRqME4yYlZ0SWw2eUlzb2JhZDdjZEIyejYvL1hyZnM3MWJPTnlicU5kM3kvTmpBNTYvaGpvT2U5Y2ZMY3crY2tydmlWam5QS3N2L3dCYkhGV0kyblpVbUNmYXBGWExLQ0dLQTlNanQxRmI0UEVPaTNLS3UzL1d4TmFtcWxrelduMWlXMmR2c3JPOGpsaHVZa0FLRHd3NzVxaGZYYjNzVVVFVEtUdkdJZ05rY2FqcVB5QTVxckFHdkQ1elNwR1hZZk8zYmo3b0hIOUJTckJLOXdiY09BeUEvTTJNQWR6eG50Uk90Vm11YS91dHBXQ05PRVg1b3RhWDVsMURHQ2hhMGcrWW9vQUpKeWM4L2xtdWh0WWRGYWFPV1F2RVFlcFJBZzlNamJnbnIrVllNRURSUm1JM0lYQjJFcXpZSkgvNnZUOEsxWXRKak0xdmNHNEhseVpEQ1JzRUg4ZVJqaXZWd2E1SUtLdGZyZC8xc2N0ZDNkemFuczF1WUlZN0IxZHNrYllrMmdZeU1EQndUWEE2bmNScHJkd214eWQ0SmRrdys0Z2RzKzllbzJ0dEZEUEliUzZEb0dYNUJnS0NjZk1Uenh4ejAvblhsL2lHZDM4YWFoTVZHNVpkcWxNN2Zsd29QUDBxTTQ1WFJYcVJncFBuYVBRUER2aGRWdURkWHdLenFka1N4T2N4OXlkM1VuSkl5UDhBNjliMFllR1R5a0tsRUIybmdCQjY1NmUxWlJ1RGFTUVEyOHozTWNhL3ZHQUpMdTNWY2pBOVNTZW1hc1hNY2x4TXpYdHhHc0RiUUxXTUU3ejBHNW1QYjZBYzE2RUZ5eHNqbG0zSjNaajY0c2R4Y0kzbHlHT0Z0emtEajVlVDA1SjVQQnhqcjNGUk5xTWRxMFV3V2J5VncwYitXQU00Ni9OMTY5dnpyVnZJN2NxOXZlZVhIQ3JBTWtiYlNPbkpJL0FZOWMxbm5STFJKNW9yZTVjV3lzRkxCZHdWZU8rTW4wR2ZyV2tydlJNSXRXMUl0UXZKSko0WklZeTRuUUE1NFlGdjR1TSt3OWExTFZMeTJpZFpTMGNVUUhtTnlBNFBVa1lIWWRhdjJOam9TSHlFK1JWWGhuUEpQYzVJNUlJSFRwa1U2UzNXYTJrdTF1WGtFYk10eURuREFkUmoxSDN2eTlhaE5SYnVOdTZTUXNVbGt0eEk4azI5MFFSaUoyNEJ4bm5KOVNSK0ZGN3FMV0dsS2tjNE16Tjg3eHJ1MkFucjdjY0N1V2l1SXkwc0VkdXM4MGx4dTgxMitTTU5qYVRqbkg2OG1wZEZrdlcxQzR1R1F6elJzc2ZtS2g4cVByMS91am4wUGVrMkhKMU9SOFMyOGlXOWxkMnMvblJFTW9DdG5JKzluanFPYW1zZGsxb2JsNVYrUlN3ampZRTR5UmtmVEFxaGVMSWRaTVorU09TRnBHaFlZNUtrRWNjWk9EZys0cURUcG9vRDhoeU40RXV3Y3NtUVNPZjkydm04UlZYdDNLVWJYZjVmMWM5V2xGOGlTZXBkdTdSN1FLL2tKTGxpNVJTUXE0NWNIMjVGWldvenh5d3JKYzVkNTBCVHIrNnh3RjY0UEdPZnBXcnJUL2FMMkZiV1F2SFB1UkkyT01qKzluOGhqMnJudFZSclM3aWd4dGtYRE42RnZYOHF4cTFPYjNZN0Z4amJWbGVBdmJhaEFzUHl5cjhwUGNrLy9yRmVtYVZvK25lYkZjM3JSVGwxejVlQVZqSUFHMCt2WDZaL0N2UDVMRmhyVmhtUm5hNEFtWml1T3JOeVB5elhwUTBpUGZCTmFTV2NseThaRENWWEpJSUE3c2Vmd3IxTXFnMVVrM3VyZmpjNWNWTzBVdlUyZEx1TENTV2VDMWlqamVJS1gyS0FEa2RqM3gzcVBVcFJiUTdVQWs4MHJHa2UzTzVqa2dIMkFVayt3TlprZ3ZyUzBtWkxRU0NISVh5NWVkdVFXSnowL0kweGdOVDFRaUoyK3pXc0FJM3B1VXlIZzVIcUFCK2RlN09UMlQzNi93QmVSNTZpbTdzdXBHMXJCZFBHd2xLSHpISjRaemdra04rSFRrZHE1blVieVM3MVlXb3RwR0RTQXpJTU1jRWJ3b0o2NUFHZnlOYjJvWDZGYlN4aENqVUxpSWJSamNxTC9lYkhiQVBIZXN5Q0U2ZFpYTG1GelBGSnZrdWNiUE4rY0FBWjY4WTRBeHlLNWF0UzdVVjhLMytYUTJweHRxOXpSaDhOeFNXcnRkVHZCYk1kNWdnYjdxWTZFOU9QWVZjdFk0N1R3MDJwM2p5T1lZVHRTVGtLRk9BTWVwSUg5S2dpMCs0djVXbXY3MFdjRHVHRnM0M091UDRkNzlQWEFYdmpwV1I0a3VvRWp0dEV0bVpJSjU0Mm1rTEZ6NVpiSkl5T1JrZzhlbUttdlc1S2JrMWJ0NjlDWVE1cEtOemU4QytIazB2U3Z0Y2k1dXJyNWlUenNYcUZIODZrMTZ6alRVWVpYOHVHRlJnT28vaUp5UXdIVE9PdnNPbExiYXRpNWpzbWY3TkdRd2pqNkVMdndBMlI4cll6eGc5TzFTckFkVGxsZXpZQ0JkeGt2RkJKbEk0S3g3aVIyKytjZ2RCbkhCUmFwVTFHUFFVK2FVM0puTWF6Y0JMSjdTT0NON3hpU3hKSk1ZeU1qT09TY2pqazg5QjFySnNCUEhmbWVTM3hHeWtTY2d0am9BQm5qb2ZmUHZYYlE2YlphRkhKSHBGbWx5Wm93Nm8yVEtvT0RqSkJ5dnNjZlUxVGxkaGIrZGRhVGR3eUFrSzRaSkNDZU1ZVWtuR1BUMTZWZkx6UzU1Ny9BSURVckpxS01xT0dlS05iK2U5bG1oUndSSXp2dndTTUtvTEE0eG5wejByTTFWNUxqVHJtUjVaU3FjNGVRNE9jZ0VLY252Njk2SmRWajg5bXMxRW8zamMwd0xkQ2UzWDhLamRZVnRaQ3N4Y1NxZXZBSEhTdWVyaUtkV0VsRG9tYndveWpKT1IwRnZEcHR2WldzOHltM3VualQ5NlF6Sys1ZUFSbnY2ODl1MVoxN3Jwa2Q0MW5rbWlLa2J5U0ZBNTZMK1ZaSzNkemNRS3Nzb2tUWWNJQ2VNREh2MkEveUtZck1xS2dpYmFHK1VqalBUcG11U1dNbDdLTVlxMmk4LzhBaGphTkJjemxMVXRJdlZnWDh2WWNNNFpBRGp2V2ZxanJKcFVrYlRTR01rRUFLTURuK1hUL0FDYXN6emVZbzN3cmpHY1pia1p3QjBJN2p2VUdwWGNjMmxQYnFnajJEOTM1WUJYT2VlUWV0VE50d2xkMlZtYWRWMU1tYUdhZlJyVlh1RndIWlZqQ0RPUDd4UFUrbFZiU2VLMmtNVTZZd2VjREpVZzlxdDJhUFA1RUpCRDcvbEpPQVNjWXFUeE5aeTJtcUo1MFlSbWpVNEJCQnh4a2UyQU91SzhybGNvdDlyR3IwYU5SSTJNYVNUUU81bUc0bGx5TWRWSDlmclZ1d3Q0aGJ5TEJidzVaUUpubFVmSmp1b3gxUFA4QW5ySHB5UHFDV052Rk0rWnQwc200Y1JoY2dEUFU5ejI2MHp5UEpsUXlvdVZHNEZsenV6MC9YK2xkRUZaODhYcGI5TlNiM1ZudVhiZ1dLMlptaEFoMzg1aWt6dEdjRlNnNkFnZDZ6TFZRNitZei9ad1FRR0tNTjNzQ0J6MjRwYnUrWjkwVWo1YjdvUWZ4ZCtmNlZzYkpMTzRqaGxqUzNqRWE4cXdjWXp6a0hBei9BSjk2NnFkTlZxaWR0RXZ4Wm5LWEpIZmNwMlVZZVhhN09wSkpLaGNrOCs1SDZjMXBmMlZlMnNYbjNFUG1SRmQrVklYNmdaSnlRS3o3R2VFU3BkSXBjaG1LRm95Y3FTZW81NS9FMTA1MXlGclE2ZkZiczBiNWNyZFNBRDE5K2M4NU9Pd3J1d3RLbnl0ZGYwOHpDdE9ha3JGdlFibEk3ZDVJN1FLOGg4d2htUUVIb1FNbkpIT0s4NzFxVUh4RmNRZWEzbFJ6RW5jTUVFZ1p6Zy81R0s3YXp1RnU3cWFGVEZHaEh6S1BuTEhxY0gxK3RlZjZ6Q3A4Wlg4SU9VTXhHRk9mVGpQVDIvQ3NzMnQ3RmE5ZjBGaEwrMGR6MVBUdFVpdUxOamEyNEJLcXBDZ3VMYUxIWDArWWpPZU0vTG5wVjNTN2VSN3FSb1NXdHQyR0xNR1pqZzhuT2MxV3NkVWpzZE50b1V0b3c3eGZPKzRLdUFPRGdEOGhUN1M3ajB4bHQzU0p2M1lLdHR5Qnp5bzl4ODNOZWpTMGhmdWprbXZlMEpkUTBUTzYvdFZhWkdCYVZaSHlYUWprZ2VvL3h4Vit5RUZocFNYRTkwcnZKQ3JPeGJxeHgwL2w2NHJtTC9YTG56WTVMTnpFaFBsaU0vTUFNOEVISXh5ZWZZZTNOSFU5VmUzMEFRM0QyMHNrYmlIOXhPR2JqSElHQjFBSGM1ejBxSlRzOVdXb05xeDNGaGYyc051Sk5nU0lBa1I1d3pzY0VIK25Qb0s1N1ZkY3V0UXViU1N4czFlT1RNVTZnN1VKSUtqREg3MkJ1QllBakhyWEl3dmNYY2l4M2s1amk0YjdQbmM4dnV3QVBHZTNTcjk0dDNkVGo3SEdzRUZzeXNoWXNQTDZZQXlCOWVtT2ZTbGZtVGtpbFQ1WFptLzRZc2JGTlF1SUpwbFp1Rmlpamp4R3lqUE9QYkhKYkpQV3U0dHJSYmFlRll6dVNTTnZNYis4ZU1IOVRYRWFibzl6cm8ydmV5UTNTU0V2TkZzUlFSajVCdFhKYkh2eDM5RDByZUdMbWU5TFQzZDFMYWdjUnZleXFTZW5WVHgwejA3MU0zYlMrZ21ydTU1TVFrbXNwY1BKR2pmWitHVURHZHg1SVA1ZmpXVFl4UXBPL21GUU1kUjB5Um5KL3dEcjFvUlhaaTFHUnlnYnpyWm8wVmlVNDQvQThjWXJIanVaWkxpNWVPM0JMcUl6akJ3Rk9SMjlBUHlyNWFwVTlwcysvd0NoNjhWeTlEWHRIbWVTNDFPUjRVMkRiSHZYc01ic2M5ZjUxaHMzOXJhN0U0WTdBd1ZSSjNPZVI3Y2tubXQyM3ZEL0FHVTB5U0NTRzNqTWcrVUE3eWVDUWVweURWZndvaU1yU0NQemJtYVRMU0U5QU03dnpEREo5cXpqTFg4QzJobXFXclErSzdMWWpPSm93eUtXd1dHV1VIUGJwWHJscmFSZVFzYzRFdkFZTko4M1VmNS9TdkxOUWxNbmpmVHk3N3dGUlMyZTJXL3hydDR0VGFBckVjc2dLNStYbklBSXdQd3grdGU5bDlTS3IxRmZlMzZublltRW5DUGxjMEd0SVlsYUMzZ1V4L01HVCsrd2JoUm50Z2srbkhzYXkxbE1FOHFQSURLU2tteEJqYWpSdHlmUUFvUVQyL1N0cEo0NFF6U2pGeE5LdzJodW1HT0V6K0lQSHJYT2ZZbDhUNmo1VnU0YTNqdDR4ZjNNcUVzSkF6RXdnQWpCNTV4MEgxcjBLODVlNmx1emxwUld0ekVzUnFWM203dEltWnJ1YnpURzZreE11UUZ6ajVzQWNjWTR6eWNrVmExTzNudWRXczNtdnJsbmtMU1RlWSt4VWtUSEFVQUZUeXZ2eDFOZFpQcDk3bzBHTEdHR2FQYVVXSkhLT21Ud0FNSGNBZmZQMXJqOVkxbGJqVXJXWWhvMmVSa1pHWWJrVWprWkhPTWdIR08xWVZIUnAwMUNXK241bTBPYWN1WkxRa1RXYm5UZDh6U1Jzc2FiV2M0RHNtTWpxT1Rub2V0WVF1THR0VE9yYWdGTjFNVDVVU2tsbDlNRHNmVHYxSjlhZHFjdW5uVWJhM1M1RVVhTDV0d1pGSkNuUHlESFVua0g4YXZXVUlOeGQzc25tTEtwVkVhN1FEQXpnc0ZISUo1T01EQXgxcmdmUFVxOHJsZU1UcFNqRlhTMVl4Zk51UXNsNDRpZDVTOHF4THpJTTlYWW5HZW5BQUhIV3VvaTFHMnNyS1dDTzZaV2p0d3FCV09lQXdJejdsc2puaXNUVXAwVzZSRm1SaDVlWkV6MDZEQVA1LzV4VUR5Unl3cTZQdHg4bzVQellKNmNlNC9PaFlqMmM1TDhSdWtweFIzdWp5cklubjJ5UW1SSXRpRHpEN1pERDFHQWMrK0s0clVMMjRqdkpGbVoxY1NFbmFUd2Z6NmQrZ3F6b2x2ZHRjS0xRdVl2bVpua1A3dlBVNDc5aHg5S3ovRWQycmFxeFdEYUNnVUZ3UVh4M0FHY0RHQms5YTc1MXVmRHFlejBPYU5OUnJOYm96cm5EVG1kQUdsVmdTaThodS9OTmxtaXlnWnNCbEoyZ2c1NC93QS9yVUxYSG0zSWlqSUVoTzVpemJSMDU2aW9wYk9henN5OXdxanpZOTF1QWNoODlSeDB4Ny9oWGpWSnpxTnU5bC9rZDBVbzJSYXQ1by9KZ2pTTGxWd0R1d0NjNXovazFvUTNWaUxlWkxpK0VzMndlUkhiZ091Y1pPY0E5T1AxckYyQUViMFZ5cWpCNmR1blBOVzdDT1dNdkxKR1d3eFlOSGo1VHgySkIvOEExMDhKaUpLMFdGV0YxZEY0UzJkcmFKbTJubFptNUhuQnR2SjdLY2pyMHh6ajJxbmRLcjI5MFlyR1FQSEdRVFBKZ3F2T09DUms5ZVAwcmYwN1hMSnJXVkw3VEdsa1pnVm1hTE81c2pPY1p6aitYMXFDOXZkTHZZcGx0c3l0S0NRSTRDd2o3Y25qUHFNNDZlMWVwVWtwMGxIbTZiV09PTGFuZG80WlM2bU5rY0JnZmxHVHdmWWRxdDY1cHQ5WnoyODE5TXM1dVl2TXlDY2pKUEIvTHQ2MVV0M1l5WkVTaHM0d3g0QnEvcTJvWE43TkE5MzVyU0t2TFlHMGpQUURIQXJ3cWR2WnpUMzBPNlNmTXV4cStHclhTYml4bHVOU3VaWTRvQUFSRklWSTZrY0FmTm45TWRQUmx6cFUxdkRETkpkU0l6QWJZeVN4Q25PY3VCd2VneCtXYXpMYTV6RExIRGtHUVlBSDQ5ZjFweG12Sk5rQmxYeTNKeEgxMlovQ3RJMXFmc3VWdzFYNTNKNUpjMTc2RXpNb2xqQ3VERkYxQUFHNXVuVURMZlUrdFc1cnk1blNWQ3dDeURhd1BvYzhmaFZmekV0cmd3eVJ4eUs0TzE5MkFPMmVmNit0Tm1rRWtoTWFnaU9QZGd1dVFTZnIvbk5UQ28xcStwYmlqU0Y0ME1NZHRLN3h6UnlISkw0SFlqSXhrOWpTeVhjMTNCR3FIZXpQbGM5TWUzWEhVMWcrYUhKVTdPVGs3VGpKN0dyTWMvbE1xeEVxY1lKeU1ZTmRFY1ZOUGV5L1FqMmE3R3JGTkpCTkpNQ3dWWDZSZ2dNaDdaNmRLNStkRlBpR1lGUXBhUU50NUE1d1QvT3RYN1RJeW9ydnlPZVY5cXdKYmdpL1ozemxXNUk2bXM4UldWU0ZvZ28yZHowaTZrZ2hOc2hua1ZkaGVTUFBLOWNET2VmdTQ0ckxtdXBaTnlLa3JrZk1RaThxQ1NQbVBRSDJKcWpMcTl6ZVhrV29YaXFrY2NHTFdJazdwbUdBQndDZlQwSHVLY3phamMzY1U2UVdsdU1qL1I5elJ1QUJ4MjR6bnR6eDJyMkZXVTR2bFQvcXh5cUxXNUl0MUFiUjQwdW5pbFJzc0pqaFkwd1J6L3RFbjdvSDVWUHB0dmJ4V0F0cElZQmMzZHlObDVkN2taWTBHY0RLL0xrcjI2ZzgxcDZEYTJWaGEvYXJpT0dlVVB0aUVrZjNUd2ZsSFRxT1NPVGs4NHJSMXJVMHU0dE10WVFKTGhvbU1xb3VXd3NibzJjSEE1WUR2NisxVlRob3BUK1hrWnpuclpHZmMzejJra2dzUnAwakI5eXZiYlZVbkhKMjlUamtjajZWZDA2N2prUXNESmN1NVJrVjFKOU1BS29JSi84QXJDcjlwNE90TlR0aEpIQmMzQkF3Z21jckdoSFZlVG5ybmtMenowRmF6ZURMVklJcmVPZVcybGI1V2EyZkJ4akI1T2UrT21PdGRLbHJxWlBsYTBNeTJ1RTB5RXpNN1FrdXFCQXYzTThuYUJuOHgvU3UzMC9XTFM3MDVMa1hDRUJjdVQ4dVBybXVCMUh3NDloZFBjRytCZzg5WXk4eTRHT3d5RDB4OU0xb0R3NWYzT215TzByTkNBVDVVZnlxbU9jNTZ0OUtWUktkbTlDVXJIa04vQ2swZ0VlOUdCSjJBa3FpNDZaOWUxV0xNd3gzTjhicVVjV3dZZktDSE9CakdlaDZEOCthSW9aQk5LbDA1TWhoTENObXdTZW5INkhIb0RWT3pzN3U0bXVaMWdNOXBic0N5bHVNQThBanVCelh5bEs2bnNleEszS0Yvd0Q2TlpmWmNUb3NveEgwR1RnRWcrMlNEM3JUMFcyUzFzV2o4Mzk3STRWMUhBQUlCSit2YXNQVnRVT3E2bEdWait6cXNwWVk2cmtqQXo3WUZkQmJ4eVF2SWpOTEp0WHpYampUTE9NQTVMTmdLT25HYzlLSVU3elVmbVBtMGJNblc1NUxQeEJCS0VWZkxWV0FYcHRCUEg5Szd1eGU0Z0orendDYTZrR0I4MkZUQXlTMy9BUTNvYTg2dkxsdFkxbUllV0kwSldHTkNRTnE1Ny9tYTlDdGRQdTdaR0x6d2xpTVc4RnNUbFFCamU1SEFBVUU0Nzd1cDZWNkdFVjZyY1RucXRLRm1TWE45ZGFicGozOGhCS3E1Unp5NGNyZ0hHT0J2Nms5ZVB4M2RHdWJiUy9ENjJOc2dhNElmRzQ4eVBqTHUzdDZuNkRyaXVNMUhaRnB0MWF6N2dmSUtJOFp5TTdjak9PQ2M0L1BOYWVrM01pdzJZdnBmTW1WVURsUG5aaTJTRXdPM0o2OXlhOUZUdFdVSDIrN3Vjemh6UXVXZForMjVodkpianpuZU1PdzhzckVoNTVBenl1ZlVuclhLK0pqSEZIWnhXb1UzY3g4eVBhdU1MdElKUDRuajZHdlI5VDFhSFN2RGJQY3crWXR0QXBYSTR5d0cwZE9EbkEvL1hYSWFPYkM5dDdyWHRhdUlJcnk5eS9sYkdCaWpCd3V3THkyY2RoM3ljMVdJY1pwVWxvM3Y2RTBYeSs5MFEzdzFvRnRwOFRTWDhFYzE3TTJmTWtPV0FQWGFEM0J4K3ZwVXN0dlBCY3oyb3R2TldWaTdaeGwxWWs1VWdZNDZmVWNWREhOZGkvRThHblRlUXlmdXhJaGozb01rNTdIcjBIcDM2VmNOekxkMmU3WmN3WEVXNHFIamRpN25QQ0FLQU9PQVA4QUNvcHh2U3RGV3RjdVR0SzdlNWpYQzI4Y3M4a1QrYWdaWTkwYTVKQkc3R09tZWNmZ2ZhbjZSR0x3d0pOS29RU3QrNlFBa0xna242OXZ4cXJZT2IyemVBSUk0STUybFoyalBRT2NSajBCM0UrdkZhZHN0dTNpTEEyU3A1eUFCaWZMYlBMTVRrWTRBOWZUaXZPbFM5Nk11alowcWVqTkMxa1dDL3RJVEt0ckZIQ1daWEtzeWo1dU1IamVjL2theEpqTmZheGR6eDcyaTh3b3J5cUFBZ0F4bnRuZy9sOWExSjlRdDRiU2FhR0dPVE14S1RzZjNtTW5rZzg1T2UzR2ZwV2JiSk5FalhKbWtWWkF6TUY3NEJPU2U1NTYxdTV4VVZGYmIyL0ltTUhkeWUreFZ1MFMwdTl1MFlWU0FXKzh4T09LemRUZ2todHVJakh0VVNMbmpnbkFQdm5KcldBRFBKTkpJeXpoV1pRU0crYkJ3RDZuakZSYTBFajBHY3BJUTc3V2ZuZHVPVnprOWZ3NSs2SzQ3UW1welpzK1pXUkFKVmtLVHhwempjV1lieitYVElvUzR1U0RHSWxkWGN0dUoyNS8rdG1sU1FpQkJIOHV5SUsyQU05dTFTd3FERVFqc1R5R0xEbkhOY3NwTys1cWtyQUVaVkN5c0FNOWgwK3BQVHZRWjROdUJDVWw2bDBJQjJuMXlPVDI1b2RWbmRXQmJ5bHdTeFBlaGJtT0p3d3dRaHlFQTRQYm10b1Zwclc1TGl1eGd5aG81WmJkYzhIa2JjRUVIcitkYUY1Ynl0Wld0eEpjbWFlZUo4S2YrV1lYZ0RBSEZWTGhrT3J6YmlBa21DSEl3Y2tlL3ZXdnJqSkRwdGlpZVdZNDAzR1ZHRE16TW95R0FBNEJISDQrMVRDSE5DbzEwdCtZcFNzMGpGMGllS0c2OHlhTm1qVGtxT3BOZEhZYUMwMW04MXpwbDlJMHlBZ1JRa2xWUElQVFBRWjQ2MXkya3VzczVqSUdHSGRzVjZmb090SXQxdm5oVmRueVRNc2d6anFNQSt3QXlEMzRyZkJ3aEtUNTNhMnhsV2NrcnhSeUMyTmxsZHU2U05Wd3lvZm5qQjlRUndha2JTYlNTRGJZenR5NEpqbWY1U3VjRmxQQnpnamoyNHJ2L0V1cjZOZUxhMjdXOE1WdW9rODZjbFc4dEdHRndVUEpMRHAvcytsWkdrU3p5M0VOMXB1bFJSYlZaWUxtOWtFY2NSQUE2Sjh6Z2pHQVFCOHg3YzF1Nks1bWxyOGlQYSs3ZTFqaW8yWWlOSGhFMXRISzhaTERDS3c0SjdNTTRCK1lZSHRWa1FXOTNKSTlwQTRpaEJhZmE2S0ZBUFZTVGduNlYyY2ZneTNuOFZIKzJiaWViKzBiZVc2bDJLWWlzcUZkeUJGSjdNTVp6d000NXJkdi9oemMyc1ZwSmFIN2Rad29EL1psMEV5alkvaGtZRWRleEdPdk5OVUU5SlBRVHJKYmJubWx1K2tDTkZ1MnVIa2tJM2tBcXlyMUczbkJ5ZU9jMXljb01sN0tFL2lialBhdlJQN0RqdTc2OXVMcTVHbXl4R05vckRjcmJGemcvS0FBUG1EY0FkK25OY0xxS0xCcmtxSVgyTElQdnJ0SUp4bmp0M3JIRTAzQ0pwQ2FrenN2Q1kwalJicUtaNHpOZkVNUHRFOGdNUyttQmpQSFFqcldocldyMjBtb0tKb0V1N2lSMHdCeUpOcFBmN3d5U09uYmlzNnowNkc2bldPT0pYY2Z2SGNjaFVHY3MzYkEvRDY5eFgwMkxTRTFGVGRYYVN3TXZteHB0UDd4Z2NMbjVlbUN4d09uZkpyc295cUtDamRMWXhuR1BOeklaYmlVN25ralczQ3NESTRHY0E5Y0hKSGM4WjYxMCtpVHRaUnkzNjI3czhpN1lsbWpMZVZFU00rMjV1cEJ6MjlEV2ZKYTIycTZxSTRib3Zid3FKQ3dRTjh3R1Zqem5IcjA2QWU5YU50YU9rTDNUYW5EQ0hqVmdBcFl5TUI5d2xpRGdkL3B3RFhWQnB2VjZHVTFkVzZtZ2RjTjM1Y2t0K0xVTHk4TUFLanFPbU9jOGQrSzZleG5pK3hTcGRTUWVSR2pONXUvK0hjY2J1bU9vL1N1YXQ3a1RTd1hNOGtVd2xRRlk3ZzdYSjZld3hubjhNZXRXclc1bGl1QTgxb1ZoVWwxWjE4dU5pRC9BSzNjZW9HZU1lMWJPVVpMVGN3Y1gyT2lodWt1WGcrMFdpUW5kbEE2NUxrREdjZFFNRVl6V3JKYldpcXFmWnJjUktDWm0yQUJmYjYxeWNHc1hHcTM4MGx0RTkwd3dNN1I1Y2FqMHoxYkkvTEI0cSt1cVNKZFR3SkV6M1Frd29rVEFSZWdJR1QyeHo3NTZWazF6V3NHcVBGTlN1bmdpbGtuWVNtVlVkWGlqMmJHQkk2Y2M0Qng3ZldyR2tGSTlCYVJabEptbkVYemNiUVFTV0k5UmpwVldZcnNzUHRIOFYwQVNwQlU0QUdjZFJuMzlhWmRRTERkSmNTcTV0ZnREc1ZKeGtBSm5INW12bStlMVM2UFg1ZmRLUDhBWnFYUGl0ck9PU0l4ZWRocEVZRkFCMXdSMUFQY2RxM2RUMUt6TnZFdmtTUlFRaFZsV05nQzUrWThIMVkrdlFEdldCNGV1VysxWEVRU01iMGJhTUFaT09uMHFqcU4rMHEvWjFsWjRJM0xxU0FDV0lHVHg5T1BhcmhKeGs3Q2FYS2liUTBrdTlZVmh6c0pra1luZ0RQVW5JeHljZmpYcDhBbHZBQVNQTFpFaU93bU5jWkoyNUhSU01IQUdlQms5YTUvd1o0ZWpoMFY5V2t1V1M0blJna1lDbkhVREdSOTdxY2pwV3BjdzM4a2NEUTNDWE1hdnUyczRYZ0Rwa1lEWjVISDUxNjJIcHlwUVQ3bkxPVVphZGpOMXVWdnQwRmhNWXpFMkhPR08xRlg1dUI2Y2dmblZ0THEyczRvcnUzWllJUkl6MjBiRE1rbUR6bnRuazRIcDZBMUZkRzkxRHhuWTJLS0pDdHV4ZE5paElobmtnWjZZVWRUeng2MXZlSjFzL0QraG55SUEyb1hTbTJqbW1PNlozYmFTVDF3b0FKd09PQU1jMVRibHoxSDAwKzcvZ2szNWVXUGM0cWFQV1BFM2lWZEdWYmpFQlV2RlBKdUNFS0ZMTUFjY2NBRDN4WGVRNkxvbW1SZlo3aExwcElIVm1pYTdjaG00MnNWenRQUWZsV040YWxpOE53c3F4bTQxQ1VobmZKTEFuSFgxNzFjbG5tdmI5cExpRkRLemg4TG5JR2M0QjdkUnpXbUdVVXVhU3UzK0JOVlNiNVU3SmZpVDY1cTZ0SGIrV0NvVWdxOGFrWVRnUGc5dmxZODlzVTdWTkZ2RXREZTJaSDJhVmdKSTBmamhTcDQ1QTVBK2hMRDBxNjBBdlBEZHphVCtmSEhGYnNzY2lGSHdTQ2Z2WXlQUWpQZkZabHRxVDZFc2R0TXlOWnp5WldLSUhZRVluZWVNbklJNmZ6eWE2cWo5L3lNSUxUVGN5ZkRjT255Mm1vU1hzMHUvd0MxdEVrZjhDNHl3eU1nSGtIam45YXQyR2h1K3ZYY2QzRjVrRWxvWmNiOWhSUzJOeTllaHh4MnJFczc4UVdreXd4SXdta2VRcWNrQTd5Y0VIT0d4am42ZWxhTnZyRTQxQ0NhMmlMTE5iU1FTYnprQmNwa2djNDYvd0JhNFBiVTVRakY5SHAvWHpPbDBwcHVTNm9odnJxeW52ZnMwVFBHQXFTc0pRQ3diQnl1ZStNZHVNa1ZTOC9mYkVLbTJNZmRJd0FjZXY0L3lxVkpWdHBaTFQ3TEZNdXg0dk1LZ3RLaGZkZ0E4NTZEUGJ0enpVY3RvU2s4Z01TRlNHTUtFNEhBd01uOFFQOEE5VmN0V0xxTnRiN2ZkL2tid2R0R1ZaNVFWVlNHVWpCeGo3eDU1cXZxamlld2wzQTRKVUJUakFHUU9vcTdjSVUwWkpaOTZLV3pHVG5hd1BPTSt2VDZWbDNiUlM2ZktWaUxTZkxoMkdBT1JuQlA5UGV1S1VKUmw1TkhRcEpvdHBOR1k5c2pBN1VIS3FUamoxcU5FbFlTM0tSc2JVWUNNK0YzY2NrOVNPb3gvT21NWWhheGpmTVdaTnZVSEdSemdWYTB5ek02dWtrclJRK1dTbkkyOVJqY1NmYjY4Q3Fvd2pPVm5xVE9UU000Tkx5c0tRUkxnbjVza0x6d0JucWV2ZXBqYlhVV0hOeXNjUkc3NVl4azU1eWVlUGFyVmhiU0M2WXpSTy9RaUpoOHB6eDA2Zm5WMk9PTzRtSmVNdUZKT0FPQ000Ny9BT2VLcU1ObXdiT1p1YmRJNzFaR2s4MEZReE80a2RlUi9LdHpVSVluMGFNeEpkUnN4VlN6dis2MmpnRUFubnFCbkg0MWxhNlBKdTQyaWpWRndSc1RqT0NlU3ZZSGo2MWFua3VCbzZ0ZkpPNGRVYURmY0VMR0NjNFdOZmxHUWUvdWFwUjVaVkZiU3hNbjhKa1dNS1dWL0N4T0NqNXo3ZzExOTNmeE1Va2d0eEdTU284dU1qY2U0SlAxTmNhVVAycmZ1S2pka0RQNjF1cnFOL2QzVFRUVzl2S3F4aVBIeXdLbzdOMUE3Y25IUFR2VVVLajVYQytyc09TMVROZXcweTBtM1hGNXFkcEd6WlVuelFXVnNCZ0FQUThqam5PTzFkOW8xell4eUpid1RXS3VQa2pQa25ia2daUDN2U3ZLN1RVTFdkZ1JhWGQzS3pibUNxTXFRdU1LQm5nRWp0Vm0yMTI4bEc2Q0N4aVFNTnNjamdGU09oSjZnOGRlT2xlbFJ4Rk9GUFE1cWxHVTN1ZWplS0w2K3NkWjBmVkx1TzBWN1c0RWNubDdsL2RzQ3VPVzlHNUpHUnRHSzd1ejhUMk56RkdVWUVzQ1ZDb1NUdDZqSHJYaDMyclhiL1RibUF2cGNrRXFrTXJiMmZrZFZJSFFkZndxM29HcStJYmExTDIxMVlRQ2NGZHgzRjBPU01zQU9EbFR6a1VjNmsvaGRuL1hjaDAzYmZVOU04UXgyV3NHMWx6SkRNUzl1V0VJREJYQklCejErWlY0OWZTdm5uVzNSOWZ2NVlZZ2crMHY4bVRnY24xcnN0U3ZOYWwycHFkM2NKZEpLSk0yd2pFTVdUd1dkUXhIWG9mMHJqSkVacng4ZnZaR2tiTERrTXdQUCtOYzJNbjd0a3JJMW93ZlZtcE9sOUZhd0NkdjNjMFpJQStRc0RuZzkyNTR5YzlxNk9EVk5YbWpCZTV0WTNqakVLQVE3MkE1QXh3Y0hudFFQQ3dhMmkxQm9XZDNJTHdPTnhHUmdESjVQMDZmbFNXdWxXYytJNFkxRWFxenNDdkxEMndENjk2MHBZYWF0Wjl1ckhLcEJtdForSHcvMmF3RThnYTRKdVpia3RoMlRJK1lLQ1JqbitMT092MDFOUjhDbFBNdUpicDJJaytVQ0Zkemdqc0Z5UHdIWUg4TWkxbnRyZlRRWXJod3ZtaVB5SUVkM2tJNUNzVGdZNVB0d2ZRMXMyVjFOWTNNUTFIVVpKU1czSkZiU1A1bTFqdDJnbkROempKQUgxeDE3WFpMbFNPZHVWN3BrZG40ZnNvTHlFM3NndXJoUUREYlcwMld6eHp4MHh5Y25BSDgrcHZvckc0dUlVMXkrRWlXNFpwTEl1U0dISHpZNUo1K25jZHVhTnRwencyL2tMSmNXa3hrMm8wS3M3c3BIR1c5Y0ZpY2QxNm10ZUhUdFB0SWxTU0ZIdVVZdElRakYzMnJ3U1Rrbm5Cei9PbnkyTTVTdVY0Tk8xQzZqTGFmWnJhVzVKVlJKY2NJTW5rQmNrSHBqNlZvV21nMnRtR3ZEaTh2bkpabkxrN2llQ0FPbU9PbnRWdlVOUWgweTBFNzVLbEF3eVZVRWVtY2RlMzVWeXN2aWlPSllyd2JaSVZWWEVhT1E1TzM1dDNYc2Y4QVBGTG1sTGZRU2oyUEViNFNmWTVidGdEREU2SWpSWVpXWmNLV0o2Z0hISEhOWGRRMUJMZTFsRWFySWlpVUlDMmZMM3NSa1o2OEVZTk4reUpCNGJuQVZHQmM0VURrdGpuSTlzQSszUHFLemRhdWkxakdzYnI1TTVEQlJHQVJ0SFFuci9GNjQ2Y1Y4Njc4MFgzUFd2bzBZcXV5cTRIVnV2MHJxL0JmZzlmRVVzbHhlU1BGWXhnZ01nNVovd0REK3ZGY3ZaV3ozZDVEYklBWGxZSXVmVS8wcjBoTDM3Qm8vd0RaOXJFWkpJSEZzb2lSaUR6eXhJempxMzFKNkd1L0RRamR6bDAyWGRuTk55dGFKdG13c0ZNYTJ0cDlxanRwRnhMdy9uN2NFY3YyQjR3Q1FUMkZSZUl0U3RkQWpjN0xXYS9sWWVSYnhNdzJOemc3Y2pnWjY0NTZWbjc1aXN3dkVtdGt0am1PTkpXM1M5eVhPRkNnWkJ5TnVNbm5zT2MwdWV5dnZFTXVvWEcxTE8yT0VFczdEQk9UdTNaM1p6azljODE2RXEwb0pSV2pmWCt2d09kUVV0ZDdIUWVGcFRvZ2RiaXp1bjFXOWRrbmxhTUFJTnVRbTVpQmprTng3VlF1cDd2eGI0eFNHTTc3R3p6RWpJM0JZamtnbkdTVHg5UFdxdmlEWHJteXVRMmx2Y3cyczZmdXpNUzdzeFhhektUa3J3cWdBbkk5dTI3bzJqdm9tbHdRcGNLbDdLeXpNd1U1SEhybkI0eU9uclV3U20xUmo4TWRYdDhpbm8rZnF4eXh5MnpOQkZZK1ZGSCs4ZkkzbGNjRXNjZS84cXZhYTltMTVpN3R4TW5Cd1A3dUFjajlQd3FaNTdtMmtXUzRrUmxJM0ZWQmNQblBCSHVSMzYxbTJhbTF2M1FvcWg4N0RuQlFIOC93cXBwUXFSbGZyYlhvRVc1d2F0MDZIVDJlbjJkL2IzZ2laVjJ5WlJTVGduSndDTy92V0ZjZUhqcGwzRmJYYmlXemFLU1NHZnkrU2lxTW9SbjBPUXc5ODlNMWUrMm9zYjdIS2dqY3Z6WUhIVCtSeFVOeHFENmxwSnRMa3NHVGE2VGJnc2lOakc0Wkh6ZGM0SEdDUWZTdXFVdFYvTWM2akplaHh1bWFYYzNNeVEyZ0xIY3hWa1V1QUFUZ2tEbkhmSXE1WlNUUTN4amE1V050cysrQUp0MnRtUE9Eam5PZlQrR3BQRE42ZE5zWkkydXl0ekRLOEo4dE0vS25JT2ZRN3V2dVJWZTl1RmwxejdhMGprdkcySkN3eTJSeWM5RDB4K0FyemF2SkNuQ2ZYL0k3WTgwcHRkQzFhM01JdWJxUlQxbVBsK1pIMjZvUUNQVG5IdlN0RklsMHltQlh4KzhNZTBManR5TUhyZ2Y1TlVMRVkzTThqTTdIYjVvUE9BQUJqOHFzeTNzbW56aEhMYnBGd29PU1NRZUFmKyt1aHJGWWh1QzhpM1RzOWVwUnY3ZTViU3JxUVR1dHFzdmx2REhuYWVtVHo3ajlLWnJWczBPaVBKRUhXM2lLcVk5d09BU09SM0lQSFg4TTAvN0pOTm9WNys5ZEJDMGg4c0U3ZUN4UEdldTdnSDJyVjFhSll2QVY0aXhva2hDTklWYmFYK2RPcTQ1L3BXc0l4bEJ0cjdQK1puS1RpMGwzTXB0TmFEVHJLOEVlRW1WaVkzZkIyZ2JoMi9pSHZ6bkdLdXdXRnhiSkhQcWx1YldCVWR4dFVnRGtaYm5QcmdmN29GU2FMcUJudk5KdTVMZDNGbEVHRVpJWUhZb080REk2QWpIcHpVM2lIeFJKcWQxdWFBUkJqc2FGbHpnQmdTTzNVcmc4ZENSV1VIVDVlZnArYnN0eXBLYmZMMS9Jb1cwWWpnaGltdVpDeTRMcWVGa3p6Z0hIWS84QTFxZmN4MmlvVW51bmlZRC9BRlRidnVlK01jZGVjbXFhM2w1ZXp2TVdVRm1HMTJWUXZYSjJnNDQ5T3Vhc29zOE1qUE1zcExrL3ZYSHpBZmR6OU0vZ0twdE9OcmFJYVRUM01UV0RidGIydmxjQlMyRkhHQnh6VURHU1N5VlpqSkpuYVUrYkNJdmIvZUp6K0dmZXJXdDZiRmFXaXpBU2VlejdXM01NbnIyd1BUdlRJWTJrOE5pUkZrQ3BLSTNMTWNaNmdBZlROY1Q1dVoraHRkYUdYS3hTUWdEN3ZvTW10QzJ0M2xzRnZ5cXpRcE5zS09wR2VuY2NmL3FxTzdzMmh0clc2QStTVXVtLys4VjI1SHJ3R0g1MXNhSmFXVFF4TGVTZVhITHYyNG5LS3BBNjR6bnVQcjA3MUZMbDVyUzZoSnUxeEFMV2FMekdVVzdoUmhDcHd6QWNzcFhvUjZWcVNUSmFDMWZWUWx6TEt1RThzNHluQTJrS09vNmc5RGsvamVzZEswUmRRTUZ2cU1rMW55dStSVlozSjlFSUo3TWMrNDZVc25oWXdPVExaRzdhV2ZFSWlrZFpGUWpoOEZzRURESGpIVHJnNHIwNlVKeFhPbmYrcm5OS2NXN01vdEt6M2NrZG9qV3J5Z0tZb3BUR01BZDhaM1p4K3RhSGhUUTB1N3k3aHVvMFAyWEZ5cU5OaG4zakdPZUNBUTJlZXBGWnBpdVlHbHRWdVNMbTErZVF6c0l6Z25zSDJrY2RSak9SeDJ6WGh1cG83cTF1akswY2JEN00vbE1DVG5rZTQ1OStmcFZLZnZjMHQxL3d3TlhpMGoxV1RSR3NyMkZZMjNMTnVRN20rVkQxeDB5Y2dzT296eFhpTThRVHhCZURhSW9oZHZzVURBVWJqamdlMWVnYWg0bG1Xd1ZJTG00UzZqMmlOblVBN3gwSU9lZ0lPZU9mYXZOSUoyODFra2Z6TjhwbEpQM2puUFUvam1zc3ltbkZSV3ZVTUxGcHR5UFZKUER1cHY4QVpYZzFlMGtoZFV5eXhrQ0ljZjdmSjR6ajZIQXB1dlMzT25RckRhM3pUejNBTnVzSU9XQ2tMdTI4NEpQTEhnQUE4OWhVK24rSnBydXp0ZEg4UFdhM044OXVodTNVWWdoK1VBc3h4a2tZNmNqNm5pbzlJMGlUVGRWam5rZUc0dVpaZk1lOWZlekVkU0FRd3gxR2VNLzA2b3ZtWExEN3pLenZlUkhwZmd6VTcrVVhWN2R5VzBaR0VDNGRVR000M0VrbGprWkl4K2dxYTMwRzNzZGFsRnRxTWd2UDcxMDVETm5xV0djamoxOWZhdTZ0ck9TOWs4MkhXWjVnUUZTTlJHSTl2SVBCWGNlVDF6MHg2VkxxUGhLM20wKzRqU09TU2VSUUYzM0RsU1FlNkU3ZXc3VlVIQ0xKY20xWm1hOTVEWnhCMmlTT2FKQ3JtMnk2OXV6ZlE4a25wK2VDM3hHc29icVZGQ3l2S0NYa09EbnR0R0NRQmp2VU4zcGlYRFMyVFdVMGR6YW9KTmpPVEZzQjVIeW5INDhjKzFZVng0V2NYRVR4NHRvSkI5OWlwREh0aGM1T2NnWTY5YzA1M3RlSTRSamZVdHZybjlvUGw0NUhaMkc1WlNBaDZENWYwN1ZRVmdMdU9PNm1CaUVtV2liaFZZbkdQZnNmOEsxSmZEUmwwQ083a25mSG1zckp0Q0FEZ0tCNzlldGN2ZXV0ajVkckpibVdXUERrcEdONFR2dUlIVEhyV00zSlJ2TFUxZ28zME1XYmZEcERYRzkzU1pmS0lBSUxaSFhyMEhQR0IwTmMxcUMrVmRORXI3MVU4SEdQekhyWFRlSkwxQnFWdGJ3eExDWUI1enE2L0x1SUdCajB4NitwcmxMcVUzRnc1eVdaMjQ5elhseVZwMjdIUmU2Ti93QUhXdm42bTl4OXArekxiUk96ell5VkJVZzRINDllMWRlYmsyRnBiTEhaK1Rwdm10TWpTRTdwbVdNbmRqM3lPdnQ5YXErRzlRajBmd3Q5azhwMk56Y0JXeEVXODBjYi93RGdPTURuMjZacUx4ZnI4K3Iza05sQkU0ZVBjU3F0MFpnb2JkMjdZd09ucWE3WXloQ2ltcjNaaTFLVTdkQ2xxR29YRU1FK2xhZSswdEVCY0NGQ0I4M1ZUenllU0R4MnhUNFUwL1RyZGJpQlpidnlJbUprbEd4RU9Sa0tIQTVKSU9PVHpYU2VHdkN6MjFudFZSY1R5eVlsa1NReHJHNTZEZGo1dnU5UDlxb2ZpTGZ5UEhwL2hpRzFXRU95M0RLQUJ0R0NGeGdudHVQUG9LdHhjWU9yTjY2VzhpZWU4bENKaCtINDE4UWE2TlExRkpudG9CaUNJNWJld3lRb3gxeHl4LzhBcjE2WEpHbDFDRmxMcGM0WmdqUmhYUWRCd0c0NDR4Ny9BSTFqYURCWWFjbHZaU1cyOUhCQ3U0d2R3QytoSUI3SDZEOGVxajAyVkl4ZTIwaXNjRlZMaktrRHBuLzlRN0gxejZlRXBleGhydXpqeEUrYVduUTVHNzArN2RJWXA5ZzJZenRKakFYSkFPU2M1NDllMzU0Rnl6Vzk0STdnS1dFekprTjFYWU1jRG5qSCtQV3UrMVZKOVFpQnViR05YaXlGa3lTQ1I2REk0UDFyei9VOXR2cmxzeVJUbVZCaG9qSGp6V3g4b3lSZ241dTNiSHRXR05nbkM2TnNOTnVXcFpGekpjcDVDd1BMc0JiYXA1eG5QUS9Ta25udTdtNFJKNHBBc2FiY09OdUFSbnA5TVYyZHBaM0VlbVFYRVZzaFJ3MjVtSVJRYzVQelp6akl4WE9YOTRMaTZaaWthUzNSeDVjYjdteU9BTzNISHZST255MDFGeTEveUtoVjVwMlNPWWdpYURXSGhTTm4zeGVlcTl2UTlmUTFZMXhoNVZxVEU2VEpJcXNRUjgzVDlmeHE3UEc3K0xvTFJpdS83RVkyVms0NE9jY2RUZ0hwNzB1dTJVcmFUZGk0bkFtUUNTTWNEZmdnNXdPbUFQNit3ODNrZkxPTFZsK3U1MDh5YlRJSXJOblpiSmJaMW5CQmJhQ3hDZ2JlM3EzMXhVRjRrVmhMQk5GZElwRW0xU2t1NDhrOVFRT20zK1ZkSHBPbUpmNjFhcGNYaTJUWGNEM0VvaGNqNUhJS0lXUEhQemRNY3I3NHJhOFZhRnB0cGM2RzhVWGxyOXRTSjJRYjk2aEhPZWM1T1Izem42VnA3Q0xwUDh5SFh0Sko5VHpseTdXVExFd2RHbEVlV1ljNVluR0JXdnJWeGJKNFR2YllPaGxLRElodVFOeERLZm1VNDQ0enh5YXoyMHFBYTg5Z1lHa3VSZlBLNkZpcUNEbGdQN3ZPUnp6N2RzNm1yNmZjUWVHdFdGdER0aFJReFZ3U29VbitFbjBBSUhYcFNvUWxDRTd1K2xncVRpM0V4N0MvOGpTck44REx4U3hvQUNwQk93Y2tmZUdCMDlhdTM0dEpkTmdFMW9rYzBjd1g1Q056cVZPV1k5MkxkUFRGVVBEZHREZVJReVhYbXJhMmFzN3N2UExNQW9VWjY1enp5QjZWck9sc05UbHVKU3Zrd0prN25Vam41UXZBNVBYZ2VsWTA1MnAyVDdGeVY1RkZMcUt6T2JhMmNSQmhsVmZJQnpuSjRyWDArMHZycU50Um5qbFNDZmZCNWhkTUZTYzdOcEo0OXVPdEYzYXM4TDNNMXRLa2U0QkltWUFnOXZrem52d01mNFZTay9kMnptUzVNU3JqZEFTYzd1eWdmeXJvVlRsbnpTMis0bVVlYU5rWWZpTXlORGxIeGFveWhRMjBrc1YzWTRBNlo5UGJ0VkcxdjNlek5xbktFaHo4dk80QWpyV3pyTnJIYStGNVZJWXloa1pqNWVQbUxaSVA1OGMxekZpOGtUTUV3R0lHQ1JYbjFscmMzaHRZMTlRamtiUWJWbW1SaWs3WWkyZ0VBams1Si8yUjJxWFFMTk5UbmFLU0paUkhHN0JRU2NIYndUdDk4ZTNyeFVXb05kdjRlSG1XeXRDc200WEM1QlVuQXdRZU1IMjl2eHVmRHVDM2J4STA5eGdpQ0I1QWpMdTh4aDBYMit0T0VWenc1dkltYjBkajFGSXRCWFFyY1NQYVEzMXdGOG94c3lHSlFRZHVWSFFLY0gxNUFxeHBzOXJhWDhGMDRlTyt1b21qVjdnbHpqaG95b3pnajVlVHhqT01Hc1RSckdXQ2VWcGRTaHRpVkV6eG9WWm54dWJhb09BQXZQR2NFL2hXN0hwdDQ2UWFzc1M2aVdVQmtsVFlZNHprSndXSUxZYkdCZ0RubnZYclU1UmxGZHpoa3JhWE1UeERwNDhYN0d1UkJGdFowVFVYczNDallSbkhPM2FTU3VDVHlDZU9CWEdYU0ZQQ3FoYm9YdHZhZ2lKSXdFZTBZblB6Y2ZPdVZQNGZwNlcvOXZDQ1cxa3RSYnJldUVSNHdOOFhCSitVNXh1eDlCNjFrWG1reHo2VEhKSkRkUTZoYUt5SVFxdTBqWkorYm5wenhnY1o0cHVsenAyS1ZSUnRjNVN3V3p1NEZ1eVdtV1Q1RTJGaHNKR1dPU09nNEp6MTJuRmNOYnlCcmhTd0xGajF6ejlhNlJ2dEdtTGMyTXJTeHlORVpMWWc3VkNNU0dBSFhQYmpwelhQMkNxYjVEOHBWV0J6endLOHZFUzA1V3JXT3lLMXVqMkh3eENrRUsyeTNFVnFwS3VKSTRpeGNnREpmSDFPVHowOUswNVpsam52TEdTR01UYlFpekdUY29KM2R2Zkk2ZEs1QzQxRVF6QklERkNDUnRqakdHSFkvd0E4MWZ0TGk1dVZsdTRiQ2U0SUxGbUlWRndCdDY0QXlQOEE2MWVwR3J5cFJPU1VOMmROcEdxeTZMY3pJMlpZb21JTWlKNVlMRW5xQ09tUFR1UFlWZnVybld0UjAxSFNaUExkdUZqeHZZWUpYNVRnWUdjOG5zSzRRWGtsK2M3VmJjUnZmek1Fa2NrQW4wenhtdGlDOGswZlR6Y1NTeEJaQzZZZHR6RGorTGs0SE9PTWRlUnpSQ2NXN29VNE5lcFcxbTZhQzFKaDFPYWFmYVNKUXBDYlc0SUtrZFR6N2MxbHozeVhXbFJMYlIvYUxxUzNYYkNDQ3NURWNqMUhCNkFkUFFITlErSXRhajFTYTR0TkZFc3Nrb1ZTTW5PMEFqTGM0WHFlTVk1N1ZUMGlYVmRLaDNKQnBTQzJ5WlBPTHliODlPRndTZXVNR29kU0xsN3VxWmZLK1hVbmkxSFdkRTB1WmJobzBqbWRGZVVxSGNLeEtsMVVuQkl3UjdZSDFxNWZhVmZ5MnNKMGwzbDArT05wSkJKdGozczJCdHdwNUpBNm5rbW16V0s2dEl0emVheWtjZTEzeGJRcU1LVk9DdThzVDZGYzU1NDVxeUxUVVpJbXRiSjlWTUVvL2RtUklRc2JaRGZNeFFZRzQ1OXFjWUorNmxvSnk2OVR5Qzd1RE5kU1NNNGNrWUxMMzdaL0dwZEN0a3VkVmpFaWdvcEdBZTdkaFVOOWJHMjhvTmdPNmJ5QjFHU2VEV3JwZm5ySloyZHJ0RXpuekhabHp0SjZma0JuOGE4YWN2Y3Vqc2d2ZVBSdFRhMThPNkUxMVl6ZVRxVjQzMmRGTEZpQUNSZ0xqZ0RPNzNQWHJpdWEwa0phWGFSU1d5dmNCUk83M0dTa3VjRGJ0NzlTMmZweFJxbDdMZmF1enFmTWZMTGJSWUpDQWRTUHIxei9BSVZkdExIVUYwK1M4bmlqVjBrS05ISXI1a3lCOHU1ZS9LZ0RQdHhXMUdjcWpoeXg5Mk52K0NUS0tnbmQ2dTUwZGpxU1FUTUk3Wm5WWTNrY2dLZGpaM014SkEya2RNNStncm4vQUF3VHF2aUdmeExxOHVQTllpRUg1dHZidjBBR0FLWHhCTEphK0hDa2Q3WXJKY3NJMGh0NGlaR0RBNUJ5eDI4ZlhxQldqcEdrTVRwZHFXYTJjSUc4MmFQZkVoSHpESFBCTERibjA3OWozeWszV2pCNjIxT2FNWThqbHRmUTZPeVhUcHpIQXR5N21QSkJUN3dKd2NkRGtBSHA2REZkVEZjUmlGSTBYYkpnQURHd0VkemdjVlF0UERkOTVSYnoxODVadCs2U0VBTnhqSXdmYjYwN1dFdjdTQm1naU0wNk4vcnJma1k0SnlPQW81OWE5Q1ZXT3paeGNqYjBNUFYyYXlrdUlyaTVuZjdUSnZVUmtZalZjSFBxT0FlZTFZTVZ2YTMzaWJRYldKSjBMMzVrWnBtSlpna2U0Wk9jZndZL0Uxb2E0ZFF2N3FLNVdQY29YeTVObU56RHB1d2UzSS9Tb1k5UEVHcWVIN3NwdExTeW1OMitVa0NNa0U5OFpQNmZXc2ExUk5mZCthT21uUzVWZnFkanI2MlZwREhib0dNanNQa1FsZU9RT2UvMCtsY2RyOFZyQXRsQlBCSGxKdkxMYmlXOXkyMFkzRWc4RG5uUE9hNysvdHBCcFR5M1F0SXdZZHJTc0FkMkFUbkpJejBQTmVhNmNyYWpyQWpRZ1R3dEpISzF6RUNscWpmTWh4a0FTSEp5VHlQd3hXZGFyZUhJdFJVWVdmTVovaWhXUGluUjdxQ0pySzIyTENteGlWalVrNDVQUW5ra2UvMXF4NGdzcmROSWxsZ2VLYVdXQm1MVEx1YmFxN1F3NXdDV0RBZlErbE44V2FUcXM4VjNOSTNueTI0VjhnWURxQWVRTWtjS0QzSit0VmJCSXRROE5Yb2dZYkhEQXN6RCtHRk1qUEg4UnpqMUo5SzQrZDgwb3RiblRHSzVWcnNkVDRFMG1XZlFUcVFWVElFU0JSR0FSc1FZTEhJT1NXTEdybXVsdFU4UjZIcDVuV0tPUHo1cHlIeVZjS0F1ZWdIM3orZGN2cHVxM2cwZTF0YlNaeHVpd0FqRVo5dUR6emc5S2krMFhwMXkxODYyZmZCRVdLNHl4REhKUEdTUit2V25TeEtWT01YM1d2ekZMRHQxSEs1cDJOb2w3NDIxNll6R1FSeVJJa3JBa1lDZ1lQcWZsNmV4cnBmR2F3UitDZFZFeVN2SWJWaUhqVnltN2dMempIY1Y1M3BGd1JETk1OaVNUM0VqK2FUa2djSDVjODU1UDRaOWEyTmExYVpQQzE1YTNheUV5dzdWbERZQkhBd2ZiT2VUNlZyVHFmdVc5dDJST2w3NnQ1R1o0RVdCZEtrdnBKWWg5bURreFNSYmh4bGpnbmpkanB3YXZwYXpXR2cyK3V6T2tTelhBZVJNS2RtU2RvQUlPTUhGY3pvRFd6SmEyVWwwc2NMM0k4OE0rQUl3UVRrKzU5TzFYdFIxRzNPdGVWRGRvWUlEZ05HM0RrREJiSFlrWnJqVW8reVhsK2ZmNUcvSytkMk5VYXBOZjNFazhNekJtR011VWZnanNOdjAvRW5qaXFqUmFXOXdKSkxsL1BBQVREZWFHT01saVFCam5qMTVOUTZqNGpTNXRsRnhweW1VREFuU05nMjNvRGc4WlByK2xadHBMSE1qbGxFSTNFK1pNamJldkNuQzVQNC9wV3RTcGYzZDdpaXV1eHIrSmRYc2J6d3RQYnBiVzF2SnVBWlVERm1PUVEzUFRHTUg2MXcxaEdoSjNkQ09sZFpmQ3p1dEp1UE11dC9sUXRKSENKc0JYeHhoU1I2RW5nRThjVnlsb1ZsbkdDeUhCd1I2OXE1c1MyN1B5TktLc2RKY1dSZnd4UE1XQ3FzWllMbmdjKy9ja1ZpNkJmcHArcExJUWNNTnVRTTllRCtocjAvUi9zbHg0RVMxbFNKN3VhR1NNeHpISkNzVHRZZkt4R0Q2NDYvU3ZMdkQxdjhBYU5ZdDFLNGJldUNUOTA1SE5PckJRaEJ4N0w3eFJrNU9WejFIU0xqVDRyc1R5MmEzQ1NNeVNUclB1RWtaUWZLQU8vWG5BR085ZWo2QmY2VGZLV3RKRURxb1V4cHhJUXZBRzBkQUNUajYxNWRxaGJUN2VOVXVEY3dJdjdxZUpBRlJtUEtrQVpHVVBBUFRuazRxL3dDR3J1MHNOUmFhMk50SGNxdVhsQ0VoaHdBRjdad004a2MvUVYyeG45anFjMDZha3VhNTZIcVZ0bTZsSXNKNy9odHpSdjVhZ0FCU2paSXo5OHNNRHQ2aXFHckpEcGQybW9SV3p3eEtUdjJuSTVHQWNmdy8vWHhXclk2eFp5ckhBMXpLNTJuL0FFNHlLQXprOUdJNEI5QmpHQlR0UnVQTzA5WTBpTjRqRUF5eDVJWUhIYlBvYzl4VzFPY291MWpGeFI0LzhRZE1HcVdNMDlwNXNwZ3UyOHRnaHlUS3dLZ2Y3MlQwN2p0Mzh5c2czblJFcVFNam12Y2ZGc2NhK0c5ZnNqSVdRV1htck1jbFFkNGtqQlBBVnZrSTdkc0RtdkQ3Wjh6SXVSZ0g4cTgvR2ZGZnVkbEQ0YkhValVKN1JMbVNMemo1aFV1Q20zZGc0Qko5T28raHJRV1h4RnFWbjltc1lKL0xLQXVXT1ZZRTl2eGJISFhOWmQ5UGJMY3dMdGY3R3BVdTVQT00vbHo4M0gwcnBkTjFYWHRWMUh6UEQ4RzIwdGlOMTVlUkJnRGpzT1Jubm9NOXZ3S1RWN1NiZm9WUGJRYmQrSDd2dy80ZiszYWs1alFTcVlkenFqRnNmZEFLNVA0SCt0YzNkdEpkWHhpdElKb2JYTzJRay9OSTJBU0NTY0E5anptdlJyN3d2b2Q1QTl4cnVyNmhxV29TcGlKcFpCR25tdWNBS2d4dEFKSEdlL09LNTNYTkc4TjZYZFQyMW5aZmFrVWxWSk1raktkdlZoa2djaXRKcHkyVmtLRCs4NTZ6ZFlVbnVMVzBpUmZPS2txd1liUmpDQUU4NFBPZWNtdE9TenVybTBXZVp4S0NBTnU0NEgxeHdPbm9hayswMjBObEdJYlYwa1RsVkNiUndPdmYyNjRxckFzdmtZV1JsYmFCSXFxZWZwL2tWbkdQTTdibDN0cU9Gbyttb0poT0dpWWZ2REcyM0hzUnhucDcvU3IybTZ4Y1dqUnhTS2ZMVldES1RoV3lBQm52amdWUHAwTTM5bnlYQ1JlWXpxUXVVM0tmVWtIcmpqOGFwcis1c1piTjRibVNWV1V4TWNCVlVuZzdUejZqSHRXOEtjb3FNb3UxL3dDdnhNcFNqSzZhUE5DSk5RdXcwck16TVZHUzNSUngxK2xkUDRNalc3MW00bVVzQU56S3pIQUF4eG45SzVteVFKYVQzTGM1SGxvUGM5L3dycVBDN3JaYUpleitWTEk4bjdzQ05Od3oyeWVnNjkvU3ZLci9BQU9QeU9tbjhTT2k4TjI5cStyYjdrbExSVThyekI5MEVaNVBIOTRZNmRoWFN3U1JHL2xhS2JmYXU1YVhFWjJ5Tnp6ak9DQVFSbi9kOXhYTWFEcE1wa3RZbkVvRGdncUdBVlRnY01PcEJHYy9YcHh6c2VOTlgwbnczcHlXZWllV2RTdTRnSlhqUVpoWG9NSHFDd1BmSndNOWV2cFllcDdLaXUxem1yTG1tY1o0aWlONzR3YlRyR2RESGJPRTgxWHlvWWdiMnlUL0FIdUQyNHpYcE5yNGkwaTIwKzIwMTU3ZVc2U0tLQTRHOXBYQUhJMjhrSHNjZnJXVDhPUEJVQnRqZWFsRWpML3p5a3h0a2M1NFBQSUdPbmZJcjB1MjhPYVpIRzhkdGEyNDJ5ZmNXSUxoU0NNWXgwSnJYRGRhajB2K1JsWGEwaDJPZmsxZVdXN2V6anVaclcyT1NWbGM3MlhCR3diYzdCbnZuUHBqclYyM3V0T01NVVVWc2pzaHhHMHpHVlcya0E4dWVQWS9rYXNQNFMwNjVEdFpJdmt5c3lsMXl3aUt0ZzlENjl1M3BXclkrQU5OdDRta3VvMHZKbTVMeUlPTURBQUhRRDhPdGJ5cVUwcm1jYWJaeDNpUzJsMDZGYjhORmIyd2tUY29tUGxxTnd5UG0rWEJ6OU1nZXRZZHJxVnA0azF2UjR0RmluRWVucEpjdXZsT0Z5ektGQUhvY3NPTWRhMi9GZmhtS1RVNDdkTHVQWkZ2WklKWm1BVmxRN2NkUnUrWUg4Qm1yUGg2Tmg4VjlhdVlVamhzSVlMZUM0azZZa0tiZ0FlTzRBUDFGY2RTcmQ2UFE2WVFzdFRNK0lHcGFsZU5aNkg5bWtTUXlSbFk0VklKSjNFSHBqZ1J1ZnFWUGFsOFAzUXNyUzFzNE5HOHFPSTVDTzRRYmoxT1FjbHNqcVBTdDBSSnF2eEQxTFhZbzNrczlQUkxDTjQxWmcweHlaQ3FnZGVRbWUyZnFSaDZscStvWEYyK2pSYVhNdHpaN3BHbEttUmt6OHhPUFRrL25VZTJzM0s0MUJOY3FHNi9hQjlWaXU0emRKQzZzWldSbWRJbHdGUFVad0QraFBGZWJyRi9aME9vMkNGWkZSR0tsWDNLTXFDVDljWS9MMnJ2N1RXcmFLM2dXOGtrY2duS2hpR1lIakgwNzkrbGNONHJIazY1STFuRkpGREpiQWdTS1ZiZ2xTcFBmb0R4eHo5YXpyVFR0S0pwQ1BMb3pxdkErbDIxejRidDcyN2ExZ1FGMVozUHpuRG5BQS93OUJWWFZDZjdXbGF5SlpEcFNTL09UdUl5Yyt1RDEvRDYxMnZ3ODhQMmQ3NEEwdWU0KzBlWE04alNDT1ZseCs4WURHRGpHUU9PdjE2VnpIaTd3OWFhQjRuMTFZWW1ZZjJFMDZtVWs1WnBDbWZ5UDUxYmt1UlJ0MklYeE5tSjRlT255YVpFa2hRT3pFbVFCbUJHY0JSanZodS9wOWFYeEZZMjg4TU52RkQ1V1Zra2JJeHdvTEhjbzZuT1BwZ1YxUGdTMWhoOEsyUnRVVzR1TmhrSCtqZWFWZmV5bm9NREkyOG4wSnJDOGZUVDZWcmR0SmZvbHRJYkNVUnc5aHZWbEl3bkF5ZlE0NmRxSk5xa292eUtWbk81eXVoM2J3YWRPWTR3UzdlV2dIVEo5LzhBUGI4TElzVnVKV1ZMcGRneWZtQURTdG5qYVBybko3RDhLemZEQ0dhM01FRWJUWGJUQllZRkdkNU9PdllEdGsrdGI3YWRlV2l2OXBXS0diSldSUzNJMjlSanBqMHgxcm5oS1M2YUkwZHU1WTAvU2tFN3pYcXlpTEhFYUp1Vld3VG5ucjNHZWY1VTV3aUJvcGJueTB5TUVKZ2tEa2RCMXozUHJWVzJ2bzRWazMzSmNvVkttT05uR1FlQm5Cd2VlNHJvTFJkTjFtekZ4ZHh6MlNxcFZGWmk3dUJ5V0JJMm9ldkh6RSsxZHRKeG1rbHVZenZGM09mWVcxeHBOMmluTXBqWWxueUFjOGZuOWE0K0N6a2pLc0dDdXBIeXQ2SDJyMEs1c2JXR1M2bnNMWW16SUFFcmlQY2Y5ajVoblBBUDByenR3dm5ydTh3YzhIT00xejRsUFEwcE5OSFgyRjFieDZmYng0RnNJa1ozWmM1Y2svZTl6eFhONkVwZldiT0pGYU12SUVCeHdNKzlkYko0VjFlZncrbC9wOCtmSlV6QkJJSEtKam5uSEF3ZWVlK01WeEduU3NMMlA5NHl1RDh1M3RTcTM1VW1FTE51elBhN1RSN3ZVZEx1NEV2bGtPOW5SWklqdGtDbmF1RklBNUNnZDhBSG5rMXl0dExlNlpOSU5QanRrWGNHZUtaYytVM2ZkdUhBNEk1OU1WN040WDBPKzA3UkxLQzllRmZKZ1ZUR3FiaXJiUmtrbkdUbnFmOEE5ZFpjZW4yTU9qeHg2Z1FzODByTEhLNDNLekVzUVNPTURrKy9hdStQSkpwN1dPSlRrcnJjOCtzdkVlcUJicTRsa1dNeWhQTlZVQkFiSncyTUhub01qMnJRaThXYWpwY3NHOUVlWW5LaHBHQ3lENkgxSEhTclhqRFQyMDIyaGpsdDdsNVhrYnlwb2p1alVMakFiSTY5Z3YwNmRLNHg5UUZ4NXN6elNtVUVLUzNBUGZ1T0RrZHF1VlNLankzS1VPYjNyR2hkK0xkVHZZcnEzbGVHM1dWb25sQ29UOGlxeENrY25BQTdFSDd2VHFQTExiYUxpTldPTWQ4Zm5XMWQ2OW04Wm9NWEYwenB0TG9ycUN2R0NNWWJvTzNOYzY2U1NUa2JUblBJNmMxNXRXU2tkTVZ5N0hlZUg5TDBiRjNxSGllN1lLaDJ4UUw4d2tJTEtjRHZqYWNEdlhaU3lhdmR1bHpwOXBaNmNnaTh1Tjd4d3JTSW94eWdEZ0VjZHdlMks1N1FmRDFucDl4RmNUUmJuYTNqYUR6NWQrMHZrNUF5T2M1NmU5ZHJCclY4MXMvMnkzRTNseENHR1NSZ3BPVGdZR2M5QWZYbkZkMUNsN3VoelZKNjNLbHQ0TjFyN0REZVRhaHB0cERFZk1VVzBUTmtrSEJPN0dQdmZ3ajBxdHJzNk1zUzJxV2M3eW41MFNGb3NFWXowTFpQUFdyME9wYXdZSlFVTUZ0SkhoZ1ZZS3ZPT2M5RHgrT0t5Y1dkdmNRU3lYVHpiV1BtUm9OcElQR01qazg0UFR0V3NseWlpMll0MjBzTmlSZFc4MEdRV2pBQUtqR0I4emZuMkZWVW1DVzR1RW1qTW9HOFFCQ1MzUElEWnowclYxcTV0N256QWtkemFCVVl0Ry9QVHNUam5rajZacnZQQjFucEVWc29HbldqeE1pRjU1YmZadE9BUmhpT2V2NTFrb3BUZHRrWEtiVVZjNGl3MXBkS3NJNWhOWVhUTmtvZ0Q1MjV4Z3JnRWNudjZIOFpKMmp1YjcrMTRJVWplUEp1TGVObFZuUWo1c2Nub09lZmV1dDhaYUJwRnZIWmFocE1PbmYyaWtoOHdsd3F6b1FjcTVIWG5ISjkrdWE0b1hpM1RNRnNJUWx1TVhNWmdERXlZd0J1eWNxTUE1SEhUclY4L3U2N0VSU2J1anljT1ZzWVloakpPY1k1T2U5ZDlEQTF2NGUweXlua0VjVnhKNWpFTHlxREhVQWpQek1LNGJ6ZnMyc29Zd0c4dGd2UElJSFVmVHJYZWFtelhGN2EvdWpHdHZiUnhsVzR3eCtZa2Z5L0N2QnEzY29xMm01NkZOYU03SFNybTMwK080dU5Yc3ZKZC9sV1dFZnV6RndoeW9BSUJVNTZIcHpqRmVjd0FhLzR4bXVoS0VzemNIWkpNTWhZd2NMK1M0cmI4U2ExSE5wTWVrV29tKzBUdmpZeHlFUWNiaHllU0FBRDZicXZhRm90cWtFZHZienhpZFhDbHl4QVVqSnlUNjVBRzA5Zm9LOUN0VTlvNDA0bk5DUExlVE81MGU1c05TMDZ3bmt0SGpXSUNQeVUvaGRSOHpNRDI1QzVJUFgyelhaMjF2R1ovd0RSZ0xhVWtaS2dBTU1EQVlldnAzeCtSODIwWFRyZlROUXQyR3N3M1UwOG0zYXNZd3VSeHU1em44c2MrOWQ1cE9xZmJyMlMxdHBvMmlnKzk1YmZMMEhBeCtPUjcxMHhnM0d6ZXhqT2FpOUVkVmFaVkJESXVIVWZOd09UM1BIclRwYmtSeHlQaklUMFBYMnJKdnRTa2hrZ01XREx1eGh1QVI2RTl1bU0xWGsxMnl1ZytaL3M4Z093azQzS2VuR1J6V1RwU1N1WEdwRm1TMW1iM1dwcGJoMVNRWi8xYTRBM01jQW5uRGNEbmpHQU8vUG04K3ZMYStFdkZ0dDlxUnRidmRlZTNoU0kvTWNGUUhBNmdBSzJENjRyMlV5UVBZckZBa01ra3lIekh5QU9SemtqbjhlYThJK0ZXa3ByZmpTNGsxS05iaUd6RXN6czVMTEpJeEFISC9mUjk2d2tiSTlhMGl6MC9SUERXbW91bVc4U2hnc3hrS003TjNabTd0a2RhZHEya1dGakEycDJTWGNhay84QUxxN0J4dUl5RnlmdWs0UFRHYyt0Wk1lbHZwT3NSU1d6WEVXbXpSNUViSGNMYVgrSWJld083UEF4OUsyMDFncGJTMm9kSTVVZFZBbFFnSEo3c3ZBSEI1QTdVUlNlNFMwMk1tUHc3cGwzYlRKY1dubUtjUERNc2JDUTRHY3NjZGV2dDdDdkovaUxZejJkM3B0eTFuSEV0eGJ5S0dVZ0Z3cEh6RURvY0VWN1l0eGEzc3p5L1k1a21TWEQrV041YzhFTU9lUmpuQkE2VjViOGE1bzMxVFNKTFVZSmptUXVOdUQ5empBSjZmVHY3VmM0TGt1UkdvK2F4dmVCZFllRHdGcE5tOHJ3T015UUFzb1dSaE94QUhYUFhwMTZjZDZxL0V1OFA5dnpNOHlneWFFeU5oYzhHUXI2K3B6Vkh3NXA4ZDE4UHRObUYvdG5XV0pJbElPMVcrMEgwUFhuOGpXRDhSaGR3ZUkvTFlNV1d3akNNVUs3bDgxdWNlbjFBNmRLYzlLZC9RY2JjLzNucC93dmpXMzBXMGh0d0Nxb3JGY0FCaVdKWmgrbGNyOFZyTC9oSnZpWmE2V2pCVERZcWNrNEFBTHlNU2Y5MEExMm5oM1NiMTlEMDgyMTVERkt0bEhHVU1XNGhnZ0dTeTRJL3dEMTE1M3F0NWVueGw0dnYyTVQzRnZhU1c3bkpHRjJoRHQ0OWoxOWFxcEZjc1NLY3J6a3pqZkNPMTFlQmtrY1hNcVJzSXp0SlFIY3d6N2dZOXM1N1Y2RHArbXRjMnMwQzJtR2NtTGZibmFJbzBBRGJRQmhtemduL2VKTmNENEplMmJVbWhuRXBUYVNxUTQzeU9SZ0JRZXBPY1Y2UHBHajNvMUJ4ZHRkSnA1UXF0dkRMczJna25iSXk0WWtNVDgzcU9tTVZqU2x5cHlOWks3c1l1cjZXOXZsTGEwS3dJUW55L09keEpIT0Jqci9BRHF6WmVGTlQ4eU85dWRKdVpZQm5KU1ZZOGdlcmRmd0E1d2VhOUd0Tkl0QTBxUnltUHkwSmo4eGZNMk56a0hjZDNjWU9SNkExZmwxQzJGcWJHL2UxMlRONVF4SU5yTmowKzhDZW9BR1BjbnFvMUdueldHMXBZNGtXZW1EVHZzOHZrV1FtQUJoc0lBMkZ6anF3S24xNEF6NkN2RVo3VlJmU0tDN2VVN0tOM0I0SkhQdjlLK20zMDdTUWh0cHJoN2xjNUVJZGNSbkdEZ0RrKy9YNlY4NCtMNEl0TThaNnJiUWJraFM1YlpGakJVSGtmVHJWMTZ2dExlUXFVVkc1NmhwbDdjVGFEYVhVTnhGZVhBaE52NWMxb3BWQmtLRk1pRlhUakh6Tm45YThtc1U4anhGSEhOR2hFVTRSbFU4SGFjZGZ3cjZFK0U4ZG9QaDdiQmxKRSsrU1RJRzBuY1JnbkhKd0IxcjUrdjlrbml1OCt6ajVEZVNiQm5qRzg0cFZQZ1Z4VTM3elI5V3dXOHQxYWVmQVVpZDEzYlJuYXZIcGpCL0tyTGFkYnlvRW5TMWxPNE5oMDR6NmdldGM4bWdIVE5OV2J3M2NtS0lxVDloblltSnNqK0UvZVQ4Q1I3VmgrSy9pVEZvVmltbjJ0bThuaUI4UnBaTkdkMExFY014NUREbmpCT2ZhdWx5MHVjaVd1aFErSkUyamFCcCsyYlVMcVc3WUZWdC90Y3JGK1FmNzJBUFhQSFRpdkpyTFFOZDhUT2s0amEyc1p5UnUzZ0Ivb0NRVzZkK0swcnpTdFFoMXBiN3hWL3BWL2NqZVkzZlBsREhBSUhwMEE2Q3JVcTZocC9sdXNNME1VbVdRdVNGUFE1WFBmb2VucFJMbW5yTFpmMXFiUVNTc251WTk1b2tXZzZoYnBFaitXN2xZNXMvUHdlcDdjanVNajhhNSs3V09IV0xwSXp1alM0Y0tTYzVVTWNHdXcxaTRiVXhweG1tZ2FienlwbGtadHpodXpua0JlTzNxZUs0bkNpNVpjWUlmR0J6am11V3Z5dHZsV2h0Rzl0VDF6U0cxS2U5MDBXOEwrYmNXWGwyN2VYaDEyZzR3VHlCZ3R6N1YxR2s2YmUzMDdOZDdQS3RGOHQ1RklZbHNqN29YcGpHTTRQSUpySzBtMjFFRHd2Y200Tng5c2lhS014Z2t4THN4MzdLck4rSUZkVHFFU0JWc3RHaG5pbmpYRVNvRGxzSEhVZHVjNWIrdGQ5S2JVVGtxUlRlaHptclhzN01xUUxDOFJPeFZUTEgySkp5U2ZyV1JQQnFaWHkxdDFDN3R5c1I5OGdFNEIvcDdWdnRwMnFXc0Uwc1Z2SmNIYis5MnJqYTJjbkpQSjdjY2ZqVVY3cWQ2ZEtpS1dnak1nTEtTd0lKQittZjBIWDJvcU85NzdGd1ZyV09TMWZkR1oxaG1qbTJXNUxPaWdBZGMvWHFLNmZ3NXJEMm1sUXd4NXU1VWpVQmRtL2dBY3Jqb09PdU04Y25nVnk0c0wrNzB5N3VUY3BHNk5JckZsd1hBWGxSMjZmaldsNGQ4TWFuY2FhbDlaV0MzTU04SUt5WGJlV1JJQmdpTGIxSFVjam5ISngxd2hVOSs5aTV3VGpZNjI3dG9OUnQwaU1UcmtneDIwY2hDUm5hZXcvWHA5YTRzNmRwMTM0ajFFaExpTzFpRU82SzFsWlR2eGtua2x1bmJPTW11b3NOUHUyUXlXYUV6Mnk3cGJXVnRreWc5Q1JraGdjZndrakhUbk5VUEJjRVUyczY3UHFPVWpXKzJzNUE4c25BNEpIM2ZYSjQ1cm9uVWkwbDBNb3hrazJlUDZMWlJOcnR4SmZmS3R1NWxZZE1nWlA2MXMzV29CWlpOVFB6TGc1WUFrakh5ajZEb1B6cVB3OUc5N0hkM2drMnp2Z2d1T0Z3d0dQKytjMG1zeHpYRnhhNlNEYXlNNU53Wm9UdWJEWndyZGhqbjh4WGhSMXFOdm9qMEhwRkpkVE5zb3J5OHVqcUxGVU80dHZQQUFIb0IyNkN1enRoZjNVRWVuYVVUT2NlWTVaaEdGQUhVWlBYNW1IQTVGWitrV0Z1cXZEY2Jvb1kxSnllcGJIQVVkTThodlQxcnNkQXUxZ3VwcGRHdFppeFZWbGpMN1JnWjUzWTlPY0gwL1Bwb2NzNTNrOS92TTZsNHgwUXpTZEgxS3l2b0k1b2JOWEQ0OHFXTnBEc09lTURBYklKeVJrOXVCWGJXakxhSWJpSHlPT3VGOG9aeDB4Mi9NMVIwcS91WjdTMFMzMDZmL1NaSEx0S1Y0akp3ckFrOGdBZzhmNDExWTBlRzcvNCswVXlLQVJHUU1lcFB2bitkZXZCd2dyVzBQT3EzYjFQTjcveEZxbC9QNUt1MGF4bGh1WExGV0gwT0RucDA5YXQyV3FmMlNHdjlYMDVwWTFKeXhiRFpPQUNFejh4SHNjODlLOU9heUVPR2hoak1nWEFZakFYOEJWUzUwNVpXaHVXV0pwSW5Wdm1YZ0VIb0IyUFhrVVNyS1Y3SUkzUnhlclhkdjRnMFI0YmVZTGFxbUxxNmhPUkdvVUU0T01CODQ0NmpKSnJsZmhSR0xmdzdjdGJXTWN0OVBJU0xpNG5FS29vSFFNQVd6MVBBNzlhNlg0czJOeW1nM2VxUnlQYm9JUEptaGlkZHNoZHdNc0N2emNIR2M4RHBqSnFId05wSDltK0NyYThXS1NlZG9pNEFUYnRKeU52KzEyNTlTUjlPS1VGT2FpZE1aOHNHMmJlbStLb3JhOG0wL1c0b3JhYTIybU5wWmd5emdnNEtOakw5TVp4bmpCNTY4OTRnMXlCSllocHNzZkVhaG8xa0lkY2ROMmVnNTRIL3dCYkU4MDkxY1c0bG5GdkRKR0h3K3pNaXAxUFhvU0FPL1lWQmFhWnArb1RSeXpXMG1veEpLOGZ5YnVRY1piZGdZeGc0NTlQYW5HaXJOZmQ5NVhQYlZtSmJlSkpqZFJva0Ridys1V0JIWEhRbklCLyt0V0g4UlpMcStmU0xxNkVTenlMTXBKSTh3NElIekxqQUhvUU9SWGIrSk5IdDlMdFk1OUxubE5zOHcvY3ZtVkFNSEkybm5IQTcvOEExK0Q4ZXd3UGVhWkpiYlpZM2FTTStYRVk4akM0K1hPQng2Zi9BRjZWUnRVM0dRNDJsSk5JMVBEdHJIYmZEMkhWemNTUlhCdkk0VWp4aU1vSFRjVDZIak9mVlJXZjR5dkh2dGNYekFWS1d5UXFTMlR0RE0zSitwUGJ0WFIrQmJYN2Y4TDcrQm9OMjZXV05YQno4MkJoZnh6MjlhNUh4aE8xL3dDTDdlM2hrR0hndG8wTERMTXJKdVVzUjFiNXh6N1ZsTldvMlhVcUR2VTlEMUR3cjRqMUpZb2sreXQ5aVZSdUJ4dUpBNEtqN3h6K1BTdlByN1Y0THNlSWlwQmZWYmtaMnR5SXhJekhQY2RBUGZOZW5QNFFzckc5YTZ0WnBHU05DYmxuUXZIeDk3a2RlT3d6akhOZU8rRzlIazE3eEJhV3NUbmJLenV3VnRtQmducnorWHRUcnQyaWs5UlVyWGsraFU4QlNlVDRuSlNieWdGWUdYeXk1UlNDQ1FCMGJuZzlqWHR1bWkyZTFNVU9vWDB5RkI1MGo3RncyRHkyRkFPVHh6elhrZmdIVHBrK0lVMm5TUjc1VWVXTjFDcTNLazU0UEhhdm9tdzBPR0tPNlp0LytrRUJ3L1g4ZWNmbFNwM3M5ZW9TZG1qRHVkTHM3RklKYnVTZG9pL0tTUzlUam9SL0VNZ0VBNUZkQll0YWFqQXNUYWU4WUNxcktZc0xrYzhkdVBYNlZhV3oyT0RHU1NPVmQ4bGx3T21UMnJRaFpuWDV4Z2lxNVVpZWU1aDNkcFlGemFhaEJHNkFib3lHSUpIR1RnWTVIdCtYTmZMSGp5MHQ3VHg3ck1Gbkk4dHVMa2xHZHl4NUFPTW5rNEpJL0N2cnU2U016UlNHTU84UnlHN3JtdmtIeHZLa3ZqelhtaUEyRy9td1ArQmtVcDJzckRqZTdQWC9BQUw0UWsxSDRkV1Y5cDE5YzIyb083a2d6TVlId3hBRHg5TVlIVVlQZk5lTmEzcHR4cEhpUytzWjlrYzhFN0szbE51QTV6d2VNOWEraS9ndmNyY2ZEeTNRS3dhR2FSR0o2RTV6eCtkZVJmRnF3U3krSjk5Z0VKY0NLYnI2b0FmMUJwVGQ0b2NJMmt6dlcrSlZsb253MnNMaFNaTlJtdHZKZ2lsK1lzNjRETXhIUlJuT0RqUDYxVDhIK0VHazBTWHhYckNOcUdxM3BNbzN2ODBTZG1VOEVPY1pCSFFZeFhPZkR2d0ZiK0lmRmR4TE8wTWxuYVlrZUZ3V0RjWVFIa1pHYzU1L2g5NitnSWJTZXpaaWl3ZVZ4eHVLaFFCMkdPZ3hWMHBxVDVqT2RQbDkxSGdGMXBzbG5xZ2U3eTFybmVwdVV5NDU0Vi9YUFB6SDhmV3J1b2FmSS8ydGhQSEZFbTBMQkM2aytZVUJJQUhQZnAzeDdWN0ZmWGVqM1UwOWpmUU91d2VZelNMaFNPaElJN0R2OWE0bldOSzBpMWphVFRKQkhBVzM3WWdjQURxeEJPRDA3MTBSczdyWW03Vmp6Y1dzczhGaEVJMmtRM3dqVnM0RGs5QnR6am9mVDhhNG5Vb0RCcmwvQ24zWTdtUlIwNkJpTzNGZW1hN2RSYWpxbG5ORE5ISkl0L2JXNnVpanpIRzFzdGdISk9jY2pyZ1Y1L3JWcXRsNGwxTzJDRkZqdVhRS3lGU0J1UFk4aXVPdDFPaE81NjdZK0lJNGRFOEhHeWNKZlF1WVNyYzVEUk1NNHlPK1AwcnI5RHZmN090OTA5Nmx4ZU9wRTh4a1VndHljRHB4NkFBWTlDYTh3dFA5QnRmRDEzWkpCSmRHQ1Z0aE9EdUJQQko2a2pnVjZOcHVoWDk3WktNUXhFZnZHa1lCZ0MzSndWNmtaOWEwb3l1dFRPY1M4ZGJzSGFTSzFmeVZsNVp6SDBiQXdCejN4K252V0JxVnRGSmJ5UnFDV0lKRW9VWjIvUTR3YzQvT3VsdWRBdG9SQmJ0RERKTHdXblB5cVc0ejdnNEdjWlBTdWZ2NDJ0cnFlMmUzamxrUlBNUmxaRTNnY0VZNEFPTTkrdjE0MTVuWWxKWE1lVkxPUHc1cmR5MTJRMGJ5aUpHL2Q0NFRIR2VwOU1WMGZoeldiS3k4SmFVa2x4dVcydEk4QUtmbGtLOU05enllSzg5MXE0ZDlPMUs1ZzN5MjdTQkZMZ2pETWlGano5QlM2S2JlKzAyT2U0dTdpMWUzd2dpdDRDN3ljRDV0eFVyMjZZNHJCVGQxWTE1Vlk3Ky9odGlrRThWeExGcWJzVml1WVdBSGY1SHljTW5BK1g4dWVhNWJ3YmJhaGQzbXZ6TkZaWUY4eTNWdkdUR1ZKNElUUEdPMkQxejFyUnU3VFY3KzF6WXZkWEVSM0FmYkVqMzlCazhiY2QrT3BBckYrRzhsMnR6ckZ2SkNYSDJsak15NEJ6em5Dc3c5L2NWVFdxMUYwT0F0NUJvWGgrMmx1RHVpbW1CS3huNXVoNC9sK1ZVZkQ5KzUxWmkrNlM1blFvc2hKd0NPMzVjZWc0cmQxQklJOUd0b0hSWlAzVXN6Y1p3eXFCMS80RWZ5ckc4UFdFTWxoTmRTd3BMdGJhUE02WnhrZmp4K1JyektiVGkyK3AweVQ1a2wwUFF0QzB2UzcyRW5VRGJYTnkwNi91MHVDcW9oUFg1VGtEQTZuOUszYnZ3L1phWlBKQnBsNWFtNmJidlV0dFpDZUNBM1B5OEhJYjFGWk1QaVJMbjdKYmFPWjRKMGsybVNDMmVkVlFjN1NRcExEMUFIYklxRlIvWm4vRXdnanViZFhHNktXRzNrZU1IUElZdXFqR2V1UDUxMzNoc2tjN1UyOVdkWG9Xb3N0ckg5bnRibkROdGR3bVVMQUFaR0FBb0hQVDlhNkdmVW04OE95WENlVVRNMXhsQUVVSndwT004bHVtTTlmWG1MUWZFaTZ2QmJXOEppVzZEYnBwRmx5a2FaNlpCK1lrL3c4ZGZUR2Q2UHd6RzdYTFhGOWNUTGNTaVZrWENLcEdNQVlHY2ZLTzliUXFMbDBNWFRmTVlLYW5kV2lxclhVVXM1bUdZR1lqZC9FUUR5ZU0vU3ExNzhRVldSTFZiWnZQa1B5N2ZtVWV4SXo4MytlS2cxRHd6R2wxZExwcUNNeHZzUnBwR2RtSjdmTm4xejJyb2JMdzNiV0VPSkUyd2xDa3JBRXMyUms1STZEcCtWTlZISjNraW5UaWtySG5ueEwxT2FUd1ZHdmx5RVgxekVoM0xncmpMZCt2M2V3cTVhYXhxR2s2SGEyN1JQTUdVUnd6MlpFcVNBNEFVOGphUUNBYzkvcldOOFVyT0syMWp3L3A5cmVSdlp1OGpnSGtyeW8rWTlEakp4K05laHplRC9BUFNIa3QwSW1LN1VsWitxOWNNUDRnY2tjOCttTUNzM0tUazVJYWlsQ3pNRHc1NGR2ZFZSdFR1TlR0L0luakt0RXNYK3JZSEM3aG5rNHp4MEJBNjlhMDlKMG1XZTF0VnQ5UWdta2pEUnQ4dTNjb3lNa0RCNXhnL1NrTmpxYVhyUTJOczloRytQTWprUlFwY0VjcWVqQTU0UDZETmEwZmhxUzN2MWtSM2lQTGIwZjc3Rmoxd0FjOC81eFZ4ZktoTlhGbm11bXRIMDlyZENjWVpsUm5VSFBRS01BL21PRDByeGZ4MURGWmF0cDdQTkkyMiszTkF5NDRJQllnWUhIR0I3VjlFMjBUR0V4VEt1NVQwSFVlaDkvclhpL3dBZXJhRzBsOFBtTFlzaE1wNkRvQ21PbnVUVTFKSnhZNmFzMGEzd2JlMnVQRHVvV3NNa2lDUFVISVhBMjdTQUJ4K2Y1VjVwcS9oOHI4VlUwNFR0NVV1cENGR2piNW8xeW5BOU1BZ0Q2VjZYOEZyRlp0RDFFU01ROGQ5TEhMczR6d3BCejdFSDg2NDYwaVc1L2FFQ1JuY2lhcEllZjluT2YvUWF5azI0bzBpclNaN1Y0dk5wb2ZnWFZwMVFLa1ZtNm9NL3hFYlYvVWl2THZndHBhWCt2MzE3SW9NZGxheHhxQ1A0M0JKL2sxZG44Ykxzd2ZENXJjSG03dW9vdnlKZi93QmxxbDhEZE9lMzhNYWhlc29BdXJzaFBkVUdQNWswUzFtdklJNlJad2ZoT1ZMUDQ5YWdHWlVRNmpjcVMyQUJsMkEvbml2bzdGZk4vaGNKSjhlYjBUQlpRZFN1T1dYcWQ3RUhIMUFyNlFvaHV3bDBFUFdrUmRwSjU1UHJUNkswSUdNb09Nak9LK0xmRUwrZDRuMU9YQUFlNmxiQTkzSnI3U2tZSWpPVGdLTWsxOFMzODNuYWpOTVQvckhMNStwSnFKbEkrb2ZnOS95VGl3NEF3OG5UdjgxZVQvRzZUUHhHMm1NNFd6aHoyenl4L3JqOEs5TytDbHc4M3cvalFwaElwM1ZXL3ZEZy93QXpYbi94L3N2TDhWNlhlRGp6ck1wOWRqay8rejBuckVwYVNPeStDMHRyTFo2cDlualpHRFJicy9SajE3OTY3YnhQRmN0WWJyYjdVN2pQeVF1cXIwNnNUMi9PdUMrQk00ZlJ0UmpPU3dlTTVQZmcvd0NGZW8zRW9QN2dBRjNIQWJnRWQrMUZIM1k2ZVpOVFdSNXZaK0g5Um5udVpMbUp0MGtiYlpwbUVrZkpIQUl4emoyeFZTZnczcUVUdExid1dVdHlTb1RZU3l3bnV4eWNEOWZiRmVvRUphUmJtTnZBaURDbHVnL2xXUmZXZGpQZEJHbGVTNG0rYjVEdHdQcW1DT1BVMXBmVWs4ajhaK0hJckhWOU51V21sbUZ4TGJTTk9BVTRMdnU3OEhwamp0WEFlTkxXR3o4ZWF0QkFra1VJdVNVV1ZpeEFJQnpra2s1em52eFhvUHhPc20vNFNEUmpEcUU4MEVrL2tGR2RuVkR1QkdDVDllT285YTRINGhXUDluK085VHRrQVVCa1lLQ3h4bU5UMWJudldkVHJjdEhmK0ZMWm5id3pjdXF5QjdlOEFJQU93cnNHVDM0VTlQeHIxM1FZNTVkT2padkxodDJYS0pFTWJoNjlPbU1WNDc0RTFCNHJYUW9aSklrWEY3RUdZNUEzQ0FjLzk5R3ZackM3Wk5PaGs4cHBKTmlqZWtZT2Z4QjZDblRmdTJGTmFrMTBWK3l5UXVxbFZQeTloajArdUNhNEsrMHEraGxhZWVhNlJnKzlIVVozSEdPcEo2WitsZDJicUs2RFJYQ2wwQUpPWWlBZi9yaXVZMUM4dlJhM3NiTXpRUU1RSmlGYjVlNjRidmc5Y0h2MHFuTFFTVFBQdGEwZWEwOEo2OFpwQ1lyUytDd0ZEdXk3ZVZsbUovMmNjZHNtdXNpdUpKTlB0QzlqSkhielJyTEpNc09SRzIzam9lTUhuMzlxNGJXTlFlVHd6ZldxU1N5V2N1cmJYazNZU1RFYTQ2bmRuNWZweFhvbGg0a3NOVlJZWVBNMklFQWdoQVpVSVAzVGpBUDF6ajA5YXlqT0pjb3NtdGIyZTAwd3BicTB5N3NCNXNEQytvSGV1UzhBSlBOcUhpQ1ZvdzBpYWlVUHlsaUNXT1NjRUQ4ZWNWME1peXlXWUVzU1IyWlV1SllvZ3JvV09TQmtrbjhCeUs0endKcTE5cFY5cmx4WnVzdHRQY2xUSkt3V1RlU3hWaXVEa0hvUjZrYzFicUxRbmxkbWNIcjh2MmFTM3RzSEUxb3d4NkVzY2svVUFmbFcvd0NFUERGenJrdW42VGJ5N1JJbm55Z2dFSW9QM2lEMTVPTWU5YzM0aEVUVFd3aEpiZEdweHV5d0xGbUk1LzNxOW8rQ25oK2ExdDc3V1ppaFdmRnZEeDh3Qzh0ejZad1ArQS9TdU9sRG5TVE41eWNXMlcvK0VNaDhQUlp1YlMrdWJWQzdLdGsrZW81TERBT1QwNDR3SzdqVHd6dXBNRWtVUVFLSWltT29HZHg2SEdPM3JXdmlnQUFZQXdLN1ZGTFk1MjI5eWtkSnNQTEtMYVFvQzRjN0VDL01DRG5qM0ZXb29saVFLTW5BeGtuSk5TVVZRaGhpakxieWk3dlhITkVXUEtYNlUrbzRmOVFuKzZQNVVBZU4vRUtDUFhQakg0ZDBmWUdqV0pmUHdPcXN6RmgvM3l2NjE3TXFLcXFvQUFIQUhwWGptaHFkWi9hQTFXOEl5dGtXUWUyMUFuODY5bHFZNnRsUFpGUzdzNDdwUUdYNWdRd1ljRUVkT2FzcXUxUVBTblVWUkltSzhHK09jQXZmRWx2RWk1bXQ5TU14N2NlWWY2QS9uWHZWZUwrUFltMWJ4ejRpamlJYzJYaHRnVjlEOHovbmhoK2xSUFlxRzVmK0F5NThMNnBKakFlL1lnZTIwVjUvNEZta24rT0N5S3Evdkx5NVp0M1lIekR4WG9Qd0h3dmcvVU1kZnRoT00vN0Mxd1h3bEJ1dml3ODd4NVpQT1k0UDNTUTMrTlQ5bEZkV2RoOGU3dGxnMEd6QUpWNVpKU1BVcUZBLzlDTmVoK0JkTFhSL0JHazJhanBicTdjOTIrWS9xYTgzK01USnFIalR3enBJR1g2bkgvVFIxVWYrZ212WjRva2hpV0tOUXFJb1ZWQTRBSFFVMThiWkwrRkh6aHBuN2o5b0M3QTR6cXNuNnlmL0FGNitrUjByNXRHWS93Qm9TWUFiYzZxT00rckQvR3ZwSWRLSWJzYzlrTFJSUldoQmtlS0x3NmY0VTFlN1U0YUd6bGRmcUVPSytNWmY5YUQyeHhYMXY4VHJuN044T05iY0VaYUR5K2Y5cGd2OWErVDdtSFpwOXZQakJlUjEvTGIvQUkxbko2bHhXaDlKL0E1bVBnSEJIQXVud2Z3V3VXL2FGU2N6YUZJSWo1Q3JNUE56eHVPejVmeUdhMGZnUnFrcjZYYzZjUXBnUWVjR3p5R0p3UitQSDVWTDhmeEczaExUbnlDNlh3SDB5amY0VWs3eEh0SXovZ0Zldk4vYU51LzhFU2tmVGNmOGE5bG10aEpNc21XM0JTdkJ4ak5lQS9BYStXRHhGZDI3eUFDZUFxb0p4bGdRZjVBMTczYzZqYVcyenpaNGxMdUVBTERyVHBXU2FGUFZrZ2dLUmJmTmtiNjRKL2xXWGQydGxaR1c2WkVTVitCazVMZXdCT00xcHRmV2k4TmRRZzQzY3lEcDYxazN1azJsNHU2NjFGNUk5d2tBTXFxbzkrQlZzZzh5K0pkdmZ0cFZoUGRPc2NhYWlqbFF3TEtXQng5TUN2Ty9pcEM5dDhRYjFaSFppWW9TR2JIekR5d004ZGVsZWxmRkdmdy9Cb2x1TFMrdFo3dDc2SjJSSkJJMkFHQlBjajByem40dWFocHQ5NDVhNDA2U09TRTJxQm1qVXFDd0xEK1dLemV0N21pSnZDOXZMckY1cE5yRzBoV1B6SmRzZkxFalpuQTZkRkg1VjlIYVBwbHhhUnFaNzk3bFZRTEdvVUtxampzQlh6WDRDMXdhRnE5bHFDeENmeVM0TVpiYmtGU090ZWg2aDhYOVRsakxhZlkyMXNoT0M3NWtiOE9nL1NzNktWaHpUZGoyQzZqRXNSVEF5T201Y2o5YTQ3VXZEMFdvNnNpU1hiaXhDanpJWW1DamtuYmtBQVl6bkk5K3RlY1MvRlB4TVhJRjVHdkhhRmZVL3dDT1B3ckV1ZkZtdTNjc2trMnAzWmVaZHJZbHdDUG9NQVZwSjM2Q2pGbXByV2l3d0ovWjZzMDExSjRqYUZTem5CakNKNmREOHk1SXJzcGZER21RelMzTmhkM0Z0SzRJOGxwaVhFZ0h6QVp6MXpqSjljOUs4V2sxWFU3eTh0bSsxeU9WdW51QnVjNUxuYUMyZXVjSVB5cmZUeGhxenQ1a3VvSGRHdzJNVlZpT0FPckE5QU85WkpYZWlOSDZuZnZlUHBMR081MUhlektGVkN2NzJMZ2tCbElJNXhqSUpyalBDOEF2YmpXUXdlV0JwaUR1SStYSmJCYkhUOEFhcHkrSk5ZdVpJMmt2cmlhU0pXMnl1VlpnRG5QT1BjMWc2RnFGMnNsNnNOMWN3Qm55L2xTRk05Y1p4K05Kcm9nWG1TNnBieDNuaTQyNnlENW9WK1lEaFNZeGs4ZEsrZy9oN1BhMkh3N3NrRTZueU42eXNUbmF4WW5uODYrZUw2YnpOZjFqVW9QM2FXNU1jUlhrTVFRZy9BbXRlMHZZM3NyS0xjNitiRzNtRW5rc3ZxTy8zdjFyT2pKeGtrdXc1eDVrejMxZkVNa2tyTUpZZ3F1VUFQUnVCZ2p2ZzVCck9meG5jUnkzVURmWndZSTk1WXlBR3ZEMnZZWVpkakYzQWJyamdELzlkV3JlNFJzbnl5U2VCZ0hpdWh6Wm1xZm1leXplT3JlM1NNdnFGc1MyMGxZeUhJeUFTT1A4L1NyNCtJV2dSeEZwcjBGZ3dVaU9ObTY5K25TdkRmdElhWUtVSXowNHhTNm5xNDAzVG1uS2JsR0ZDampKbzlvNzJIN05XdWUwUy9GSHcvR3AyaThrUE8wTERqZDlNa2ZyaW1QOFR0RnQ0ZGhndkdtVGhvMVJlTWQ4bHNlOWVDTDRtamwwNFRTMmNtNzVRRlVjYzV4ZzB5VFdJcDdhK2Z5Sm9XRVRCWGtiTzRrY2YwcWZiayt6OHpzL2h2NHVzOU0xWFdkYXZvcDVIdnBYWlZqQzUrWmkzT1NQYjg2OUxpK0tlZ01nODFMdUpzNDJtTUhINUd2Q2RKV05OSGdqTzBPVkxESjU1UFVWcFdtbDZwTU1oQjViQWxHZmdjamluQ29yTjNIS0RiUFlUOFdmRC9SWUw5MjU0V0pmL2lxaGsrTEduNzlzR21YcmtkZCtGeDZkTTE1Z21uT2JsSTFudGx1UnV5bThBbjY5NlJOQjFHS1liN3UzQkpKd0pDYy9wVnVwRzI0dlpzOVMvd0NGcFd1Yy93QmtYaFgxUmxKOXVLNGV3OFZXMTU0MDhZYWcxaE50dnJaYlZGZGxVcis3Q25kejdkdldzNU5OdUVqQWt2b3dlQ1NDZWVmcFhQMmNrdHN1bzNLSTA3ZmJwWWdFWGxzWTVOVDdSU2FTWlhKYlZtLzhLdkhObjRZOFBhaERkVzgwaGxsM3FZaU9NSUJ5Q2ZYdlhOZkRmeEgvQU1JOXJ0MXFndHhjU011MFJ0SnQrOW5uT0RYUGFmY3oyOXBlSkZDellKTGZMa0tQZjhqVE5PanVvckJMaUdKMkRaTE9Ca0RIL3dCYkpyV05QbTVWZmNodTEyZC9jK0x6clB4U2cxNjQwLzVMSkk4VzZ5WkoyOGpuSFhKejByMHYvaGJNSEtIU0psa0t0dEpsVXJrQWtaL1N2bjdTcmZVSi9QdWJPMnVKNUdiNWpHaGJHY250V2wvWjNpS1FaL3MrOTV6ejVMZjRWVk9DbGR1U1FTNmFGcE5kbHUvaTNOckN3b2t2MnJ6aEh1eW9LZ0hrK25GZXhMOFV5UXhheWlYQUJBRXBPZlh0WHozcGNjMGZpdG9aSTNGd1drajhzcWQyL0JBR1BYTmRPdWo2OUpsV3NKeHhnWkdLemlsek84ckZXdXRqMVQvaFoxNlJLdmsyb0xBK1d3Sk93NTR6Ni84QTFxeDduNGcrSnB0eUxlV2tLbGdReUlNanB4em11R1RSUEVvR2Y3T2x4VFRvSGlQWmo3SEw3a2tEK1pxclE2elgzaTVYL0tMNHcxN1ZMbXhsaXU5WG51QlBJTjZienRJQkpISFRpdVcxT05WOEw2Y1NSdjhBT2tiajBPQi83TFZuWDlOMVBUdkpHb3hHTXlrbEFTRGtEci9NVW11V0Z3dmh5eHVnbitqZ0JTUWY0aVc3Vk0xSG1TVEdrN1BRditHR1greXhtUXBoeW9JOWV0UWVKc0N3VEVxdis5QngzNkhtbitFclM0MVhUcnF5dEFyWEFkWFhjMk1EdlRmRW5oclZOTHNQdEY2WXRvWWNMSms4OFZNWlF0Sk4yZlliaTlHa1VmRE41OW51NWZrSkcwRW5zQlcrOHNNamx0d3cvWWRxd2ZERmxMcUZ6Tlp3QmZPbVRDbGpnRHYvQUVyY2s4R2E3QXU5MnR3dmJFaEpGVkIwbGZtbFpnMUoyc3JqenFObkN1M2VTQmc0elQwdkxTVVk4b0E5bXp6U1IvRDdXU2Zua3RRZSs1Mi93cTZuZ1hVcmZFa2x6YllBNUM3ei93Q3kxcE9lRlMwbnFKVTZqM2lZK3V2SExad0dOTnJHVmM0UHRXSnI2bGRRaEo3b1FNOWVELzhBWHJmOFIyRFcrblJUQUZkczZvY3FSbmcrbzlxcWVOdEtsMDJTek1zb2NzWDVDTXZaZlVWek9VVzdKbE9Na3RpbnBUS3lZRGJjT0FjZXVEVjkzajhtU1BlV2pCNUdlOVptaVJDNGltalJ5Sk4wZU9PT1dBT2Z6cnVaZmg1SkNTWDFKaUR3UUxZblA2MHFkV25UYlUzWWZKS1NYS2pqWkowUzdDb1dLZ0Erd3JUSlI0OEo5NlBPUjY4VnFEd09wRFhMWGM2S1RnZnVlUDUxZGg4STJhMnEzSXY1OXhISzdSaXRaWWlocHlzU3BWZXFPSnRWTFhUbENkd1k1d2VnT0NNRDhXcldUVG9VWEJHNzVlY25PMzYxa3lFV2ZpZWUxalltTVNDTGNSejlmenJYTTZ4cVV6MHJOU2VxVEtzbnVUdzJzRnY4eWtuUGNtc2ZTQ0JxdXBJaTVHL1AvanhyVVNSR0FBeVFQV3NqVDVGVFY3N2svZkpHUDk3L0FPdlNrd2ExUnZOYXhybzEzOXJSVmFVZWMrM2pxZDJmMUJyMFRRdkIyazZuNFJnbnZJR2FhUkdZU1J5RldIekhHTUgwQXJpSWJacmhtYTRUekxWNEZUWUNDVHlRUVZ6bkdNVjBWaHFrbW1XMzJhT2E0aXRzL0xHZ0FBUGNZYk9CWGl5eEtwTngzZmtidHJxTGYrRzlPaHM1cm1FczR0b1duRU84WmtDQWx1VzljWTRCNlZvSnBSTnZGTloza2laUU50QVE1ejc0ck1pZ3NwUzIyNm1oM29WWU1BTnlzTUVBamdnODlDYTA0WTVMU0pJNDVtZU5Wd3U0WndQeXJscTQxOHFVYjM4eW94YmQ3RkRYNTdiU05KZTUxaTdsYUdWeEhnRVpVa1p5T3ZJeC9QMnJ5cnhSNGtzNzIzanNySWxvVWZjenZ5ejljWndBTWMrbjQxNi9lU3hPUDMwTWNvVVpHOVEzODZ6R24wMkZ5SHRvVi83WXJqK1ZkR0d4clN2T0xiL0Q4aUtsR1V0dEVlR0hVcmtNTnNqWUM3UUNjakZTMnMwcmgwd3pJUUFjazRYbjh1MWU2QzYwd3hncEJDTzQvZHFLNHZ4MXJVczlqQmE3VVdJekJodHh5Y0VkdnJYbzBjZDdXWElvVytabE9nNEs3WnpWNWNRMjE5YVBKYnlTeHgyc2VBbzRKd1NUK1p4WFU2SjRoMUMrbGlrdXJPVDdHQ0VqQmRtMnJqamhlY0FjOU9sV3RQMXZVTk9zNHJTQzZuaWlWZmxWY2hmZit0U2Y4SnZkckp0amNNQWNiM09NZmthenFWVzdwUS9FdFI1WGU1Mmx2YjZEZVI3Z3pPUVA0M0lQMHA5em9HaXpERTFtN292ekRkSzJGOSt2RmNKTjR5MVYzSURxdnFRVHhXWEw0cTFLVS92TDUxUFVzcm5wOWE0NDBxcmQ3dGZNdDFrdWg2ekRieFIyMEVsbkZHMGJkQ3MyNDdSMlBmSjk2NWp3T1o1RHI3UlFTU3NkVG1PRUl5cHozelhFdzZ4ZVNBc05SbmRzWnl6dmpIMHp6VWNMNm12Z2MzVm5JMFpXV1I1U0cyazUyNElIVW4rbGRIc2trMWZkcGFzajJyMzdGN1M3NlN6MHp4eTBjVGtGaXBJWVlUZTBpRFByOTd0VEcxZHRKK0c5bHAwTHZIYzZqS3hCVWc3bytWZjZjWUZjT3NwanNwb2k1M1NzbkhQekFFay8wclkwTFNKTlIxZURmeXNTZ0VZNUE1TmQwNFJpbk9UMFd2M0l5akp2UkhxZmdSVHBIaDlRMFRocDM4eG1VQWpHQUFQWHNhNnRkWmlJT1JjQURCSHlEMStuMXJrSXJTSkFBMzdzRG5ISFQ4YWJLOWpFUWZNa3lldUdBL3BYZ1R4Q25OeXNkRWFyaXJXT0w4NVgrTHM4NmtnZmJtY1p4bmcxN0VOYXNZd1N6M08zZDBJWDA5aDYxNGxiK1dueEVrWmNpTVhERUNUcjlLOU1WckpXeWZLVmV1U0NmNW11N0cxdVRrMDZFMHB0SnUzVTZOUEVPbWJuM000QzRJeU9TTy9hcEJyV2t2dDNISVlIN3k1L01WeU11b1dXOGhKSlNCL3p5VURQNlUxcnRDRGlDNmZQVGUyUDVWdyszYit5YktyTHNjeDhVOVF0NzdYYkdHME9ZNHJiZC93Sm1QOEFRQ3RUeERGcDh2d2tTTkNQdGR1SVpUd1J6dUFJR1J6d3gvS3VIMXFVNmo0c2NSZ2pkSXNTcm5rWXdEK3VhN0h4aUpMYndsY0k3Z1IvSkdpNFBQekQvQ3ZWblVVUFpSNnN3VXJ1VWpDK0YxekhhK0lta21ZQ01Sa2tIdlhkL0U3V3JRK0RYdG95alBjeUlxL056d3diT1B3cnpQd0s0L3RzeGtmZmpJem5HT2E3RHh2cG9Ud3pQS0Zqa01ibzJjbjVlY1pINS9yUmlha1k0cUtmV3hkSnYyVFNPUzhFWDZhWjRodGJ0M1ZRa3FnZ25HUVRnL3pyM2pVciszK3dYSlJsSU1MSGVyK2cvd0RyMTgyYUhINTJyV3NiTTNsdEtvZkhwbXZjbHN3b0lDTVJ4L3JKRGorZFpaalVWT2F2cVZobStWcEhWcmZSU013VTd0all5RFVCMU9Fd05JemdBQTVKZmdZNjF6dzNRcHRTV0ZUais5bitkTmRTdy9lWEs0UFhBSDlSWG4vV1lMZE02ZVptZDhTOVF0cnp3bkVJWjQ1RysweHR0VndjY05XVDhWcm1PNzhPYVRNbU53bEg2eGsvMHJwVm10WTF3ekpLdlVxWWxJL2xYSy9FbTZndS9DNkxIRkNzc2M2dUNxQUhHQ3ZiNjExNGZGMDVWSVFTZS81blBWYnRKczRYdzlKaWNvWHdDVlBHT0NDRFgwR2IrRnZOQ05FWFRPUndTRDcxODYrSDJGdmZ3dTZoOXJxU2hIM2hua1Y2eTJ1U2tobDA4dVFNYnRwSEgxelhSaldveVNaR0hueXhaMkF1SVBMQi9kaFI2S01Db1pibU5ZU0FxRjFQS2hSMHJrSDEyYVBIbXcyY2FZNURUdG44UmsxRVBFY1QvS3NmbVpYYmkxREhIL0FzR3VKUzZvMmRlSndWN2NSUDQwdWJnSUdpRi91MmdBZ2pmMHIyVDdSYXpYaWlDMXNVUUtTMFRLdS90ak9CeHhuMTZWdzl2NGQwUVA1ZzA2N2prM0NRR1M5NmtjOTFKcmFPcHdmTjVWc1luYmhtamtYbjY1UVpyZXZpYWMydVI3R1ZPWExlNTBjZHhwc3pQaTNnUmhqS0dOVGcvVVY1M3BFdHJhZkZiVWtrU0lRU3RJQmtBQmM0YjZkcTZIeTdwNWk1dTVkcmVoVTQvU3FNWGc2SnRYT3JMZlRDZmNTeXNpbFR4anRVVThUU2lwS1VscWk1eWNyTkxZNkhUUlpIVG9mT2lVcUU0a1pPdnZ6VXR4cGRwY1JFd0VnS2ZsMmtFQSt3T2E1MXhxZGhhb0JCNTBDRGdRdHU0K2h3Znl6MXArbjY3Q2wyRmE2VlFRY3hPdXhoOUEzL0FOYXZKblFuSnVwVGxjYmNYb3kzSnAxMHFNdmxLeU5uY001NStuUEg0bjZWbmhrZ2N4bVNTQWpxaU1WVWZndnkvbml1bXR0UVc0SkNESzk5eWtHblNRVzgrZDZMbk9RYXhXSm5CMm1qSndhMk9TYXd2OHMwT3BUYk9QM2NzWWtHUHF1RFZhNWoxRlZKVmJTZGw2a0YwNDdjYzExYjZVSTVESmJ5dkF4T1R0QUtrKzROWnQyMTFhUVRNUXBJQlBtUXAzOTF5YTdhR0s1NUphTXVLdnVjZE5yT3B3Z0FXTnVHL3dDdXZKUDVWek90WGwvcWs4UDI4UXdKRzNCUWNmaWZ3cnF0VTFIZTVrVlVjdW9ET0lNRnYwckFudTdXTXFyb3lienlYVGFSOU9PYTkrakJSZk55MlpsT045TGs5dnFGdEpEKzljWkJ3RzV6L0xtcTA5MHF1U0VNcXR3cmJNWjkrZ3EvYjdIeElnTzBIc1AvQUs5RXNjRXkrWEpEY3NBYzU3VTR3aHpFdEl6dzgxeHRTS054d01LQVdxMUZwaXhiWmIxWGpVamdNdkovRHRVN0JZZHJwYnpCZ01Ba2dESCtOTmdpRTBrWktTYjBPY3lISUgweFJKVzIwR29wanJocHRSU0xUN0xUNUxlSXZtZTVrVWIyUWNrRFBia0g4cXQ2MWEvWXRKdTVsMVYvbm1XVlVCQ2pkNkRIUFEvcFdMcmVxWE5yY0pFSTFSdW8zZk1HSFBQK2VlS29tMjFqVXJhSmhhUDltSkxOTkZHV1VET0NTUm5HS3VsaDVlN0s5bzcrcGxVbEZYaXR4Z2dpWm9ZN3BYZ21Qeks0K1lPcHp6Z2ZoK1ZkcHA4eVJ3ZWZhMnNwYzRVc295VDdjVmkyOXlsanFpNEhuQUpzVnBWNHdvN0R2V3BIcUwzMEx0SE1VWTRLanl5QVBZVmhpM0twYlRRMHBRUzB2cWFUejNEZ1BOS0xkVDJBNVA0MDJMVnJXS1RkR3lSbGpqekFOeEI5ejJyT2R4RTZmNnFSeVBuejgyYzlPdmJnMVBPMXRIc2t1UmprNUpPMUZPTWpQNi9sWEQ3SmR2dU5MVzFPWlc1RWZpZWU1TWgyK2UvempzTTlhN1Z5WTMzVHlHUWRja2piaXVDc1IvYWVzbGxLUm9aTi9QVEFQU3ZVdE1odDQ3U0h6WW9wWlFnVmllY2tjWngycmJNSktDajNNNlYzZXhERTAyM0VNQWpVOGdqa244S3V2YnpXOWxOYzNNN0JVUXNRM0dNRDBGUlBxK0hkSVpvVjJjc2lZM0Q5YTV2VXRjdTlYMDZlenRrOHpjcEJkM1ZXS2c4a0R1T3hyejZkT3BWZHJXWFUxY3JHQjRZVTNIaXUxa2xIM1hNblBjOG11cytJc3N0eDRiUS9kVkoxWWoxNEkvclhKNlhvK3RXOThrME1rRnVZdnV0SzJTZmJBelc5clVsM1A0WHVZSm5XUndtOTMyNEIya0hqOHE5TEVjc3NWVG5GcDJNb1A5MjBjcjRTbjhyV1V3MjBrRURQZm9jVjNuamUrdUQ0VW1qVURhem9yQUFjTG4vSEZlWmFQS0l0VWdjaitMQk9hOUMxMmNQWVhOcDh2elc1YkJIM3VPb1BybXRNYkg5L0NkZ3BTL2R0SEQ2RklGdjQ5dVNjZzhjZERYcVp1WGxHMVpXbGIrNkNUK2VLOGswbVpJcjVXZmdESTZaN1YzcTYwSjFSSW81WlhBNVZDUUI5YWpNYVRtNHRJVktWbHVicTNCdHY5ZThVWHNUeWZ3Rk51TmFoalVZbWJyMUM0SDYvNFZnRjNsT0pMaFlzWi9keElTeCtwLzhBclZadDdPYUVySXRyc1hPZk91ZVRqMnpYbU9qQmF6Wm81c3ZmMmswMFdZN2QyWFA4UnhuOFRqTlpQaVlPL2gyNUhseEFMc0p4a3Q5NFZzQllsVkhlNCswK3kvZC96OWFnOFFTeXQ0YXY0Z2tLeG1JazRYQnlPZjZVVXBLTldQS3VxL01VbmRNODQwOEg3YW1DUVFSajJyMXFId3RkM2lwOXBsYVh1MlpEai9QNFY1Qll1QmNxZW9QM3NmNFY2Mi9qZXlzNEVpa3pKTVZHRWorWjg0OU1lOWQyYlJydHg5aXRkVEtrMGxxWGg0VWlzZ0NMQ0VPTUVaQmIrZkZTUzJFeS9kQVJCNkFkUGJtc21QeEg0aHZGTGFacGFXeWs0TWwwd1h0L2RwWFhYcmxtKzI2MUlBT2lXc1NnWTc1SjVyeHZaMXIvQUwyUysrNy9BRk51WmRFYXNtbFdRWmZ0TWt4Y2dFRHpGSDZET1JWV2E5MFBUMkRUTEFIVWRIbU9DUjJ3YWhObGJ6T1RjeHpTRWpuelMvT01lcHdLa1A4QVoxakN5TGF3cm4wUUEwa2xzMjMrQVhsMklwZkZWcEpBVnNkSW51bWZPREdTZzQ2ODUvS3Evd0J0MWU1Q2lhMWcwK054L0dXY2crNEFINjFkTjlaeUVTeU1FNDZEZ0dxOXhxZW1pTWVaZEVGZVNRZHhQNGsxcEJKYVJoK2Ivd0NCK0FKdnF6ZWFXd2FOakc1aUFCT1VicHhrOGM1NDlxeHJLOHNmRXRySzlqSEZlV3lTZVczbXg3R0p4bmpJK25wV0lMOENOb3I2MytWdVBNM2JrT1BjZFBYa1ZxYWZxMFVFVVMyNGpFRzM1ZHZRNTlDTzlQNnU2Y0cxZHZwMkxVcnNkYmFMcWR0cWtseXQyOW5iNFVRUXJ5T003Z3dQeW42akZhc0Y1ZFJPM25wQmRMMmtoT3h2eEJ5UC9IcW1UVkFZdnZaUS9lSGVrYTRzM1k3VkNOME9CV0ZTck9mOFNQOEFYNW1rVmJRc1E2cGJ6M0gyUVBzbjZxci9BQ2svN3Zadnd6Vmk1VGFva09IT1RrSGpQNDFsdUV1TXhwNVVpc01NR1VNRCtITlowemFtOHdzN1FuSks3NHNiZ3EvWHFPL1U0cThMaGZhMUVxZS9ZdUxqR0xsSWcxS0NLUzhLV1ZydVlra2lNWnJLMXJTdkswK083MUd6MlFLK3haSlkrTnh6K3ZCL0t2VDlLc0xUVDR0eXdnU25HNTJiY1NhelBpTEY5dThDNmhHT1hRTEtwUHFIQlA2WnI3aW5sMHFVRnpPN1I1TThiR1V2ZFdoeWVqNkRjMytseDNkcmJpUzJZa0lWS2dOemc0SFhyVjlmQ2QvS3BBczJYUEdEai9HdGI0VzNaUGd5S01uSlNSZ1BweC9YTmRyNTQ0OXExbzROU2dwWE1xdUtjWk5XUE8zK0grb3lBSGRBcFU5Q3gvd3BFK0hWMnFjL1oyWTlTSGJuOEs5Rk1vWTRQU2xFK09sYlJ3VUVZdkZ5UE5MbjRaejNLaEpWdDNBL3Y5dnBYazltdDdwT3QzK25XMXpOQ2RzMEV5SzJBd1VFRUhzUjFyNmsrMFo2MTg3YWxjeHA4Uzlaait4VHRMYzNGeGJvRlRKVXlaVXVCOURuNkdvcTRkVTByZFM2ZFp6ZXB5OWhMOW11bzVIQWxTUFBEOGhlZW85T2E2N1RsZzFQVUxlQ0tKWHVwQ29RRnlBUzNhcU9nNlFYSGl5d2w1a3RyQjJVNC9pamtScy8rTzFXMHlLOHRyR0RYb0EyMjNuVkNRT0JqQnorb3JocTRaenM5VHBoV1VibldhekpmYUJFRW4waVVUS2czYkl2M0lIUFUxeDA0MUhXM1dhOWtNRnJrc3NZWEM4ZW5ZbXZvM1E5WGcxelJZTHJDdDVpRGNPdlBjVmllS1BBbW5hK2dsdEcrd1h3L3dDVzhRKzhNSGhoMEk2ZmxXME1yakNQUFIzZmNoNDY3NWFoNG5KWlR3Q01XeE9SamphTUgwSi94cTFaNnZxRnZxYURWYmwxaUdWS3JqT1QwUEZaOTFMY0cvbjBuVU1RWE1MR0luYjNIRlEzUGh1OWdzeGVUUnl5V2hPQkpDQVJuT1BhdUwyU2Q0Vk4vUTZlZGFPQjFGMjBldktFamtuOGxRQ1VRWURqSnlmeHFDMDAyeHQ1VzMyOG9JKzRDK2NmbFdmcDB0MURiQmJkbWJDakNzaEF4Nlk3VXllOXZ2dGlOSkNRQXdPM1BCL0xyV0hzbmJrZzlEYjNYN3pXcDA4Vi9CRXgrVmNBRDNxQzkyMytsenJrdDhqcUQ2Y2RlZndyQXViNk43c1NOSzZIQUJqaUlIOUtwYW5yWmpVd3dPY0VGY2RnUGYxTlpSd2o1bHk3a3lta21aTnUySmtmUEFJelhvQWtrMUhTVml0akcwb1Y0V2Q4WkJ4NmtWNTNGS2l4Z1pHNnVnMGpYQmIzS3N3S0YxdytCa01SME5kbUxwU2tycGJHTkpyWm1FTjhGNkZiY3BSeURuc1FhN3ZSWVpMaXc4dUdRb3lBaGlNQTR6ajh1TTF4ZW9IemRTbmtENTNTRnMrcDcxMGVnNmlWdW9YUWdzQUVPUjhwNElINmdWT0tqS2RLNjNDbm8yanFZTGV5c1NCY3VnbTY1TW1lYXNrNWpWNVZYeTJKQ2xjc28vUHZXWmU2akZiU3RKTk1nZVJlWSt1VDdLS3pQN2F2THVBUVcwSUNzZHFzN1lVRHY4dlN2R1ZDcFAzbWJiSFN6elJXc2F6U0FSeGdFRnhnZnJ6V1RkNnF1b1c4dGxwNnpYWmtSbFlLRHRHUjZ0V2VkQ2RtZ3VaYmtTT1NDRHg1WS84QXJWclJDWm9mTG52SUN1UVZDSnRDblBUL0FDS3RVNmNMTk83L0FLL3JvSHZQWkhua0FNWkJ3UXc0SU5lamFHMFF0VnVvSUlRN0RtVE9HT1BYUGJwWG45eW5sYWpkeGtjck80eCtOYnRocU56YldJanRpVzY1Ry9hRjkvclhvNHltNnNOREduWk96TzYvdE5WaUVseEtxWjRKSEtLZlFuTlZKdkZOb0VYeWxqblhkMnllZmF1VmJVSTh5Q2VlV2JBNVpoa2ZRRTlhelpOV1JDWTdTMWp4akc0aXZQaGw4WmJvMWxWc3REc3JqWGRRbTN1ei9aWWh4bDMyay9RZWxZTjM0amFNa1J5bVp4L0VPQitacmxwUDNzclpsK2JxZDNBcDhZZlp1VStaaXUybmdhY0RubFViTkY5VzFDNmI3NmtlaXFBQitPS2pabWNrM0Voa1A5MEhnVkVoblk0RVROZ1pLcU1qNjFKSGFseURJeklNOGc4VnZhTWR0Q2RXZERHSG1reFozUlI0OG55cE04ZTNQSXFWOTBTdDVzTHhPZVhhREdEN2tEcitWSDJvU01UcUVDTW5IekZEdUhQSFBVVnB3eGk1alQ3RklXaHhuREVIOEEzNDl4WG1UbHk3L3dCZlAvTTZVcmxhM3UzUXE4VXFOR1JqZEZrZHMvZEpJL2xWcUxXby9QMk5nOGNidTlVTDZ6Z2pJbThsclNRSEFKK1VIMkpISDYweXpnRTRmL1NvMmtiblpLTUszMFlmNFZMaENVZVlwT1MwUjBUM3FKYllpWUkvSHpKZ1lGUlByOXdqb3llYjV1Y0FyazcvQUdPS3pKZE12aWpNSVpWSTdPY2owNFlWaHBlVEdWYmRZaThqdnRLRVk3MXRncUtWUk9uOFMrODFuTmN0cEk5bHRMc3ZHbTdoOW95Q2FqMVZXdmRIdTdWY2xwSVhDNDY1SU9NZmpXQm9sbTFoR3UrTkZmR003Zm1BOUFjbml0cFh6eGpyblAwcjcyRVc0cm5WbWZNMUdveWZLN281YjRWYWc0MHk1dEg0ZUo4N0NQd05lanBMdVBhdkpQQm1kUDhBSDJxNmFpYkZMeWJGemtCYzdoK2xlc1F4OHFPK0s1TVBKUnBXN1hSdlZpNVR1dXFMQXp5ZDFOWm5VZTFTQ0ZqZzlNMUhNcm9Na2c0UFd0STFFM2E1RHBNajgwZ1pyd3JWMjFSZmkvSk5CYkNTNUYwSGlpWWtxeWdZQlA4QXdFWnIycDdnZzVJL0N2RnBkZWlrK0xodlZtVVFwY2VVSDdZQzdUK0hCL09saUV2ZHYzQ2hkTjI3RzdwTVN6ZkVUeGZicUJ0bHNwVXgyeWRuOWFqOEIyMGVwZUJOUzAyVUFzTG9kUjB6dEg5S2w4TlR4emZGRHhDNFlFbENvSVBZRlFmMXFQd25ldzJmaWZYZE5KSVkzR1FEN05qK1pxSUpLVVplYkxrM1pwZGthdnc1MUdTeXViM1JKbUlhR1FsUVQvS3ZSaE9meHJ5dSt1VTBYeC9iRmlFKzFEa2tkZWNBWi9HdlJWbEk1SjYxMFlkS01YRHN6Q3ZxMUx1ZUgvRUxuNGwzMnhBRG1FL1UrV2hyMnJ3N3Bkdk40UDAreXVJa2RHdDBabEl5Q1NBMzg2OFkrSWcyL0VRdm5IbUpFU2Z3eC9TdmJ2RDhtM1JyQlR4aUNNZitPaXVLbkg5OVV2OEExcWRjbis2aFlzdDRWMGlRSC9Rb2xKN2hSWEVlSmZBWDJiN1RmV3NwYUNLTXllUzZaNUhYQnIxRldVZ2Z6cHp4Sk5DeU9BeU1OcEI3ZzFuVnAwcHEwb2x3bE9MdW1mS21xWEVFMlh0NENaY0Q1bGJqL3dDdlhQc3NqTVN5dHVQdFhVWHRvbmhqeDc5am1VR0MxdkJ3UmtOSHV5UDBydGZIUHc0dDdUVHA5WTBNeWJnNWxhQld5dXc4bmI5T3Ywcm1wVW55MmowTjV6VGZ2SGxOclp2UGN4UnQ4Z2tiYUMzRmQzbzhlbndXTnRNMXVyU1JzNFB5NUpBeXhQNUN1SGd2Wi9OalZwV0tBOUNhMmJkRFBFajJ0NEkzM0VCU1NlMlA1VnlZbUxsWk4yUjBVbkZKMk02L3VZcm5VYmlRSEtzNXdkdU0vaDJxM3AxeVRwOHR2RXdFeXlBcU05UjMvcFdKY2VaOW9rODBFU2JqdXlNYzBrWkliSkJ4N0d0M1RUall4NS9ldWR5cGkxRUcrUjRKTHUzQVZ4SXArYmpyMTY5ZnlxVlpXbXVENWJ1a1lPZHFjQmVuYzlLNTZDeXQ1WUVlQlpZNXR2REZ1dWU5RU9tM0hudUpaWDgxZ2Z1bjd3K3RjTTZjVzNlUjFYZHRqcjExSzB0NEVTY3g0T1I1aXk3Y1k3LzV4V2JlYThza1lTRjMySm5hNGoyL2tRUi9XdWFsc0pMYzhuTVk2NS9oUHBpcTB0ek9GRWJ2bFYrN2dkS1ZQQjA3M1R1UktxMXBZbmR6SkpOS3hPNTN6ejFxNWJzWHMzUVNCV0hJSi96OWF4eklONjRMZWhKcTNCTXdERlR5RkpCSHFLNnB3ME1FOVNadDdaUG5mTU8yZVByUWJYNWQ1a0lHY1k3VkpCUDU4SG14N0Vib3dWQm1ya09sWEV3RGVXeFZqOHd4MStvcktVK1hmUU9Wdll6aW9kbVJ6dEE2WUhOSkVDbVZJSWJzY1lINjF1UTZUdmJKaVlNaDVBRzRZK3VNaXJnc0NwSUVZYU1FL0pLR0lPY1lBendLeWVJaXRDdll2Y3E2ZmJ4M0NobzUyUEh6SXVSMEhQU3B0MXJHcXVaV3lNOEVaL1hyVVRSUEJjaTRTMkZ1NkxsbkViRmZ5UEg2WXBZVEpBbHd5d3pCSGJKS3c0L0VHc0pLN3ZjcFJzWEUxV2FaQXM2cEtxREFaVG45YW5FMXN5cVlibVMzbVhMYlZ3TW4zUFEvU3FkL28xMVlQNXRzaWlNNXpzWURIcldaTGNUQkhhU01PcE9BNjRCQi9EZzFFYWNKNndZY3pUMU5zYTdmQ0tPTjdkcnFJY2VidEtuUHYyeFV2MjIwWXNsM2FHd2tQSG1NY2JzK2g2Zm5WQzF1QkNBb2FTTUE4Ymx3Uld5TDFKSWxXN2ppbVFqREs2WUREMSt0WjFJcUwwajkzOVdORTc5UjF0Zlh1bFJDVkRETmE3Z3Fya1p4N0RQOHFxVHdRWGw3RmVXSVFzWHhKRmdQdDQ2a0gvUEZXNHRQMDI1czJnV0ZvWm90M2trTjkwbnVNY0g4YVVhUEFrMFNUQVlZWWxaU1EvWFBicmpDOXoxUEFyU2hWaEdYT3RHamF6bEd6Mk4vVGttUStaSnVJS2JmdWhUMXlPQUszN0tONUZHUjcvcldQb01PbjJNRWl6M0dBemNGM1BYOFRnZEs2bXhtczBneEhKSEp5U0dEQTVGZlNVTWJ6dHpqcmM4eXRoMGtvczg3MVMzT2lmRnpUN3AySWkxQlU1UElCKzRSK1FCL0d2VzRsVmE4aytMTWdpbjBiVmJjWW50NVdqemdIUFJsL1VIODY5QTBqV1cxSFNMVy9lUHkvT2lWeW5vU0t6NW5kK1k3ZTZqZmtuVlFNOERwVUwzQUtZR1RXYnFOdzBNQWJzdytYNjFCRGVMRlpyNXpqYzJTRDY1cW96U1ltblk1dng5cVdxNmJwTXR6cGthcWlMbVNYekZCWFBvcEJ6K0hQTmVJV2tnc21TL3VMYVNYek4vbGx2bFV0NjU3NEo2VjlFNnRwVnByV21td3VXazhxYmFYQ25CT0NHeG5IdFhudnhLMEN4MDN3MWFDMGdFYXhYVFkycUFGRGhpUjlNZ1lyU3ExTlh2c1p3VGpwWTU3d1Zwa2VxZUxib1EzRThLUXFaWXpFNUJZQmxHQ2U0NXEweW1QNHV6d0lTb21sQWIrSHFvYlB2eUtoK0hGNFlmRUtJbHVEdnRqRzBnYnA4d09UeCtINVV2aU9Sckw0ckpPaEFQbXdzQzJRTUZWRkVaTDJhZm1EaStkK2gwSHhLUm9GMHJWRSsvQlB0TGZxUDVHdTRzcnNYVmxEY0prcEpHR1gxNUZjdjhBRWFGWmZCOXc1WEpoa2pjZjk5WS85bXFid1JlZmF2Q1ZzV1B6UlpqT1BRZFA1MTNRbW80aHJ1amtsQnVrdkpuQ2ZFYzQ4YndzZitlTWY4elhzZWlUQmJDekhVZVNuSC9BUlhqZnhMQlh4YmJ0bkpOc2gvOEFIbXIxSFRKU2RMczJ6bk1DY2pqK0VWRkZYcjFDNmphcFFPK2lsalpCeFVxVHhxTVpRajNiRmNQOW93Q2VTZnJTRzVPUUFCaXFlQ3YxR3NTbDBQT1BqUllMQjRxdHRTaENoTHVIbkJ6ODZIQi9RclhwSGhqV0UxTHdicDl4SSs5bXR3anFSMVlmS2Y1VndueFNUN1JvbHRPRi93QlRQanIyWUgvQVV2dzIxRFBocTVnTzNNTXBiM3dRUGYyckdGTDJkZmtmVkZ5bnowdVk4c3ZFV0srdUVUN3F5TW8rZ05kbjRFOE9SNnhjU1RUL0FDMjl2alBxekd1SWtjeVN1NXhsaVR4WHNQdzZWSU5BZkp6SThvTEFIcHdNVnkwSVJxVlZHV3hyVms0VTI0bm5mak5ZWVBGZDlEYXdtQ09OZ20zMXdCejlEV1ZCZXpSaFVCREtEbmFRRHorTmRKOFNOcDhYeWtER1lvOCsvRmN4Ym9HV1FZK2JIeS9YTlJYaWxPU3QxTHBTZkttZERwa0IxV1NRV3NFcVRSUjVMTHlneDYxSGRTNmpaeGtTeE1RZlRQVDFyYTBWWnRHaGtoY2xIa0FMSHJqSDBxenFCVlFyWERQendDVG5OQ3djSEJTZTVmdHBjMXVoeE0xN0pjRWJqazUrNlBXbzMzc3U5dnVEUHlyeGlydXIyNkFoN2RBUmsvZEdLeUR2YzdjWTlxemRMbDBIejNIU3orWXFxRVZRUFFkYXRhVE84VjhqQmQ0d2ZreG5keDBwYmZUMUJqa21EUEdUeXFmeXJ0ZE9qZ2xpaVJMTHlJaU1nbDFPT2VEOWE1Y1JYakNOa3Jta0tjcE15OU1qaUJHNnhRR01iczVLOGVoejc5SzZCVVdTUGNyNUJYSmlBemcreDllOVVMeUEzSG5XMG9MRUhLRkhJSUhxYzhZL0EwelN0VzAreUt3WE53Q3dZcVNpN2xJLzNzOC9sWG4xZWFvdVpiblFseTZNMG9ZQ3R3b04yUXFMbmJJd3lENmY1L09yTWtna2hWVUFjTDFDa0VBWjlQU3FFdDNZWEN2TkVaTHFNTHp2TzdaL3dFQ29qcWtBS3hwTENtNEhheXFxNUg1Vnp1bk51OWl0aTBKL2ttU1JKQ1B1THVmYVQzeHlEeFZHZTRpWWtzcWladVNrWTVCOWprVTJTMm51N2xKSmJpMllBbnkzUUF2Z2RzWTRxekRkUkxhT0pMWmpJallMN2VHT2V1YTBzb3E2MUlzMmRoOWcvYzVER1ZpMmRwNXdPNCt0WWwzb3l4aDhXaENrazdNOS9XdFZOWW51Umh4RVVBQkppWUFwbjYvalYrTzlnbTJoWEFqSkFVNUpKYjA1NzE1U2xWcE81bzZhNkhJdzJqU3d5V3JSSW9QVGV2Qjc5YXJIUXBsV1FXMGdRNEdVbEpJSDA3MTJEMkt5WFJ3V1ZzWTJ2MUp6NlZuUzJlWHpobzlyRmZNQndmOEFQK0ZkRU1UTG9adWt6bGxqMUMwM05QYm1SR1Azb1d5UldsQktrOXNIU1NPUXEyZHNxbks1SDgveHJSbnRpTGxCYTNNVWpOaG5EakIyOFk0eU1WVnY5TE9mUHRXOHFRNXhoc2grZXBIb09QZm11aU5WU2tyNk1VSXVMR1I2ckdSODVqd21kcWdqR1BmK1ZhTmpyYVJMdUM3V2ZCT2ZsVW4vQUQvS3VUdXo1Yyt5N2dhUEs1RHhydUdldjFBNmpwVks1bHQ0bVZZOVFaQzJOeUVFWTQ2NVAxcjFNTWxEYnFPckxtV3AxdmpqVWpxZWhTQlkxMlF1cjV4MTZESVBweWVhdTZkcndYUnJDYWFUeTdkSVk0MlBxUU1kdmNWeXIyenoyTWlHN2xLT3ArVTQybmp2Z2RLaThQb3R4Q3NyNEFqR3dMamdjOG12UVN2Slc2bkxzbWRhZkVjMThnQWVUY1cyaEN4d2d6eDZkZ1B6cXkrdEh6STRUSkwrNUNzNHp3ZXZTdWJrczRGdXQwVGdGV0o0UC8xNmVzdXhwV2NxUVdIUDA0cTQwM2V6SmJPeHR0V2FTWXMwamJGQXh6NjhWekh4QnYwdnRCZVBmdUVVaXlMam4yT2YrK3FEZEZJVElqbFl5TVZ6ZXF6eVhWak1paG1YeTJJNE9EMC93cmVjRkdOa3RUTk83dVFlQXI4V3V2T1hSMlY0U2loUDRTV1dwUGlGTDV2aWlHNWlCVU5BbU05Y2drZjBxbDRSQ3JyTWJBNXhBekgyNXhWdngwKytheFlMaGxSZ1c5UmtmNG1wVVY3Qnk4eE9WcWlSNkg0a2IrMHZDRitnQkxQYjc4RDFHRy9wWEovRFRVRVNTN3NIT0N5cktudmpnL3pGZEpZWEl1ZEh0Mno4clJMblBQYm12TnZETE5wL2lxMlZ0MjVaWGhZQTQ5Ui9uNlYwMVh5MUtjMTFNSWU5R1VUWStKcXFOZHNaQVI4MEdEK0RuL0d2UXRGbFZ0R3NtM2RZRTYvUVY1MThSU0h2ckJnTU5zWUU1ejNIK05kZm90eVYwaTBYZ2dSS09UN1ZyUWovQUxSTkVWSCs1aXpvM2tUakJGUW1VTGtjZXRaejNRQ1lMS3ZOTmp1OTIwTklRYzhqRmVnbFpISzNjZzhWcUxyd3RmeHNNa1I3eGovWk9mNlZ4UGdPOE52SHFpY1krenRKei9zaXU5dVkxbnRwNEhJWVNJVXczZklyeWpSRmxGemQyeU1WZVNDU1BqMUl4ajg2ODNHdmtxeG12Ni9xNTFZWmMwSlJNZFFXY0FESkp4WHNuaEtNd2FGRTRVS1pDVy9MaitsZU93bkU4WjlHRmUxNlVkbWsycWs1UGxEbjhNMWhnRisrNXV5TmNVMzdPeTdubTNqMmZ6dkZkeDgrN1lpTHdlbnk5UDFxdjRWMDMrME5idGt6bEZiekpCNkJlZjF3QitOVWRjRGpYTDRTSGN3bmNidlhrMTFudzZoSW52Ym9qNVkwQ2RPdWVmNmZyV2FYdGNScjFaYjl5bHAyT24xUHcvYnpSczhLZnZjOERQRlVydlM0b0FQTWtERURHQ2VCZ2RhczZqclVrTnpzalVjZXZjMWtUM3ozY3J5amJHWEdjR3ZVcVNwN2RUbXB4cWFYMktWd2ltRmpHeWhRVkdldU1rQ29JTFdPZlRMbVc1VkdlS1JsejZnZWxQa0x6SXl4WlZYWURHZU9UajlLaVM0Wk5CMU9NeHB1Tnl3NTRQSlhQODY4eXJHTW5yMk8yTW1rVjc3UXBvYllUUVhFaFEvZWpQcCtGUXpUdkJFbXg1VkxKdDI0S2tFY2NjK2xiUGlEVUk0OUtUYWM3bVg1YzllcHJIR3AyMTBtMjVpQmJid1NmdW12UHF3Y1hhMTBkTk9TYUpFc0o3OEVQZEpCR2NjTVJ1Si96NzFveGFab0VGdVlwV2tlVW5LU2c0NTc0SCtOWTh1alhKUlpvWmhKQklkMlNwNmV0Vnlzc0ovMHBYODFTRjljcjB5T2xZVHB5ZW5OYjAwTGpKYjJOZTUwZTB0VmorejNSSWt6djN1QURucHgycU9NK1JNdSt5UzRWVkNmdXp3S3JpMU50TW91NDR5Z0Nrb3dHNEFnRWZUT1IrZGFkdHBJZTFtTzJPS1ZRQ3FSUHNEcjZGc0hrSEhUODZoclQzbmNlNzBSQk85M2J0SVNMaU9Bc1dSdnVqSHB6em1oTmFpdGtuU1pKN2lOdWl5dUR6MTZBVllYUnJpYUY3TnJieTdqRzRaY3laSFVBSE9PZmIxcXRwT2p6eVJiTDBlU0E3WlZrNVlFQVZQN3UzdmRCMm5kV09rbDByVmRQWmpHclNJVGtZOVBwMnA5bnFzZ21NYzl2NW1RV3dueXQzL0xrVjF4dUZubkxNcERrWUljZ2JqOWZyNlZYdUlyZlppNnRZeTY4Rmw0d1NQVDYrL2V2QldKNWxhY2RUVnc1ZmhabWYyaWx4NWNjaHdpdHdHNGZqZ1ZZRjdIYndDUzVnZVZEMVpVT0ZPZjhNVThhVWdiZkhoam5wSWMrNXdhcVhPWWxlTHo1NGticmdieCtHUitINDBsS25PeVErYnVhVHgya3J4eXBidS9ta0JncDVHT2hKUFRxZWFiRmJSeWw3WVJ0REpHVCs4YkRibE9NRUFIanJXUkw5a3VJbmVBR09SVkd3UXRnRWpBUGJqcm44NmJieXMyd3gza3FZNnBOSGc1eG5qQXEvWjZYVEx2RjZ0RHRYc3BJWlVpdVU4cG5YTWJweXJZUEk5aU9lUGVxMTc0ZDAvVVhNVXNUcE1xajcvR0Z6eWMrMWFpYWcwS0xIZlJDYUlzR1hmampJSXlQYkZNa3ZvR3k4RTZ1WXlVZU1waDFYUEdNZHY4QjFycnBUbWtyRHRGN21icXVpVzBGa3NLeGhsQUFWVnlDQ09lZlExbTZacDV0cmVTVURjb3h3Yzhja1lQNkg4YTNFbkY3Y3ozRUUwd1VCZmx5QUcrdmZQSFgycTFjMzF0YlN5UjNhcWtMTHU4N0JJSUhSampzTVYxMDhYVnB0ZFd2NnNaU29RYU1DY1J3RjdoamdZOWNjbXFzektFSVZ3VkdjRSt1YXYzSnM5UlMzZUdWWFVFL2RJeG5BNTZldWZ6RlY1RmlaVDh1Vnh5RkZleFR4eW5GdTFtY2J3N2krNVhiVVdraVdFcVBMN2NjNXFDNTJwYVNZSitTTml1VDFPRFZsYlJGbFU0T1A3cGJCRlB2YldJMlZ3V21jQXhrWjNkT0tmMTcrWkI5VzdITitGbkVlcnEyTWdXN1ovUHRVbmllNmt1aEMyTUtneGdqKzluL3dDSnFUUTlNLzAwenF5dWlSNHlEa0UrbWUxUzMra1NUV2x3SW5Fcmg5NUhRTDdaOWdhcU9JajdMa3VadWhMbjVyR3ZvdXBlWm90cEVtY3F1MXNrZXRjN3JrSDJmWExoMWJBWXBNaEhHVDMvQUZ6V3RwbW52YWFmR0M2RnZ2WlU1eUR5S3pQRUt5UGVXMkV3WFVwODNHZWYvcjF2VW43VERLejJNMVQ1S3IwRThVVENjV1REbmhpT2M1QjIxMUdtZkxwOXM1T2RxRFA1VndWN2RHYTF0RWJkdmlES2VCakdSaitWZGhZM0JUVG9veWNuWUNDUHdyVERUY3F6bDVmNUVWWWZ1MHZNMmpKdlRHUjk0MEJtZVJNSEFISng2MW1DNktFOGtucmowcTdhM0srV3dKR1J5YytsZWhUcTh6MU9XZE54VnpTZVZqSGpJTGUxZVpSeW0wOFdTTm5HSjMvbWE3Nlc4VHlzcWNFNTdWd0dzcjVPdWVjd0ozQlhPZnBnL3dBcTVNeDFpbWpiQ3hhYk02VVJqVW5DZjZzU25iOU0xNi9iWEpTeWhDbnBHb3hqMnJ4eEFUS3ZKeVRYcWNETkpaS1dZS1dqSEFIS25GVGw2VG5JZUtUU1I1bnFzNjNlcjNkd2hKU1dabUJJeHdUWG9mZ2tyYmFDMjNibVdWaWZwZ0QrbGVheXgrUmRTUkVoaWpsYzQ5RGl2UWZETW5sYUZBUVB2YmovQU9QR293VWVldnI1anhHbExRMWRSc29KNG5aZjlZUmtITmN4Rk45bWNpNStZNTUybnZYUjNZZWUyWUlCOHc1NHJsSlFzTTMyZWRlVllsTTl2eHJzeE5CWFRpWjBhanRaZzF5cjNTTU40Qzg1OVNLemhMTE5jelc1dzI2NDh3aHVuSFhuOHF2TVF3VWhGQXlOM1BhczIxVmpkM0VrYkVsV1B5RTUzQThHdk9xVW1rcnZjNlZLL1FtOFNTNW10NGlNRUtYK3VULzlhc3Exak05MUhDT1M3YmVLczZ5VmE3UUt4YkVZSEk5elVlbEkvd0J1UjBYSlhMQ3NaSk9WaWszWTdhUzlnV3lNY2tiREVXeERucGdkTUNzczNXNitrakwrWkRKSGhVWnR2ZnIwNjFNUnY4dVp4ODJWRFpIcndSU0tJQmxtVlVrWGdaSHA3VlZaMDV5dFljT2VLdmN3OVNrbGp1OThRVm95QmpBL242L1d1cHRwVjAxN1NTNWtRTTdSbGxZQTQzRWtnZ2pIQTVySWExU09ZdkRMSEpJaXFXVnVNQmpqT1BiK29xS1pScVVUV3lLVnZZUVhCSjRrd01zdWZYakk5ZVIxeFhEVlVaT3kyTjROclZtcEZkeldWKzhjY2tiWmZZdk81VkJZY2dkTzJLc3k2a0JlbGc2WkRIc01mU3VlMXNTMkdvUktZekN6Vzhia0U1NUtqbjhldjQwc0dtNmpmd3BKREdxUVp5SkpDQm4zQTYxZzhPcGFteXEyMFBYSW1XTmQwc2lPb1hsbFB6RWVuMXF6REZINUxJMC9IYmYxNXo2WXhVSkdueWtvaWVYeWQ4YjUybmdqbjNwcFFTd3JzY0JPTmhEZEsrU2V2a2JxM1VmY3dKR0EzbUxFckFxSmwvZ09PcFA0R213V3hWRWFLVXlKZ2d1OGdZUDF6eWVwck52bzdrYklyYU4zTHNRekJzQlI3L1VmcmluL0FHaVd6M3JIdUNzTUZQUTU2OVByVzZnM0ZXZHhYTEYxcDloY1Njd3I1eUVFTXZCOWMxQi9aVHVRa2R6SVNneW9rYnY3L2hUWHUzV1JJMWl6TUJsRjNBc3VPLzVIOUtmNXpRc2dqWGRCSjh4VWNGVDJQK05XblVpdEdQUXp0UXM3b21DSHpJdkpkaVhYeXZ1bm5QSTdZYXF6V1R4anpKN1VlWW5ET2o5T092OEFUOEszMG1nbU9CaEc2YjJBd2ZjWi9yVURNN0JrR3dzaHd6eUtBTURIZm9ldGF3eEVsb1MxWm5NU2FsZngvWjNDS3U0RWgrTU9OeDc0eTNUcVRXajlvUzZ1WWx1TGRWTGt3NVk0V1JSeWNmaGpQdG10ZTVTRyt0MmlrdDBLajdpRmh4eVNRUFRQRllxVzdSdXNid1F5Qkh5aXl1QjBIR1dJQUhyK0JHZWMxMjA2MGFuU3pHcjl6THRORWExdVpHdG5JV1JpeXhwSUNoSE9PUWNHckV3TUpBbVJvMnlRYzhnRDhPT2xWTGRFdWk1dHJscmRtbElTR0xQR0QvaGs5T25ldEpyZVNjWWFSM1k1QlBHRHdPbnFEdTZlMWRjcFN2cXlWb3RDcE5Ja1JMTE1tN2tnazhlbitGUW0rUlljdE1zamY3UFUwK2F5Z3ZBclNzRTNaMnZLY0E5Q2NFZGV2UStoNHFwRnBJdUxJWGd1SW5SNUJHeUlUd0N1UXg0eGpnL1N0SXRXOTVpYmQ5RU5pdmxpa0p0d1FTVGtFWS9Fakp6K2xUSFV2TFJ5RWJBUEFCNmV0Wi9sUlc4OHNkeWpGbzJJTHI4dmZ1UHdwelQyM2x5TkhiTzhaejJ6V3NVdVd5UkxidnVUdzN6VFJoRHNJWFA4WGI4cWM4KzZOWWk4V3djRGNNNCtucDBxdEJNZGl2RlpSeDU0eVRqK2xGeE5jZVE3SkpDckRwZ1pyU0tYTFlsMzVybUxyRVRSM2JneDQ1ejh1TWRQYXRtMHZDSWtUZ2dJT285cXBTeFN5dEdUTVNwWGtnNEdPL0dSbXJsdmFSVG9qNzJMQWZmVWNmaFc5S3NvU3V6R1ZPVFdoYSsxaFZPVG5zT0ttUzlpRVNvR0pZOVFPLzFxRTJZT1NnWWtjNHgvT29GTENaa0VZVTUyNUs0cjBhZUxwUmE1ZXB6VG96YTFOT0c0VW5KUEhZTi9TdWE4VG5mY3d5S0R0S0VCdlhCLyt2VzZ5U2s3Vlg1ZWhOWlhpR0dUN0xESVNXdzVYMTYvL3FyYkUxSXpwTlExU002Y0dwNm1KcHlXN3o1dUpTdTM3cWdmZVAxN1Y2WFozTm5GQ24ycUs0bVlzUGx5MFl4amtISGYwOXgrZm1jTU9abytQdk5nQWl1OWprVXI4KzBuYnlNMXhZYWc2M01sSnJiWTJxVDluYTZUOVRGYVRRSk5jYnpiTmhhR1liN2d5YnpnOVNRRC9uOUszdE91TEc0czBiVG9uZ2hWaWdSbURjaHM5Y2Q2NE82aGlndnBZVkIycTVISkhUUEZkZG9lWWRMVWJRRlppd3gyN2YwcU1IUlVxM0xLKzNkbDE1dFU3cXh0czN5Z0FrRDE2MXlsM2EzVTEyUXd3Yy9mOUIycm9mTXp5RGtZOWFwdEhOYzNESkdwWjI2S3A1SXIwc2FvUnBwTjJPWEQ4emxleFUwMkxTN3RYdHJtL2FNNUN0SVR4bjBBeGs4NEhGZEVQQWVuV1NpU0RWb0pHazZrT0R3T3JBOEJnTytNMXpEMk56R1paQkUyOFBnc3lqY1NQLzFVL1Q1dFFzMlp6Y01xN2QzSFpzbmtZNlY4OU9GUnl2Q1o2VVhHM3ZSSTlVOEpYRnpNMTNaU3BOQ3dCeU9CanB1ejNIdlVHa2FMZDJUR2U0Z0JpZktLNE80WkI1NmZTa25hVjVwQkhlR01zK1NGeW96MFBUajBxNVpSelJSdHVuODE4NXlHSkg0R3JwMUpxVjVPNU1veHRvaG1weFN3MnpNbS9uQlB6ZE9hWmN5UHZ6TkVXWmo5N05YQjlwblJ3b1VyL0Z2Y2cvVEJITlR6MlprVDVnQnh4Nlo3MTF1cDdXN2lZOHZMdVlLdEVreGRDVkJVbzZoUnlDTVkvVWZsVXNkcUw2Q0dFYlJMRk1VTWhCKzRlUm4xeHlmeHEwOERLdzRVTGc0eDlLcTNrczFxaVBHaFFrNVloY2pwL3dEWHJrYWNub2FKMjNMbXUvdnJwYjZReFRpTUpBcGxPMUNGVGFweDlGSEh2WFBQcUY5RTdlWGR4cWhKeEhHUnRIMEhRVk5xdDNKTGJLQ3UwRnNzdU1jNHhXUUhUQXl0YUtueUV5bnpIdkN6UVNLcFdYL1dNZHlsZVBwVS9uN0JFeXhKazlja2ZNMytGVVpMT1dIRHU1WVNNRitRWkE5di9yMHNNY2pPckJwSFpjcmdrbkE3L3BYeERpclhUTzY4azdFNHVvYndEeVlpaGNzQ0FlTWp0OWFhSGxsbFdPSHlsS25MRnVUeDYvclV4Z2l0NUpQSlNhUjJjRjlwR1YrWHFPTzlNaHR4Y0I1RVNXTlR3Y2dBSEI3Ky9PUHpvdWx0c044MnhVdDNWWkFjZ1lPSWljazU3RDZaSDVWUE04cXNFS1NINWMvSzNROFp6eU0vV3BYRnBMdjNRY28rRS9oeC9UdUtKSUhFWWFPQnpGbkFCd1NHN0hOVTU2Nmo5N1lSb2JDNVVodzBjeWpHQTN6TjM2LzQxVlJGa2w4a01NUjhoZXBQcDlLZXlCaXBtV1Jib0lBeFU0VEFIZlBlcXl3TEV4Y1BJQ1JzYkRja0RBNC9Lcml0TndZeTVpbWliYXRwa3N1N0M5YzU2LzU5YW9yZUc0S0xjdytXZ1BRMWNHcElaRldGcFpFUVkza0U0UHVmcFZnM01ZaUVRVGNPV1BBSEg0MXFtNHJXSmxkM0tWckhBbC85cnQ0NC9QQWJFcmtzQjJ5RDAvSDYxblhkcmVKZE5KQzdxcUZwQWl5Zkk0MjRBQUhvZlQyNlZ2QmJmeTI4cFUrY0hiOHVCN25pcUNMZXRLU3R1a3h5T1FRQmcvalcxS3ZKTzYvRXRPNXphK0lURmZoU25sSWpGTVNMaklIQlgyL1AwcmFzNzJDMjBjNmJGTkFnbll5Q2RJc2xSMVBLL01WN0hQMDdjV3JuU2JhMnVGdUh0WVpNODVLWUNuM3g3MVJrMFcza2hSSXkxc1Zac2VXMlI3WVBYci9PdXhZaWhKSnJRVjJ0ekExSnBVMUxjUXpxMFdRUzVBVEl6OVRqUFRqdjBxa0p3aU41VEZVM0UvTjJQMXJxcnpRNHJoMUt6VGJ2dW5LQUFjZE1qNkRzQldXMmtQRm1LV0ZRQ1NIM04wSHJ4MUZkdFBFVVdyR1RVcjZHWmJ4L2FNRjNZOStEL1d0QkxDMlRJTW9SemdybXJVdWhTeFF4WEVicDVlUG1hSTVLWU9NRmVvT2NjbjFwcjJwdDBCZGtacEFIWGE0UFgxeDBQc2VhTDgyek5GWmJvbWh0TGNMaENqNDZsYWNZNGwzcUZ5RGpJSDlhekpJVW1VcXlNY0FnK3E1Ly9WVDdYVGxWV1dLV1VEUExGaHhXVVlXYnV6VnlWdEVYR2lXUjBVSXp1ZnVvZ0xFRWowRlFPeC8xZUdUWWNBRW5qOERVZjJXTmNTN21rQjRQekFqM3BmM0pZRUFobFBSVGtaelc4RW51MlpTYjZJbkRiUmgzNjFXMVMyTjdaK1ZIdFVod1F4T0FQOGFuRnhDZ0t5Qmc3REMvTDM5NmdaMmtoTEUrV2dQSktFNDU5czF1M1V0YUwwUmw3bjJ0eDl2Wk1sdEM4MEluOHJnU053T3ZhclRTMjRSZDZCQ1RnWkhCeldHYm1WcEdVYjIyRUJremdZUHJrYzlLMFdHOUFyQXVRdWRxdDBOT2pHU1RmTllWU1MwMEtkOWE2Wk5OSTBDa1NmeHNYT04zMC9TdEN6V0tLMGppenlBZUI5YXo0WWJRTzAwNkg1bU9WQUovWE5XZnRFQ1I0amlNaWJRMlY3ZTMxcThQV25TcU9TZjNrMUlSbkRsYSs0dXFoNFlaOU1IcCtOUkRNYnBKNWF0S29JM2R6bjZWSkZIRUdKREZWVmNrNXpqL0FCcFdQbVlrV1FNamdFYlVIelo2SGo2VjMxTVZHci9FU09lTkZ3K0ZzaE0wYlJqSk8vUEl4eVB6cWx1dGxqV2FHRkZrNUhLNDNleHhWcDR5TGlWR01PQ01oQm5jQjcvclViMjhxSklwa2pKQjdvT0QrZnBYREtWTjZXdDh6WmMyOXlKMzBxYVhDMzBkc3pjRm1CT3ovSDhxbTgxWWxJczFkbFBLbHVGUFBZNHgrVllkemFiYnAxZUpYNHlDR0Nrayt4clowN1RvSTA4enpFWGQySjRCOXdNNFArTll4Y1l0TnN0cHZSQ203UkhaR1pjc2NGdUEzc1BlcG9aUFBDeG94WlFTQzJPbnJtcjF0YlJPa2dSd1ZVNHdGUDUrMVVwamR4ekZqYkc1aU9Cc0JPN09lRG5wVzg2aml1YUwwTTFGWHRKREJZTE92bWVhU0NNSGpCejlLYU4xdEhJR1pXQUhBR2MxZGZSdFFsUW1KNUlXWGtaWElJOU04K3RXckhUclhTYmp6cjJhSzRmeThTYnlNak5jRmJHVTRxOFh6UHNqUlJkN1dPWHVTMThEQkhiQWtqSWJ1ZmIwcHVuK0NyL1VVYVZaSW9sSForOWROTjRrMGkxa1ZiZTBqWXFjankxenozNVBhcTBuaUs1dnlSYlc4cEhSZ2h3Qm5wbkZaU3hlSWt2Y2h5cnV4Y2tVOVhjNmlYeFBhVzltemlMemhnZ3FQbC9JZm5ScG5pdXdsaDMyMjlCRzNsNGNBTjAvK3RYbjFoNGdhMlRiTmJKSVFNRGNLc1MrSTRKSXJUWmJSMjhrTFNNU3FqOTV1STRZZDhZNHJqZVd4czR1UHp1YXF2Zlc1NldQRVVMeXBDeXI4MmNOeURpcEpOUTh0UkpLNFZBZUR6aHV2R0s4dC80U1NWeXF2YUltekRGbEJKYXIvd0R3bHR1WTVJRGJzNGM1RzQ0Mm4xRmMwc3JrdGtDcnJxenUxdW9wOVFFcFlORWNoa0F5dU1ESEIrbjYxZGVTRXhJanVGaWJPNForbi8xcTR0TmU4UHlSSUhlWkpsd1ZLSDVUanNlYWxubjBEVWNPdDBZM2lJVldMNFBQWHZXTXNKSk5YVFh5TlBhSkxRNmlScmFRRzJkUE9Hd2JIeitWVmZ0Y0ViZnZKTUZSZ1k1QWIvSVA1MXpzcnd3WE8yM3ZvOXd4OHJuNVcvcm1ySWdpQ0pJWFpXVXRnWXd1VGpIUGYvNjlIMWZsVjI5dzlwY3RYMEtKRVJGT3NNakhrRVpKL0xIZjFxQUVqQ3FWbWNLTnpzZHVEajAvUDhxSDAyZTZSdkwzTktBWkZLbklISFA0VldmekVsY3lJVXp0QllMeTNwK3ZldG9xOGJYdUp0dmN1bGtzMlFUVEZKQ1BseHhqNlZYKzFNaWxzc0ZBeHdPY2p2OEFTcWJyZE51a0VqRkIwVTVPUFQ2VkJmUnplWUo1UVF5cGxDTTlCNjFjS2FidGN6NTdEN3VXYVUrY2p5c01FRStZU3ZQcUtTQnJ5RkNqZ094VUJzOExqNmltVzgxL0pLcGVCZkxJQjJEalA0SHIrRldvcG5FNERRRGJqRzR0M0pKTmF5MFhMb3d2cUpQZDNpUVNOREY4cXFOb0I1UHFLcVhkakpkUnZJTHVkQ3loaWhiUFVWc1c5d2tNR0pJVEpHRkxFcnlPUHAzck9rRWd4OW5qYkJiZDh5bmtmMFBGS25VY1g3dWhUU2ExTTdUQVFUWjNVY2JvQjhzcktXQTlWSS9DbjNzYzBVUk1FVVVrS2pidEJ4d2ZmMTVxNHJMOCtWWkRuZTUya2tBbjE5TTFkUzJJakRMaWNaeUN2ZjB4V3M2N2pMbUphYVdoaFJ3VzhrZm15R1dBU0VSaVdRZ3JHTTRPUnhuOEtzVFJTNmZBWTdpQnAwbVVnU0xJNUMvTU8rTVo2ampqbnFhMWsreTJ6eVEzZVNIR1BsN01PbFRSK1ZQRUZ0Z29jbmQ2Z1ovTEpxbmlsdkphRkx6T2V2bnQ3WjQ3ZXplZGJSU3UxcDBJQTRHUVFUd001NzFGOWttRXJsQXJ0dERNVUl4dHpnZjA2VjBNMmxYOXJHc2N6L01vSy9OSjk1ZmYvd0N2VFpWYUt6aUx3bHRwM09ZeWR6ZGR2Si9MR0syamlvSnJsWTk5RG4xZ3U1cENyUmw1QjBBQi9RVkhMRmRSU2JKWDI0SUozNEJ3T3dKNzFwS05VaWhkSVY4eDJZRmNBYkFjWVBVOU1jSHR5YXRRb0xtd2grYVg3UUhLRkVnQ0FqSE83STU2WUgxcloxN3JkV0lVWW1QOWlGMHIzTUprSlhhN0lDTWxTY0FqQjU1K2h6VW9qbktCV01UNXhoa1lBRlQzeG5JNjQ5S3Uvd0JoczgxdGNRYWUwTUJieXlRZDJDZWVjbkdNaXJMNmJKTmN3eFhFUWlRb0UzN3M1R2VjQUFZNS9uVVBGUWl2aUh5cG1kRHBOdWIyMmxQbG56aU5wZC9MS08yUnl3SkhHT2h4OUswdFcwWVJYUml0RmtXRlJnTkZMdlY4RE83MS9wK2VLblBoNmVhNDJ4UjI4ZHZ6NWdTUGFCeGpnZzlmdzYxWmswbVczRWEyMERBcDhvbGFjeUp0NHlCamI2citsWVBGVTVQU1JwR0RYUXp0TmcxQ0F0anlZZzBaUExlWElWOUFUZ2R1Um5QU21MSHFBbW1OeGNvMFNueTNWbVZneFhPM0dDUFUvZ2U5VnJ1MTFDWnBKcEkwTUFHRmVES2JldzlpZnFhbWkwMjhpaEVlOTJBd1Vra1FTRlJ5Y0hQQnJYMnRPTzdXcFBvWjZmYm85U1VaYUNTR1FncE11NHQ3Wjl4MnEzZnFibUNNL1kyamtqQjNNVzJqQjQ1R2Y2WXBMZXhzZEZ1L011TDBGOEV1RkpVNTVQQUhHUHAwN1ZKTjR1MDZKbU5ycHhrbFpDdTV6eTNQQlA4QW52MnFKVlhLU2RPTjE5d3JwTDNtVEpwVTA5aDkrT09ZRU1YV01NU3ZZaklCOVIvK3FyTjdvN2VZcW82aUlIRy96VlhLbm41bEFPUHBrKzFZMXpxZXNhcXgreXd0Ykl1RHR5VHo2ZTFSUitHTlpNcXpTeUQvQUVra2x2TkJPUjF6endlZTlacVUxZHptbDVFZTA3SzUwTTF6b2RoRVBuS3NSdEtxeFlISFVnOWVmeXoyckprOFhXOXNmOUJ0MkpIM2QvR1BldEMyOEhXMDBQNytkbm0yNXdwR0MzcG44YXZqd3phS3AyVzNseUFqYWM1UGJucHhYSzYrSFdrMjVma1UvYVBiUTVtNDF2eERmVys0YjQxYmtCZUNheVJwT3BYdHl5eUNScEJqY1g3WnIwbGJHYU9HTUkySkNtR0liZzg5QngxeGludFp5RkhXV2VTWmNqR1ZBWWUzRktPWVJnclFpa1Q3SnkrSm5MYWY0WXQ3Wng5czJ5RFBLTi9GK1ZiRnBwdW4ycnY5blF4c2NBcUFTTWU5SmIyQ3dzKzZlNVZId2haenpqdGo2Yy9nYW1XT1NLUXhMZVNOZzVSbVRBNHJHclduTnU4aW94aWpHLzRRNjFhMTNLU0pZcGYzaXNmbDJrZXZzUjE5NnlybndvVWZjanh5Rm0zTnQ0d09PQit0YmJhemNTMmhsTVdETHdXQVBIcFdXK3B6UElRNTJrRGc1NjVycnBWTVRmVm1jb3dSSnFIaEo3YTFTZENkc2grVlFjOGU5WUYzb053aUtxQUJzRWtIc0s2K0hWWlo0dktFc25BeXFrazhqcFN3d3MweGs4MWQ1QlhCSE9UVHA0cXRUK05qbFRnL2hPQ1RUSlJHNjVPNVFEZzhVMkswZVY4Wks0NDVIV3U3ZlNMbWE0VXRoWkNjRFBHZS93Q05UUTZWSEt4am1VUlNyZ3Q1ZzRJOWMrbU9hNkhtQ1N1Wit4MU9GT2pYYUVIT1BsM0RuazFiaWkxT1MzZUlTVE5qbmFEK1g2NHJxenBVOEdveHBkQlJieWtiWlZKSUs5cTJCb1RXMG9raFFtTUUvT3c0T1J3YXlxWmdrbGV6S1ZCOUR6L1ROWTFheEpSWkpTTnBWbGNIanY4QTQxYS90bldMaHR5aHNzUFRBSFArT0s3U1RTM2lRM2JSQ1Z6bmxWKzhSNi9UdlZjcXp6a05ib0VjOEVyam4vRDNyTjR1bk44M0lpM0NTVnVZNHIrM3RTaFhBVlUyL2VPMDgrbWVhZkg0dXUrVklEaHdWWUh2WFZMcDFuY2IxZU5IWS9Ld0IvbFdhdWd4eFhFY29TSjlyZklDVGh6NllyV05mRHl1cFFJdFVYVXpSNHBsVXhock5DZ0dBalB4d0QvalU4SGlPQjVTWm9Ob0l4d2Zicm42MW9YZW0yS3NzY3NRVG5uak8yb1JwRm02eXF5b0hLN2p6Z2Rxbm53N1YrVW4zeFYxeUdXQk5sN3RrSUlXUEdGeG5uUGY4elZ4TmEwM1laSmlZeXluZHRIQlBiNmUxWXNuaE5IdmZrdkZFTEFsY2Z4WjZDdHF3MG15aGlOcmNCWmVuemhxaXFzT282TnN2bWx0WXJ5YTlwM21QR2hhTlFBZjNiRTdnZXRMYTZ4cDZJL2xTYkE3WVV1ZW52N2NVOWRKMDNjL212bEhCSVlqa2ZqVVowSFRSRW9DN3NIQkN0eVQxL0RqK1ZUZWhhMm9LVTdsOXZzTEk0WnljOHMyY2J2enJHa210NG94REZjbUZ1VkxoYzRQYm5tdXE4blRKOXYyaEkyS2hCdmpmb051TW42WXpWZHJLeGpudUVDbjV2bVU3UUJnL3dEMXhXTk91bG8weW01R0xCcWYyZTJBYVF6eHBsSGtrazNaNkVZWEEyNC9HcDAxdTBna2trZThSY0VydkFMZHVNRDhhMVlkS3RKUVM2b0ErR0w0eHlPUi9MSDQwUytHTkpXWVN4NFVqR0ZPQ0hQOWV0TjE2RGZ2Smh6VE9iMVB4RHA4anh2RlBLRHpreGdxRGdmMXA4WGlXenlDazByU0RBWGVCeGp2d00xMExlR2JEeUhZVy95L3dxcTVBUHY3VVErSE5JaGdZTmJKS1g1TzdxdnNQU245Wnd2TGF6SnRVdVlUZU1wa1FpTlpIamJsaWUvVG5IMXFoYytJdFExYTQreldsb0E1UTlSa2tmalhvTmhwT2syMXFrWDJhTDVsNk1ja2YxcGt0bGFvQXh0eEVGWENNcTU2NTcrbVRXY2NaaDR5OTJtVnl6YTFaeUZuclY1YXd4eGFoRmNxNVBQa243NHhuQjVHT090WFYxUFYydEhTMnRXQUw0UXlIbkdCaml0ZnpsYTdLUzJya0lwWkpTdkc0Y2R1L2VyRmlmTWxqODJVbGVkb0E2R2lwaUZhL0lpbEtWclhPTXU1UEVjekpCSmJoMlpoMUFBQjR4eWFjZEkxNjdaSHVKOWtZeGpCN25IYjFydXpHa1ViRnBFbGtqSlptOHZuSHQrZjhxYmFYYU5JcUpFOHZJdzdER3o4ZTFMNi9MbDl5S0RrNk5uQnhlRWJtYVh6SlMwck1TU0YvaS9INlpyZTAzd3RiVFJxV3RzN09oVmR6SDF5UlhRVDNVOGRzelFxY0k1REx1NDVQV290UENqVFQ1N0ZwWHlXQVBBeWVudHhpaDR1cFVWNXlzdklJd2pjcXJvc1RXMEUxc3g5ZWhVajFEQWlyUnQ1UE9LbFZKQTNFQWNaOWptckQza05vakFXN0FnOUR6eC9qVk83dldtaldXM0JSVk9OcDQvT3VhVW5ONmJlWnEwckZveng3WFNPM1hZNjdWTzNsVDNyT2xtYTNqZ1I5M29aQ01qcC9XcExWanVrZVU4N3Z1S0NSN0dpU0tlZFdSM0pSdWNNUUIrRlRGV2V1eEZtMEtYTWFydGNBRDVnMmVwOWFmRXlORCs4bUFMbmhpTy8xN1ZVVlVTT01tVEh0MU9QV256V00waVNlWUZFWkl3ZXc1NHB0THF4SmR5MUJCSmVYUGxTa2JVR2M4RFBOTEtJakZ1RzhLcElJelVMVzh2MmtCTGtCQjI0NjB4a1lDTkpOakVnZ0JlLzA5Nm0xM3VXbzJLTWR1aHRtaktCRWpKSkFQVDAvd0FhcVNRV1dNaFNTVGtmTHdSViswQS90U1VZNkFrZjk5VlB0VjRwbmRRekFPQXhHU090ZFhNMHhjcVpRdFk3YnpIRVEyREl6SUZ5RnFhZFdCWWJBRG5ncXZVNHhtcTlzU1R5ZXNveit0U3hNMjl6dU9RNXdjOU9SUkxSM0pVU3haRHpZOHo4c29QSXovS2s4bVc4dVpBd1RBd051TUI4MXFCUjlqZHNEZDVUYzkrbFZXQUFHQUJrS0RqL0FIYXlVdDJqYmxWaHN0ak45bkFaMllBc1F1Y0ZoeDAvTDlhcWlTOTA5L0xjc29ia2dNV1VENmV0YW8vMXNSNzdCeitKcEp4dmU1TGZNUXVBVHozcVZVZCtWb1VpbWI2NlMyYUpaeHRrUEozRUVFakdNZlROVkZkNHRrTFRKdEdTQm43cEFKRlIzNEMrVUFBQnZIVDZWQktxbUdjbFFTU1FTUjFHY1Ywd2dtWnkzc01XVE16ZVhJUE1MRU50NmdkeFRrc1pSZUtzazQzY0ZWWGdMbm1zalJBR2pKWUFuZjFQMEZiN0UvYU1aT01yeCtGYTFVNmN1VkVKcTF4MXphc2JwQk5LR0pRN2xLbklYUFlqL0pwa1duUU5JU2tFOGdCeXU4YlJVc3NhU1JqZWl0aE1qSXpnNUhOTE83UldrWGxzVStjL2RPTzRyTzc1VlkwVFY3V0lUQkJIY2VXMW9nSkc5amx5QitPTVpOVEpZV2s4Y2ZsUjIzbHNmbDNJUVNPK1FmcC9LcldudXoyTUxPeFp0aWNrNVBTbVhERVh3QUp4NUxuSDRWbTU5dnpLWkVkRnVWQlNDQ0RaN04yOWgvU29MclJyb1JLRFBHSW84WVJUOHpaOWZ3K3RiMm9mTFpnamc3K28rZ3JGMTkzWFRqdFpoOHk5RFNwMVpTYUhLS2R5RkZpdG95cXFURnR5emNjKzFTZVhGY1daZFNuN3ZBSXprZ0hINWNWVFQ1dElKYms1VTgvOEJxbHBaTEMvVmpsVkl3RDBIeTEwS20ybTc3R1ZyYUhReHE5cEtpMjBvTUxNQjg2OWFzbVM0VXNDY21NbktCUWNkTzU5ZUtwV0pMWFFqSkpRQmZsUFQ4cVc0SjJ5akp4NTNUOERYTTFkMlkzb2l3MnJTQlJJektBK1F5RmNnNDZjQ3FNdXIyOGV3Z2xEa2xnQmc0OU1keHdQenFxM3pYMkc1R09oK2xaN3F2MitFN1JuNXhuSCt5YTNwMElNbTdOSzA4WHRmM0lXT0pWdFZQek04V0QwT2NZUEZhTWwyYjFFZUdWbUE0QWNldlBTcVBoeUtQOEFzeTYvZHAvclcvaEhxUDhBRS9uVWR1N2YybEtOeHdHVWRmYWlyVHBxYlVGYXc0dHRhbW9WbG1rYUY0MFZzL2VIQXdLa1Z6QzRhUGtLU0I4L0NtbzBZaTl1VGs5RC9PczY3Wmx1NGRwSTNFWndldnpWenBjMmhVbFptOUdKcEltaW5tVWpid01qdm5OUkJmTGgySktSa1l5blE4OS9wL1dxSy82K1FkZ0RqMjVxL0NCNUNjZHdQMHJOeHNKV2VnK2RtaENvMDZiRzVaTURuanVPOUpidzhQQ1ZiZm5KSitVQWNldmVxV3NxcDFPMXlvNnAycDg3dUZZQm1BK2ZvZmVtNHZrVHZ1VTBtMmFlSUhEUnpsa1pWTzFnT0J4M3FsTVlJeXp4c0dadUd4akdQWHZVeUVsc0Vrall2OHF5Qjh5cVR5Y2tjMU5PTitvcEdwTGN3dERsVldJS1FFbFJ2ZnVQNjFSdDRaVE16eHpTU0RPZm1QSFBYbXFiRW0vaFU4cVZHUWVuVTFyZUdsRGE1NVpBS0dVZ3FSeGpudFd6anlRYlJQeE5JYjlqbENtTVI4REk4enJqL1BGV0o3YVo0VVR6VWFKc2pHZVNQWGl0ZkFXNHVRb0FIbWtZRlVicjVTeFhnaHpnajhhNVBhdHl0Mk5GRkZTTzNDU0lpc0F1UmxTM2YzTk1OdkpOSUYyamRra0Fub1J6V25jcW9MNFVENkNxMFJQbVJjbjc0SDYxYWsycmxxQ1ovOWs9XCIsIFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvL2dBK1ExSkZRVlJQVWpvZ1oyUXRhbkJsWnlCMk1TNHdJQ2gxYzJsdVp5QkpTa2NnU2xCRlJ5QjJOaklwTENCa1pXWmhkV3gwSUhGMVlXeHBkSGtLLzlzQVF3QUlCZ1lIQmdVSUJ3Y0hDUWtJQ2d3VURRd0xDd3daRWhNUEZCMGFIeDRkR2h3Y0lDUXVKeUFpTENNY0hDZzNLU3d3TVRRME5COG5PVDA0TWp3dU16UXkvOXNBUXdFSkNRa01Dd3dZRFEwWU1pRWNJVEl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeU1qSXlNakl5TWpJeS84QUFFUWdCbWdGQUF3RWlBQUlSQVFNUkFmL0VBQjhBQUFFRkFRRUJBUUVCQUFBQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVFBQUlCQXdNQ0JBTUZCUVFFQUFBQmZRRUNBd0FFRVFVU0lURkJCaE5SWVFjaWNSUXlnWkdoQ0NOQ3NjRVZVdEh3SkROaWNvSUpDaFlYR0JrYUpTWW5LQ2txTkRVMk56ZzVPa05FUlVaSFNFbEtVMVJWVmxkWVdWcGpaR1ZtWjJocGFuTjBkWFozZUhsNmc0U0Zob2VJaVlxU2s1U1ZscGVZbVpxaW82U2xwcWVvcWFxeXM3UzF0cmU0dWJyQ3c4VEZ4c2ZJeWNyUzA5VFYxdGZZMmRyaDR1UGs1ZWJuNk9ucThmTHo5UFgyOS9qNSt2L0VBQjhCQUFNQkFRRUJBUUVCQVFFQUFBQUFBQUFCQWdNRUJRWUhDQWtLQy8vRUFMVVJBQUlCQWdRRUF3UUhCUVFFQUFFQ2R3QUJBZ01SQkFVaE1RWVNRVkVIWVhFVElqS0JDQlJDa2FHeHdRa2pNMUx3RldKeTBRb1dKRFRoSmZFWEdCa2FKaWNvS1NvMU5qYzRPVHBEUkVWR1IwaEpTbE5VVlZaWFdGbGFZMlJsWm1kb2FXcHpkSFYyZDNoNWVvS0RoSVdHaDRpSmlwS1RsSldXbDVpWm1xS2pwS1dtcDZpcHFyS3p0TFcydDdpNXVzTER4TVhHeDhqSnl0TFQxTlhXMTlqWjJ1TGo1T1htNStqcDZ2THo5UFgyOS9qNSt2L2FBQXdEQVFBQ0VRTVJBRDhBOW9ER21TWk5OTWdYT2FpbHVrVkEzT0RnOUs3TmpuZXJBOWNVbVRtb0k3dFpDMmVBT2hQZXA0V1dWTnk5SzE2WEx1UFJkM0lxWEFBOTZUSVVZRk1aK2VhamNoNmFrRXd6VkdXTUVZcTdLdzlhcVN1dkp6VzlPNURkeUhiZ2hjOUtyYWdwRVllTWdIY0FmZm5GSTF4L3BJVUhqSE5WZFNuWDdPUXpqYmtIcjE1cmJiVmszMTBMRXlwNVl5QXBZYlRXZk84VnFueUFiZ3A2VkJjM0V3a09BY0RvT3VSVmVlT2FaczlEMEJOY2xTcFZtbW82R3NJS0xYTXdtSzNVQWoyNDNIREg4S3lqTWkyMFVSVWlSVGhqamdqcFdoT2pXMkNDekQrUEZZMHJiNEpHVmxVY2pESHFPdWE1cXNwcFdrYXExOUI4VW5teWhWVE83N285d2VmME5RVDJ6UlgvQUpNTC9JM3paUElIdC9TcXozRWtpeDRRaGtYZDVnNHlSM0ZTV1Y3SXl5TTVJTWk4azlqU2pPUE1rNDNEM2tTWE0wZjJaa253M2x5S3UzMFhJeCtsWThMQU5MTEh3aGtiQ25yalBTckdwU0UzNitYamZoQVJucVFlOVJXUWhmeTRaeTZoc3NRTWRlMzlhaVR2T3k2RGp0ZG1rSmdiaEhqWVlrWFl6cU9vNjlLak54OXBjUmpjVVBYSTVBSGVxMzJuWkFXakRMdGxZOU9RZlFWZHNyV1MyZFdJWjVYajNNQjI1NlYxUXB1cTB6TnRSUk5ER0lZSVpHTFNTdWVSazlPdjhxczZYZ3l5T1F4WThLTWNZeFQ0YmhQc2VWVTcwWG9WL2k5S3EyczVzNTJoamNNU053eWZiOUs2RzR3cUpyWXlkNVJmYzI0UXpPNnRFb0E2VmFLRGhnTWNkdTlWSXBXY0s3RFk1SEtqbXJLU2RqMHIwRkdMV2h5dHRDN2M1SHBVTG9RYzFPRHhuTklRQ0t0YUN1bVZjMDJwWFFqNlZHZWxhRXNiaW0rMU9OSnhRU0pTVTQwaHdhQkREOUtRMC9GSVJ6UU1ZUUtiVHpTRUNnUkdSU1U4MHpIU21JYWFUcG5GT3gzcEtZejFPUkZsWU1QdkQzNE5VTGtnWmlBWXlEN3ZQUVVzaFk0VVQ3Y1BrK3c5S2hNY2NraGxjSEJKd3dQUVY0bnM3N3M5T0V1cEpIRUdtU05NN1ZBWmxZZDYxRXd1QUJnVm1Xc3F0ZnpJaDNLcWo1djZWZlZobWlhNkJmVW1aZ0toYzhacFdiM3FGMjRxWW9KTXJYT1hVZ050Y2REV1c4MDZDUU95L0tPRDFxN2RTbENEZ242Vmd5M0Jsa2tJQlFsVHdmVE5iY3R2ZVNJU3VOUzlCbFVTZytabkE5RG1xdXIzUHk3VkFKYlBBK2xSdVd1SUFxeUt1MGs1SzhnOWpXZlBjSWJHT1ptQVpuSUpBNkhPRFdPSW01UWR1aFZPUHY2ajQ5V2FSVTN5RmtZTG5hYXZRemdBZVlBN25sVkhwNlZnYWZJaUx0T0dVT1YzSG9CV2piekYza2dqSTh4U0NyamtjLzhBNnE1NmVucXpTZGl4ZTNCbWtqYUtKbFVuYXpzZWhIYXFQMlI1TGo3TTJGREFzd0k2WTZmekZUNW5RT3IvQUNnUHVjTDNIcitOVWIyWUpjNTVKTGJTU2M4VTIxb3BJY2R0Q2tpbEpQTGVUTUNIY2ZsNUNkdjYwTWlMTUJFcmJKSHd2SFRubW52SXIzaGFRcWZQVFlFQTQ1ei9BSi9Hc2tTeVdyS1dMRHl6dVhPY0VWamZrYWFLM1ZpSFYyV0xWSEtvZUJuNzNXcGJNTDlqYWQxK2ZZRlFIazRQcCt0TTFwWXpFbDBqa000M1lZK29ILzE2dk1ZbVVoTmczcXNJMkhPTWNuajhxY0lyWFhVVGVoVlZRdDB5STd0RmpLbkdNbnVhNkNDL0R5UnJGZ050d3JkcXo0cllJSVZLSzBnRzBLUmtBazBsekt1bk16RXRHeUVBUnJ5R1lldGJSY3FkbjBJa2xMUTBMcVZ2THRMVU5pUmlHZkhZRC82OVBodEhMR05wU3l0a3FDQm42NXJMdFpKSGxNMjRCNW4rWTQ3OWNldzVycExNQ0FLclJCWFlEbk5kTkY4NzVwTFF5bmVLc2lTQzFFTEprdGtManJWb2lqR2VUK0ZMMXIxVWt0amljbTl4dTRpbDNHZzU3VTNOVnVJR09SZzFFUUtlYVlhYUVJUlIwcFR6U0dnUUg5S2FmYWw2NXBEUU1NVTA5S2QxNXBNYzBBTnBPdExqajNwTzlBaHBGTjdtbjRwdE1CbmVrK2xQTk53T0JRQjFXcVR2RmFPU1YzT1FtNGRqN2lyeHZJenBlOU5wZFZDWVRuRGVsWnlRUlhlb0VuY1Z0d296NnNldWZmcFVxeHh5YXNxUWphc1EzeTdUd3g3WkhyWGw4djQva2VuZFdTTkxUNHhCWlJoVGtrWlkrcDcxYUQxRWpqT0tjem9nR1RqUEFwUzFlcEVwRSs3SXBoYk5RZVlRZXRKSk1CR2VjZTlMbElsSVNmYmlzVFVGRHF4Q0VNb3dHQTZpcnMxM3h0VmN0NzhWZ1grcVBDanF5Wk9leDdVMU9QSzBhMDR0MlpRdU5tNHR2d3c1QkhVakhJTllseElaWTNnS0lBSDduakhVNC9HdFc5V1I0VmRRTU9NakhYbnBXSXQyc3R6SjlvVFkrekNNT2VSbXZNcjNqVjAyWnRIdVNXZTlUY3hTcmtCZ2V2R0QvUHBVdGxjQ3pra1h6ZmtCeHlPcTU3SHQxTlZMTnN4bzdFNWNiTWQvWS9TbVhQbWJOK1FBRG4zL0FCck9wS3BCKzZ0RU95a2ExeGRicFhXRXUwWTQzZzU0cXBkTXlReHlLUzhnY3N4SXdWeGpPUWFpaGVFcGJLelB2ejgzb2FaUEdKUVZSeXg4d0tDemNFSElGVXAzWHFGa3RpenFkMURGYnVGSVpwSTFLRUFjTUNmL0FLMVV0SnRHMUY1dHB6RHVBSVk5dXZGUXRJRGdBQXNJemxUMk9jWS9sUzJIN3FTU0lPQUpjSTNvaEpPRC9UOGFxTStlVjVhaXR5clFnMVNCb3YzUlFsUE15TTlFSnpnZlRHYXNhYXV5T2FWbVV5bkcxaWVuc0txM256V0VFU3paZVNkejk3MDRHZTFPc1lRNTJpVGF6RXFGQXp5T2g5K3RWRlBtNW9vSDhObXpiUXJoTXZ0UmxKQkhVbnNENzVyQ21FODk2Uys1b3kreFhKNnQ2L3pxOUxJcnFxTXpxYzdVM3JnaGU3ZjArdE52UEtIbExaL0lJMUpPRGtrWjROWE9Mdjd4RWZJdTJ0ckxZc2p6Z0ZWa0N1QjE2a1pycGJlYU80UkpOb0JJUEI2OFZtV053WjRQSm1LK1lveTI4WkpHTTVxeDVwaGtWSUkxWkN1QWVtMzFyMWFQTEZXajl4eVZMeWQzdWFRWldZZ0VISFhGR2VlS2d0M2hqVUluSHQzcWZxQVJ6bXVtTWx0Y3dhQS95cHBHZnhwM1NtNTZZcXhEVDJwdlU1cC9YZzBsTVF6RkdLY2V0Tm9FSlNVdEo3MEFJYVR0UzhVR2dCRDA5NmJpbFBUbWt4UUEwOWFTbjAybUEzSE5ONzAvclNjMEFiYVR5V0dnTmVNQjU3cjVoQjdzZWcvbFYvVElqRGJocE1HYVQ1cEc5U2F4ZFphWTJGaVB1RTNNU012OEpHYTI0M0NxQURuanJYSHkzdS9NN1pUN0Y0U0JSdUpBSGVvSjVHTnl1R1hHM2dFOVRVRXNtK0lsVGtETzRlbzcxblJoTGxqSmxtV044TEwzR1BUMXJKd3V5Rks3TkkzeGJ6bFZDcnhvR0c3b2F6amZQNXhrREFvektDT29YSTZHcVlra2FhVzFEcEtjWWR5ZWNWbnpHTFQyUGxHWHk1Q3ZEYzV3YzhmclRwdGJzdWRQc2ErcTZqRWJWZ0NXY0VaQ0RyVkpwRDVKbURmSzZmeERyVkZZV3VKOWtjcEtGdk5aVDI3WTl1bGFCaVoxRWNwYjVPUnp3Qml1S1RrcE5yK3U1cFRpMUd4bUNFd1hDd3hNRVdSY2dnOWZ3ckkxU0dXMHZWY2xYQkJRc3EvZEpBT1I3NHJSbENSM0p5d0FpUTRjSHI3WTlhVVN4M05zcXlFbmJNallLam9lT3Y0MXpScUpxMHRHYk85N29Ja2ltc25USUxCT0QwSVByN0hOWms1S1JLWlNtMXlVUFBDNUdLMzJXTkZrZE1IK0ZNVnpOeklxM0Z5R2srWWtOaHVuUFhqODZ4cVRjclhZNHBYSUV1R2dlTm8vbVl0OHhCemtEMitsV3A1R0U1UzN4dWNid0QzeGh2Nkg4NnEzRDI2M3FHTnhoRGpmOUJWZWJVWTVibEpZZzZzejREWnp0SFE0OXNHa3BxTnRTcFJ1dzMrZGVTUEtTRTNzdytuWGo4d2FuUzFobFc0dU43S3ZsQm9RcTU4eCttTWZoK2xKYjNDelhwOHRsVjVrQ0I5dVFNOGZoa0NtVDJ5V1U0VjUzTnNpbFZraU8zRW1DUm42WklyYW55TFVsdDdGS1FzbDdBbTVHWERPdUJnWlBGYTFtaFVSM01rMmRqQlk5cWZNRDdEdUt3WUxvUGMyN1pQN21FRTd1ZWM1UDRjMXQyWURoNzZOVEdrWnpIRUQxQjcvQVAxcVVkTkNtYWoyODFqc21sdUJQSzZCUXVQdURQQzUvd0E5YXhwSm11cmhwWmxFYmtuSkhZZHY1VjB5UGE2alpuWk9QTXpnOXF4YnkxYzdZUE5WZWRyUzl1RDBwMXVaMmxGNk1tQ2p0WXZXTUQ2cGJCaklZSThZVjB3U3c5RDZHck1VRTluY0NMYzBsdVk4ZW5PZXcvejFxdlpzTFdYeXNzMGNaREFEZ2pwemdkUlYrYlV6SVlqQUdRNHlwWk1nakdlYTc2TlNMaHF0ZjY2bUU0dTlsc05qdVpaTDR4eGpDQWtuUFk0N1ZaaEZ6RXpPWkF3M1pJUE9QcHpVVVVnbWhFS291QUNRY1kvT3BBOHNTTEdNT1R6MC9uVXg1WXZtM0IzYXNYRnVZMk9GTzQrbFNodDZoaHdENjFDWUM1RGtydkhjRHI5YWxVTjBZZ24xOWE5S2x6M2JrOU9oeHo1YmU2RkpUalNIR2EyTWhsRkxTZHFZQ1lOSWVsTzlxU2dCcEhyU1U2a3htZ0J1S1FqbW5VbEFDWTlLVEhGTGlrNzBBTnhqTk5wK2FTbU1nMS9VSnBsQ013UmJhVkdjWTZrTU9mcFhTV0VqU1dxT3c2aklQdFhLWFVjbzhOeW02VW1TVWVhMlI5ekJCNjkrbGF0M2V6bVpMQ0pWS01tOTJVOUU3RDhlbGNVRTQzajFmK1IwdGFhRnVWWlo3djhBMEtiYkNRd21jOGpKL3UxTjVKc05QRWtTaVJJaGxWNTYxWVliTFlSb3VNcmdZSEFxbGN6QmpCYi9BR2hJd2YzamsvdzdmMDY5dmFxa2tsWkVOM00rZEw0V3F5QzBEenlFa0ZNREk2a1o3NUdhemhjT2IrSjVTUEtJQldJL3drNUhHZjhBSXJSbGwxQ2FFUFpYRG1HSnl6U3lBZm1veDB3VFVkdFlpSzhNRWpMTGNHNEVnbEsvdzdkMk1mVTFoS0VtN0xRNkl6MHV5ZUJCQmMrZE81MlNITzBjZ2UxVHlLcnZJeFpnblVBSG4vOEFWVWtqbEk1SVM0S0Q3dUU2Vmx5M1p0MVZwWmZtRGZPb0hVVjV0V29xZnV0NkhUUVhQSXFYS0Fyc2JHUVNPVGpKcUlMRVlaQkN6Zk1NN2NjNUZSMjkra3Qrenl5WUFZOE1Nai82MUpjM2dWWVhURFlUYVJqR1ZQTmNWZWNGQzYzSFo4OWk1SGYyOHNJODBFWlhoZ00xeGQ0d3VMMlVxY01lTU5XNDhna3Mvd0IycUJVYkJ3M1gvT2F4N3UzanlYa2Y5MmZsWHl6ME9NMXdSclNrN1NPamtTZDBWVldSWXYzai9LNUtFK2c0TlFPV2hWb2xZYmxPVnhVaFErUWl5QmxqTDdzbnIwN1ZYbWhLbmZFeGFOempjUm11bmZxVHVWb0puRXJzSkFwNmZMeWV0U084azd1WFppdk9XNmRPK0taQnA4eVR1STR6S3luaFFlY2RlbFdaZkpOb3lMZ0VmTTRISDBIdlE2aVQwS1VTQ1dVcGNNUWN4c0ZVamc5QjZpdDYwa2RwWTRGa0NxL1R2MHJCaWlWb2xaYzRiT1FUMDVyUnR0c2MzemhzcVF5NTR6anQ3VmNxcXZkOUI4blk2YTBnbGl2Rit6RUNVc1NVWmM0NTcrMWJWM2F5TGFJOHNCWkErNlFzdUZKLzN2ZXM2RFVVc1k0NUxSVm11V1hEK2FtVlE5ajdrZGgwOWMxRmRTWEdveUNYVWJtVzZjZmRFamNMOUIwSDRVVmN3cFU0Y2tWZDkraDdHQzRlclY3VktyNVUvdkx2bTJVOHNVTm9FZHBHQ0REQWNFOEFuUHJpcWF5dlpTVHh2ZXI5b2pjcTBiOEVZUFFOME5STENpbktxQjZZN1ZHYlJHUWtnbHNrN2llYzF6UnphWFk5UC9WaWgxbXk1SGRyY3FXS3NySjk3QStZSC9DckszaFNRS0VKSlQ3eDdrMWtSSkdzYkdXWXg0K1hPTS95OUswTFh5NUxOZHp4U0tUdExMMng2NTZIcFhwWWVxcWxtbWZNNWhsMVRDVGxHU2JpdXZjMXJTOGQyV040c1pIQkI2ZmhWN3Rtc3lBT1oxV1Bjbkc0alA2VnBLQ0ZHVGsrdGUvaFhMbHRJOENzbzN2RU1kcVNuVW5XdW93R2tkNktVMGhGTVFsSjNwZUtTZ0J2YkZKak5PTkljMEFKU1U3bkhTa29IWWJTRVU0OWFUcFFPdzMrVko5S2QyNjBtS0FzVXRjdXBJZEl1YlJzVE82c0l3cHljWS9vRFVuaC93QTJmUlkyMmlSNWR1NlFuQkl3TUQ4S3NXbWxxdHVibVVqelpBUTdOOTFWUFlmNDFoYVpyRTMyU0RTckZWYTZqWjQ5empLeGdNY0UvaFhISDNKdGJ0Mk9sSzZzanNMM1VrczdjSTRMM01ueXh3eG5MTWY4UGVzM1M5TmxMK2RxRGk0YVdRc3lML3EwYit2cHpVY1ZyL1orNjRsSTh6SDc2NWtjYnBQWGJub1Bhbng2ek5xTnBJdGhhaElmdXJOUDh2UHFGNm42OFZhMzJ1LzYvcnVRbGJZMzlueTVnWlNQdXNqY2dqMHJseE9GMXlZeVhLeHZGQ0VJUGZrakkvQUNya3l5cEdWbXVabU9mbTJueTBIdGdjL3JYSzJ0eEcrcXp5UE15eGpqYXJFQndQVDE3L2xYbjRtczZkUk5mTTZLVUxwM04yVytjWG1JbmVVSjBCWEFiUHZXYnFkNFpBWlpJUnRZa0VEbmJqRkxhbzg3UE5CT3BSdVF1TWdZOWZlb2J1UkVzNWJpUlFBdzJzRHhrRWdmL1hyeXEwRk4zYjNPdWsrUmxLTytpZ3RKVlZ3WjVNN2xic1JWQnJ0cEZWQWM0NUdUakE3aXE4TWU2OWxNZ0xNb09NSEo1NmZXbVJ4c0xoMkNTTTdZd240ZjQxeFNWM3FhNk9WeTFIZFN0SDVBWlNzbzNjSEdBS3FRT3hua2ZJSU9SZ2pBSnF4Y3gvdXdaWWdySU9BcDI3Z2V2NlZXalhNZ3lvRVpmSUlQRGNZSi9sVXdnbmRsU2xxU1NtTlZKVDV3M1ZmN3Z0bjhLaWhmeW8xQlQ1UU1NUXZYSm9zYnY3SmZSVHVpbU5KQ0hSbHlHeU1mbFcxY0xheXpRYWk0ZFZrUXNiYkJYZWNrREJIOEkvejN4dTRKUnUyVlFvenJUVUlMVm1MRHRqbFZvRVl5U29BcDNaMkg4dTlVbnRuVjVDR1ptWE8vZHdEaXV4bG1udnJWSU1wSGJKalpCR05xRDA0SFUrNXlhZ1N5aVRKY3N4OU4zRmNjOFRHTW5ZK25vOE95a2x6eXN6bDRKWFZrWndDT2RveDFyVTAySjN1RElaQ3lnQSsyYTB6WldybmxUeFVNVWtGc3d0MDRWVGdIMSt0WXp4UE1uWTdjTHcrcVdJVTVTNW9yeU5LTUJGK3RPQnFIekJqZzhVcXRYblNuZG4wRGlXVjVxUXI4alk5S2dWdWxUcTN5MUtrWXlNeVVlWmJ5ai9hNHFqWjNCdGJoUTVQbE9jT0Flb3Erdi9MVWY3VlpONWhMcGw3WnpYcllhbzR0V0p4bENGV2xLTTBkaFl6cEZJeXN4Mmc3aHlmUVl4V3EwZmt5bVZaVDh4QUlKeURYTGFYZU9Jd2hPQmtBT0R5SzZHSzVlVXNoVm0yZ0VNT2pWOWRnNnpsSFhVL0k4YlE5bFZjT3hmUXVjbGdBUFFVNm80NVZjY013UG9SaXBEMXIxSXRQWTgxcXpFeFNVN25OSmpuQXF4RFR4bWs2MHRKNzBCWVR0U0U4VXRSVHpSVzhMeXl0dFJlcC93QVBlb25PTUl1VW5valdsU25WbW9RVjJ4MmZlbE1icWdkbEtxZUFTTUEvU3VhbDhVM3NOeUhzMWppVUFoZHlCeVBmbnZWTjNtMUM0TnhxRTh0eEtmNHBXSk5lRlh6NkVkS2NibjJHRjRPcnlWNjhsSDAxT3RtZExhMmt1Sm0yUklRcDR5U1QwQUhjOEUvaFdjK3N4RWtRUVNQencwbnlnaitkWmMwMHNpMjhabGRvb3o4cWs1QXFUZUFBQ09PdGVWaWM5cTFIYW0rVkhzNExoYkMwRW5YWE8vdVgzRzdienBkajkyQ0pPNkhyK0hyVmx2OEFSOHBuOTkwWWorRDJIKzEvTDY5T2VodVRGTWp4c1ZkVGtNT0NLMmc2elJMS3ZVOE1CMk5lbGxlYXZFUzlqVmV2NW5oWjlrVWNMSDIrSFh1OVYyTHNUUXBCSkpjR1FTMjhaWjRabUIyNDdqQTVIdlhIZUhQdE54YlQzR21yNWw5Tk83T1pGeEdxKzU3bjJGYjNqT2FPWVdtbXhxVGUzRGhReUg1bFRQUDRIMHJaaHRMU3poUkxka2lpaVVLd1g2VjY4RnpOeWI4bCtwOHVuYU4rNVV0TlBqdURGUGZlYmRUamxkNllSUDhBZEhUK3RNdW1ranVZb0YyeHBJeHh1R2ZmRmJLcVk0Z0JKa0R1UjJyUHZycUZvSklwNGZNR01GUjFQMHE1elNJdTJjL3ErcS9aN080aU02a3M1QU8zT1NSZ0Q2ZTljMVBxZHFraUtyTXJSS0ZBSXp6My9EclJyYlJ2ZC9ZQThoaFFGOTZMOHlzUnd1ZS9TdVpDWGpYTWNrck03cTJDcmR4eFh6ZUxtcXMybTlqMEtNSEdKMk5qZFJ3Uk1oZHVUbFRHcEt0Nm4vNjlWN3JXNHhFc1NySWN5YmR4d1ZJOTZ5bzc3ekFWU1lSTHZaUW9HR0FxdzhjRVpNYURmSUhKeTNRQSsvU3VLZFcxdERkUnVTVG55VDVqU2lUSkc1aHhnZmhUdnRDTk96b3FqZGdnWndldkpGVkxpMnpLVlVkVnpqUHQvalFMN3kyamtDcXpqMDdEMHJOV25ydVg4SmJtalNaUkY1dUNEa1l5U2ZXcTBFZm1yTkF3VUdJbHNrOU1keCtWVG05WlowazJBb1RuSjdaOS9YclVzbHB2dWZQaUtuY054RGNEUG9NOWMxVXBSakczVWNLYzV5dEJYTTRpTzRzNWZNM2JvL3ZLblQyNSt0V1pKSGttamlKUDd1TlVBOUFCeit1YW1nMHMzR29RMndVd2lSd3Z5bmNPVGlxOGNxeVg5ekl2S3RJeFg2Wk5SS1NWSnlUUG9janc4bmlHcHExalV0SDJxUjZWWWNnak5ac01tSFBOV2ZOeU1acnlwU3VmZE9ucm9MSkp0VW4wR2F3ZDVKeWEwN3FURUwvU3NjTlZVVm8yRW55Mk5LMnZDQUVjOGRqV2lrbWE1OVdxN2IzUkJDc2ZvYW1wUzZvdFdramJSNm5SKzFaaVRaeHpWbU9iNXh6WE5acG1NNmJFUWZ2SkJXVHFDLzZTRFdvamZ2R1ByV2JxQi8waE9ldGQ5Q1h2SVZWZTVMMEwybCtZV2NSbEEyM3EzcC9XdXZzbFVSeHM2S3JIZ2JWeVB4TmNsb2czNmlzUWpTUXVoQVYrQmtjLzByckxlNGRVYU40MmhrOHphZG9EZlExOW5sa1U2YWtmbE9mUmNjUy9QWCt2dU5EYU1kS1hISFRGT3hTWTRyMlQ1NWpjSEZONzA2bXUwVVVVazl4SUk0SXdDN2taeHpnQUR1YVU1cUVYS1d4ZE9uS3BKUWlydGpUMXdCVGNqc2M0NjgxeCt0Ni9OZDNzaVdtWXJkVHRSRlBKQTd0NmsvbFZPMXZKN2RoSUpDcit4cndxMmVLRXRJNkgyR0U0UXFWcWZNNTJmb2QwVCtkY2pyR3JmYTdueW9qKzRqSkEvd0JyMU5XYnJYeStrVGpHMjV4dEJVY0VIcWZiaXVhZ2ZMYzF3NXBtY2E5TlJwUFRxZTN3M3cvUEIxNTFNU3ZlV2kvelJOeUhHZVI2MWNTWGpGVW5mQXhTTEtSWHpjbTJmYXVGelZNbnlqMk5Qbm1HN2pvQUt6QmNaQkZOYWNtc2VSbWZzTlRTZ2szT1RtclVtcXZZd3M4YkRMRGFBUldMSFB0NzFCZDNCa1lEUEFyV201UmxkR2RYRHhucE5YUjJXbE1tcWVMOVExV1JzdzJuN21Fa2QrbitQNTF2endOT2drdDRRenQ4eEpKQTZkS28rRjlOK3hhRGJ1WWlzOHc4MW42OHQvOEFXeFhTRE8zQkFIc0svUzFIbGlvOXY2L00vQzV2M3RPaGlXbDI4a2x4RElDWnowVHVCMno3VlZ2cEZtbE15TzJ5T011cUQ3cFlEdWExTHp5V01ySUNreURQbWdZd2E0THhCcmNrRnFwc3JnMjluTzVYY1J6SVQ5NGoyOTY1c1JWVk9ENmhDRGs5RGpyblZKSHY1Ym9UNUpmL0FGWVBZMUlsNnIzSGxvR1FiT0N6Wkg0VSszdFFoYVNLUStjNjVaVlVjS1R3YWtrdUxhNXRRalFRb1dmYVh6OHc1OUIzcjVtYVU1TldQVFNzaVVSeEZRMjBSeWJRQndmbUhjMCtCaW9MeWgzWEJCeXB3UGYwNHBZWTQ1SEt1eEdGK1UrM3BnMUZPYnVEWXUwN1d5QVNjQThuUEhybitWYzdXdkthSUh2ekZJemVTV1VuRzNJR0Q2NEZGbmFNN3MyeGtqREhJemtuSFlIOGFqZTFlMGRaM1VNV3d4QkdNYy9yMHB0ekltWkd5N2VZdVl5akhnOEFqMzRwNld0RHFDTFFpTnMreVRjSXR4SVhkeVBVZi9YcTFCY0c1bWtiRzFSd3Fqc1BTc1V1UUJ1bGJrY0l3T1RWNjF2YmVLTlFjaHU1eFdOZFM1ZTU5ZnczQ2lyemxvMGFzMTAxdEFXamNwSUJrTXA1RmMvRmNpSmdlaEJyUXZKVmt0Z3luUEZZam1zNkt2QnBuMFdLYXB6VW85alpTNVVzR1U4R3JQblZ6Q1RQQzJRZVBTdGUwdUJQSGtkZTRyS3BSNWRUYkI0dU5aOGozTFVyRjBZZW9yTERZT0swNnk3aFRGTXc3SGtVVXV4cmpseXBTUklHcDZ2aXFxdjcxSUdyUnhPU0ZVMHJlZlBHZVJWNktYOTRLd281Q2pnKzlhS3Z0ZFRYTlVwbm9VcHFySHpSZWxuV0ZESTNRVmlHNGFhN0RNYWwxTzQ1V01IanFhbzI3Wm16VytGaFpYWjV1TXJXdkJIVGFQSThXczJ6cDF5ZTJleHJ0STFpdXBwQVpnVzJmZVhnci9oWEdhTXU3V3RQUHFmNkd1cjFWR2pYY0dWVlpTQVRuQVB2am5GZlhaVmYyRGt1NStkOFNwTEZSWGwrcHNMamJ3Y2oxbzVyTjA2WlFnQmVUYW5BR09EbjllOWFmQkdSWHNRbGRIekVsWVlhNWp4amR2SFl3VzRKQ1NPenNQVWdBRCtaL091b2F1SjhiM01iaU9KTTc0VytmMCtZWkg4cTVNeGtsUWFQV3lPRGxqSXUyMXprWTdwa2JyeUswaEx1dzNzS3dNa3k4ZHpXbXNuQXI0dkZxN1IrcVpiVXNtaTNQSi9vempQYXFsdkprWXp6VDVtL2NQOEFTcU1Ua0hpdWFNYnhaMjFxdkpWaWFnNXBhamlrRWk1L09uMW0wZDBaSnE2Rm9vb3BGaUU0R2FyTTJTVFVsdysxQVBVMVczY1ZwQ09sempyMUxTNVQzaEVFTUtxT2lnQVZtYXRyVU9tS2tiZlBQS2RzVVlPQzUrdmI2MVUxUHhPcXVMUFNZV3ZMMlJjcXFkRkI3azAvU05FU0JHdTlWS1hPb3pMbVZwTU1FSDkxUjJGZm9WM0xYWmZuNmY1bjRPbzlaRkJyVnRSVHp0VXY3VHlvUG5lMXQ1TUw5SGJQUDhxOHk4UmF5bXFhc0FoQXRZV01kdkdCd3NlZXRkMzQxVzNzdElrbWhhM1pybGhBQ0VBMlpIVVk5cTh1bmtFck80aUFCd3FiVHdBT0s4M0dWTHZrT3FoSDdScXhhNGhEbTRZTk5FdUZad2Ztd0R0NmNjVm0yTnpHOTBDeTdIZHlRNEdRQjZZTkUybVNlYXl3c0pZd29MeUo5MFo5NnNhYnBzVTRWbGwzRmVUeDFQOEFkeFhsdFFweWNtenJTYldocWZhVmtVZWVvQVljRkFCbjMrbEt1MmMrVDVnRGh0NjkvcWF0VEtJSVdoaXRDRVlCR1lvU0ZjOVNQd3hXWWZKaWxLdzRKKzRHUEdmejZWeFRsenR0RldzV0o1Uk16ckpreUtvVm1IQVVqMC9TcTRjaU1CdmtNWkxLTVpCOWNmaFRFWGRPK1NRcEp5Q2V2NDBTS1V0MktuNWdTTnd5T0IzNUZFWTlFQ1pQTEVDTUxKL3EraFB5OWUxWnNnMnNlbzlxdld6TEpaYlZJWlErMWlUamRqbW0zZ1dkd0ZsQlpRZWk0ei9uMW9TNk05TEFZcjJGVFhaN2xlRzUycVltUHlucDdWQXhxS1ZXallxd3dhakUyT0RTVWQyajZuNjF6UlNiMEh1TWluV2R5WUp4ay9LZXRSZWFEM3FLVGc1RlBsdXJNdzlzNmNsVWc5VWRXckJsQkZWYjZIZkZ2SFZmNVZGcGx4NXR1TTlSd2EwRGdqSGF2UGFkT1I5ZENVY1ZRdjNSaEI2bGpmTlIza1J0NWlQNFR5S3JyY3FwNU5kbkx6SzZQbm5WOWpOd24wTHpIQXEzOXJSSVVabTV4V0RjWHVHR3c1OWFoRndYNm1qMkRrdFJMTm8wcE5RMVpyWFYydHhLR1VZQUdPYVpieWZNeDk2ejFrcVdDVG10STAxSFJISlV4VHF5NXBkVHUvRGJDVFdMTmovQ3JNZisrVFhZWFY3Q0dDQXFlRG4ycmhOQWdsbkpLY0tFMnNjK3B6ajlLNlkzRm1iWXdFUHZRRWxjRWxmVThmNTRyM2N2bEtORlJ2YTd1ZktaL0tOVEdYN0pMOERYaGxFOENHS1RrQW41ZXA5YTBGTzVRVHhtc0MxdkVpS3REQ3ZsS1BtYmJ5bzYvd0JhM0k1VmZCQjZqSTk2OWlsVTVtMDNxajUyY2JkQnpBaXZOdkV6ZWRxZXBBRDd1MGovQUlEOHAvblhwUjZWNTU0aXRURjRnbEQ1Q1hLbmFmWEk0LzhBSGhYSm1hYnBwK1o3bkRzb3F2SlBlMzZvNDVQOVo5S3VLM1ExUys1S2MxR3R3eVNaenhucFh5dGFEY2o3eWppRlNXcGVudlZTUmJkdXNpa2cxWFJxeU5XdU51b1JNdjhBQ28vbWEwRWZLaGgzR2FuMlhMRlB1Yzhjd2RldE9EK3kvd0FEUnQ1OWpqSjRQQnJSckJEMXJXYzNtd0RQVmVEWE5WaGJVOTNMOFR6TjAyV1JTMDBIclM1R2E1ejFreW5ldis4UmZiTlFidUtXOWIvUy9vb3FIZHpYVkZlNmp4SzlYOTdMMVBiYlBUYkx3L1o3TFZHTXNtQTBoK1puUDk0bW1haEk4VVlaWkYzQldZYm13Q080SnF6Ym9McWVTZTN1Rk52dFZGQy9NQ01aSkI5OGo4cWJyVmxEY1dnTWtoaUtzQ0NPbnZuMnI3eWJ2Rzl6OFl2ZDNaNVo0d3YzMUc4czlMaFVZQkI0WEJKYkE1OWVLellyZU9XOE51cFhjaElWUU1FWVBUbit0WFZDVGVMTDY5a2Qvc3RxR1paVjU1VVlYQit2OHE1NlNDVzN1VmFkbWpmcStlb3p6K3Y5YThIRlJjb2MxOVhjOUNscFpIU3cyRnpGYitRQUdEay9QdHlSOHA0L0UwdGtQc2p5UUxzM3EySFdPUGRrWTYxbFdWK0ZsMnVaOXVPSHljajA0clY4OGZhZk8yeWxqOTdjdkJIcmtmalhrMUp5UzVaSzUwSmRoN3pBYllWakd4MkljczJBMlA4QURpc0wvUm51SlFxc1ZVNHlveXYxelYyV2ZZelNKTHZqWGNjRGtZN0RwVkMzdW11TGVSU0VpQkk5ejE5UDYxTVhKcHNMQUhXR1FtTm1jQmVkNjhlaHhUcDdpVzZJemg0dTJUZ2ZTb3AxWXlaVGU0SjVKd0tjOHhpMk41UUFITzNKeHpXbDFvMXVOWEVSWkxDZFpIWGFqWXlCL0QrRlNGeGRPSmZNVmNIQlJSei9BSUNxelNpV1krYUR0WmVkbk9UU1FQaEpXWnlySngxNm1oM2VyM0tUTE1kamtzSm13NzlCNmQvL0FOZFpsMUE5dktWY2ZqNjFmYTY4MkpYa0tzRjRBQXdSK05PY3JkMjIxaU40RlJlVVhkN0gwT1dTalhvdWc5SkxWZWE3R0tUZzBwa3lNR2xkQ3BJSTVGUkd1aGFrU2JpV0xXOWExY2tjZzlxdnByYmpncU1WakdreWFtVkdFdFdqYWptT0lvTGxoTFEzSkwxTHlFcElBSEhLbXNTNHlDZWFVU0VWSEtRUm5OVlRwcUQwTThaakpZaU41N3JxUkJpVHpUekw1YSs5Vjl4endLYTI2Ujlvcm81Ym5qZTM1VnB1YUVVdTVDZnpxM2I5UWUxVVlZaUVDRFBxVFc5b2RsNXQydVVEN1J1Q053cmZqV2FoelNzanBoamVSWG4wT3AweU13MkVFVVVvU2VVNUxIT0ZQSEh2eC9PdHlPMmtua0tNZkpuVW56Q0Y0STV4Zy9sV2JhM0NYZHVZREVJa1U0Q3FmdUVkeDM3VnZhU3EzS0I1VlpibUpzTXpEREgweVBTdmJvMDR0cVA5YUh6K0lyU25Kemx1eTJ0dUhqaVpsUTdnQVhIVDZmU3RLSHl5aEVlUGw0SUhhb1lMVHlYZkREeWo5MU1mZHFRTDVMS3FEaHZXdlNVWEhVNFc3azJLdy9FZWxuVWJIZEdQOUlpK2FQSGYycmRwakRJcXB3VTR1TXRtWGg2ODZGUlZJYm84VTFlTUxkbVJCaFpCdXg2SHVQenpXUzNCcjBIeGxvNFpEZjI2WVF0aVQ2bnVQYXVBa1hCcjVYR1lkMHAyWjk1aHNUSEUwVlVpWldvNWU2LzRBSzA3RnQ5bEczcHdhb3o3WHVqei9DQitsVzlNa2pVelFNdzUrWlRXRlQrR3ZJNGNCVS8yNlVXL2l1VzgxY3NKZHNwVFBEQ3FEOGRLU0M0MnpBOXdhNVpRNW9zK2lvNGoyTldMWjBRZmsvU29ZYm9TM0VpRCtDcTExZHJCYnZKa2NEaXNDRFVKVWVSMFlaZnJXTlBEdWNXejBzWm04TU5WaEJ2emZvYlZ4SUh1WkNEM3hVTFNBQTFTamtZSVdZOG1qek4zMHJvVk8yaDVNOFp6UG02czlzR2xheG9FN1hOakl0NWJTc0dtdFNvVERkMlR0K0ZWUEVYaVlEUTVab3BVREhnUnZ3d1BkV1hzYTZPVFZqNThTUmplSDY0alluMitsY0Q0cmhqMWZ4dmJXY0kyU01paVU3Y0QxNTlUaXZxc1F2ZFNqMWRqODRwcm1sN3lLME9ucmJhQnA5akczL0V5MUtaVE1qNVhLRTdnRCtHUHJtb2ZHVm9OUDFWSGVSQzBxL3ZDaWNaK2grb0g0VnY2bVpOTzFiUUx5NVdQN09zclJHU0ZEdjNFWXd3NS9TdWU4ZjZaY3JyRnpkUnE1Z0RLcE9jNE8wZGF4eHNlYWswbDEveU5xYmJtbWMvRGYrVktTOFpreW5CSk9RZmJ0VTlrSG5sUG5UN2tPY0toNUorbmY2Vm1Rd1MzZHdxaFhWaUNWQUJQdng2Q3RUU0xQemJlWjVVYmVHenZNZWNjK3Zhdm42c1l4VHR1ZWpUcHltMG9xN0puQThrUXRISzBaSUczTzBrZW5mSjk2cFJQRkNKQXFpM1laVXNRU3hQOTNPZjFyVk9nMjkvZUZScXRwYXh0eVRNc2c1SHZ0SS8vQUZVMjY4TVJXR3kzWFU3TzVEa256YmRpd0gxeUJpc1dsR0hOZmM3WTViaW5QazVIZjBLdGpiZmJFR1ZQbHEyQzdESmJzY0NrT2pJWlZqbXVwSTdjTjh6Q0xjMzEybGgvT3VrVHk3ZUpZb3NiRkdBUlViUnh1MjRxQ2ZVMXgvVzNHV2g5ZFE0ZHdzWUpWRTJ6bDFzR2lYSVlGUzNPT01pcWM4QmlrVnZtVVA3NXJyR2hSVmFQSHlNT1BZMXo5OWJTeHFyN3p0VTVHRDA5QlhUUnI4N1BIem5KbGg3VktDOTNyNUVHREhDMGJPQUZQWVpCcUVUQ09US0hQOTdIZW5QY2k0WlJJU01MaHNkVGpwU1NwNWR2NXFyajFIcDdtdWh4VzNjK2ZwMUowNUtVWFpvZkxFbHd1OU1CdmJ2V2ZKRXlua1ZidHp1bFVNRHp3Q094N1ZJeFY5NnNBR1gwNzBXY0hZOW1PTm80aGZ2UGRsK0RNd29SVENLdnlSZVcySFVqUGZzYWFzYUhPU0twVEpsVHZyRnBtYzJlZ3BmSlBWaVRWNW9sVWNDbXJiczNMSDhCVjg1NTFiblQxS0RLb09POVdiZTFKaTh6YnhuSHZTU1FBT0hDbkJxN2FSbmNHQkl4emtldFUzb2NxWk0wY1VWb1VYQVk5U2VwL0hzS3VXTTAxcGNKY3drb21Bclo2SDJxRjQ0eEdGZHhsbnpnY21wQ2hTMUM3eTI3K0U4NEZTazFab3lrK2JjNmV6bGUvRTg3K1h1M0txWUdCOWNkUjJyb0xBcWhTWlhLaDBJS04vZVh2V1Q0ZGhpYXlMSk1yT3VBMlJqSDQ5OFZKZWdEVVlJV3VBQVd5ZGdKQ2M4ZTFlMVNseXdqTGU1d3pWNU5IVzIycFc4emJCSXU3R2V0WGNLNUI2N1QrdGM5WVczbHlCdkxhYmN1ZCtRQTJQYkhBclJpdXBJWkdSMXhIbkdTY2hUMzk2OU9GUjI5NDVKUjdHaVNBUHBWVXlDNGZhb1BsZHo2L3dEMXFpdXBuWkM2UHNpSXh2QndUbXMyVFcvSmpTT0ZZeUJsV0piQUIrdlNzNnRkUWRtVkNtMnREV3VyV0s2dG5na1hNYnJ0SXJ5SFg5R20wdThlTnhrRGxXQSs4T3hyMDZ5MWxKZGtVamhaR0IrK0NCbjI5UlVtcDZQRHExbjVWeGplTTdIVWZkckRFVTQ0dUh1N285WEs4YjlUbnkxZmdsdjVlWjgvM1VaKzBFMDJGV2psQnJiMXZUellhclBiTVFURzIwa1ZSRVBTdkNsZUh1czNuVVNyT2NYMUhlZVVYNXVsVlh1QjVtNWFsZUE3c01lS2lhRlIzck9LaWQ5WEZTa2trUlhWNUxOaFdKd0toaVlyelQzVUZzS000NjFZamlCeDhqYysxYTNVVlpIRzVUblU1cE83R3BOSVR6azFjZ1Y1V1ZWVWtrNEFBeVNhbnRkT2ttWWJZMngzSjRGWDVkR2xWb21qbktwdUNrcU9RVDBQNTFuYm0yUjFReERwL0c3bnNiZWZwem1XNmtJMzU4dFFlUzN2L24xcmxkR2IrMGRjdk5XbmxWaDVvakEyayt2SDVEOWEzZkd0NkxMUjNtVU9acEZLb1dJUFVja2ZUTlpYaDZCYlh3MWFPSXcwcjdyb3AwM2M0NmZTdmJjRjdTVFcwVitQL0RIZ1FkNFgrUm9Seld0N3IxdmJzbTViTWh5aE9Ocit1QjE2OWFpOFIzNldtbGFwY3lDS1VTU2lCVUp5RDhveitPQlZIUjVZMWhGMDkzdHVKNWQ4Z01PU2c1eCtYSEdhcTNkaExxMnFYRWwzTUpMY3NUREh1MnFXeGdNUitWY1VzWFRqRGw1dFhmcjN0L3d4NlN5ckZ5U243Tjh2b1o5ckFqNmY5c3VyZEd0WW1FYVJiOXJ6T1JrS0N2TzBEcno3ZFRWMUZlU0JHbkk0QXdpakNxQjBBQTRyTmpUL0FFbmFBQXFuQUE2RDZWb3UrRkE5Qlh6dGV2ek8wZHYxUDBUS3NxamhLYWxMV2IvRHlIZ3hBY0l2NVZGTDVPMW1ZWXdNOFZBWmNIclZhOG4vQUhCQVBVNHJrVjJ6MmVUbFZ5RkpHUmlVZnFlbFhJYmtPTWRHOUt5bGVwRmtJSUlQU3RaVTB5WTFFeldmNWtKSGJrVmszSitkeDI2MWZobkRyZzFSdStKUHFNVk5HOFpXRlhpbkR5T2ZlTXgzRWdZZ0tUa1ZJQUpBTnpjTndUNlZOZG9wVU1lb1A1KzFWMFZzWkF3RzZWNjBYeks1K1o0NmlxTmVVRnNXTGFOWVczTklCNWJaQkhPY2Rxc0JVallORW9Ka0dXTERQNENxMXFZanVNZ1k3UmpBN2craHFlNkNsRUVjTEtvR051NGtpb25yS3pPSWhaempEakRaeUNmV3BaN2VOYmNNQjg1T1NGUFhOUnNzVWFvQ3FHUTV3RlBQNDAxQklEZ1lKSklLNTRGV3U0aEk0eGtoZ0hJWFBYcFN0RTZvR2tBVk9Sak5TS0ZlM2ROaDNBNTZkTVZMY1c1bnQ5cXlxemdiVlFjWjcvalZhdDZHYmwzSzhibThrOG94QmxLa0JzWXdCM3FXeWpNVEdHUVlQWGtkUjJxQVFYc0NSeXQ5MWNydGIrSDJJcXdybVhQUUdFWkE1eVJua0Q2WkovT25LRGpvT0QxTlBVTEtLTzF0eGJ4RXBLTXBKdHdRd0h6TG52Z244aUtvbUtSbE1rbUFWNEJ4akgxRmRKb3QzRkxhU1drMzNYeEpDY1oyeWdjZmd3SlUvaDZWWCt6VzhubUc1bGFEZVQxNk5qMXJTbCs4V3JKcWU3cUxZeUpaNmRKTEZjSzhZeHVBQkJKN2pJcktuMXFlUzZWMTJncUJnZ2NOaW9idTdDaFlMWmhIQ1NlUjFQMXFreDJ6Zk9ISzhrRURQMU5ieXFOZTdFeVVGdXowSHd4ckU4d2VMQUxaNDNESUJQdjZWMGkvTkdZbzFESVgybmFjalBmOEs4MzhPWDIrWTIvbUtrWitZczdiUnhYZTNPcExEYUpQR1ZFam5HN1AzZXd5QlhwNGV2OEF1N3k2SEpVcCs5WkMzTXNVeCt6YldhTURKd1B1OWlQd3JNdjVZb3JhVzNYS3hSZzdTVUdXUEJIUDFyUXNsdW1oTXN4VmZNNGZJUFBwbm4zSnhVZC9ZdExHdTFXT1J0K1ZnQTNVSGowNlVWWEtVYklkTkpNekxLQnJ6eTJaTXFEdXlUalorRmRSYnpiVUVjZ2NFRGhtSFVmaFdIb2NBdHBqYnlxREhJRHRjY0E0L2hyb280U213S29DQVk2MXJoZWJsOHlLMXJuam5pOU1lSnI3M2t6K2dySGpYTmRGNDJqMmVKcnZqR1NwL3dESFJYUHB4WGo0cGZ2R2RzSDdxTkd3MEM4MXJlTE5FWW9CdTNPRkl6OWEwZjhBaFd1cHFobFo3ZDNIOEJrUCtHS244RjN2MlhYSWxKd2syWWorUFQ5YTZ6eG5yUTB2U3pCRzMra1hBd1A5bGU1L3BYWGhxTkIwWE9TMVFwNHFxcEtuRkszb2VRM05rYmU4WkNCMXdjSEl6V3ZwVnFtME50R1FjSE5RYlBOdHhJUmtvMmZ3clh0a2h0NGhJWENSNDNNekhnVjUwclJta2RkM0tOeXpERVcrNk05YysxWnVvNnQ1aXZaV0dHQitXU2ZINkwvalVGNXFNdCt2MmEyekhiZnhOMGFUNitnOXFJTFpZMUFBcTl6STMvRkY2ZFQxcTNzclc2RHdsVkdBUndQN3ZIcFhRK0lOV2hzeGFXdWt5eHU1aENPeUVreDQ0MittZno2VnlPa0d5Z3ZEZEY0dzZxY0U5aU80RlRSU3h5WHMwcVpJTGxseWVkcFA5S3p4T01rcURVZXIxUFl5SEIwS3VLVWF2VFZlWnJ4RGFxanVCejdta3VKbWpna1lIQkM4VWlObGNpcTk2K0xWL2NWODV6T1V0VDlJc2tVTGU4VVBpWGcrdGFFc21WeURrVmhNS0k3cDRPT1dUMHJwbFN2cWpLR0k1WDcreHBNMlRWUzliQ0w5YW5qa1dWQXluSXFLOVRkYmtqcXB6VXcwa3JuWFhmTlJiajJLYXRVZ2FxeXRrVklHcm9jVHlJVlMxSEtVWUVVWGtnTHFQWG5OVnQrS1pKSnVLSFBRWXFWRDNybXM2L3VPSkhjdVVUSVVOeU9EVUhudDVBaExCZ3VmeTlxc3VyU3VGUlN4STZBVlZuWTdseGdIR1B3SGF1eWtycXg4Um5OdnJMOUNVS2l4b1VKRGM0R2VNK3VhYVpwcEZ3WkNBb0lKSEhGV0pMZFZzbFF4RU9HTzQ0eG1td0w1YTRDZzVYR1R5Qi85ZXJzZVFRbys3YVFmbVFER0IzL3JWaGIwdHZDeGJWWnVXN2s5NmJqZ0NKbkdSbkczdlNCV2ZLeVNCWGk1VmR2ZjBOSEtteVdUQVpqNGpVRURJMjhGc21vVVlSeUNUS293Ykd4d2VmY2tkS3NSNzBsV0tYYURqbmozcDk1YlFXVjNKYnVTRWJvMk9Hb2pWNUprdU4wVTVMeGhIbnlncERkYzVCNTlLdjJaa1NTR1FJQys0T1VQS3VNOVBvYzFtTGF2R0FaTnBnYy9lUFdySDdtTzZMUmIyaFVZRFB4ZzFWYWZQc0tLc2FwS1cxKzZSWjhsanZqeUNNQTl1ZlRwbjJxYnhDMHQzNUY1RXBJZGRzZ3h4NW82bjhSeitkWmtiU1NLWThNem9Xa2laUjhwVWZlQS9EbjhEV3RaK1hlMjdXemtCWmh0RGYzWC9oUDB6MTlpYXg1bkYzWFUxK0xjNWtySkxNbmxoaXovQUNuMEpwV3QzQktraHNkZ09hdE9yUU93ZmVrc1JLTWhHT2VoelZtell0TGlRb2hIUG1OeUIwNjR6bnBYVFRsZXlNbkZocE1VaVhOdTRpWkFyZ0FzdWN0a2R2OEFHdXg4a3ZLOTFMWk9OeDJDSnVRdkhyNisvdlVrRU52WTJubUNiZGN5NExGbEdPM0hyZzQ2VnVYZW8yMmpXcVI2Zy9tWHNnM0xhdzQzSUQwM25vdjZtdlZjYU5HRFU1V002TkN0aUtpalNqZGtlbmhYZWEwazNJOGUxZ29KNmRmdmQ2bXRmMzFvVGhta1FsUnVHTVZ6Mzl1WG5tazIwY1VLRTVDbGQ1L00vd0JNVk92aUI0SXBQT2dZVFozSVU1Umo3ODVGVEROS043TjdIcDFPR01ja25GSjM2WE5OWlkydW1NeUZkaDQ1emcrbzlxMDRERzBlWThIMXdLNHB0ZGw4Mk43eU9HV0ZqaG5WY01CN1lycmJLU09GRmczN3VtMC9Yb1BmNjEwWUhGeHF0OHV4NXVhWlZYd0xTcTllMng1cDQ4WEhpU2NqdWlIL0FNZEZjc3A1cnF2SHgvNHFPYi9jVC8wRVZ5YW12UHhqL2VTTTZmd0l2V2tyUVhFY2lIREt3WWZVR3VoOFZSM092YXhiRzF0M0N0YnF4WmlBdU9TVG5vQnpqOEs1ZEd3UlhxL2d1NUYxb2ZsUGd0QzIzbm41VHlQNjA4Rjc4L1ozdGNpckpROSt4NS9jVzFscGFxa3QwMHFPaDNzaUVLVC9BSFZKNVAxd0JUb29SUFp5V3o4N1RqTmVpYTk0ZTB1NnNidTVsczR6Y0xFeksvSUlJSEhTdlByY2JaVVBaMHdmcU9QOEtqTWNNNk5uZTUwWWFzcWlkaWdJZkpVZ0RsYzB0bXpTUkZtNjVxN2NvRmxQdlVTQlZYamdWRVhkWFFOYTJLanpmYWJjeUtnK1ZWNVBHQjZlL1RyVDlPbnVKMkNRS0dTSWJtMjhnRG9TYXlyVzN1NytSb2JRTTBhcmduMjk2MExPeThxT1pmTzh2R0FkeHdHNzgxbE9sQ0VmZVdodFNxenB6VTRPeld4MFZyY28zQVlGZTFGOWsyclkrdFlFTnlzVEtZdnVrYzg5NjJJcnBiaUlxVHpqQnJ4S2xGd2x6TFkvVE1Calk0cWdwWDFhTTdPUlViRGluT05raktleHBoTmRDRk45R0ZyTVlaOXBQeXRXcnd5a0hvYXhKT21SMXJUdFpoTEFwenowTlJWajlvNk1CV3MzU2Z5S0U4WmdtSTdkalVUU1lyUnZWVjdkaWVxaklyRGFRMXRTOTlIblk3L1o1Mld6MkoybUpvUjhuclZVUFVrYlZyeTJSNThhN2xMVW5rbjhraHNucUJ4MXBVQm51R0lVaGw1NTdZNjFWbkpLZzR5QTJUUWs3aFNtVG5rOWEwaEhUVGM4SE5KcVZmNUdnMTJaWWdzbkxnNVZpZVRVdHBleGVkdXVCODRKSzVIeWppczZObWE0QkpNbUIvQ0taS3psc01BdUQyclZLelBMZXFPaG0xR3hCQVZBVDVZQ1NKeGh2VWcxbU1JN2d5eXpUaGRuTzBEbCtlZzlLaERKOHdWUGxPRHVQSng2VXQzQ3FNREhuYXkvclZ4VGVyMUZ5MjJKb1dWcitBeHdsWW5kRUc5c2tuSTZWcDM1VjVXa2VNT1FUdHlTTWU5WnNUaGJpempIQVdWV0I5OGl0ZWRBU1FSbm5GY0dJazRWWXlCeHNqSE15enlvSTRSdFhzRDArdE9XU0l1d2JCVW5xVHo5S0ZIMmRwVVlBQm55T2NkcUhsRWpCZ3VNOWowK3RkU2wyMkpjUVlUUk90eEJPRk1iZklVZmtIMk5hVnR0amx3bWZLY2JrejZIL0pINFV0bG9keHFFSUlSWTBISVpqZ3Q5QjNxMWRtelN4aWl0MEt5UWNtUThtVS94SDJBNHdQWSt0R0lqYUN1ZEdIb1RxcVVvL1ozRFVkSGUrdEZ1cmU3aERPeEVzVEErWVhIY1lIUWdqazQ1elZHQ3p2clllVzhSS2prZVhqaysvZkZhMm0zWUFlTWdzc3dDNHllR3p3Y2QrNC9FMHNrdTBuUFd2TnFZaVVXa2tmVFpWbFdHeHRCdVYrWk10M2VwU1FXU0ZRWTd1UWdoUWNpUGprajM1NjFTdEVVczAwcEx5TWNsbU9TVDYxUWxuWjVpekVrRGdlMVR4empieDBveFdJcVZuek0ra3kzSzZPQ3BlenA2dnF6UWVVRnM5S0o1bE5xd0o1NkNzOHlrbW9acmcrWWlrOENzWXRzNzUwMUZYRldab3QwVFlJWWZMbnNhN3p3L3V1TkRzYmdZTWthRk9lK0NSajhoWG50eDg2NUhVYzEzdmd1VVNlSDBVSEpTUjFJOU8vOEFXdm9za2FkUnJ1ajR6akdEZUZqTHMvelJ4UGo4ZjhWQzU2Ym8wUEk5cTVJZGE3YjRqUjdkYmpiczhDbjlTSzRqK0t0TWFyVlpIeE5OKzRpZGE3L3dGYzdOUWt0eWVKWXNnZTQveWE4L2o1TmRYNGFtK3k2NVpOMEJjSWZ4NC9yWE5ScWNsYUQ4eWF5dkJvOU0xQk4yblhTK3NUajlEWGs1VW9oNE9ZM0IvQThIK2xldTNTN3JTWWVzYmZ5cnpDZU15aGxWUmxrUC93QmI5UlhxNXFycEx5SXdEM0sxMk14cTRHYWdnaE1ySG1ybHNxWEVVU3VTcWtnTWZRVkpCR2dnOHhNN0RnNU5lTlFuN3RqdW5IVzVTc2JjYVhweXJLelJxeWI1VGtEUE9NL1RnaXNlNjFDeHZHUmZtV0pHSVJPbTdQY252VlhWTlNOd1ZoaUkyakFZbmtzUi9UT2FxMitueU01ZVpXU01BL01SeCt0ZE5lU2VteU1vWDNaWWx1U1V4YnhvSTB3R0tqbGo2MVlodVg0Wkd3MVZJSGtqM3ZzWjQySUROaXBTQmdsY2h1V1k0enVQb01WelNwYzJrVWV2bCtQZEI4cmVqTDV2Qk9RV0cyVG9mZWxMVm5rNU9HQlJ4NjhVZWM2akJybWRLMmlQcG80MjZ2SjM4eXpMS0FEVlEzVWlaQ09RRFVUeUZ1cHFFdFdzYWE2bkJYeGNtL2RkaTU5dm1aQ2pPU0QxelViTmtWVzNBZDZlQ1N2UHlqMU5WeUpiSFBMRnRyMzNjZnY0Snp3S2tna0RBbnNPOVFQR213RjJ3blhhTzlOa21ZeHFzVWUxRDBOUGx2c2NieGpqSzVlVEVvSkQvS0RnZ2RlbFJLb0xOR2h6M0p6elZhQ1ZzTkdwd3A1TlN3ekpES1dWTXVPR0o3RDFyV01MYkhtMWFqcVRjbjFMcmcyeXFJcER1eDh6OGdaSTZWRXFZVVA1bTl4OTRZemdWZHVicU8vTU1hYkU4c0R2OHBQclZKcnFScEdqd0ZjZktTRHhpczNlK2hNWGMwTjBMUXA1Y1FqeU11UWM1UDhBU3BZUkdxbDNHVVRuQnFoRmNaQURZTEx3T01DckVrbVlraUI1WnVhdWpUU3U1Ykk2NDJpcm1nMFVUVzhGd0FGTzdKeldsT243NlZjZEdJL1dzUy9rMndyRUd4czRJcmRsYmRNWEg4ZnpEOGVhNWN4aWx5U2oxUmhXbGV4ajMwYUxpWmxKSTlCbXBrMDJkbzR5V1hoZ0NuQUl6eU9QY1ZZbWk4eU4wUHBWZUhXWjdlelMwYUtPVHk1Q3dKSHpIMnpXbUNxUWxEbG51dGpIM3JxeDBqK0pUSFpHd0ZuYWJCOHZtbVA1L3dBRzdjK2xjM0JMNWpxQWNGV0lQMFBXcTg4cGNNU01FOGtHb0xTZnlyaFNlbWVmcFdOYVU1TFZuM05DalFwcE9Dc21sY3U3emJUU1FFNTJuZytvN0dyOHMvbnFzM1RjUG0vM2gxL3gvR3FHc0lWOHFkUndQa1kvcVA2aXE5cmQ4U1JrL2VHVjQ3Ly9BS3Y1VnlPSFBGU1JobDlUK3o4eGRLWHd5LzRkZjVGbk9hRmsySFBidlRBVGlrWTVCb3NmVWUwYTFSZFZnd0JIU3FjN1luTlNXakg1bDlPUlVWMk1UQStvcFJWcFdOSzFUbm9xWktIekdSWFErQWIzWnFkMVpNZmxsVGVvOTFQK0IvU3VXRDdWclM4SVM3UEZ0cVNjQjl5L21wcjBzc2s0WWhOSHp1ZXhWYkJUZyszNWFtdjhTNGYzbGpPTzZNaC9BNS9yWG5YOFZlcy9FUzI4M1FZWmdNbUticjdFZi9XRmVUc1BtTmVwbVViVldmbkZCM3BvbnR4dmtWUjNOYjBUR0M2aWtIOERCdnlyTDBtQXkzRzQ5RjVyU2w0YXZEblV0VlNYUXRucjhyYnJWMkhkQ1Fmd3J6UlR0bXpuSkFCcjBYVDM4L1JyVit1NkJTZisrYTg1eGhqWDBtUGQ0d2ZrWVlUN1JCQ0RGTk1pNVhZK1I5TzFYdkVtazMwVmhwdGhKSkcwRU8zTHhxUjV3SXlyWjc0VTdmWTU5YXF1SFM4Um54bVZBM0F3UFQrbGRuNGY4Zlc5dmJ4YUxxOWtzOXBHcFVHUVpIYm9lM1d2Q3BPMDVSUFNrK3JQRUxOakZJSm1Ddms0R1JtckQzRWtrbTJXWmlnQjRCem1tM050THBrNXRwWXlyS2Y0aG1wYmUzR0N6S29KT01IaXV1VWRic3dUdnFTcXM4VXdVS05zaTV3TUhBclZWQmF1ME9XRGdnbGovSG42OU9PYXltQmhkOXFveFhnSGRqUFBiMXE0Yk82YTV5YzdOdVdabE9DQjdWaktvb1AzZENrcnJVWmN4U2F2ZmVhcFlSeHFFNEhDajAvclZhVzJtZ25lRTdaQXJiYzU0L090aFlJNXJjUTJiU3U0WGM4YWdqQkhmSDRjMDZ5czdhV3d1Ymk1TzZXTlZaWWdjSTJlRFZ1RGx2di9BRnNiMGNWVW8vQTlEblpJbDdoMCtvcXM2RU50VXFSNmsxdFJOTEhQOW5LN0ZZNVV0enhWR2UwSXU1RS9nYmtNUGZtc0l5MXN6cG5qZWRhcXpJRWkrWExiUjlLcXNDWk01eUswWTFlTTdGVXNtMGdEZG52U3dyQ2tMSklvSlk5c0U0OXYxcTd0TTVKVkhKbExZeEtIYnVDOUJpbGx4aU53dk9jOEg5TVZzYWZDaVNaTzhvMlNoSXh1WE9NL3ArWXFucU1MeFhJajI1Ry81Y0RxTzJLRkwzcmRoVFhWRk8zWUZ5QUFBVDNxd05ObG5sR3lHUjJmaFZSU1NUVDlNTUVkMEpKbzJhT05pMkFNODlxMlcxdTJqZHAwbGN5NHdBZzI0NXpuK2RkTm9xUE1aT1R2WkdITkVJcFNqUXZEdEd4MEk2SHZRMGd0Ui9vNmpMRGFaRHpuMXdLdlRTV3QzSzA1WjVDVjVWajM5dTlVWG54QkdqS3JCTTdjTGc0ejNOY3lkM2F4cEZpaVVnamVxNHdNbGVNMVp0MkQzVVA5ME1NMVNrbWtuUU1TdXpQQ0RQeTFhdFFVQWZQQStZVmNyS05qVG0wTFdwU1JpZHNZZDNIVDByb0kyM1cxcTU2bUNQOEFNS0IvU3VYa25Fay9tRkdLNTZkTzFkZHBqeHphUmFyZ2t4aG96azU3NS84QVpxNGNUSDkwak9iSW5RZ3EyUGxQRlpOOERCSVdVRDV1cHhYVDNFYWlCY0RnVmo2bmE1aDNqb2E1S0UrV2F1VEZtTVpUSXB5U1Q2bnZVRFB5S3NNNThsSUFUNWdQM2ZXcXNpbm5Jd1JYcFNqYlZIMHVYNHB6cGNqM1J1SS8yL1NtaEdDNVhiejZqa2Z5cm5vNVNwRGM1VTFic2Jnd3ljSHBVVjdDSTlRY3FBRWwvZUtCMEFQYitZckNuSGxiajBOczM5K25UeE1kMW8vME5SV1VqS0hLOWo3VWRhcVdoSWgyay9kT0tzYnhXTW8yZGo2SENZbFZxTVo5MFQyM0V4K2xMZkxtTVA2R21XekF6SDZWTE80ZUdWZjd0WnZTWjZNZVdXSGE5VE9kL2xGYnZnMjBhNDhTMnJnY1JicEcrZ0grSkZjeUgzUzQ5SzlQOEE2VzBWbkxxRHJ6UDhrZWY3bzZuOFQvQUNyMjhzb09WZFB0cWZGNTFqWXd3MCs3VmtiSGlxMCsxZUdMMk1EbFVEajhDRC9MTmVJT3A4ekZmUTkxRUpiT2FOaHcwYkQ5SzhFdWJmN1Bxa2tMZndPVi9XdlF6VldhZmtmRDRaKzR6WjB1M0VOdG5Iek55YVM0R0RWbTJPTGYzcXZjRGsxOGxHVGRSdG01NmY0YmZ6ZkRsa2YrbWUzOGlSWG43Y1NrSHRYY2VEbjNlRzdZZjNXZGYvSGpYRVQ4WExqL0FHai9BRHI2ekV1OUNtL0l5d3VrcEMzeDNMYlNmM0NZL3dBTUFqK3RSRlAzNGZBd0FmcnpqL0NwcnBNMkxuKzZ5UDhBb0IvV21Ea0E1Nml2QXB5dFYrODc3M2ljM2ZNaXlmUG5jV0ozWTVCK2xVN2lXYTdqRTZya1pDa2hjWUlITk1JVzl2SjJMQ09CQVcyNUg0QWM4MW9RZVFBelJ3dEtzV2MrVzJEeU9NL2pYZEdNbEhWbU4wWHRLaGlNZHRiT3hkbVVsZW1RMmVRQjE2VkpjVzF4dHVWUjVOd0lLaGpqUFB2MUdLYmJOZkxwOGFSV1JqY3lFaVhZY24yeWVuR0tXTzZ1N2k0MlNSc20zRG9xS09XSUFIMXAxSUtMdWwrQUp0N21sWjNGdjVua1hFYXdya0JtajViYVJ5QmorZGMvZHhKYjN6ZlpWREtKQzBJeGtFWjZHcDB1WnJSaGRSU3RIUEd4eXM1T0dHZW1QV3FsN3FUM3N4S1o4NStRdUFvWFBVZm5WT2Q2U1hVRkZxVndtdWJlNWxrbHVXZU9RakJRcUR4amcvblZLZTRhVjE4czdjSEc3MUIvcFZlNGphMWsyZ2xwR0hQcGcwZ016SDVnUGw0d08ySzVZMDE4UnBjdTNFc2YzSVFyQlJoampINEQxcU5iVU15T2R3OUFGeXg5aFY2eGVKUmlOUDN3VW5sQ2QzR2VCVU9JM2xta25sMlk1QVBCUG9LM2hHMHROU0d5emEyazdhYXR5Zm1jeU5zUlI5MERybjY1ei84QXJxeEk1bXNpOFVjY2pvcHdHR2Nqdmo2ZFIrTll0MXJGdzl5eC93QlhnQUJRTVl4V3BhM3dtY1hDL0taRCs4QUdBcjlUajBCNmo4YXlyeFh4cEcxTnUxbVk5dEpJdHRPVWlEWmNESVBJNTdDbzd0QkJQdGRUR3JmTVU2NEhZVmQxYTNGcElwdDFJamw5ZW1lNC9yV1N3YVVmTXpOTndCazlxM2pKTlhJYWFaTEsyN2I1WlhBWGNWejA5cWZMTUpsNDJ3cWlEQzVQUDAvT3M4QnQzUFdwblBDZzloaWs0NjNZMG1XenQ4c2VXKzVjYzl1YUkyVWpCSXllT2FyeHR0UWphUHFhMTdYUlo1TE5Kc1I1bXp0VXY4d0g5N0hZR3M1TlJWMnpxbzRlcFhseVUxZGkyald6d09IaWRpRHcyNDF0NkpLUExtaUJ5QVZaUmpISFEvMHJJazBtUzFrakV1OVZmQTRHQWZ4clIwNHhXMXdJNDJCVnpzYm5uT000L01WaFVoR2ROeVRJcjBKMG00VFZtZEw5KzNOVmlvbHRXUnUxVHdIS2tlb3FLSWZ2SFUxNURkbWNteHk3TzFucWl5aklLOGdoY24wcHVyVHkzMTFKZVBibVB6Q041eHdXOWZhcitvU3pXTXpUUXNFUFFuYUR4K1A0Vm1yckJoa2FCY3kydk9JNVR3VDB5ZndyMzZEalVvcTdOcUZlVktvcG96aXhVN2dhc2lVM0VLRS84c2pqOEQvOWNIODZxc2R4SlVjWnFXeng1NVRIK3NCWDhlby9VVmpLSjdWYXQ3U2kxRjZNdW9oVUZ2bEF4azU5cXJYRnlFZFhVNTdHdFNDSHpJOEhJR01IRmNwY0ZvYnFXQnczeU1WeldWR0ttMzVHV0V6SjBhSHN2UFEwNE5TS1hDdWZ1OTYwZlA4QStKYkxjRmxHOXNLQ2VUK0Zjd2lzN1lEVjAraGVGTlMxZWRFaGdrRWVmbWxjRUtvOWNuK1ZkUDFUMmtrb0kzaG4xU2xGcHZ2K0l1Z2FMZDZ4ZWhZbzM4b0VHV1JWeUVIK1B0WHVWcGF4V2R0RkJBdTJLTlFpajBBRlJhWHBWdHBWakZaMjBZV05CaklITEh1VDdtdEFMZ1Y5UGhjTkdoRzNWbnlXT3gwOFZMWFpFYkRLa2V0ZUgrSjQvSTErUnNZM051cjNQSE5lTCtPb2ZMMWJkanFXSDVIRmNlYVJ2RkdlRmU2SkxUNW9oOUtpdThicU5MYmZBaDlxTHZxSytMU3RVc2RYUTc3d08yZEF4L2RtWWZ5TmNkZWNYMHc5SkdINjExbmdKczZST1BTYy93QWhYSDZpMjNWcm9la3pqOWErc3FPK0ZwdnlNc1BwT1Jka1hmcDU0R1hoeVB3Ly9WVk9MNW9rclFnUG1XMXVvUFdNcitaWVZtd2tpMzQrOHAvV3ZtM0xscXQ5bWRzZGluNUZxTFdLMnNiR0ZZNWo4bHpNdTZTWTV3Y2MvS0IzcnFQRG1ockVTc2p3UXh3eWh6Skh5V0haYysrQWE1L1ROY0YzZVR6UGFxc2txa1JKdEpTSWdESlQwNUF6V2xhYXZjTFp5d1hhb1ZMN281QURobXdNODl6WDBzYTlPTW03YXBmMGptbENWamYxUzdtdEZqc0xWSTFkSno4cnA5L0lMQWdqOEt4dE8renhXa2w1Y2tJMGdNWVh5K1MvQjNaL2hOWXNGNWU2anF4dVZrbWFNNUREZHQ0eGtqOVAwclN2OVlnTmdYdW1ReUpIdHRvbEdUdndRQ1QwNHlPMVlTcnFiY252WUZCeFZqQXZib2ZiWmJWSTg0YzRabUpZQTQ1SjcrMVZ4R3NWMzlvUUIySUh5bE9VQTdZNzlLdmFkcDB0OWR4eWlBeVR1UnVYZzd1Y1p3ZW9xbHFVTTlyZXpwNWhhVk1xeHhqR09vSHFPMWNrNFNsRG1leHNtazdkVEp1WkJOY2IyUEpISHQ3Vk1rZTdFVVdIWXJubGNjK252VldaSmlxbVJjSDFJNS9HcGxVUzRWSDJZWGx1bTQ5ZjhLbFJ2R3lHSWwwcUdRU0VnRWJSamdxZnJWS080a2lMSU1FTnhrODBraGwyaEdCQzV5M1AzajYwakF0dEpPUVJ3Y2ZwV2tWWUJjU1hEanpDeGM5T001clRzeVlibGJkblZWa0FEN2dmbDlEOVJWVlk1VUt5Qm14akE0N2RLblJEZ016ZzRPMGp1ZmNWTXBhV0xpYXM2TExidlozT1VrQjI1UDhBQ3c2SC9QWTF6RnpCSmIzVHd5RmxkRzJ0dUdDQ0szWkhqa2dXU01mTkZoWk1ISXgvQ2ZyMi9La20wdHRWaEUxdVZFNkFKSXVNYmgyYlA2Zmg3MWxDU3A2UFk2YWRDZGVTakJYWlIwZlNqcTJweDJrYzBjU0hCZWVVN1VqWHVXUHBYUzYzNGQ4UFFSUjJ1bWFuY1hsMEcvZVhBaEN4WXdlRkIrWTg0NUovQ3Mrd3NKTFNMeXBnUStjdDcrbGE4U1JJQTIwYmgwTlkxc1piU0I5YmwzRHNaUVU2Ky9ZNSszOEwzODF5QXdTT0VESmxMWkFIMDY1OXE2NUlvb3hHb0xIeTFDS1dPVGdEQXFGWnVsTWFiTFpyZ3ExNmxXMXozY0RsTkxCeWs2ZlV2WEVhM0Z1MGNpZ3FheG83R2I3U3F0Rkg1TUpKVmxBQko2ak9LMFVuendUeFRWdVJGZENOdnV0M3FJVkp4MFE4WGw5SEVXOXF0djZzWFlPR3hUWC9BSGR5UGVyckphb1ZaWmN1UnlvN1ZUdThGZ3c5YVVrOTMxUHl6RVUvWjFaUTdOb3pkWWdXUlR2R1ZQQnhYSXl3b3ZUaHNuQ25yaXU2dms4eUVIR1FSWEU2aEcwVjd1WXR6M3J2d0ZTNjVESkRubCt6V3dpZUZHWS9NVzQ3MVdqa01ick1GQkN1TWZYclVpeWJyZGszY0ZnVG51UFg5YWh1bEN6bGsyYkNUdDI5UDE1cnYzZkthd3FTaDhMT3N0VlFzU24zRHl2MFBJclRUd3ZwbDdDdHp2MzNNcllNTWo3VUdPdlRrNUhQVVZqYVRMdnM3ZHgyWFlmcUQvaGl0Ujd1ZXp1TFY0QTc3cE5yeHFmdmpyajI2ZGF5d2FqREV1RWx1WTFITGw5MW5JU1dNdWlhK014N1dpa0VxS2ZZNUEvU3ZvZTBsanVyU0c0aU9ZNVVEcjlDTTE1ajR4OFB1YkNIVnhHcXQ1bTJUYXhiS3QwSlBybmo4YTZ2d0JkK2JvWnRIY3M5czIwWi91bmtmcmtmaFgwR0Zmc3FycFByc2NtSS9lVTFVUjFXS0tkU0d2U09JWWVsZVIvRUdQRjJyWS81YXlEUDQ1L3JYcnByeXI0Z3JtV1U5a3VpdjVvcHJ6Y3krQkhUaGQyWWVqTm0xSFBUakZUM2ZJL0dxV2hITWJnK3RYN3pwa2RLK01xSzFabzZ6c3ZoOGY4QWlYWGc5SmdmMHJqZFliWnIxOHZiejMvbWE3TDRlODZmZWNmOHRWL2xYR2VJaGp4SHFBLzZlSC9uWDFEL0FOMHBtVkgrSkkwckZpTGFCdlFIL3dCQ05WbFhiTGNSOWxkZ1B6cVRUVG16aXo2SC93QkNORWlnWDg0SFEvTitZQnI1aXEvM3MvVTdJZFM5cUdqV3k2UnB3dDNhS1VSc3p5N2dBWHdPY1o0R1JXUkpMZDNWcTBjS3JjeUZqSTB3QnlwNHkyUHFPOVN4V3I2aGJ6U1JsaEVoODJYYzVYNVFSbnJ4akZVSDFTR0JObGpKSVRzS2tNY1o2SEI5ZU00cjM2a2szenZSTXlTdG9TM3NkNWFpZVVMNVJHMUpRSWdxWkhCSFgyNjlEbXNPS05wcjJLUzY4eE1nN0R3TjJCMEhybmdWdXZvRi9xOWxKcWM3ekJIZEVJa09Xd2NFRUxucC9qV1pkMmF4QnBMZHQ1ajVJOU9UMnJucXJsbHFqU0xSY1R4SytsTThNWDd0NVB2RlJuQTQ2R3BkVnZiRzlrUzc4d3FOZ1FRajBBNkE0NS8rdldaR2ZMZysxVHloeHlnVUtNNDdIMTYxVnVMQlBKTXdtazMrWU5wYzRHUDZWUHRYeXFEZWd1Vlh1TWt0RnVra01ja20xQUNlT2xWSGhEUnV5RnlVT0Q4dUJWaEh1WVdEbVRhV2JDc1QwcCsyV1NPYVFGU0U1TEVaQjdVcFQyR2taTXNkMDRVc3VBdUZ6ajFyb2JYU25mUUpnTW00SkxaOVFCMHBFa2lrdGpLUWtjMjBvdklLdDA2NXJYOE5rR0o0Uys4cXhVKzN0V1ZldktNYng2QnNjbEFTSVN5YmlWWDVoazlNMU5iMmQxZFFUeXh4aGdtQ1ZKd1FDY0NyMnNXeTJON2NSNENMS044WkE0ejNGVmRPWW9oVGM1ZVJ3WHowN2dmenExUG1qem83TUhSVmFyR20rcG82THBwaWpmN1hFVldVRk9lcFU5OGV4d1I5S2hzNTIwelZERGNaVUszbHlaSDhQci9JMW9Xc2hWaUQyTlZQRlVjangyK3Bnc3dJRUVySHNRUGsvd0RIUmovZ05jMFp1cFVjWmRUNmpHWmVzSGg2ZGVqdkI2djUvd0NaZXVaQ0xwaG5PM2lwRVlNdVJXVlpUTmM2ZkZPY25IN3BqN2djZnBqOGpWdUtUYWE1NTArWFRzZlRZTEdxckZWRnN5NVJTQWdnRWRLV3NUMUxobkZWYmh5WlNjMWFxaEtjeVA4QVdyZ3RUbXhVclJSc1FURWlPUW5naXJzdnpSNS9Lc2VKOXRtZ3p5Q0QrZWEwN1YvTWd4MXh4V05SVzFQeTdQS1NwWTZhWFd6KzlYRlRFbHNRZTFaTnhZd1R6Ylp5eXEyY01veVFhMUlEdGRsUDhWVjU0L21QcjFGVlFxdW5VNWtlU2M2MXJDMitHS1loVjZnZ2ZqVlkydStSREtYYUpUZ0JldVBhdEc2OHl6dXcwY0lhS1llbkE1NUIvSG44cXMyV2hYdW82akl5eEh5d0dKWW9RT1A1ZlN2b3FQNzFjMFZ1SnV5MUpyT3dheXRVSURpT1FpVk4zSXdlUHo0RmJWZ2dsdVl6a2JreTZnNDVJQjQ1L0dyRjNIL3hKNHJjdVVNS01SQXdJMmtFZE94R0JtcXVuTVJjUThBL01CeU9PZUt4cng5bGk0eTlDWXZtZ3p1V2loMUhRWmtaVzh1WmZLZGV3UFRjUDBQSEhGY1o0T3ZXMHpYVmhtTzBPVEJMOWM4SDg4VjNXbk5KREJKYmtobWl3QWhHU285TVpyaXZGTmdiRFdvcnBFRWFYU0JzTDBEamc0L1EvalhzNHhPS2pXanVqbnd6VDVxYjZucG4xcEQwcW5wRjcvYU9sVzl6L0U2NGIvZUhCL1dycEZlakdhbEZTUnlPTm5aalRYbFBqcHQ1dkQ2WDJQOEF5R0s5V1BTdkpQRjVEd1h6K3Vvc1B5WEZlZm1MOTFIVGhscXpudERPWGtHZlN0TzdPSThWbGFHZjlLY1ovaHJXdi91NC9HdmtLLzhBSE9vN0w0ZUtmN052RDZ5aitWY2I0b0czeE5xQS93Q203VjIzZ0FySG9rek54dW5KL1FDdU04WERiNHB2L3dEcnBuOUJYMDcvQU4wZ1kwZjRraVhTbXphb1ByL09wYmpBMUFmN1VhL3l4L1NxdWtOKzdRZldyZDJNWFVEY2NvUit2LzE2K1dyL0FNYWFPcU83T2RzMHZkV3VJcmVIWXFTbkF5b3dNRHFjMTExbm9tajJ0dE9sdlBJMHNSMmI1VnlOemNGOXZiSFN1VnM1WHRRanBPR25YNXNEbkhUQSt0ZEkycVN5YVdVczQ0MW1FV3lZbCtYWE9TZW5CNjU5aFh2MGFrVkZ1VzVOU0xleEZhNnNqdThFMitSUTZzaFU4T0FUdzM2ZTNGTzFFTmVOYXltZEpKV0cxbUtiUXFFWUFQMEpyRURwQ0Njbytja2pwaklINWoyOXF0S3p5SVFKUWlNd0JrUEpUSHpkQjI0ckNwV2xOY2pHb0pPNktxc1VEeGJjbFQ5M0FCOWlUNmNWbjNFWDJtVU5JNStWaVd3T2V2dlYyNHRRaS9hSTNBK1lLMi9rbmpralBiL0duWFVKaGVmS2IzaStWaW5Jem5yK05aS2k3M3VWekdGTHZlUllJbzJPVHdEem4vQ243aEJCa3NBTVpLay9lNTZWdFBmV0ZzMjFXSlpzSElqSEE3am5uclhQM1ZvelhPWW5LVzdjN202TDYxcW9KZTZ4RWhudDQzOHNNUExjN3hodHdYanBpdFB3dElFdUpkbytSbXlLNXA0aEZKNVlHV2JvUWMxcWFFWnJYVTBTUU1xc01nSGpOUmlLZDZVa2dPbThWMmtjMW9yOUhIekw3anZYUDJycVlGSTZvUmcxMCtxc0o0b3hqbFIxckdYU3BJclpaa2J6UFBkZ3NTTGtnREpyaHduTk9seXJvZXZrK0toUnIybm9ucDgrZ0J2bTNEdlUxeEQ5dTAyNXRkZ2QzVE1lYzVERGtZOXp5UHhyTWpuTVoydDB6MTlLMGJlWW82c0R5Q0NLbVNjR211aDkzR1VNVFNsU2wxVmptZEV1Tmx3OExNQUpGeVBxT245YTNRMWN4ZXQ5aDF1WnJmTVlTVXNnQjZEUEZieVNoNDFZZENNMTE0aUNiVTExUG5zbHhFb3huUW52Ri8xK0pwMnNtY29UN2lyT2VLeW81ZGpLM29hMFBOVWtnRWV0Y0U0MmR6N0RDMTFLRm05aVlkS3puT1pIOTJOVy9NMnFTZTFVYmR4TEtUMkhKb2dyWFlzVlVVbkdIYzB3bWJLWEErNkZQNi8vQUY2dGFjMzd6SHFLemJDNmU2bXVJVkh5ZVV4T1BiQi9wVjJ5YmJJcHJPcEZwTk0vUGVKWnduamVhRzFrVzVUNWNvUG9lYVM1NnEyT3RQdTB5dWZXb2kzbVd3SGZGYzY2TStmR0hjWUpFUlZkc2JsVnVRZU9mMC9VQ21hUnJNY2N5MjBjVHVGUW5hbkp6ams1K2xPaGtJMnNPbzcxaGF2RGNhZHF6VFc1S3h5amZHVjR3RDIvRGtmaFh0WmRpWEg5MnhPS2tqME5yK3l1NFpkenRGTExBRVdJSGNEbklIME5jL2JOdHdlNE5RZUV4SGYza2YycVp2Tlg1azNIQ25iMk5UN2ZMdUpJL3dDNnhINUd1bk1KT1RoVUZTamE2UFQ3VkJMZEM0Q01BeTVEQTRYR09oSDQxbCtNclZMN3crOGlrZWJhdUhIOGlQeU9md3JXMGk0U2JSYlE3bEo4cFFSblBPTWMxUXY3bXowKzNaSm1pRHNDc2tiWkpLa2UzdDYxN3RTcFRkSDNubzBaWWZEVnAxbEduRnRtUjRIMUpSRGNXa3JxcWpFcUVuSG9EL1N1dEV5cG5lNFVCc2JtSUFKUFFWNU5ZM1V1bjNybTNZYmwzSXBZY0VFWTVGWHJtNjFIVWJTSzJ2NXQwY1Jaa0M0SE9CMXgxNlY1VkxOWVVLWEpMVm85ckNaQlV4MVdWblpMZnVlalg4OE1GdnVudUVoQlpRQ1d3U1NlbGVSNisvbWFHa3VmOWJkeVBuOFdyVTFMVW4xQmJOcFNkOXBDZHh6OTRydUlQNVlyRzF6NVBEMWluKzBNL1hZRC9XcHJZejZ5N3JaR2VOeXQ1ZTR3azd5YXUveU1yUk1mYTJ5ZTFhMS85dzFsNkVNM0w1OUswcjgvdWo5YThPdHJYUE9PNjhGdDVmaDZKVHdYa2R4anYvbkZjWDR2T2ZGRjhmOEFiSFQ2Q3VsOFBYTXNHa1J4bmR3Z0s3QUR3ZHgvblhKK0pTNTEyY3laM25hVG5xRHRGZlNTcVhvUml1aG5TaGFiWS9TMndrWHU3RDlCV2xmajViWmgyWmgvS3Nxd2JiYXd0NlROL0phMWI3bTFqYis3SVAxSC93QmF2bWNScFhadXR6bTdkQXNwVXlGRVpnQ2lBa1lGYUgyaFdNMGNFNUFCUEFHM2VCazVLNTY0ejlLeXB0UXVaNGxTZFZtV0xDS1kyd1QxSTQ3OVRTM1U5dGRLV0VHN2EyNHFId1Z3Q01FRWZUbjJyMVpSYmlXTE1zanpQTTBaOG9yZ2JpZm14ME9LbVdSRWVNenVkcmdCeW9JOXMvMXBsaUlKbW10bGlJVjFMb3U3Y01EbmpqanAxcTdkdEJOY1JORWs3ZnUxT3lUbGdlZmJwZ2NmU3M1clN3MGlWYnFPS3plQmNTUlNnRGZLT3ZmSTlCMi9Db1pZNDJsTVVIbEUrV1NTc2pIQzUrdlBwVXNWMUsxcThjWktSQmdGM3B1Mm5udVBUbXEyb1djOEZ5NU02c3o0YmZ0Q0FnOGhzbjFIODZ0YXJVTEpGQyt0Sm1kQThxcWdBeTZBNEdjSCtSRlFQYmlSamIycnozR1A3a1dCV2pLUVlGUm96TWpwOHdPVllIbkJ6MzYwdHRxc1Zva3NjTVVxeGtENVFjcUQ2OCsxYVUzYjRoUzhpbUxhNWhWVk95MkliYVhmQnhub2ZiNjFiTmc5cXhtbGtXZVZXQk1oUEs1NkQ4YXBTYWpZczhxeStZb2FUY0N4enZIb2FzeVRTNmhsNHJsQXZ5QmxhVUF2MXh4M3dCL0t0SmNuSll6dEpzMXRSbGtpMDAzRVVZY3FCdXllZzljZDY1aDlVa01XOVpIVXJuQlhqWVQzRmRWQkRGZjZlSUo4bEhYQndjVnhkeFp2cDJweVdya3RHVGhYeGdNUFd2THdiaW00OVVYRjJDSzV5MkhZdUNNbGlNYzFmdDU5aEFKeU94cWxhNlhMZXp0Q2dBS2dzUm5HUU9UaWk1QnRaOElGMnMyQkdIM2xlQjFydWxRYzQ4eVBld0diZXlhaFVlM1VxYS9HQmVyS09qcno5UlducHFlZHBTU0wxVEtzS3l0UmxFMEtaKzhqZCtvclE4UDNhd3hUUnlFQmZ2YzFGUlM5Z3U2T3ZCMUtUek9iYjkyYS9IZjgwU3ROc0JPYXo1OVplT1FHSDd3WGFjMUhyRjFCTE9SYU0yeitMdGsrMVpWYVVxQ2E1cEk0OGZtbFNNM1RveTI2cjlEWEd2M0RSbFhDOGpCT0tudDlhV095ZUR5UDN6blBtYnVnOUt3YVhKNlZvOFBUZWxqaWptMkxUNW5OczdIUTdxVVhWbXFSL3ViaVI0M2tCNmtydEEvOGV6VzdDTnAraHJodEhqa3RkYXRtZHdvaGxWMndjZ2dFSHIrRmVoenhlVmRTSjJERVY1ZVBqR0Uwa2NlSXJ6clBtbXlhUTdvRk5WRjRZcVRnSHBWbUw1b2lQU3FqbkJCeDBOZWZGZERuSWxPeVVnK3RYTGl3dHRUMDAvYWJwcmNXMlgzckY1aEtuQXhqSTc0Nyt0VVp6aHc0OWF2MkVxTEp0a0dZM0d4eDZnMXRHYnB0VFJwU2FVMDViRUdrUjJNRit5eHl2YzJ6TGg1WlZNZU9Nc1FBeC9uelZtZDBlK21lTUVJN2IxRGRjSGtmenJOdm9mc0NQYkl4NFlxVDZqLzY0eFZvc04wWkdjR0pPdjhBdWl1aXBXbFVqZG4wdWI0S2hRb1U1VUZ2MTczTHR0QWcvZkx1V1FuN3dKQkZPdnBHSlZwWm1iZTNKWTVKUHFUVHJNNWk2ZDZvNnRKdW5WQWZ1akorcHJtVldUbHl0NkgxV1d1THc5T1NYUkRicVB5cmlOeDBjWVAxSC8xc1ZxUXQ1c0N0M0lyRU14ZTE4dHVTaDNLZmIwL1d0UFRaQVVLL2pTcTNjTDlqemwvczJhU2owbXIvQURLRjB4anNyaHgxS2JCeDZrRCtXYXFlSUpDZEt0UjZ6Uy9wZ2YwcVhWNTFqV08zUEcrUU1UN0Qvd0RYV2RyY3JOcG1uQTkxZHZ6YXZRd2wvWjNQbitKYW5Qald1eVMvQVhRRnk4amZoVjNVZnVBRDFxdm9hN1lNOXp6Vm1WZk51NFk4Z0JwQU10MDYxelAzcTU4NWM2elNGanRXMjc1SFdPMlhJWCs4YzhmUWYxcmp0ZjJuV3JuYmpidXh3Y2l0NzdXMWxPSDJoNXBTVmkyNUM4RUVFSDE0UDBybnRaakVXb01tell3VWJ4MzNkODE3emw3aVFSVm1UV3d4cGtSLzZiTi9KYTE3cm5UeWZSbFA4LzhBR3MyT1BHaVdyZjNuYy9xQi9TdEUvUHBUZjljd2Z5SXI1L0VPOWEvbVd0enorYytaY3l0SzdGRWJhQVJqbXJGbkFzc2daUU5yY0VCOEg4cVNDTlZ0SEU1VWlRS1N4WGR0eWV1ZTFRRXk2ZFBnUGxHNVZ4L0V1ZXZ0MHIyV25zV2JSdEdoZ2p1UXJDS1J2bDNLYzhaNjRIcURUcE5VTXBFamtidG9qTWdYRzhZNzg0T01qMzVxR3oxQVhMbnpHVkdoaXhHb0lYZWQzRzQ5OFovSVV4eW9hT0o0L25BTEZ1aTVQUEhyeFVyUURhVzJ1SW9ZcEVlQlkvTVVLSXlBempHU1NwNE9QV2t1dkpndHkwc3BXZFNFa1IweHZCNTY1T0FPS3FXa3dudGhHakE3UDlXVG5BSS9wVGJuVjlsdko1eStYZWdoVHNVQkdJNHlSMHpnOWdLaUVsTzY2ZzNmWWJkNm5IUGJpQVFNa2FNVHRkZ1Q5T21lMVpoWllWREJzTWZtT2VpNTdVOHdQY1dVMTljRVJCU0ZVTHg1ams1eGo2Yy9sVk1vSmNCdHlnY2ozcTM1bExZVm9JMnQ5MDR4RzJkc2lBNHorUDFwYmV5OHNyNWMrN2NDQWNIQVBwVXNzc2JXNWpYZnRVWkVaYk8wOStQeXA5bk5jSWloRWtSRmNQdVhJeVIwNXBYZGlUcE5MbVdPMFh6SFZOcHdTeHh6V0o0b3ZEY2FrcUl3TWNLakdEeGs5ZjZWZTB5Tkx1Mmx0cmhkd2ZPN0o1ejE2K3RaV3I2SytteHBLaitaQ3h4bkhJUG9hNGFVWVJ4RHU5U1VRU013S09wNTI1NHFyRGZ4TmRTdmYyNWxFcWJkdytVcDdqR01tck80K1JHZHZKTzNGUWFwZHBjTW9qaTh1TkFBcStnQS9yWG9VSk9KVGpkYWxLL2p0b2RRYUd6dVBQZ0dBSk5wWFA0R2xkUExoM2NnWXdjVkFJOHlCaDBCclhNSWUyYnVNVmRTYVRSVk50R01zTHlJOGtjRWpxb3l6WUpBSHZVQjYxcXczbDRmTmlnODVvaXUxMWpKeHQ5d1BUM3FxbHVKV1k1SlpqaEZZOG4zTmEzU1Z5TlpPeERGQ1pRd1g3d0dSVVlYT2NuR0szM3RtdDdXd3UyQ1ovMVpLbjd3SCtHY1ZWdnJTUDdmKzZHWW41SHQzcUhVU2xZZkw3dHh0a3BTTlhQVTgvaFhvN3Y1MEZ2T09mTmhWdnh4Zy9xRFhBS0FPZ3dPd3JzOUxsODd3L2F0eWZLZDRqK2U3LzJhdkx4eTVrcGVaTWk1QWNPUU9ocUNjSGV3cHlzUklLYmZTTEJ0ZHM3VzR5TzFlY2w3MmhtVjVCdWl5RFRMZVR0NlU5V0RLUUNDRzVCRlZnZGs1SHJXeVYwME12NnpHWnJhM3ZGN2Z1cEIvd0NnbitZL0FVemRtTzNQckVQMEpIOUtuaTIzTnZKYXVjTEtNQW5zZXgvUEZVazNpMnR0NElZS3lrSHNRN0NpR3NMZGoyUHJYdE1DcVV0NHY4TlRTc3JsVmw4bHVyY2lxbDZTMTdKbjFxRU9GdmJkcy94WXE1cVVlSkVtSFJoZy9XczdLTTE1bjEyVDFYTEJ4OGlvbzJuMlBGV3RQY3JNRlBYT01WV3lHVTBSeUJaUzJlT3AvclYyNW90R0dlUzVIU3hDM2kvK0NabmlDYmRxUlVIN2d4K05aMTdlRzRodG8vOEFubEhzSDVrMHk3bk54Y3l5bnE3RTRxQlBtblFkczE2ZEtISkJMc2ZHNC9FZldLODZ2ZG5UNldteUlmU3BBNkxmSTBneXZQSDRVV0tnUmdlMVZMOWdyODUvQ3VLbDcxWTRFYVNTdExKR1ltY1RLTnlSdUJrOERJNDllVGsrbFpXb084dDF2a2N1N0FFazlhbXRCOXJ1b1lTT3ZMWk9OMzFOUmF4Q2JPNjh0d29aUUFWUTV4WHM2MjhpMWE1c3NtUERlbm4xM24veDl2OEFDcHJVNzlPY0hIM0dINlpwSlV4NFpzUmpwRnUvTm1QOWFacGJibEtldVIrWXhYZ1ZOWnlmOTRPcHdjQ1RTeWZMODR6a0RIV3JOeGFzWWtNcU9qWTNJV1hHVjdFZTNXbmFSYjNGNWR4cmI4UDFCM0FBQWZYajg2MmRmczIwNlNETW5taVlueVFINVZNOUNQZm5wWHZ1THRjYmV0am5kUGxqanVrTTRiYjBZQTR5RFd4Zm9OUTFHU08xQVJpM0t4NFpNWjRIQUdPUFNzaTd0bzQ1MkVjdTZUUDNXR0NQWTlzLzRWYjByVVhpUGxLQ0pTUUZrT0R0QTV4ZysrTSsxUzFmWXJmVTFSWXRvK29DMGU0aG0zUnJJR2liS2dFWng5UlVsMXB4MUVvSTNDVEFqYVc2TjlhcDNjWGtYTWMzMmhabWNrTVVYQ3Jqb1B5d2Z4clRpYktxYTgvRU4wNm5Pak85bVltcDNhWE55bHVqa1c4QTJJU1B2SHV4K3AvcFZTUklpV1lTS216b01INXE2UFU3SDdYYnRjUW92bW9DMGloZVpCanFENjF5d2RHM0RMbjFHQWZwM3JxcFZJMUZ6STA1cmhKQ2tzYnNtTjVHUVMyTVk1b2hlWVdvTzdHNDQyNTZnZTFOTWlLY0xHeTUrOE93cVBZa1NPUzJDVGtFMW91eFcrcHQ2RmNrVEVNZWE2RFZGOHpSN3BRdTRoTndIMDVyanRMdWsrMkFLT1NPVDYxMlkvZTJwVUhsbEsvbU1WNW1NanlWVkl6ZTV5TnV5eURHY2lxZDdFc2NtekJBUGV0RmJkclpzc01FTnRaYW5rdFpkUnRKcmFLTlAzUU54dng4eHdPbWE2NHpTbGZvYXArN1k1bVJRbkdTRFc1YWpmYmozV3NjcjVxNDZPdGF1bU1XdFZ5ZW1SVzFmNGJrclJsS0svZXpNa2FUVHEyQ01BZ2duUGYyeG1vTEcyKzJUdENOM212OTBnWngzSlB0aWx1MFJMdVlzU1RuZ0QxTmFkaW45bWFOSmV2eFBkZ3hRK29UK052eDZmblczTmVJMW95aEw1aS91UE55RjR5ZW1NMVpXVXZBb09EczRVMVFMaG0zaGlXN2lyaW5FTVk3WXowOWF6bXRBNXRHTFhVZUduTDZmZXdmM1Nzby9rZjVpdVc3MTBYaG41TG5hVHhNcGovRTlQMUFya3hDdlRhTXpVSjV6UmVwNTFnMk9TQmtVeCtDUjZHcG9TSGpaZld2TTJzeURta3VKYmQ4bzJQYXBmdHU5bExnQStvcU85aU1OdzZlK1JWUW5JcjBWR01sY1owVU11QUNPMVB2WEJ1bGNObFpGMzQ5Q2V2NWtaL0dzUzB2VEVDcmtsZjVWZGxtM3RHeXRrYmE1M1NjWkZSYldnWHNwaldOMVBJYmludHJqUzJoaWtRRnY3MmFxNms0VzJVblAzaDByTVNhRW81WjJWZ1BsQVhPZjhLMmhSVTRwdEh1WVBNWjBLWExGbWdiK1FIZzBKY3U5aGNPTS9Ma0UvWC9BQ2F5NFhFdHlxeU9WUW5ranNLdnlNMEdqaU10bnpuejE3TC9BSWtuOHEyOWpGSTU4Vmo2dGFQTEo2R1l4NXBGZmJLRDZHbWs4MHpQelZ2WTh0bmEySnpBRzlWcW5kUStmS3daZ3NTakxzZWNlbkE5OFZOcERiN0ZUM0F4VkMrbGJ6WGl6aGVwd01rKzFlZmgxYXUvSWlKbzZkSGJ1c3NNclNGUGxBWk9RU005ZWVPdFE2NzluWFVZMHQ1QTZLbVMyM0E2bnA3Vm1yZFN4V3dpZ3VKRUxxZk01SURFbnB4MnFJc0hSRjJzd1ZRdVdQdlhxODkxWXBMVzUyOCtEb2Rvb1A4QXk3SWYweldmcFVtTGhSbnVQNTFmbU9kTnN4LzA3Ui8rZ2lzZXpmWk92MXJ3ZDNMMUV6UHNvMnNZTE83TWFQR1JzQ2JXRy9zVG5IdU9sUTMxNkpiMTBnUXM2NEJqWUhjQ004TDE0SFdxVFh0eTBjTWF5U1NRMnYzY0hpSW51Q09nemlsdEpMb2FndW8yN1NwUHY4eFNvM0hJUHFhK2djcnF6S1MxdVhMKzFRN3JtV1JUS1h5VVhBd01kL2NjY0FZNXFUeERaMkZsYjZmZGFjN3JkT20rZFEyUXBQS2xlL1NtWE5qZXlhbTB1b1QyYzBzMFhtRnBMbE9OM1RKQjRJejBwUkhGYzJjQWphRmJwQ1ViYTRjT3B4ampwbkpOUzVXMlFKTWlpZGIzVG1sM0JKTGNEZDZPQ1JqOGEwckdUZEZqTmMxUEc5amNTd2J3UXI3VzJuZ2tWc2FiTDB6WEhpNDh5dUthTnBydExLSXp5eWJGVG5QdlhINmplV2wxZnZjUVdyUksvTExuZ3QzSUhiNlZyZUpaQ0xTRk0vZVluOGgvOWV1YVFqdlN3ZE5LUFAzQ0pvUnp4dXpaa3dOdmRjNFAxb21pajhoSEVxc0hKRzN1S292S3BBV3IwbHNaYmZiRmwzUWJtWlJrQVk2VjEyTmJxMXl0Ym9zTjBybVRHRHdBT3RkeHAwbStISGZHYTR5eHVWam5XU1NMek5tU0FlbWUyYTZQUjU5d0hOY21PZzNDNW5OTG9iTTFoRHFOdVVmNVpCOTJRZFJYTFEzRnpvMTg5dGNNUTRPMlR1R1h0aitkZGZhdnNsSTZVdXFhVmE2akJpWlBtSElkZUNEOWE4MmpYVk44azlZc0l5c2VjYXBCOWkxQWxEbUovblFqcGowcTlwakJvenQ5YWoxR3hraVFJN0Y0Z1R0Yis3VDlFWmJGcDJ1QUNpcnVYM3IySnZtcGFhc3BiYUZhYTNOOXJpV3NaQUx1RkxIb1BVbjZDbmE1ZkpjM1Bsd2dyYnhxSTRsOUVIVDgrdjQxQmF6eVBlWEU2Zzc1QXc0N2J1djZack9rWXU1UGMxMFFqWkpkZ2JIQmlvd085YTBTN3dpNS9oR1B5ckxVRmxJL0RyV21nS3h4K3UwWnFhdXhKb3cyYWJBWkYrYnZXaGJzWUNqSndWSUkrdFZyYVh6b3NuN3c2MVlYc0s0WjM2a214ZkRiY0YxNFNRQjEraDVGUXdQdGs2OFU5bTg3VEkzL0FJb1dLSDZIa2YxL0txcU9WWVZ3dU82RXlQVklDNDNBZk1Ld1R3VFhWemZNb1k4NXJtcjZMeXJrZ0Q1VHlLNmNOTzY1V05GYk9NMVlzWFBRbm9hcU54VXRpM0ordGRVbDdyR2pwTEV4T0pJNW9oSkc2NFpUNmYwUHZXSnFXaHpXYytZMkQyNzh4eUhqUHNmY1ZxMlRmT2Y5MnRFQkxtRjdhWS91MzcvM1QySXJpalZsU241RnhueXM0dExhVVNLTUJpVGpBcTVxanFia1F4Z0JJaHNBSFRqcit1YXYyU2ZZSjc4VHhabGhVS3BQUUhQR1Bmb1I3WnJHYkxPU2E3YjNkeHprVjJHR3FJSG1wcGhoczFBSzNXeG1kVG9MNXNwQm5sVHhUdnNRdjVEdGNlY0RoWXdCbC9YSkpIWVZVME9URnZPTTR4amlxOXhCTXdONENCREVGeU4rQ1NTZTNVMXkwWXBWNU5rcEY2RFRUOWc4NHVHUVB0WlNwT0NlZ1BPQm5uOHF5cmxKVWN4cU8vS2dFWVA0MVllOFI3QkI1YmtSbkRIZjE2N2Z3RlZvMjgwaDJmTGR3ZjYrOWRrbHJkRks1M1dkMmoyQjR6OW5RSDhCaXNaRzJYSi8zcTFJTW53OVlIT2NSa2ZreEZZMHhLM0JyeElyMzVMelpMTUtXWmJleFJWbFZsbVFGdGk0SndlaHExWnpOQmMyMTFDejVaY05IR3pBNE9RUitJejA5YXozdUVlelNKSVVHMFl5UnlEM3BzSmZ6NG1jU1NJQUYyQi95eFh0bXBOY1hMZjJodkVuQ0VLdTlRTUFjWU9QcFYrMmxGdERKcW14WTVwTXh3S293TTR3V3g3RDlUN1ZUdHJlR2E0OHE0ODFZVkJNbmxnRWpBNi9TaSt2QmNYSUtMaUpCc2pVOWwvenorTkYraUdsMUhSYWJkM2hqMjJ6TWs3RUpJZWh4MS9FVmFGcGRhVmVQWjNjYlJ5eG5HRDNIWWc5Q0t6WTcrN2pmTWM3UmtjZ3B3ZnpxUkxpYVNZUExMSktlbVhZbW9xeFRqWW1VVzFjbThRVEYyZ1hQQVFuOHovOWFzVVZkMUo5ODY1N0tCVk1VVVk4dE5JbEZpd3RQdGQ2a1c3Ym5QSnEzYXhYUXVXaERNR2NsTm5jKzFTK0g0ZDkzSy85MVA1bXRXK1ZiWlh2WXgrL0srVmtEcG4rTDh1S2oyMXF2SU5Qb1pPb1J4K1lZclpjeHdqYVhIVm03bjgvMEZXZEptS050SUlZSGtWRmFRQ09KNWJtQmp2SDd2SjRKcVNPTlk1dDZzU3hBSjVvckxtaTBPV3FPcGpmSlJ4M3h6V3Q5NlBQdFdMWnR2Z0E3aXRhQjkwWStsZlAxVlptYU9idW9sOHlTTmxCR1NNR3VVMU9CcmU2S1pQbGtaVFBZZWxkeHFrQldYelFPRDFybHRjaUx4SzViaE9nOXpYcllPcGRvcU4raEJhUWJOSWE0N21iQUkvM2F4RlVpUWc4RVYxTnBGSy9oa2lTTEVXNHVrZ1BRL1N1Zm1BaytkZUcvaUZkMUtkM0plWmR0TGtsd2tjYzBidzVYS0szemM1UGY4S3QvTVF1N3JqbW9TbS9UbyttNURuR09hdFR5cEw1Y2lIS2xBT21Qejk2YzNkQ1krMWw4bVVIK0U4R3RnRU1BUjByRGhBZDloUDN1bjFxOVkzQkJNRW5VZEs1cHJxaVRlMDg3ak5ibnBLaHgvdkRrZjFINDFTSktPUlQ0WkdpbFNSRGhsSVlIM3BkVFVSM1JaQmhIQWRSN0htdU5yM2hkQ2VKOThKR2F5dFVqM1JoeDFVMWJ0cFBteDJOTnVVRWlzdnFLVVBjbUk1MXp4VDdFL00xUnR3U080cGJNL08xZWkxN3JHYjFveDh3ZlN0QU5najJyTHRHeEt0WFpKUkhHem5vQm12T3FSdklIdUpyczZHS0tOUVBNWlEwakR2MlhQMEZjK0Y1elRrbmFhUnQ1NUp6VWlwd1RYVkNQczQ4b215bGNEQzFXRlhiaGNqSDQxU1hyWFREWWFOblNHeEZPUDhBWnBkUlpsaWloSllwaklBOWY4NHFDd2tFY00zcVJ4VnE0ZFhGcHZZS0NCbHU0NDlheWd2M3JZMXVVdktaYkIzSllLR0FIeTVCejJKcDZHTHl3a1ozeVpKZHNjZjU2MGs3dDVMd0pNelJzKzRybkFKSEdjZmpVTm9OcElJcnJLdG9kcnB4RCtHWWNIT3gzVDljL3dCYXlybi9BRnVmVVZmMEtRUG8xMUVQK1djd2Y4eGovd0JscWhkZmUraHJ4cFJ0WGtpSkhLdXJ3c1ViSU5TV3NoTndubVM0MjlDZWMwNjhBRW93QU9sU2Flb2JVYlJXQUlNcTVCK3RldjBOYkdocVVxMjhiUXJrVDNPR21Za1pDL3dyL1UvaFdNdkxnbGdmcFZqVWlXdkxvc1NTWkd6bnZ6Vk9IN3RFZGhqMUdXUHBXaHB5V3pUZ1hLU3VuUEVUQUg4eURWQ1BvYUpQOVUxRFYyUG9GODhiM1RtSU1JLzRReHljVkF2TkQvZkZLdlNuYXlNVG92RE1meTNNaDlWSDg2MkdVSzN6REtucldmNGIvd0NQS1gvcnAvU3RLYm9mclhrVnBQMjdKZTVrM3l4UXpHTGtuR1FEMHdlaDk2cHNtR2p4ODdkQXFqbXIyc0Q1TFE5L21HZnlyTmNrTVNDUWRvcnVwdThVMmFYdWpvZE5tNEFPUVJXNUEyMThZcmx0SkpLTGttdWtRL2NyeU1WRktiTStwTmR4QjBJd0NENjF3SGlXTXdha0lkd1lCQWVQZXZRNS93RFYvaFhuR3ZrdHJjK1NUZ2djL1N0c3NiNTdGSTZsSVZid3NrYWRSRGdqM3hYbnNVaFIrZWxlaTZkL3lESlIyd1A1VjV1MytzYjYxMzRIZWE4eG92UE9VUmRwTzMwUElxYUpzd0lSNy96cW1lYlkxWXR2K1BWUHFhNnByUWJKZ3hVZ2pzYzFibnpoTGxPL1g2MVNGWDRPZE9renp5YXhscHFTWDdTNUU4UVBjY0VWbzNLK2ZwaXVPV2dPdy83cDVINjVybmRLSjg1aG50WFMydjhBeDYzWTdlVi83TUs1S3NlVjZDTWJ6ekR6NzBvdmd6WWZqTlY3anIrTlZKUHUxb3Fha0NFdTEyWEQ0NkhrVkhhbjk0MUxOeVV6L2QvclRMYi9BRmhyZGZBQnNRUHRrUSs0cVRWNXZMdGdnNnVmMHF1bmI2aitkTjFyL1hwL3VmMU5jeWluVVEzdVppUHNjTjZWc0FCb2d3NzFpVnNXeC8wSmZyVzFaYk1sbFdZZmZ6MkZaNjhtdEdmcEo5S3oxNjFwVDJIRXN3K25PS3R6NCt6MnpISWJhUXBIYm1xa1o0TmF0Z29rdnRMUndHUXljcWVRZWFjZmlLUnVlRnZBdC80Z3ZFVng1VVR0OHJFY3Y3Z2YxTmVrM2Z3bjBmUUxIN1RjdkhKamttZVE1ejdBWUZZZHJjVFFPR2lta2piZDFSaURWYnhSZTNkeGJ0NTExTkpnY2I1Q2Y1MTBKWFJvbGZjYTUwclpjMnRqREJHMnpjVEdvQk9EL3dEWHJrYjFNTzNJNjB2aDVtT3ZzQ3hJOGwrL3RUYi9BUDE3MTVXSlZzUnAyUm5JLzlrPVwiXTtcbiIsIi8qXG4gKiBFYXNpbmcgRnVuY3Rpb25zIC0gaW5zcGlyZWQgZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cbiAqIG9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdXG4gKlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcbiAqXG4gKiBObyBsaWNlbnNlIGF0dGFjaGVkIHRvIGdpc3Q7IGFzc3VtZWQgTUlUIGJhc2VkIG9uXG4gKiBodHRwOi8vZ3Jld2ViLm1lLzIwMTIvMDIvYmV6aWVyLWN1cnZlLWJhc2VkLWVhc2luZy1mdW5jdGlvbnMtZnJvbS1jb25jZXB0LXRvLWltcGxlbWVudGF0aW9uL1xuICovXG4gLyoganNoaW50IG5vZGU6dHJ1ZSovXG52YXIgRWFzaW5nRnVuY3Rpb25zID0ge1xuICAvLyBubyBlYXNpbmcsIG5vIGFjY2VsZXJhdGlvblxuICBsaW5lYXI6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0OyB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0KnQ7IH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCooMi10KTsgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAodDwwLjUpPyAyKnQqdCA6IC0xKyg0LTIqdCkqdDsgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5DdWJpYzogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQqdCp0OyB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAoLS10KSp0KnQrMTsgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwwLjUgPyA0KnQqdCp0IDogKHQtMSkqKDIqdC0yKSooMip0LTIpKzE7IH0sXG4gIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbiAgZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0KnQqdCp0OyB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxLSgtLXQpKnQqdCp0OyB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0PDAuNSA/IDgqdCp0KnQqdCA6IDEtOCooLS10KSp0KnQqdDsgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQqdCp0KnQqdDsgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dFF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gMSsoLS10KSp0KnQqdCp0OyB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiB0PDAuNSA/IDE2KnQqdCp0KnQqdCA6IDErMTYqKC0tdCkqdCp0KnQqdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFYXNpbmdGdW5jdGlvbnM7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIvKlxyXG4gKiBDb29raWVzLmpzIC0gMS4yLjBcclxuICogaHR0cHM6Ly9naXRodWIuY29tL1Njb3R0SGFtcGVyL0Nvb2tpZXNcclxuICpcclxuICogVGhpcyBpcyBmcmVlIGFuZCB1bmVuY3VtYmVyZWQgc29mdHdhcmUgcmVsZWFzZWQgaW50byB0aGUgcHVibGljIGRvbWFpbi5cclxuICovXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVzLmpzIHJlcXVpcmVzIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGAgb2JqZWN0Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgQ29va2llcyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cclxuICAgICAgICAgICAgICAgIENvb2tpZXMuZ2V0KGtleSkgOiBDb29raWVzLnNldChrZXksIHZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBBbGxvd3MgZm9yIHNldHRlciBpbmplY3Rpb24gaW4gdW5pdCB0ZXN0c1xyXG4gICAgICAgIENvb2tpZXMuX2RvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xyXG5cclxuICAgICAgICAvLyBVc2VkIHRvIGVuc3VyZSBjb29raWUga2V5cyBkbyBub3QgY29sbGlkZSB3aXRoXHJcbiAgICAgICAgLy8gYnVpbHQtaW4gYE9iamVjdGAgcHJvcGVydGllc1xyXG4gICAgICAgIENvb2tpZXMuX2NhY2hlS2V5UHJlZml4ID0gJ2Nvb2tleS4nOyAvLyBIdXJyIGh1cnIsIDopXHJcbiAgICAgICAgXHJcbiAgICAgICAgQ29va2llcy5fbWF4RXhwaXJlRGF0ZSA9IG5ldyBEYXRlKCdGcmksIDMxIERlYyA5OTk5IDIzOjU5OjU5IFVUQycpO1xyXG5cclxuICAgICAgICBDb29raWVzLmRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBwYXRoOiAnLycsXHJcbiAgICAgICAgICAgIHNlY3VyZTogZmFsc2VcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDb29raWVzLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKENvb2tpZXMuX2NhY2hlZERvY3VtZW50Q29va2llICE9PSBDb29raWVzLl9kb2N1bWVudC5jb29raWUpIHtcclxuICAgICAgICAgICAgICAgIENvb2tpZXMuX3JlbmV3Q2FjaGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIENvb2tpZXMuX2NhY2hlW0Nvb2tpZXMuX2NhY2hlS2V5UHJlZml4ICsga2V5XTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDb29raWVzLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBDb29raWVzLl9nZXRFeHRlbmRlZE9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZXhwaXJlcyA9IENvb2tpZXMuX2dldEV4cGlyZXNEYXRlKHZhbHVlID09PSB1bmRlZmluZWQgPyAtMSA6IG9wdGlvbnMuZXhwaXJlcyk7XHJcblxyXG4gICAgICAgICAgICBDb29raWVzLl9kb2N1bWVudC5jb29raWUgPSBDb29raWVzLl9nZW5lcmF0ZUNvb2tpZVN0cmluZyhrZXksIHZhbHVlLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBDb29raWVzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENvb2tpZXMuZXhwaXJlID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29va2llcy5zZXQoa2V5LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENvb2tpZXMuX2dldEV4dGVuZGVkT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiBvcHRpb25zICYmIG9wdGlvbnMucGF0aCB8fCBDb29raWVzLmRlZmF1bHRzLnBhdGgsXHJcbiAgICAgICAgICAgICAgICBkb21haW46IG9wdGlvbnMgJiYgb3B0aW9ucy5kb21haW4gfHwgQ29va2llcy5kZWZhdWx0cy5kb21haW4sXHJcbiAgICAgICAgICAgICAgICBleHBpcmVzOiBvcHRpb25zICYmIG9wdGlvbnMuZXhwaXJlcyB8fCBDb29raWVzLmRlZmF1bHRzLmV4cGlyZXMsXHJcbiAgICAgICAgICAgICAgICBzZWN1cmU6IG9wdGlvbnMgJiYgb3B0aW9ucy5zZWN1cmUgIT09IHVuZGVmaW5lZCA/ICBvcHRpb25zLnNlY3VyZSA6IENvb2tpZXMuZGVmYXVsdHMuc2VjdXJlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgQ29va2llcy5faXNWYWxpZERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09PSAnW29iamVjdCBEYXRlXScgJiYgIWlzTmFOKGRhdGUuZ2V0VGltZSgpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDb29raWVzLl9nZXRFeHBpcmVzRGF0ZSA9IGZ1bmN0aW9uIChleHBpcmVzLCBub3cpIHtcclxuICAgICAgICAgICAgbm93ID0gbm93IHx8IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGlyZXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBleHBpcmVzID0gZXhwaXJlcyA9PT0gSW5maW5pdHkgP1xyXG4gICAgICAgICAgICAgICAgICAgIENvb2tpZXMuX21heEV4cGlyZURhdGUgOiBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgZXhwaXJlcyAqIDEwMDApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBpcmVzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZXhwaXJlcyA9IG5ldyBEYXRlKGV4cGlyZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhwaXJlcyAmJiAhQ29va2llcy5faXNWYWxpZERhdGUoZXhwaXJlcykpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGV4cGlyZXNgIHBhcmFtZXRlciBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgdmFsaWQgRGF0ZSBpbnN0YW5jZScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZXhwaXJlcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDb29raWVzLl9nZW5lcmF0ZUNvb2tpZVN0cmluZyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKC9bXiMkJitcXF5gfF0vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcclxuICAgICAgICAgICAga2V5ID0ga2V5LnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKTtcclxuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgKyAnJykucmVwbGFjZSgvW14hIyQmLStcXC0tOjwtXFxbXFxdLX5dL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvb2tpZVN0cmluZyA9IGtleSArICc9JyArIHZhbHVlO1xyXG4gICAgICAgICAgICBjb29raWVTdHJpbmcgKz0gb3B0aW9ucy5wYXRoID8gJztwYXRoPScgKyBvcHRpb25zLnBhdGggOiAnJztcclxuICAgICAgICAgICAgY29va2llU3RyaW5nICs9IG9wdGlvbnMuZG9tYWluID8gJztkb21haW49JyArIG9wdGlvbnMuZG9tYWluIDogJyc7XHJcbiAgICAgICAgICAgIGNvb2tpZVN0cmluZyArPSBvcHRpb25zLmV4cGlyZXMgPyAnO2V4cGlyZXM9JyArIG9wdGlvbnMuZXhwaXJlcy50b1VUQ1N0cmluZygpIDogJyc7XHJcbiAgICAgICAgICAgIGNvb2tpZVN0cmluZyArPSBvcHRpb25zLnNlY3VyZSA/ICc7c2VjdXJlJyA6ICcnO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZVN0cmluZztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDb29raWVzLl9nZXRDYWNoZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAoZG9jdW1lbnRDb29raWUpIHtcclxuICAgICAgICAgICAgdmFyIGNvb2tpZUNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHZhciBjb29raWVzQXJyYXkgPSBkb2N1bWVudENvb2tpZSA/IGRvY3VtZW50Q29va2llLnNwbGl0KCc7ICcpIDogW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvb2tpZUt2cCA9IENvb2tpZXMuX2dldEtleVZhbHVlUGFpckZyb21Db29raWVTdHJpbmcoY29va2llc0FycmF5W2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29va2llQ2FjaGVbQ29va2llcy5fY2FjaGVLZXlQcmVmaXggKyBjb29raWVLdnAua2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29va2llQ2FjaGVbQ29va2llcy5fY2FjaGVLZXlQcmVmaXggKyBjb29raWVLdnAua2V5XSA9IGNvb2tpZUt2cC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZUNhY2hlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENvb2tpZXMuX2dldEtleVZhbHVlUGFpckZyb21Db29raWVTdHJpbmcgPSBmdW5jdGlvbiAoY29va2llU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIFwiPVwiIGlzIGEgdmFsaWQgY2hhcmFjdGVyIGluIGEgY29va2llIHZhbHVlIGFjY29yZGluZyB0byBSRkM2MjY1LCBzbyBjYW5ub3QgYHNwbGl0KCc9JylgXHJcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JJbmRleCA9IGNvb2tpZVN0cmluZy5pbmRleE9mKCc9Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBJRSBvbWl0cyB0aGUgXCI9XCIgd2hlbiB0aGUgY29va2llIHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgICAgICBzZXBhcmF0b3JJbmRleCA9IHNlcGFyYXRvckluZGV4IDwgMCA/IGNvb2tpZVN0cmluZy5sZW5ndGggOiBzZXBhcmF0b3JJbmRleDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBrZXk6IGRlY29kZVVSSUNvbXBvbmVudChjb29raWVTdHJpbmcuc3Vic3RyKDAsIHNlcGFyYXRvckluZGV4KSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZVN0cmluZy5zdWJzdHIoc2VwYXJhdG9ySW5kZXggKyAxKSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDb29raWVzLl9yZW5ld0NhY2hlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBDb29raWVzLl9jYWNoZSA9IENvb2tpZXMuX2dldENhY2hlRnJvbVN0cmluZyhDb29raWVzLl9kb2N1bWVudC5jb29raWUpO1xyXG4gICAgICAgICAgICBDb29raWVzLl9jYWNoZWREb2N1bWVudENvb2tpZSA9IENvb2tpZXMuX2RvY3VtZW50LmNvb2tpZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBDb29raWVzLl9hcmVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGVzdEtleSA9ICdjb29raWVzLmpzJztcclxuICAgICAgICAgICAgdmFyIGFyZUVuYWJsZWQgPSBDb29raWVzLnNldCh0ZXN0S2V5LCAxKS5nZXQodGVzdEtleSkgPT09ICcxJztcclxuICAgICAgICAgICAgQ29va2llcy5leHBpcmUodGVzdEtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVFbmFibGVkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIENvb2tpZXMuZW5hYmxlZCA9IENvb2tpZXMuX2FyZUVuYWJsZWQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIENvb2tpZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjb29raWVzRXhwb3J0ID0gdHlwZW9mIGdsb2JhbC5kb2N1bWVudCA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KGdsb2JhbCkgOiBmYWN0b3J5O1xyXG5cclxuICAgIC8vIEFNRCBzdXBwb3J0XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvb2tpZXNFeHBvcnQ7IH0pO1xyXG4gICAgLy8gQ29tbW9uSlMvTm9kZS5qcyBzdXBwb3J0XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIC8vIFN1cHBvcnQgTm9kZS5qcyBzcGVjaWZpYyBgbW9kdWxlLmV4cG9ydHNgICh3aGljaCBjYW4gYmUgYSBmdW5jdGlvbilcclxuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjb29raWVzRXhwb3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdXQgYWx3YXlzIHN1cHBvcnQgQ29tbW9uSlMgbW9kdWxlIDEuMS4xIHNwZWMgKGBleHBvcnRzYCBjYW5ub3QgYmUgYSBmdW5jdGlvbilcclxuICAgICAgICBleHBvcnRzLkNvb2tpZXMgPSBjb29raWVzRXhwb3J0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBnbG9iYWwuQ29va2llcyA9IGNvb2tpZXNFeHBvcnQ7XHJcbiAgICB9XHJcbn0pKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gdGhpcyA6IHdpbmRvdyk7IiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBVc2UgY2hyb21lLnN0b3JhZ2UubG9jYWwgaWYgd2UgYXJlIGluIGFuIGFwcFxuICovXG5cbnZhciBzdG9yYWdlO1xuXG5pZiAodHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNocm9tZS5zdG9yYWdlICE9PSAndW5kZWZpbmVkJylcbiAgc3RvcmFnZSA9IGNocm9tZS5zdG9yYWdlLmxvY2FsO1xuZWxzZVxuICBzdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IHN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1zfHNlY29uZHM/fHN8bWludXRlcz98bXxob3Vycz98aHxkYXlzP3xkfHllYXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCJ2YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCduYXZpZ2F0ZUFjdGlvbicpO1xudmFyIHF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnktc3RyaW5nJyk7XG52YXIgc2VhcmNoUGF0dGVybiA9IC9cXD8oW15cXCNdKikvO1xuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHVybCkge1xuICAgIHZhciBzZWFyY2g7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmwubWF0Y2goc2VhcmNoUGF0dGVybik7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgc2VhcmNoID0gbWF0Y2hlc1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIChzZWFyY2ggJiYgcXVlcnlTdHJpbmcucGFyc2Uoc2VhcmNoKSkgfHwge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIHBheWxvYWQsIGRvbmUpIHtcbiAgICBpZiAoIWNvbnRleHQucm91dGVyIHx8ICFjb250ZXh0LnJvdXRlci5nZXRSb3V0ZSkge1xuICAgICAgICBkZWJ1Zygnbm8gcm91dGVyIGF2YWlsYWJsZSBmb3IgbmF2aWdhdGUgaGFuZGxpbmcnKTtcbiAgICAgICAgZG9uZShuZXcgRXJyb3IoJ21pc3Npbmcgcm91dGVyJykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlYnVnKCdleGVjdXRpbmcnLCBwYXlsb2FkKTtcbiAgICBcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgbmF2aWdhdGU6IHBheWxvYWQsXG4gICAgICAgIG1ldGhvZDogcGF5bG9hZC5tZXRob2RcbiAgICB9O1xuXG4gICAgdmFyIHJvdXRlID0gY29udGV4dC5yb3V0ZXIuZ2V0Um91dGUocGF5bG9hZC51cmwsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVcmwgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgZXJyLnN0YXR1cyA9IDQwNDtcbiAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIHBhcnNlZCBxdWVyeSBwYXJhbWV0ZXIgb2JqZWN0IHRvIHJvdXRlIG9iamVjdCxcbiAgICAvLyBhbmQgbWFrZSBpdCBwYXJ0IG9mIENIQU5HRV9ST1VURV9YWFggYWN0aW9uIHBheWxvYWQuXG4gICAgcm91dGUucXVlcnkgPSBwYXJzZVF1ZXJ5U3RyaW5nKHJvdXRlLnVybCk7XG5cbiAgICBkZWJ1ZygnZGlzcGF0Y2hpbmcgQ0hBTkdFX1JPVVRFJywgcm91dGUpO1xuICAgIGNvbnRleHQuZGlzcGF0Y2goJ0NIQU5HRV9ST1VURV9TVEFSVCcsIHJvdXRlKTtcbiAgICB2YXIgYWN0aW9uID0gcm91dGUuY29uZmlnICYmIHJvdXRlLmNvbmZpZy5hY3Rpb247XG5cbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBhY3Rpb24gJiYgY29udGV4dC5nZXRBY3Rpb24pIHtcbiAgICAgICAgYWN0aW9uID0gY29udGV4dC5nZXRBY3Rpb24oYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGlvbiB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2YgYWN0aW9uKSB7XG4gICAgICAgIGRlYnVnKCdyb3V0ZSBoYXMgbm8gYWN0aW9uLCBkaXNwYXRjaGluZyB3aXRob3V0IGNhbGxpbmcgYWN0aW9uJyk7XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goJ0NIQU5HRV9ST1VURV9TVUNDRVNTJywgcm91dGUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWJ1ZygnZXhlY3V0aW5nIHJvdXRlIGFjdGlvbicpO1xuICAgIGNvbnRleHQuZXhlY3V0ZUFjdGlvbihhY3Rpb24sIHJvdXRlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goJ0NIQU5HRV9ST1VURV9GQUlMVVJFJywgcm91dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCgnQ0hBTkdFX1JPVVRFX1NVQ0NFU1MnLCByb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZShlcnIpO1xuICAgIH0pO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTmF2TGluazogcmVxdWlyZSgnLi9saWIvTmF2TGluaycpLFxuICAgIFJvdXRlck1peGluOiByZXF1aXJlKCcuL2xpYi9Sb3V0ZXJNaXhpbicpLFxuICAgIG5hdmlnYXRlQWN0aW9uOiByZXF1aXJlKCcuL2FjdGlvbnMvbmF2aWdhdGUnKSxcbiAgICBIaXN0b3J5OiByZXF1aXJlKCcuL2xpYi9IaXN0b3J5Jylcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4vKmdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIEVWRU5UX1BPUFNUQVRFID0gJ3BvcHN0YXRlJztcblxuLyoqXG4gKiBUaGlzIG9ubHkgc3VwcG9ydHMgcHVzaFN0YXRlIGZvciB0aGUgYnJvd3NlcnMgd2l0aCBuYXRpdmUgcHVzaFN0YXRlIHN1cHBvcnQuXG4gKiBGb3Igb3RoZXIgYnJvd3NlcnMgKG1haW5seSBJRTggYW5kIElFOSksIGl0IHdpbGwgcmVmcmVzaCB0aGUgcGFnZSB1cG9uIHB1c2hTdGF0ZSgpXG4gKiBhbmQgcmVwbGFjZVN0YXRlKCkuXG4gKiBAY2xhc3MgSGlzdG9yeVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdICBUaGUgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7V2luZG93fSBbb3B0aW9ucy53aW49d2luZG93XSAgVGhlIHdpbmRvdyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gSGlzdG9yeShvcHRpb25zKSB7XG4gICAgdGhpcy53aW4gPSAob3B0aW9ucyAmJiBvcHRpb25zLndpbikgfHwgd2luZG93O1xuICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSA9ICEhKHRoaXMud2luICYmIHRoaXMud2luLmhpc3RvcnkgJiYgdGhpcy53aW4uaGlzdG9yeS5wdXNoU3RhdGUpO1xufVxuXG5IaXN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGdpdmVuIGxpc3RlbmVyIGZvciAncG9wc3RhdGUnIGV2ZW50IChub3RoaW5nIGhhcHBlbnMgZm9yIGJyb3dzZXJzIHRoYXRcbiAgICAgKiBkb24ndCBzdXBwb3J0IHBvcHN0YXRlIGV2ZW50KS5cbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMud2luLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRfUE9QU1RBVEUsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGxpc3RlbmVyIGZvciAncG9wc3RhdGUnIGV2ZW50IChub3RoaW5nIGhhcHBlbnMgZm9yIGJyb3dzZXJzIHRoYXRcbiAgICAgKiBkb24ndCBzdXBwb3J0IHBvcHN0YXRlIGV2ZW50KS5cbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVF9QT1BTVEFURSwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZ2V0U3RhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gVGhlIHN0YXRlIG9iamVjdCBpbiBoaXN0b3J5XG4gICAgICovXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndpbi5oaXN0b3J5ICYmIHRoaXMud2luLmhpc3Rvcnkuc3RhdGUpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhdGggc3RyaW5nLCBpbmNsdWRpbmcgdGhlIHBhdGhuYW1lIGFuZCBzZWFyY2ggcXVlcnkgKGlmIGl0IGV4aXN0cykuXG4gICAgICogQG1ldGhvZCBnZXRVcmxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSB1cmwgc3RyaW5nIHRoYXQgZGVub3RlcyBjdXJyZW50IHJvdXRlIHBhdGggYW5kIHF1ZXJ5XG4gICAgICovXG4gICAgZ2V0VXJsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMud2luLmxvY2F0aW9uO1xuICAgICAgICByZXR1cm4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgSFRNTDUgcHVzaFN0YXRlIEFQSSwgYnV0IHdpdGggb2xkIGJyb3dzZXIgc3VwcG9ydFxuICAgICAqIEBtZXRob2QgcHVzaFN0YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgVGhlIHRpdGxlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIG5ldyB1cmxcbiAgICAgKi9cbiAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgICB2YXIgd2luID0gdGhpcy53aW47XG4gICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgIHdpbi5oaXN0b3J5LnB1c2hTdGF0ZS5hcHBseSh3aW4uaGlzdG9yeSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHdpbi5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgSFRNTDUgcmVwbGFjZVN0YXRlIEFQSSwgYnV0IHdpdGggb2xkIGJyb3dzZXIgc3VwcG9ydFxuICAgICAqIEBtZXRob2QgcmVwbGFjZVN0YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGl0bGUgVGhlIHRpdGxlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIG5ldyB1cmxcbiAgICAgKi9cbiAgICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgICB2YXIgd2luID0gdGhpcy53aW47XG4gICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcbiAgICAgICAgICAgIHdpbi5oaXN0b3J5LnJlcGxhY2VTdGF0ZS5hcHBseSh3aW4uaGlzdG9yeSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHdpbi5sb2NhdGlvbi5yZXBsYWNlKHVybCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhpc3Rvcnk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4vKmdsb2JhbCB3aW5kb3cgKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBOYXZMaW5rO1xudmFyIG5hdmlnYXRlQWN0aW9uID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9uYXZpZ2F0ZScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnTmF2TGluaycpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gaXNMZWZ0Q2xpY2tFdmVudCAoZSkge1xuICAgIHJldHVybiBlLmJ1dHRvbiA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50IChlKSB7XG4gICAgcmV0dXJuICEhKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSk7XG59XG5cbk5hdkxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdOYXZMaW5rJyxcbiAgICBjb250ZXh0VHlwZXM6IHtcbiAgICAgICAgZXhlY3V0ZUFjdGlvbjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIG1ha2VQYXRoOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICAgIH0sXG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbnRleHQ6IFJlYWN0LlByb3BUeXBlcy5vYmplY3RcbiAgICB9LFxuICAgIGRpc3BhdGNoTmF2QWN0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkZWJ1ZygnZGlzcGF0Y2hOYXZBY3Rpb246IGFjdGlvbj1OQVZJR0FURScsIHRoaXMucHJvcHMuaHJlZiwgdGhpcy5wcm9wcy5uYXZQYXJhbXMpO1xuXG4gICAgICAgIGlmIChpc01vZGlmaWVkRXZlbnQoZSkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZSkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBjbGljayB3aXRoIGEgbW9kaWZpZXIgb3Igbm90IGEgbGVmdC1jbGlja1xuICAgICAgICAgICAgLy8gbGV0IGJyb3dzZXIgaGFuZGxlIGl0IG5hdGl2ZWx5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHJlZiA9IHRoaXMucHJvcHMuaHJlZjtcblxuICAgICAgICBpZiAoaHJlZlswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgaGFzaCBsaW5rIHVybCBmb3IgcGFnZSdzIGludGVybmFsIGxpbmtzLlxuICAgICAgICAgICAgLy8gRG8gbm90IHRyaWdnZXIgbmF2aWdhdGUgYWN0aW9uLiBMZXQgYnJvd3NlciBoYW5kbGUgaXQgbmF0aXZlbHkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaHJlZlswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBhIHJlbGF0aXZlIHVybC4gY2hlY2sgZm9yIGV4dGVybmFsIHVybHMuXG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gbG9jYXRpb24ub3JpZ2luIHx8IChsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcblxuICAgICAgICAgICAgaWYgKGhyZWYuaW5kZXhPZihvcmlnaW4pICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBleHRlcm5hbCB1cmwsIGRvIG5vdCB0cmlnZ2VyIG5hdmlnYXRlIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBsZXQgYnJvd3NlciBoYW5kbGUgaXQgbmF0aXZlbHkuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBocmVmID0gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgfHwgJy8nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRleHQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQgJiYgdGhpcy5jb250ZXh0LmV4ZWN1dGVBY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5jb250ZXh0ICYmIHRoaXMucHJvcHMuY29udGV4dC5leGVjdXRlQWN0aW9uKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5wcm9wcy5jb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjb250ZXh0LmV4ZWN1dGVBY3Rpb24obmF2aWdhdGVBY3Rpb24sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgIHVybDogaHJlZixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucHJvcHMubmF2UGFyYW1zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmF2TGluay5kaXNwYXRjaE5hdkFjdGlvbjogbWlzc2luZyBkaXNwYXRjaGVyLCB3aWxsIGxvYWQgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRleHQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQgJiYgdGhpcy5jb250ZXh0Lm1ha2VQYXRoKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMuY29udGV4dCAmJiB0aGlzLnByb3BzLmNvbnRleHQubWFrZVBhdGgpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLnByb3BzLmNvbnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm91dGVOYW1lID0gdGhpcy5wcm9wcy5yb3V0ZU5hbWU7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5ocmVmICYmIHJvdXRlTmFtZSAmJiBjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmhyZWYgPSBjb250ZXh0Lm1ha2VQYXRoKHJvdXRlTmFtZSwgdGhpcy5wcm9wcy5uYXZQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgb2JqZWN0QXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgb25DbGljazogdGhpcy5kaXNwYXRjaE5hdkFjdGlvblxuICAgICAgICAgICAgfSwgdGhpcy5wcm9wcyksXG4gICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2TGluaztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuLypnbG9iYWwgd2luZG93ICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ05hdkxpbmsnKTtcbnZhciBuYXZpZ2F0ZUFjdGlvbiA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvbmF2aWdhdGUnKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi9IaXN0b3J5Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFRZUEVfQ0xJQ0sgPSAnY2xpY2snO1xudmFyIFRZUEVfUEFHRUxPQUQgPSAncGFnZWxvYWQnO1xudmFyIFRZUEVfUE9QU1RBVEUgPSAncG9wc3RhdGUnO1xudmFyIFRZUEVfREVGQVVMVCA9ICdkZWZhdWx0JzsgLy8gZGVmYXVsdCB2YWx1ZSBpZiBuYXZpZ2F0aW9uIHR5cGUgaXMgbWlzc2luZywgZm9yIHByb2dyYW1tYXRpYyBuYXZpZ2F0aW9uXG52YXIgUm91dGVyTWl4aW47XG5cbnJlcXVpcmUoJ3NldGltbWVkaWF0ZScpO1xuXG5mdW5jdGlvbiByb3V0ZXNFcXVhbChyb3V0ZTEsIHJvdXRlMikge1xuICAgIHJvdXRlMSA9IHJvdXRlMSB8fCB7fTtcbiAgICByb3V0ZTIgPSByb3V0ZTIgfHwge307XG4gICAgcmV0dXJuIChyb3V0ZTEudXJsID09PSByb3V0ZTIudXJsKTtcbn1cblxuZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGUsIGhpc3RvcnkpIHtcbiAgICB2YXIgaGlzdG9yeVN0YXRlID0gKGhpc3RvcnkuZ2V0U3RhdGUgJiYgaGlzdG9yeS5nZXRTdGF0ZSgpKSB8fCB7fTtcbiAgICBoaXN0b3J5U3RhdGUuc2Nyb2xsID0ge3g6IHdpbmRvdy5zY3JvbGxYLCB5OiB3aW5kb3cuc2Nyb2xsWX07XG4gICAgZGVidWcoJ3JlbWVtYmVyIHNjcm9sbCBwb3NpdGlvbicsIGhpc3RvcnlTdGF0ZS5zY3JvbGwpO1xuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSk7XG59XG5cblJvdXRlck1peGluID0ge1xuICAgIGNvbnRleHRUeXBlczoge1xuICAgICAgICBleGVjdXRlQWN0aW9uOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICAgICAgbWFrZVBhdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gICAgfSxcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnRleHQ7XG4gICAgICAgIHZhciB1cmxGcm9tSGlzdG9yeTtcbiAgICAgICAgdmFyIHVybEZyb21TdGF0ZTtcblxuICAgICAgICBpZiAoc2VsZi5jb250ZXh0ICYmIHNlbGYuY29udGV4dC5leGVjdXRlQWN0aW9uKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gc2VsZi5jb250ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYucHJvcHMuY29udGV4dCAmJiBzZWxmLnByb3BzLmNvbnRleHQuZXhlY3V0ZUFjdGlvbikge1xuICAgICAgICAgICAgY29udGV4dCA9IHNlbGYucHJvcHMuY29udGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuX2hpc3RvcnkgPSAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHNlbGYucHJvcHMuaGlzdG9yeUNyZWF0b3IpID8gc2VsZi5wcm9wcy5oaXN0b3J5Q3JlYXRvcigpIDogbmV3IEhpc3RvcnkoKTtcbiAgICAgICAgc2VsZi5fZW5hYmxlU2Nyb2xsID0gKHNlbGYucHJvcHMuZW5hYmxlU2Nyb2xsICE9PSBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHNlbGYucHJvcHMuY2hlY2tSb3V0ZU9uUGFnZUxvYWQpIHtcbiAgICAgICAgICAgIC8vIFlvdSBwcm9iYWJseSB3YW50IHRvIGVuYWJsZSBjaGVja1JvdXRlT25QYWdlTG9hZCwgaWYgeW91IHVzZSBhIGhpc3RvcnkgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIC8vIHRoYXQgc3VwcG9ydHMgaGFzaCByb3V0ZTpcbiAgICAgICAgICAgIC8vICAgQXQgcGFnZSBsb2FkLCBmb3IgYnJvd3NlcnMgd2l0aG91dCBwdXNoU3RhdGUgQU5EIGhhc2ggaXMgcHJlc2VudCBpbiB0aGUgdXJsLFxuICAgICAgICAgICAgLy8gICBzaW5jZSBoYXNoIGZyYWdtZW50IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIgc2lkZSwgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gICBkaXNwYXRjaCBuYXZpZ2F0ZSBhY3Rpb24gb24gYnJvd3NlciBzaWRlIHRvIGxvYWQgdGhlIGFjdHVhbCBwYWdlIGNvbnRlbnRcbiAgICAgICAgICAgIC8vICAgZm9yIHRoZSByb3V0ZSByZXByZXNlbnRlZCBieSB0aGUgaGFzaCBmcmFnbWVudC5cblxuICAgICAgICAgICAgdXJsRnJvbUhpc3RvcnkgPSBzZWxmLl9oaXN0b3J5LmdldFVybCgpO1xuICAgICAgICAgICAgdXJsRnJvbVN0YXRlID0gc2VsZi5zdGF0ZSAmJiBzZWxmLnN0YXRlLnJvdXRlICYmIHNlbGYuc3RhdGUucm91dGUudXJsO1xuXG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiAodXJsRnJvbUhpc3RvcnkgIT09IHVybEZyb21TdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwdXQgaXQgaW4gc2V0SW1tZWRpYXRlLCBiZWNhdXNlIHdlIG5lZWQgdGhlIGJhc2UgY29tcG9uZW50IHRvIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSBsaXN0ZW5lcnMgYXR0YWNoZWQsIGJlZm9yZSBuYXZpZ2F0ZUFjdGlvbiBpcyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgICBkZWJ1ZygncGFnZWxvYWQgbmF2aWdhdGUgdG8gYWN0dWFsIHJvdXRlJywgdXJsRnJvbUhpc3RvcnksIHVybEZyb21TdGF0ZSk7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uIG5hdmlnYXRlVG9BY3R1YWxSb3V0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5leGVjdXRlQWN0aW9uKG5hdmlnYXRlQWN0aW9uLCB7dHlwZTogVFlQRV9QQUdFTE9BRCwgdXJsOiB1cmxGcm9tSGlzdG9yeX0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5faGlzdG9yeUxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IHNlbGYuX2hpc3RvcnkuZ2V0VXJsKCk7XG4gICAgICAgICAgICAgICAgZGVidWcoJ2hpc3RvcnkgbGlzdGVuZXIgaW52b2tlZCcsIGUsIHVybCwgc2VsZi5zdGF0ZS5yb3V0ZS51cmwpO1xuICAgICAgICAgICAgICAgIGlmICh1cmwgIT09IHNlbGYuc3RhdGUucm91dGUudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXhlY3V0ZUFjdGlvbihuYXZpZ2F0ZUFjdGlvbiwge3R5cGU6IFRZUEVfUE9QU1RBVEUsIHVybDogdXJsLCBwYXJhbXM6IChlLnN0YXRlICYmIGUuc3RhdGUucGFyYW1zKX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5faGlzdG9yeS5vbihzZWxmLl9oaXN0b3J5TGlzdGVuZXIpO1xuXG4gICAgICAgIGlmIChzZWxmLl9lbmFibGVTY3JvbGwpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxUaW1lcjtcbiAgICAgICAgICAgIHNlbGYuX3Njcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChzY3JvbGxUaW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjcm9sbFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoc2F2ZVNjcm9sbFBvc2l0aW9uLmJpbmQoc2VsZiwgZSwgc2VsZi5faGlzdG9yeSksIDE1MCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHNlbGYuX3Njcm9sbExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5Lm9mZih0aGlzLl9oaXN0b3J5TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9oaXN0b3J5TGlzdGVuZXIgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLl9lbmFibGVTY3JvbGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9zY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oaXN0b3J5ID0gbnVsbDtcbiAgICB9LFxuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICAgIGRlYnVnKCdjb21wb25lbnQgZGlkIHVwZGF0ZScsIHByZXZTdGF0ZSwgdGhpcy5zdGF0ZSk7XG5cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHJvdXRlc0VxdWFsKHByZXZTdGF0ZSAmJiBwcmV2U3RhdGUucm91dGUsIG5ld1N0YXRlICYmIG5ld1N0YXRlLnJvdXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hdiA9IG5ld1N0YXRlLnJvdXRlLm5hdmlnYXRlO1xuICAgICAgICB2YXIgbmF2VHlwZSA9IChuYXYgJiYgbmF2LnR5cGUpIHx8IFRZUEVfREVGQVVMVDtcbiAgICAgICAgdmFyIGhpc3RvcnlTdGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKG5hdlR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVFlQRV9DTElDSzpcbiAgICAgICAgICAgIGNhc2UgVFlQRV9ERUZBVUxUOlxuICAgICAgICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IHtwYXJhbXM6IChuYXYgJiYgbmF2LnBhcmFtcykgfHwge319O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5U3RhdGUuc2Nyb2xsID0ge3g6IDAsIHk6IDB9O1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Zygnb24gY2xpY2sgbmF2aWdhdGlvbiwgcmVzZXQgc2Nyb2xsIHBvc2l0aW9uIHRvICgwLCAwKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIG5ld1N0YXRlLnJvdXRlLnVybCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRZUEVfUE9QU1RBVEU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZVNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICBoaXN0b3J5U3RhdGUgPSAodGhpcy5faGlzdG9yeS5nZXRTdGF0ZSAmJiB0aGlzLl9oaXN0b3J5LmdldFN0YXRlKCkpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gKGhpc3RvcnlTdGF0ZSAmJiBoaXN0b3J5U3RhdGUuc2Nyb2xsKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ29uIHBvcHN0YXRlIG5hdmlnYXRpb24sIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uIHRvICcsIHNjcm9sbCk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGwueCB8fCAwLCBzY3JvbGwueSB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlck1peGluO1xuIiwiLyohXG5cdHF1ZXJ5LXN0cmluZ1xuXHRQYXJzZSBhbmQgc3RyaW5naWZ5IFVSTCBxdWVyeSBzdHJpbmdzXG5cdGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nXG5cdGJ5IFNpbmRyZSBTb3JodXNcblx0TUlUIExpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cdHZhciBxdWVyeVN0cmluZyA9IHt9O1xuXG5cdHF1ZXJ5U3RyaW5nLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuXHRcdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblxuXHRcdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98IykvLCAnJyk7XG5cblx0XHRpZiAoIXN0cikge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHIudHJpbSgpLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XG5cdFx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdFx0dmFyIGtleSA9IHBhcnRzWzBdO1xuXHRcdFx0dmFyIHZhbCA9IHBhcnRzWzFdO1xuXG5cdFx0XHRrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblx0XHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdFx0aWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRyZXRba2V5XSA9IHZhbDtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdFx0cmV0W2tleV0ucHVzaCh2YWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSwge30pO1xuXHR9O1xuXG5cdHF1ZXJ5U3RyaW5nLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHRcdHJldHVybiB2YWwubWFwKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbDIpO1xuXHRcdFx0XHR9KS5qb2luKCcmJyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXHRcdH0pLmpvaW4oJyYnKSA6ICcnO1xuXHR9O1xuXG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBxdWVyeVN0cmluZzsgfSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IHF1ZXJ5U3RyaW5nO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5xdWVyeVN0cmluZyA9IHF1ZXJ5U3RyaW5nO1xuXHR9XG59KSgpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSBwYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBwYXJ0aWFsbHlBcHBsaWVkKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwiXCIgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkpKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZmV0Y2hyLXBsdWdpbicpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnRmx1eGlibGU6RmV0Y2hyUGx1Z2luJyk7XG52YXIgREVGQVVMVF9BUElfUEFUSCA9ICcvYXBpJztcbnZhciBGZXRjaHIgPSByZXF1aXJlKCdmZXRjaHInKTtcblxuLyoqXG4gKiBDb2xsZWN0cyBtZXRhZGF0YSBmcm9tIHRoZSBzZXJ2aWNlIGNhbGxzIHNvIHRoYXQgdGhleSBjYW4gYmUgdXNlZCBmb3IgcmVzcG9uc2UgaGVhZGVyc1xuICogQHBhcmFtIHNlcnZpY2VcbiAqIEBwYXJhbSBvcGVyYXRpb25cbiAqIEBwYXJhbSBtZXRhQXJyYXlcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVGhlIHByb3h5IG1ldGhvZFxuICovXG5mdW5jdGlvbiBjcnVkUHJveHkoc2VydmljZSwgb3BlcmF0aW9uLCBtZXRhQXJyYXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3J1ZFByb3h5TWV0aG9kKCkge1xuICAgICAgICBkZWJ1Zygnc2VydmljZSBwcm94eScpO1xuXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVwbGFjZSBsYXN0IGFyZ3VtZW50IChjYWxsYmFjaykgd2l0aCBwcm94eSBjYWxsYmFja1xuICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgJ2NvbmZpZycgaXMgYW4gb3B0aW9uYWwgcGFyYW0gZm9yIHNlcnZpY2VzXG4gICAgICAgIC8vIHRodXMgZW5zdXJpbmcgdGhlIHByb3h5IGNhbGxiYWNrIGlzIGFsd2F5cyBwYXNzZWQgaW5cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgLy8gY3JlYXRlIHByb3h5IGNhbGxiYWNrIHRvIGFkZCBzZXJ2aWNlIG1ldGEgdG8gdGhlIGNvbnRleHQgaW5zdGFuY2VcbiAgICAgICAgdmFyIHByb3h5Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCBkYXRhLCBtZXRhKSB7XG4gICAgICAgICAgICBkZWJ1Zygnc2VydmljZSBwcm94eSBjYWxsYmFjaycsIGRhdGEsIG1ldGEpO1xuICAgICAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgICAgICBtZXRhQXJyYXkucHVzaChtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYXJncy5wdXNoKHByb3h5Q2FsbGJhY2spO1xuXG4gICAgICAgIC8vIGV4ZWN1dGUgc2VydmljZSBhcyB1c3VhbFxuICAgICAgICBzZXJ2aWNlW29wZXJhdGlvbl0uYXBwbHkoc2VydmljZSwgYXJncyk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZldGNociBwbHVnaW4gaW5zdGFuY2Ugd2l0aCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMueGhyUGF0aCBUaGUgcGF0aCB0byBzZXJ2ZSBYSFIgcmVxdWVzdHMgZnJvbVxuICogQHJldHVybnMge0ZldGNoclBsdWdpbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmZXRjaHJQbHVnaW4ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB4aHJQYXRoID0gb3B0aW9ucy54aHJQYXRoIHx8IERFRkFVTFRfQVBJX1BBVEg7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRmV0Y2hyUGx1Z2luXG4gICAgICovXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHBsdWdpblxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogJ0ZldGNoclBsdWdpbicsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgdG8gcGx1ZyB0aGUgRmx1eENvbnRleHRcbiAgICAgICAgICogQG1ldGhvZCBwbHVnQ29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dE9wdGlvbnMgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNyZWF0ZUNvbnRleHQgbWV0aG9kXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0T3B0aW9ucy5yZXEgVGhlIHNlcnZlciByZXF1ZXN0IG9iamVjdCAob25seSBzdXBwbGllZCBpZiBvbiBzZXJ2ZXIpXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0T3B0aW9ucy54aHJDb250ZXh0IENvbnRleHQgb2JqZWN0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhbGxcbiAgICAgICAgICogICAgICBYSFIgY2FsbHMgZnJvbSB0aGUgY2xpZW50LiBUaGlzIGFsbG93cyBwZXJzaXN0ZW5jZSBvZiBzb21lIHZhbHVlcyBiZXR3ZWVuIHJlcXVlc3RzXG4gICAgICAgICAqICAgICAgYW5kIGFsc28gQ1NSRiB2YWxpZGF0aW9uLiAoZS5nLiB7IF9jc3JmOiAnYTNmYzJmJywgZGV2aWNlOiBcInRhYmxldFwiIH0pXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBwbHVnQ29udGV4dDogZnVuY3Rpb24gcGx1Z0NvbnRleHQoY29udGV4dE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB4aHJDb250ZXh0ID0gY29udGV4dE9wdGlvbnMueGhyQ29udGV4dDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmdldFhoclBhdGgpIHtcbiAgICAgICAgICAgICAgICB4aHJQYXRoID0gb3B0aW9ucy5nZXRYaHJQYXRoKGNvbnRleHRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQWRkcyB0aGUgc2VydmljZSBDUlVEIGFuZCBnZXRTZXJ2aWNlTWV0YSBtZXRob2RzIHRvIHRoZSBhY3Rpb24gY29udGV4dFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhY3Rpb25Db250ZXh0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcGx1Z0FjdGlvbkNvbnRleHQ6IGZ1bmN0aW9uIHBsdWdBY3Rpb25Db250ZXh0KGFjdGlvbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlcnZpY2VNZXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2aWNlID0gbmV3IEZldGNocih7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXE6IGNvbnRleHRPcHRpb25zLnJlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoclBhdGg6IHhoclBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB4aHJDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25Db250ZXh0LnNlcnZpY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IGNydWRQcm94eShzZXJ2aWNlLCAnY3JlYXRlJywgc2VydmljZU1ldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZDogY3J1ZFByb3h5KHNlcnZpY2UsICdyZWFkJywgc2VydmljZU1ldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBjcnVkUHJveHkoc2VydmljZSwgJ3VwZGF0ZScsIHNlcnZpY2VNZXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZWxldGUnOiBjcnVkUHJveHkoc2VydmljZSwgJ2RlbGV0ZScsIHNlcnZpY2VNZXRhKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25Db250ZXh0LmdldFNlcnZpY2VNZXRhID0gZnVuY3Rpb24gZ2V0U2VydmljZU1ldGEoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VydmljZU1ldGE7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDYWxsZWQgdG8gZGVoeWRyYXRlIHBsdWdpbiBvcHRpb25zXG4gICAgICAgICAgICAgICAgICogQG1ldGhvZCBkZWh5ZHJhdGVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRlaHlkcmF0ZTogZnVuY3Rpb24gZGVoeWRyYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyQ29udGV4dDogY29udGV4dE9wdGlvbnMueGhyQ29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoclBhdGg6IHhoclBhdGhcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENhbGxlZCB0byByZWh5ZHJhdGUgcGx1Z2luIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIHJlaHlkcmF0ZVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVoeWRyYXRlOiBmdW5jdGlvbiByZWh5ZHJhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyQ29udGV4dCA9IHN0YXRlLnhockNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHhoclBhdGggPSBzdGF0ZS54aHJQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBzZXJ2aWNlIHRvIHRoZSBtYW5hZ2VyXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJTZXJ2aWNlXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlclNlcnZpY2U6IGZ1bmN0aW9uIHJlZ2lzdGVyU2VydmljZShzZXJ2aWNlKSB7XG4gICAgICAgICAgICBGZXRjaHIucmVnaXN0ZXJGZXRjaGVyKHNlcnZpY2UpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBleHByZXNzIG1pZGRsZXdhcmUuIE9ubHkgd29ya3Mgb24gdGhlIHNlcnZlciFcbiAgICAgICAgICogQG1ldGhvZCBnZXRNaWRkbGV3YXJlXG4gICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE1pZGRsZXdhcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBGZXRjaHIubWlkZGxld2FyZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSB4aHIgcGF0aCBiZWluZyB1c2VkIGJ5IHRoZSBwbHVnaW5cbiAgICAgICAgICogQG1ldGhvZCBnZXRYaHJQYXRoXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRYaHJQYXRoOiBmdW5jdGlvbiBnZXRYaHJQYXRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHhoclBhdGg7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cblxuLypqc2xpbnQgcGx1c3BsdXM6dHJ1ZSxub21lbjp0cnVlICovXG5cbi8qKlxuICogRmV0Y2hlciBpcyBhIFJFU1RmdWwgZGF0YSBzdG9yZSwgdGhhdCBpbXBsZW1lbnRzIHRoZSBDUlVEIGludGVyZmFjZS5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgaXQgYWxsb3dzIHJlcXVlc3QgY29uc29saWRhdGlvbi5cbiAqIElmIC9hcGkgYWNjZXB0cyBtdWx0aS1yZXF1ZXN0IGluIG9uZSBIVFRQIHJlcXVlc3QsIHJlbW90ZSBzdG9yZVxuICogYmF0Y2hlcyByZXF1ZXN0cyBpbnRvIG9uZSByZXF1ZXN0LlxuICogQG1vZHVsZSBGZXRjaGVyXG4gKi9cbnZhciBSRVNUID0gcmVxdWlyZSgnLi91dGlsL2h0dHAuY2xpZW50JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdGZXRjaHJDbGllbnQnKSxcbiAgICBfID0gcmVxdWlyZSgnbG9kYXNoJyksXG4gICAgQ09SRV9SRVFVRVNUX0ZJRUxEUyA9IFsncmVzb3VyY2UnLCAnb3BlcmF0aW9uJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgREVGQVVMVF9HVUlEID0gJ2cwJyxcbiAgICBERUZBVUxUX1hIUl9QQVRIID0gJy9hcGknLFxuICAgIC8vIEJ5IGRlZmF1bHQsIHdhaXQgZm9yIDIwbXMgdG8gdHJpZ2dlciBzd2VlcCBvZiB0aGUgcXVldWUsIGFmdGVyIGFuIGl0ZW0gaXMgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgIERFRkFVTFRfQkFUQ0hfV0lORE9XID0gMjAsXG4gICAgTUFYX1VSSV9MRU4gPSAyMDQ4LFxuICAgIE9QX1JFQUQgPSAncmVhZCcsXG4gICAgTkFNRSA9ICdGZXRjaGVyQ2xpZW50JztcblxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdqc29uIHBhcnNlIGZhaWxlZDonICsgZSwgJ2Vycm9yJywgTkFNRSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24ganNvbmlmeUNvbXBsZXhUeXBlKHZhbHVlKSB7XG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBxdWV1ZSBzd2VlcHMgYW5kIHByb2Nlc3NzIGl0ZW1zIGluIHRoZSBxdWV1ZSB3aGVuIHRoZXJlIGFyZSBpdGVtcyBpbiB0aGUgcXVldWUuXG4gKiBXaGVuIGEgaXRlbSBpcyBwdXNoZWQgaW50byB0aGUgcXVldWUsIGEgdGltZW91dCBpcyBzZXQgdG8gZ3VhcmFudGVlIHRoZSBpdGVtIHdpbGwgYmUgcHJvY2Vzc2Qgc29vbi5cbiAqIElmIHRoZXJlIGFyZSBhbnkgaXRlbSBpbiB0aGUgcXVldWUgYmVmb3JlIGEgaXRlbSwgdGhpcyBpdGVtIGNhbiBiZSBwcm9jZXNzZCBzb29uZXIgdGhhbiBpdHMgdGltZW91dC5cbiAqXG4gKiBAY2xhc3MgUXVldWVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGlkICAgICAgICAgSUQgZm9yIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3dlZXBGbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gcXVldWUgaXMgc3dlZXBlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IHN3ZWVwRm4uaXRlbXMgVGhlIGN1cnJlbnQgaXRlbXMgaW4gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gcHJvY2VzcyBhIGdpdmVuIGl0ZW0gaW4gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrLml0ZW0gVGhlIG9iaiB0aGF0IHdhcyBwb3BwZWQgZnJvbSB0aGUgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIFF1ZXVlKGlkLCBjb25maWcsIHN3ZWVwRm4sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuX3N3ZWVwID0gc3dlZXBGbjtcbiAgICB0aGlzLl9jYiA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xufVxuXG4vKipcbiAqIEdsb2JhbCB1bmlxdWUgaWQgb2YgdGhlIHF1ZXVlIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSBpZFxuICogQHR5cGUgU3RyaW5nXG4gKi9cbi8qKlxuICogVGhlIGNvbmZpZ3VyYWl0b24gb2JqZWN0IGZvciB0aGlzIHF1ZXVlLlxuICogQHByb3BlcnR5IGNvbmZpZ1xuICogQHR5cGUgT2JqZWN0XG4gKi9cblxuUXVldWUucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIE9uY2UgYW4gaXRlbSBpcyBwdXNoZWQgdG8gdGhlIHF1ZXVlLFxuICAgICAqIGEgdGltZXIgd2lsbCBiZSBzZXQgdXAgaW1tZWRpYXRlIHRvIHN3ZWVwIGFuZCBwcm9jZXNzIHRoZSBpdGVtcy4gIFRoZSB0aW1lIG9mIHRoZVxuICAgICAqIHRpbWVvdXQgZGVwZW5kcyBvbiBxdWV1ZSdzIGNvbmZpZyAoMjBtcyBieSBkZWZhdWx0KS4gIElmIGl0IGlzIHNldCB0byBhIG51bWJlciA8PSAwLFxuICAgICAqIHRoZSBxdWV1ZSB3aWxsIGJlIHN3ZWVwZWQgYW5kIHByb2Nlc3NlZCByaWdodCBhd2F5LlxuICAgICAqIEBtZXRob2QgcHVzaFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtICAgVGhlIGl0ZW0gb2JqZWN0IHRvIGJlIHB1c2hlZCB0byB0aGUgcXVldWVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcHVzaCA6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb25maWcud2FpdCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBwcm9jZXNzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB0aGlzLl9jYihpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICAvLyBzZXR1cCB0aW1lclxuICAgICAgICBpZiAoIXRoaXMuX3RpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IHNlbGYuX2l0ZW1zO1xuICAgICAgICAgICAgICAgIHNlbGYuX2l0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3RpbWVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLl90aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBzZWxmLl9zd2VlcChpdGVtcyk7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYihpdGVtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLndhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyB0aGF0IGFyZSBpbml0aWF0ZWQgd2l0aGluIGEgdGltZSB3aW5kb3cgYXJlIGJhdGNoZWQgYW5kIHNlbnQgdG8geGhyIGVuZHBvaW50LlxuICAgICAqIFRoZSByZWNlaXZlZCByZXNwb25zZXMgYXJlIHNwbGl0IGFuZCByb3V0ZWQgYmFjayB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gYXNzaWduZWQgYnkgaW5pdGlhdG9yXG4gICAgICogb2YgZWFjaCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQWxsIHJlcXVlc3RzIGdvIG91dCBmcm9tIHRoaXMgc3RvcmUgaXMgdmlhIEhUVFAgUE9TVC4gVHlwaWNhbCBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRleHQgcGFyYW0gaXM6XG4gICAgICogPHByZT5cbiAgICAgKiB7XG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdXJpIDogJy9hcGknXG4gICAgICogICB9LFxuICAgICAqICAgY29udGV4dDoge1xuICAgICAqICAgICBfY3NyZiA6ICc1WUZ1REs2UicsXG4gICAgICogICAgIGxhbmcgOiAnZW4tVVMnLFxuICAgICAqICAgICAuLi5cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBAY2xhc3MgRmV0Y2hlckNsaWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgRmV0Y2hlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy54aHJQYXRoPVwiL2FwaVwiXSBUaGUgcGF0aCBmb3IgWEhSIHJlcXVlc3RzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJhdGNoV2luZG93PTIwXSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdG8gYmF0Y2ggcmVxdWVzdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29udGV4dF0gVGhlIGNvbnRleHQgb2JqZWN0IHRoYXQgaXMgcHJvcGFnYXRlZCB0byBhbGwgb3V0Z29pbmdcbiAgICAgKiAgICAgIHJlcXVlc3RzIGFzIHF1ZXJ5IHBhcmFtcy4gIEl0IGNhbiBjb250YWluIGN1cnJlbnQtc2Vzc2lvbi9jb250ZXh0IGRhdGEgdGhhdCBzaG91bGRcbiAgICAgKiAgICAgIHBlcnNpc3QgdG8gYWxsIHJlcXVlc3RzLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRmV0Y2hlciAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnhoclBhdGggPSBvcHRpb25zLnhoclBhdGggfHwgREVGQVVMVF9YSFJfUEFUSDtcbiAgICAgICAgdGhpcy5iYXRjaFdpbmRvdyA9IG9wdGlvbnMuYmF0Y2hXaW5kb3cgfHwgREVGQVVMVF9CQVRDSF9XSU5ET1c7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCB7fTtcbiAgICB9XG5cbiAgICBGZXRjaGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIERhdGEgQWNjZXNzIFdyYXBwZXIgTWV0aG9kc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvKipcbiAgICAgICAgICogY3JlYXRlIG9wZXJhdGlvbiAoY3JlYXRlIGFzIGluIENSVUQpLlxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzb3VyY2UgIFRoZSByZXNvdXJjZSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgICAgVGhlIHBhcmFtZXRlcnMgaWRlbnRpZnkgdGhlIHJlc291cmNlLCBhbmQgYWxvbmcgd2l0aCBpbmZvcm1hdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJpZWQgaW4gcXVlcnkgYW5kIG1hdHJpeCBwYXJhbWV0ZXJzIGluIHR5cGljYWwgUkVTVCBBUElcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJvZHkgICAgICBUaGUgSlNPTiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcmVzb3VyY2UgZGF0YSB0aGF0IGlzIGJlaW5nIGNyZWF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgICBUaGUgXCJjb25maWdcIiBvYmplY3QgZm9yIHBlci1yZXF1ZXN0IGNvbmZpZyBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBjb252ZW50aW9uIGlzIHRoZSBzYW1lIGFzIE5vZGUuanNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAocmVzb3VyY2UsIHBhcmFtcywgYm9keSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc3luYyhyZXNvdXJjZSwgJ2NyZWF0ZScsIHBhcmFtcywgYm9keSwgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlYWQgb3BlcmF0aW9uIChyZWFkIGFzIGluIENSVUQpLlxuICAgICAgICAgKiBAbWV0aG9kIHJlYWRcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlICBUaGUgcmVzb3VyY2UgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zICAgIFRoZSBwYXJhbWV0ZXJzIGlkZW50aWZ5IHRoZSByZXNvdXJjZSwgYW5kIGFsb25nIHdpdGggaW5mb3JtYXRpb25cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJyaWVkIGluIHF1ZXJ5IGFuZCBtYXRyaXggcGFyYW1ldGVycyBpbiB0eXBpY2FsIFJFU1QgQVBJXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgVGhlIFwiY29uZmlnXCIgb2JqZWN0IGZvciBwZXItcmVxdWVzdCBjb25maWcgZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgY29udmVudGlvbiBpcyB0aGUgc2FtZSBhcyBOb2RlLmpzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChyZXNvdXJjZSwgcGFyYW1zLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9zeW5jKHJlc291cmNlLCAncmVhZCcsIHBhcmFtcywgdW5kZWZpbmVkLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdXBkYXRlIG9wZXJhdGlvbiAodXBkYXRlIGFzIGluIENSVUQpLlxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzb3VyY2UgIFRoZSByZXNvdXJjZSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgICAgVGhlIHBhcmFtZXRlcnMgaWRlbnRpZnkgdGhlIHJlc291cmNlLCBhbmQgYWxvbmcgd2l0aCBpbmZvcm1hdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJpZWQgaW4gcXVlcnkgYW5kIG1hdHJpeCBwYXJhbWV0ZXJzIGluIHR5cGljYWwgUkVTVCBBUElcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJvZHkgICAgICBUaGUgSlNPTiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcmVzb3VyY2UgZGF0YSB0aGF0IGlzIGJlaW5nIHVwZGF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgICBUaGUgXCJjb25maWdcIiBvYmplY3QgZm9yIHBlci1yZXF1ZXN0IGNvbmZpZyBkYXRhLlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBjb252ZW50aW9uIGlzIHRoZSBzYW1lIGFzIE5vZGUuanNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAocmVzb3VyY2UsIHBhcmFtcywgYm9keSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc3luYyhyZXNvdXJjZSwgJ3VwZGF0ZScsIHBhcmFtcywgYm9keSwgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlbGV0ZSBvcGVyYXRpb24gKGRlbGV0ZSBhcyBpbiBDUlVEKS5cbiAgICAgICAgICogQG1ldGhvZCBkZWxldGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlICBUaGUgcmVzb3VyY2UgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zICAgIFRoZSBwYXJhbWV0ZXJzIGlkZW50aWZ5IHRoZSByZXNvdXJjZSwgYW5kIGFsb25nIHdpdGggaW5mb3JtYXRpb25cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJyaWVkIGluIHF1ZXJ5IGFuZCBtYXRyaXggcGFyYW1ldGVycyBpbiB0eXBpY2FsIFJFU1QgQVBJXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgVGhlIFwiY29uZmlnXCIgb2JqZWN0IGZvciBwZXItcmVxdWVzdCBjb25maWcgZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgY29udmVudGlvbiBpcyB0aGUgc2FtZSBhcyBOb2RlLmpzXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAocmVzb3VyY2UsIHBhcmFtcywgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fc3luYyhyZXNvdXJjZSwgJ2RlbGV0ZScsIHBhcmFtcywgdW5kZWZpbmVkLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN5bmMgZGF0YSB3aXRoIHJlbW90ZSBBUEkuXG4gICAgICAgICAqIEBtZXRob2QgX3N5bmNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlICBUaGUgcmVzb3VyY2UgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0aW9uIFRoZSBDUlVEIG9wZXJhdGlvbiBuYW1lOiAnY3JlYXRlfHJlYWR8dXBkYXRlfGRlbGV0ZScuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgICAgVGhlIHBhcmFtZXRlcnMgaWRlbnRpZnkgdGhlIHJlc291cmNlLCBhbmQgYWxvbmcgd2l0aCBpbmZvcm1hdGlvblxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJpZWQgaW4gcXVlcnkgYW5kIG1hdHJpeCBwYXJhbWV0ZXJzIGluIHR5cGljYWwgUkVTVCBBUElcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJvZHkgICAgICBUaGUgSlNPTiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcmVzb3VyY2UgZGF0YSB0aGF0IGlzIGJlaW5nIHVwZGF0ZWQuIE5vdCB1c2VkXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHJlYWQgYW5kIGRlbGV0ZSBvcGVyYXRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICAgIFRoZSBcImNvbmZpZ1wiIG9iamVjdCBmb3IgcGVyLXJlcXVlc3QgY29uZmlnIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGNvbnZlbnRpb24gaXMgdGhlIHNhbWUgYXMgTm9kZS5qc1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc3luYzogZnVuY3Rpb24gKHJlc291cmNlLCBvcGVyYXRpb24sIHBhcmFtcywgYm9keSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICBjb25maWcgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgY29uZmlnLnhociA9IHRoaXMueGhyUGF0aDtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiByZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24odGhpcy5iYXRjaCkgfHwgIWNvbmZpZy5jb25zb2xpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2luZ2xlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHVzaCByZXF1ZXN0IHRvIHF1ZXVlIHNvIHRoYXQgaXQgY2FuIGJlIGJhdGNoZWRcbiAgICAgICAgICAgIGlmICghdGhpcy5fcSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3EgPSBuZXcgUXVldWUodGhpcy5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXQ6IEZldGNoZXIuYmF0Y2hXaW5kb3dcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuYmF0Y2gocmVxdWVzdHMpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChiYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KGJhdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNpbmdsZShiYXRjaGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubXVsdGkoYmF0Y2hlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3EucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8vIEhlbHBlciBNZXRob2RzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBfY29uc3RydWN0R2V0VXJpXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfY29uc3RydWN0R2V0VXJpOiBmdW5jdGlvbiAodXJpLCByZXNvdXJjZSwgcGFyYW1zLCBjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IFtdLCBtYXRyaXggPSBbXSwgaWRfcGFyYW0gPSBjb25maWcuaWRfcGFyYW0sIGlkX3ZhbCwgZmluYWxfdXJpID0gdXJpICsgJy9yZXNvdXJjZS8nICsgcmVzb3VyY2U7XG4gICAgICAgICAgICBfLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIGlmIChrID09PSBpZF9wYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZF92YWwgPSBlbmNvZGVVUklDb21wb25lbnQodik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5wdXNoKGsgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoanNvbmlmeUNvbXBsZXhUeXBlKHYpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoJ2pzb25pZnlDb21wbGV4VHlwZSBmYWlsZWQ6ICcgKyBlcnIsICdpbmZvJywgTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgXy5mb3JFYWNoKHRoaXMuY29udGV4dCwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICBxdWVyeS5wdXNoKGsgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoanNvbmlmeUNvbXBsZXhUeXBlKHYpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpZF92YWwpIHtcbiAgICAgICAgICAgICAgICBmaW5hbF91cmkgKz0gJy8nICsgaWRfcGFyYW0gKyAnLycgKyBpZF92YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0cml4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaW5hbF91cmkgKz0gJzsnICsgbWF0cml4LnNvcnQoKS5qb2luKCc7Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsX3VyaSArPSAnPycgKyBxdWVyeS5zb3J0KCkuam9pbignJicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZXRob2QgX2NvbnN0cnVjdEdyb3VwVXJpXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfY29uc3RydWN0R3JvdXBVcmk6IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IFtdLCBmaW5hbF91cmkgPSB1cmk7XG4gICAgICAgICAgICBfLmZvckVhY2godGhpcy5jb250ZXh0LCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LnB1c2goayArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxfdXJpICs9ICc/JyArIHF1ZXJ5LnNvcnQoKS5qb2luKCcmJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluYWxfdXJpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBBY3R1YWwgRGF0YSBBY2Nlc3MgTWV0aG9kc1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZSBhIHNpbmdsZSByZXF1ZXN0LlxuICAgICAgICAgKiBAbWV0aG9kIHNpbmdsZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdC5yZXNvdXJjZSAgVGhlIHJlc291cmNlIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3Qub3BlcmF0aW9uIFRoZSBDUlVEIG9wZXJhdGlvbiBuYW1lOiAnY3JlYXRlfHJlYWR8dXBkYXRlfGRlbGV0ZScuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0LnBhcmFtcyAgICBUaGUgcGFyYW1ldGVycyBpZGVudGlmeSB0aGUgcmVzb3VyY2UsIGFuZCBhbG9uZyB3aXRoIGluZm9ybWF0aW9uXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FycmllZCBpbiBxdWVyeSBhbmQgbWF0cml4IHBhcmFtZXRlcnMgaW4gdHlwaWNhbCBSRVNUIEFQSVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdC5ib2R5ICAgICAgVGhlIEpTT04gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHJlc291cmNlIGRhdGEgdGhhdCBpcyBiZWluZyB1cGRhdGVkLiBOb3QgdXNlZFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciByZWFkIGFuZCBkZWxldGUgb3BlcmF0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QuY29uZmlnICAgIFRoZSBcImNvbmZpZ1wiIG9iamVjdCBmb3IgcGVyLXJlcXVlc3QgY29uZmlnIGRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlcXVlc3QuY2FsbGJhY2sgY2FsbGJhY2sgY29udmVudGlvbiBpcyB0aGUgc2FtZSBhcyBOb2RlLmpzXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgc2luZ2xlIDogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHJlcXVlc3QuY29uZmlnLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcmVxdWVzdC5jYWxsYmFjayB8fCBfLm5vb3AsXG4gICAgICAgICAgICAgICAgdXNlX3Bvc3QsXG4gICAgICAgICAgICAgICAgYWxsb3dfcmV0cnlfcG9zdCxcbiAgICAgICAgICAgICAgICB1cmkgPSBjb25maWcudXJpIHx8IGNvbmZpZy54aHIgfHwgdGhpcy54aHJQYXRoLFxuICAgICAgICAgICAgICAgIGdldF91cmksXG4gICAgICAgICAgICAgICAgcmVxdWVzdHMsXG4gICAgICAgICAgICAgICAgZGF0YTtcblxuICAgICAgICAgICAgdXNlX3Bvc3QgPSByZXF1ZXN0Lm9wZXJhdGlvbiAhPT0gT1BfUkVBRCB8fCBjb25maWcucG9zdF9mb3JfcmVhZDtcbiAgICAgICAgICAgIGlmICghdXNlX3Bvc3QpIHtcbiAgICAgICAgICAgICAgICBnZXRfdXJpID0gdGhpcy5fY29uc3RydWN0R2V0VXJpKHVyaSwgcmVxdWVzdC5yZXNvdXJjZSwgcmVxdWVzdC5wYXJhbXMsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgaWYgKGdldF91cmkubGVuZ3RoIDw9IE1BWF9VUklfTEVOKSB7XG4gICAgICAgICAgICAgICAgICAgIHVyaSA9IGdldF91cmk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlX3Bvc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF1c2VfcG9zdCkge1xuICAgICAgICAgICAgICAgIFJFU1QuZ2V0KHVyaSwge30sIGNvbmZpZywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoJ1N5bmNpbmcgJyArIHJlcXVlc3QucmVzb3VyY2UgKyAnIGZhaWxlZDogc3RhdHVzQ29kZT0nICsgZXJyLnN0YXR1c0NvZGUsICdpbmZvJywgTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmRpdmlkdWFsIHJlcXVlc3QgaXMgYWxzbyBub3JtYWxpemVkIGludG8gYSByZXF1ZXN0IGhhc2ggdG8gcGFzcyB0byBhcGlcbiAgICAgICAgICAgIHJlcXVlc3RzID0ge307XG4gICAgICAgICAgICByZXF1ZXN0c1tERUZBVUxUX0dVSURdID0gXy5waWNrKHJlcXVlc3QsIENPUkVfUkVRVUVTVF9GSUVMRFMpO1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdHNbREVGQVVMVF9HVUlEXS5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0czogcmVxdWVzdHMsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0XG4gICAgICAgICAgICB9OyAvLyBUT0RPOiByZW1vdmUuIGxlYXZlIGhlcmUgZm9yIG5vdyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgdXJpID0gdGhpcy5fY29uc3RydWN0R3JvdXBVcmkodXJpKTtcbiAgICAgICAgICAgIGFsbG93X3JldHJ5X3Bvc3QgPSAocmVxdWVzdC5vcGVyYXRpb24gPT09IE9QX1JFQUQpO1xuICAgICAgICAgICAgUkVTVC5wb3N0KHVyaSwge30sIGRhdGEsIF8ubWVyZ2Uoe3Vuc2FmZUFsbG93UmV0cnk6IGFsbG93X3JldHJ5X3Bvc3R9LCBjb25maWcpLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ1N5bmNpbmcgJyArIHJlcXVlc3QucmVzb3VyY2UgKyAnIGZhaWxlZDogc3RhdHVzQ29kZT0nICsgZXJyLnN0YXR1c0NvZGUsICdpbmZvJywgTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbREVGQVVMVF9HVUlEXSB8fCB7fTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJhdGNoIHRoZSByZXF1ZXN0cy5cbiAgICAgICAgICogQG1ldGhvZCBiYXRjaFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSByZXF1ZXN0cyBBcnJheSBvZiByZXF1ZXN0cyBvYmplY3RzIHRvIGJlIGJhdGNoZWQuIEVhY2ggcmVxdWVzdCBpcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHJlc291cmNlYCwgYG9wZXJhdGlvbiwgYHBhcmFtc2AsIGBib2R5YCwgYGNvbmZpZ2AsIGBjYWxsYmFja2AuXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSB0aGUgcmVxdWVzdCBiYXRjaGVzLlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG4gICAgICAgIGJhdGNoIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKHJlcXVlc3RzKSB7XG4gICAgICAgICAgICBpZiAoIV8uaXNBcnJheShyZXF1ZXN0cykgfHwgcmVxdWVzdHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiYXRjaGVkLFxuICAgICAgICAgICAgICAgIGdyb3VwcyA9IHt9O1xuXG4gICAgICAgICAgICBfLmZvckVhY2gocmVxdWVzdHMsIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHVyaSwgYmF0Y2gsIGdyb3VwX2lkO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICB1cmkgPSByZXF1ZXN0LmNvbmZpZy51cmkgfHwgcmVxdWVzdC5jb25maWcueGhyIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBiYXRjaCA9IHJlcXVlc3QuY29uZmlnLmJhdGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBncm91cF9pZCA9ICd1cmk6JyArIHVyaTtcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBfaWQgKz0gJztiYXRjaDonICsgYmF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZ3JvdXBzW2dyb3VwX2lkXSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBfaWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdyb3Vwc1tncm91cF9pZF0ucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmF0Y2hlZCA9IF8udmFsdWVzKGdyb3Vwcyk7XG5cbiAgICAgICAgICAgIGlmIChiYXRjaGVkLmxlbmd0aCA8IHJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKHJlcXVlc3RzLmxlbmd0aCArICcgcmVxdWVzdHMgYmF0Y2hlZCBpbnRvICcgKyBiYXRjaGVkLmxlbmd0aCwgJ2luZm8nLCBOQU1FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYXRjaGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlIG11bHRpcGxlIHJlcXVlc3RzIHRoYXQgaGF2ZSBiZWVuIGJhdGNoZWQgdG9nZXRoZXIuXG4gICAgICAgICAqIEBtZXRob2Qgc2luZ2xlXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlcXVlc3RzICBUaGUgcmVxdWVzdCBiYXRjaC4gIEVhY2ggaXRlbSBpbiB0aGlzIGFycmF5IGlzIGEgcmVxdWVzdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzOlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHJlc291cmNlYCwgYG9wZXJhdGlvbiwgYHBhcmFtc2AsIGBib2R5YCwgYGNvbmZpZ2AsIGBjYWxsYmFja2AuXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAocmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHZhciB1cmksXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBjb3VudCA9IDAsXG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIGFsbG93X3JldHJ5X3Bvc3QgPSB0cnVlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RfbWFwID0ge307XG5cbiAgICAgICAgICAgIF8uc29tZShyZXF1ZXN0cywgZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gcmVxdWVzdC5jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdXJpID0gY29uZmlnLnVyaSB8fCBjb25maWcueGhyIHx8IHRoaXMueGhyUGF0aDtcblxuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0czoge30sXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0XG4gICAgICAgICAgICB9OyAvLyBUT0RPOiByZW1vdmUuIGxlYXZlIGhlcmUgZm9yIG5vdyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG4gICAgICAgICAgICBfLmZvckVhY2gocmVxdWVzdHMsIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1aWQgPSAnZycgKyAoY291bnQrKyk7XG4gICAgICAgICAgICAgICAgZGF0YS5yZXF1ZXN0c1tndWlkXSA9IF8ucGljayhyZXF1ZXN0LCBDT1JFX1JFUVVFU1RfRklFTERTKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X21hcFtndWlkXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Qub3BlcmF0aW9uICE9PSBPUF9SRUFEKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93X3JldHJ5X3Bvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdXJpID0gdGhpcy5fY29uc3RydWN0R3JvdXBVcmkodXJpKTtcbiAgICAgICAgICAgIFJFU1QucG9zdCh1cmksIHt9LCBkYXRhLCBfLm1lcmdlKHt1bnNhZmVBbGxvd1JldHJ5OiBhbGxvd19yZXRyeV9wb3N0fSwgY29uZmlnKSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9yRWFjaChyZXF1ZXN0cywgZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHJlc3VsdCBmb3IgcmVxdWVzdHMsIHNvIHRoYXQgZWFjaCByZXF1ZXN0IGdldHMgYmFjayBvbmx5IHRoZSBkYXRhIHRoYXQgd2FzIG9yaWdpbmFsbHkgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKHJlcXVlc3RfbWFwLCBmdW5jdGlvbiAocmVxdWVzdCwgZ3VpZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gKHJlc3VsdCAmJiByZXN1bHRbZ3VpZF0pIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhyZXMuZXJyIHx8IG51bGwsIHJlcy5kYXRhIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEZldGNoZXI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4vKmpzbGludCBub21lbjp0cnVlLHBsdXNwbHVzOnRydWUqL1xuLyoqXG4gKiBAbW9kdWxlIHJlc3QtaHR0cFxuICovXG5cbi8qXG4gKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25zOlxuICogICB0aW1lb3V0OiB0aW1lb3V0IChpbiBtcykgZm9yIGVhY2ggcmVxdWVzdFxuICogICByZXRyeTogcmV0cnkgcmVsYXRlZCBzZXR0aW5ncywgc3VjaCBhcyByZXRyeSBpbnRlcnZhbCBhbW91bnQgKGluIG1zKSwgbWF4X3JldHJpZXMuXG4gKiAgICAgICAgICBOb3RlIHRoYXQgb25seSByZXRyeSBvbmx5IGFwcGxpZXMgb24gR0VULlxuICovXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpLFxuICAgIERFRkFVTFRfQ09ORklHID0ge1xuICAgICAgICB0aW1lb3V0OiAzMDAwLFxuICAgICAgICByZXRyeToge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IDIwMCxcbiAgICAgICAgICAgIG1heF9yZXRyaWVzOiAyXG4gICAgICAgIH1cbiAgICB9LFxuICAgIENPTlRFTlRfVFlQRSA9ICdDb250ZW50LVR5cGUnLFxuICAgIFRZUEVfSlNPTiA9ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICBUSU1FT1VUID0gJ3RpbWVvdXQnLFxuICAgIE1FVEhPRF9HRVQgPSAnR0VUJyxcbiAgICBNRVRIT0RfUFVUID0gJ1BVVCcsXG4gICAgTUVUSE9EX1BPU1QgPSAnUE9TVCcsXG4gICAgTUVUSE9EX0RFTEVURSA9ICdERUxFVEUnLFxuICAgIE5VTEwgPSBudWxsLFxuICAgIHhociA9IHJlcXVpcmUoJ3hocicpO1xuXG4vL3RyaW0gcG9seWZpbGwsIG1heWJlIHB1bGwgZnJvbSBucG0gbGF0ZXJcbmlmICghU3RyaW5nLnByb3RvdHlwZS50cmltKSB7XG4gIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcnMoaGVhZGVycykge1xuICAgIHZhciBub3JtYWxpemVkID0ge307XG4gICAgXy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uICh2LCBmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRbQ09OVEVOVF9UWVBFXSA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVkW2ZpZWxkXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZW50VHlwZUpTT04oaGVhZGVycykge1xuICAgIHJldHVybiBfLnNvbWUoaGVhZGVyc1tDT05URU5UX1RZUEVdLnNwbGl0KCc7JyksIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJ0LnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBUWVBFX0pTT047XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJldHJ5KG1ldGhvZCwgY29uZmlnLCBzdGF0dXNDb2RlKSB7XG4gICAgdmFyIGlzSWRlbXBvdGVudCA9IChtZXRob2QgPT09IE1FVEhPRF9HRVQgfHwgbWV0aG9kID09PSBNRVRIT0RfUFVUIHx8IG1ldGhvZCA9PT0gTUVUSE9EX0RFTEVURSk7XG4gICAgaWYgKCFpc0lkZW1wb3RlbnQgJiYgIWNvbmZpZy51bnNhZmVBbGxvd1JldHJ5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChzdGF0dXNDb2RlICE9PSAwICYmIHN0YXR1c0NvZGUgIT09IDQwOCAmJiBzdGF0dXNDb2RlICE9PSA5OTkpIHx8IGNvbmZpZy50bXAucmV0cnlfY291bnRlciA+PSBjb25maWcucmV0cnkubWF4X3JldHJpZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25maWcudG1wLnJldHJ5X2NvdW50ZXIrKztcbiAgICBjb25maWcucmV0cnkuaW50ZXJ2YWwgPSAgY29uZmlnLnJldHJ5LmludGVydmFsICogMjtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnKSB7XG4gICAgdmFyIGNmZyA9IHtcbiAgICAgICAgICAgIHRpbWVvdXQ6IERFRkFVTFRfQ09ORklHLnRpbWVvdXQsXG4gICAgICAgICAgICB1bnNhZmVBbGxvd1JldHJ5OiBjb25maWcudW5zYWZlQWxsb3dSZXRyeSB8fCBmYWxzZSxcbiAgICAgICAgICAgIHJldHJ5OiB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IERFRkFVTFRfQ09ORklHLnJldHJ5LmludGVydmFsLFxuICAgICAgICAgICAgICAgIG1heF9yZXRyaWVzOiBERUZBVUxUX0NPTkZJRy5yZXRyeS5tYXhfcmV0cmllc1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAvLyBQZXJmb3JtYW50LWJ1dC12ZXJib3NlIHdheSBvZiBjbG9uaW5nIHRoZSBkZWZhdWx0IGNvbmZpZyBhcyBiYXNlXG4gICAgICAgIHRpbWVvdXQsXG4gICAgICAgIGludGVydmFsLFxuICAgICAgICBtYXhSZXRyaWVzO1xuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgICB0aW1lb3V0ID0gcGFyc2VJbnQoY29uZmlnLnRpbWVvdXQsIDEwKTtcbiAgICAgICAgaWYgKF8uaXNOdW1iZXIodGltZW91dCkgJiYgdGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIGNmZy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcucmV0cnkpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gcGFyc2VJbnQoY29uZmlnLnJldHJ5ICYmIGNvbmZpZy5yZXRyeS5pbnRlcnZhbCwgMTApO1xuICAgICAgICAgICAgaWYgKF8uaXNOdW1iZXIoaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCkge1xuICAgICAgICAgICAgICAgIGNmZy5yZXRyeS5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4UmV0cmllcyA9IHBhcnNlSW50KGNvbmZpZy5yZXRyeSAmJiBjb25maWcucmV0cnkubWF4X3JldHJpZXMsIDEwKTtcbiAgICAgICAgICAgIGlmIChfLmlzTnVtYmVyKG1heFJldHJpZXMpICYmIG1heFJldHJpZXMgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNmZy5yZXRyeS5tYXhfcmV0cmllcyA9IG1heFJldHJpZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0bXAgc3RvcmVzIHRyYW5zaWVudCBzdGF0ZSBkYXRhLCBzdWNoIGFzIHJldHJ5IGNvdW50XG4gICAgICAgIGlmIChjb25maWcudG1wKSB7XG4gICAgICAgICAgICBjZmcudG1wID0gY29uZmlnLnRtcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjZmc7XG59XG5cbmZ1bmN0aW9uIGRvWGhyKG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBkYXRhLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMsIHRpbWVvdXQ7XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyhjb25maWcpO1xuICAgIGhlYWRlcnMgPSBub3JtYWxpemVIZWFkZXJzKGhlYWRlcnMpO1xuICAgIGhlYWRlcnNbQ09OVEVOVF9UWVBFXSA9IGhlYWRlcnNbQ09OVEVOVF9UWVBFXSB8fCBUWVBFX0pTT047XG4gICAgLy8gdXNlIGNvbmZpZy50bXAgdG8gc3RvcmUgdGVtcG9yYXJ5IHZhbHVlc1xuICAgIGNvbmZpZy50bXAgPSBjb25maWcudG1wIHx8IHtyZXRyeV9jb3VudGVyOiAwfTtcblxuICAgIHRpbWVvdXQgPSBjb25maWcudGltZW91dDtcbiAgICBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2QgOiBtZXRob2QsXG4gICAgICAgIHRpbWVvdXQgOiB0aW1lb3V0LFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICBvbiA6IHtcbiAgICAgICAgICAgIHN1Y2Nlc3MgOiBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKE5VTEwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWlsdXJlIDogZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5KG1ldGhvZCwgY29uZmlnLCByZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5kZWxheShcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJldHJ5WEhSKCkgeyBkb1hocihtZXRob2QsIHVybCwgaGVhZGVycywgZGF0YSwgY29uZmlnLCBjYWxsYmFjayk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucmV0cnkuaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YSAhPT0gTlVMTCkge1xuICAgICAgICBvcHRpb25zLmRhdGEgPSBpc0NvbnRlbnRUeXBlSlNPTihoZWFkZXJzKSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogZGF0YTtcbiAgICB9XG4gICAgaW8odXJsLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW8odXJsLCBvcHRpb25zKSB7XG4gICAgeGhyKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgTUVUSE9EX0dFVCxcbiAgICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IG9wdGlvbnMuZGF0YVxuICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3AsIGJvZHkpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHJlc3Auc3RhdHVzQ29kZTtcbiAgICAgICAgdmFyIGVyck1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKCFlcnIgJiYgKHN0YXR1cyA9PT0gMCB8fCAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA2MDApKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVyck1lc3NhZ2UgPSBib2R5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJNZXNzYWdlID0gc3RhdHVzID8gJ0Vycm9yICcgKyBzdGF0dXMgOiAnSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3InO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IoZXJyTWVzc2FnZSk7XG4gICAgICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICAgICAgICAgIGlmICg0MDggPT09IHN0YXR1cyB8fCAwID09PSBzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBlcnIudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3AucmVzcG9uc2VUZXh0ID0gYm9keTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9uLmZhaWx1cmUuY2FsbChudWxsLCBlcnIsIHJlc3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5vbi5zdWNjZXNzLmNhbGwobnVsbCwgbnVsbCwgcmVzcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAY2xhc3MgUkVTVC5IVFRQXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgIFRoZSBjb25maWcgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnRpbWVvdXQ9MzAwMF0gVGltZW91dCAoaW4gbXMpIGZvciBlYWNoIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnJldHJ5ICAgUmV0cnkgY29uZmlnIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yZXRyeS5pbnRlcnZhbD0yMDBdICBUaGUgc3RhcnQgaW50ZXJ2YWwgdW5pdCAoaW4gbXMpLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJldHJ5Lm1heF9yZXRyaWVzPTJdICAgTm1iZXIgb2YgbWF4IHJldHJpZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmNpdG9uLCB3aXRoIHR3byBwYXJhbXMgKGVycm9yLCByZXNwb25zZSlcbiAgICAgKi9cbiAgICBnZXQgOiBmdW5jdGlvbiAodXJsLCBoZWFkZXJzLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGRvWGhyKE1FVEhPRF9HRVQsIHVybCwgaGVhZGVycywgTlVMTCwgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgcHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gIGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICBUaGUgY29uZmlnIG9iamVjdC4gTm8gcmV0cmllcyBmb3IgUFVULlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnRpbWVvdXQ9MzAwMF0gVGltZW91dCAoaW4gbXMpIGZvciBlYWNoIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yZXRyeS5pbnRlcnZhbD0yMDBdICBUaGUgc3RhcnQgaW50ZXJ2YWwgdW5pdCAoaW4gbXMpLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJldHJ5Lm1heF9yZXRyaWVzPTJdICAgTm1iZXIgb2YgbWF4IHJldHJpZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmNpdG9uLCB3aXRoIHR3byBwYXJhbXMgKGVycm9yLCByZXNwb25zZSlcbiAgICAgKi9cbiAgICBwdXQgOiBmdW5jdGlvbiAodXJsLCBoZWFkZXJzLCBkYXRhLCBjb25maWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGRvWGhyKE1FVEhPRF9QVVQsIHVybCwgaGVhZGVycywgZGF0YSwgY29uZmlnLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgcG9zdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9ICBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgVGhlIGNvbmZpZyBvYmplY3QuIE5vIHJldHJpZXMgZm9yIFBPU1QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudGltZW91dD0zMDAwXSBUaW1lb3V0IChpbiBtcykgZm9yIGVhY2ggcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy51bnNhZmVBbGxvd1JldHJ5PWZhbHNlXSBXaGV0aGVyIHRvIGFsbG93IHJldHJ5aW5nIHRoaXMgcG9zdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yZXRyeS5pbnRlcnZhbD0yMDBdICBUaGUgc3RhcnQgaW50ZXJ2YWwgdW5pdCAoaW4gbXMpLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJldHJ5Lm1heF9yZXRyaWVzPTJdICAgTm1iZXIgb2YgbWF4IHJldHJpZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmNpdG9uLCB3aXRoIHR3byBwYXJhbXMgKGVycm9yLCByZXNwb25zZSlcbiAgICAgKi9cbiAgICBwb3N0IDogZnVuY3Rpb24gKHVybCwgaGVhZGVycywgZGF0YSwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgICAgICBkb1hocihNRVRIT0RfUE9TVCwgdXJsLCBoZWFkZXJzLCBkYXRhLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBkZWxldGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICBUaGUgY29uZmlnIG9iamVjdC4gTm8gcmV0cmllcyBmb3IgREVMRVRFLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnRpbWVvdXQ9MzAwMF0gVGltZW91dCAoaW4gbXMpIGZvciBlYWNoIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yZXRyeS5pbnRlcnZhbD0yMDBdICBUaGUgc3RhcnQgaW50ZXJ2YWwgdW5pdCAoaW4gbXMpLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJldHJ5Lm1heF9yZXRyaWVzPTJdICAgTm1iZXIgb2YgbWF4IHJldHJpZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmNpdG9uLCB3aXRoIHR3byBwYXJhbXMgKGVycm9yLCByZXNwb25zZSlcbiAgICAgKi9cbiAgICAnZGVsZXRlJyA6IGZ1bmN0aW9uICh1cmwsIGhlYWRlcnMsIGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICAgICAgZG9YaHIoTUVUSE9EX0RFTEVURSwgdXJsLCBoZWFkZXJzLCBOVUxMLCBjb25maWcsIGNhbGxiYWNrKTtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIilcbnZhciBvbmNlID0gcmVxdWlyZShcIm9uY2VcIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKFwicGFyc2UtaGVhZGVyc1wiKVxuXG5cbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxudmFyIFhEUiA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBYSFIoKSkgPyBYSFIgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcblxuZnVuY3Rpb24gY3JlYXRlWEhSKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBsb2FkRnVuYygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2UgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwidGV4dFwiIHx8ICF4aHIucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCB4aHIucmVzcG9uc2VYTUxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cbiAgICBcbiAgICB2YXIgZmFpbHVyZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAwLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGVycm9yRnVuYyhldnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xuICAgICAgICAgICAgZXZ0ID0gbmV3IEVycm9yKFwiXCIgKyAoZXZ0IHx8IFwidW5rbm93blwiKSApXG4gICAgICAgIH1cbiAgICAgICAgZXZ0LnN0YXR1c0NvZGUgPSAwXG4gICAgICAgIGNhbGxiYWNrKGV2dCwgZmFpbHVyZVJlc3BvbnNlKVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkRnVuYygpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGF0dXMgPSAoeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMpXG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gMCl7XG4gICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIHVybDogdXJpLFxuICAgICAgICAgICAgICAgIHJhd1JlcXVlc3Q6IHhoclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIilcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVyaTogb3B0aW9ucyB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBhcmd1bWVudCBtaXNzaW5nXCIpXG4gICAgfVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWERSKClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWEhSKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlcbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIgdGltZW91dFRpbWVyXG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucykge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJBY2NlcHRcIl0gfHwgKGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIikgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYylcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICBcbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XG4gICAgLy8gYm90aCBucG0ncyByZXF1ZXN0IGFuZCBqcXVlcnkgMS54IHVzZSB0aGlzIGtpbmQgb2YgdGltZW91dCwgc28gdGhpcyBpcyBiZWluZyBjb25zaXN0ZW50XG4gICAgaWYgKCFzeW5jICYmIG9wdGlvbnMudGltZW91dCA+IDAgKSB7XG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIik7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCsyICk7XG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuICAgIFxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmIFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KVxuXG4gICAgcmV0dXJuIHhoclxuXG5cbn1cblxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsImlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7fTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gb25jZVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzXG4gICAgfVxuICAgIFxuICAgIGlmICh0b1N0cmluZy5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2VcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGksIGFycmF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tdLCBrLCBvYmplY3QpXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb25cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChmbikge1xuICB2YXIgc3RyaW5nID0gdG9TdHJpbmcuY2FsbChmbilcbiAgcmV0dXJuIHN0cmluZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fFxuICAgICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiYgc3RyaW5nICE9PSAnW29iamVjdCBSZWdFeHBdJykgfHxcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgLy8gSUU4IGFuZCBiZWxvd1xuICAgICAoZm4gPT09IHdpbmRvdy5zZXRUaW1lb3V0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XG4gICAgICBmbiA9PT0gd2luZG93LmNvbmZpcm0gfHxcbiAgICAgIGZuID09PSB3aW5kb3cucHJvbXB0KSlcbn07XG4iLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG4iLCJ2YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn0iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3JvdXRyLXBsdWdpbicpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIFJvdXRlciA9IHJlcXVpcmUoJ3JvdXRyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcm91dHJQbHVnaW4ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciByb3V0ZXMgPSBvcHRpb25zLnJvdXRlcztcbiAgICAvKipcbiAgICAgKiBAY2xhc3MgUm91dHJQbHVnaW5cbiAgICAgKi9cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnUm91dHJQbHVnaW4nLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHRvIHBsdWcgdGhlIEZsdXhDb250ZXh0XG4gICAgICAgICAqIEBtZXRob2QgcGx1Z0NvbnRleHRcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHBsdWdDb250ZXh0OiBmdW5jdGlvbiBwbHVnQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZXIgPSBuZXcgUm91dGVyKHJvdXRlcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFByb3ZpZGVzIGZ1bGwgYWNjZXNzIHRvIHRoZSByb3V0ZXIgaW4gdGhlIGFjdGlvbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbkNvbnRleHRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwbHVnQWN0aW9uQ29udGV4dDogZnVuY3Rpb24gcGx1Z0FjdGlvbkNvbnRleHQoYWN0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25Db250ZXh0LnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFByb3ZpZGVzIGFjY2VzcyB0byBjcmVhdGUgcGF0aHMgYnkgbmFtZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcGx1Z0NvbXBvbmVudENvbnRleHQ6IGZ1bmN0aW9uIHBsdWdDb21wb25lbnRDb250ZXh0KGNvbXBvbmVudENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Q29udGV4dC5tYWtlUGF0aCA9IHJvdXRlci5tYWtlUGF0aC5iaW5kKHJvdXRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZXRob2QgZ2V0Um91dGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRSb3V0ZXM6IGZ1bmN0aW9uIGdldFJvdXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXM7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcm91dGVyJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG4vKmdsb2JhbCBwcm9jZXNzOnRydWUgKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnUm91dHI6cm91dGVyJyk7XG52YXIgcGF0aFRvUmVnZXhwID0gcmVxdWlyZSgncGF0aC10by1yZWdleHAnKTtcbnZhciByZXZlcmVuZCA9IHJlcXVpcmUoJ3JldmVyZW5kJyk7XG52YXIgTUVUSE9EUyA9IHtcbiAgICBHRVQ6ICdnZXQnXG59O1xuXG4vKipcbiAqIEBjbGFzcyBSb3V0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgIFRoZSBuYW1lIG9mIHRoZSByb3V0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgcm91dGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnBhdGggIFRoZSBwYXRoIG9mIHRoZSByb3V0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSb3V0ZShuYW1lLCBjb25maWcpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMucmVnZXhwID0gcGF0aFRvUmVnZXhwKHRoaXMuY29uZmlnLnBhdGgsIHRoaXMua2V5cyk7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgZ2l2ZW4gbWV0aG9kIGlzIGFjY2VwdGVkIGJ5IHRoaXMgcm91dGUuXG4gKiBAbWV0aG9kIGFjY2VwdE1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAgVGhlIEhUVFAgVkVSQiBzdHJpbmcuXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIG1ldGhvZCBpcyBhY2NlcHRlZDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQGZvciBSb3V0ZVxuICovXG5Sb3V0ZS5wcm90b3R5cGUuYWNjZXB0TWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIC8vVE9ETyBzdXBwb3J0IGFycmF5IGZvciBtZXRob2QsIFsnZ2V0JywgJ3Bvc3QnXVxuICAgIHJldHVybiBtZXRob2QgPT09IHRoaXMuY29uZmlnLm1ldGhvZDtcbn07XG5cbi8qKlxuICogQ2hlY2tlcyB3aGV0aGVyIHRoaXMgcm91dGUgbWF0Y2hlcyB0aGUgZ2l2ZW4gdXJsLCBtZXRob2QgKEdFVCBhcyBkZWZhdWx0KSBhbmQgb3B0aW9uYWwgbmF2aWdhdGlvbiByZWxhdGVkIGNyaXRlcmlhLlxuICogQG1ldGhvZCBtYXRjaFxuICogQHBhcmFtIHtTdHJpbmd9IHVybCAgIFRoZSByZWxhdGl2ZSB1cmwgdG8gYmUgbWF0Y2hlZCB0byB0aGlzIHJvdXRlLiAgUXVlcnkgc3RyaW5ncyBhbmQgaGFzaCBmcmFnbWVudHNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhcmUgKipub3QqKiBjb25zaWRlcmVkIHdoZW4gcGVyZm9ybWluZyB0aGUgbWF0Y2guICBFLmcuIC9zb21lX3BhdGg/Zm9vPWJhciNoYXNoQmF6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd291bGQgbWF0Y2ggdG8gdGhlIHNhbWUgcm91dGUgYXMgL3NvbWVfcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1nZXRdIFRoZSBjYXNlLWluc2Vuc2l0aXZlIEhUVFAgbWV0aG9kIHN0cmluZy4gIERlZmF1bHRzIHRvICdnZXQnLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm5hdmlnYXRlXSBUaGUgbmF2aWdhdGlvbiBpbmZvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm5hdmlnYXRlLnR5cGVdIFRoZSBuYXZpZ2F0aW9uIHR5cGU6ICdwYWdlbG9hZCcsICdjbGljaycsICdwb3BzdGF0ZScuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubmF2aWdhdGUucGFyYW1zXSBUaGUgbmF2aWdhdGlvbiBwYXJhbXMgKHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBwYXRoKS5cbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSBUaGUgbWF0Y2hlZCByb3V0ZSBwYXJhbXMgaWYgcGF0aC9tZXRob2QvbmF2UGFyYW1zIG1hdGNoZXMgdG8gdGhpcyByb3V0ZTsgbnVsbCBvdGhlcndpc2UuXG4gKiBAZm9yIFJvdXRlXG4gKi9cblJvdXRlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgLy8gMS4gY2hlY2sgbWV0aG9kXG4gICAgdmFyIG1ldGhvZCA9IChvcHRpb25zLm1ldGhvZCAmJiBvcHRpb25zLm1ldGhvZC50b0xvd2VyQ2FzZSgpKSB8fCBNRVRIT0RTLkdFVDtcbiAgICBpZiAoIXNlbGYuYWNjZXB0TWV0aG9kKG1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gMi4gY2hlY2sgcGF0aFxuICAgIC8vIHJlbW92ZSBxdWVyeSBzdHJpbmcgYW5kIGhhc2ggZnJhZ21lbnQgZnJvbSB1cmxcbiAgICB2YXIgcG9zID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICB2YXIgcGF0aDtcbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgLy8gcmVtb3ZlIHF1ZXJ5IHN0cmluZ1xuICAgICAgICBwYXRoID0gdXJsLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgLy8gaGFzaCBmcmFnbWVudCBkb2VzIG5vdCBnZXQgc2VudCB0byBzZXJ2ZXIuXG4gICAgICAgICAgICAvLyBCdXQgc2luY2Ugcm91dHIgY2FuIGJlIHVzZWQgb24gYm90aCBzZXJ2ZXIgYW5kIGNsaWVudCxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCByZW1vdmUgaGFzaCBmcmFnbWVudCBiZWZvcmUgbWF0Y2hpbmcgdGhlIHJlZ2V4LlxuICAgICAgICAgICAgcGF0aCA9IHVybC5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSB1cmw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcGF0aE1hdGNoZXMgPSBzZWxmLnJlZ2V4cC5leGVjKHBhdGgpO1xuICAgIGlmICghcGF0aE1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gMy4gY2hlY2sgbmF2UGFyYW1zLCBpZiB0aGlzIHJvdXRlIGhhcyBtYXRjaCByZXF1aXJlbWVudHMgZGVmaW5lZCBmb3IgbmF2UGFyYW1zXG4gICAgdmFyIG5hdlBhcmFtc0NvbmZpZyA9IChzZWxmLmNvbmZpZy5uYXZpZ2F0ZSAmJiBzZWxmLmNvbmZpZy5uYXZpZ2F0ZS5wYXJhbXMpO1xuICAgIGlmIChuYXZQYXJhbXNDb25maWcpIHtcbiAgICAgICAgdmFyIG5hdlBhcmFtQ29uZmlnS2V5cyA9IE9iamVjdC5rZXlzKG5hdlBhcmFtc0NvbmZpZyk7XG4gICAgICAgIHZhciBuYXZQYXJhbXMgPSAob3B0aW9ucy5uYXZpZ2F0ZSAmJiBvcHRpb25zLm5hdmlnYXRlLnBhcmFtcykgfHwge307XG4gICAgICAgIHZhciBuYXZQYXJhbU1hdGNoZWQ7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbmF2UGFyYW1Db25maWdLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBuYXZQYXJhbSBkZWZpbmVkIGluIHRoZSByb3V0ZSBjb25maWcsIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gdGhlIHBhcmFtIHBhc3NlZCBpbiBtYXRjaGVzIHRoZSBkZWZpbmVkIHBhdHRlcm5cbiAgICAgICAgICAgIHZhciBjb25maWdLZXkgPSBuYXZQYXJhbUNvbmZpZ0tleXNbaV07XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IG5hdlBhcmFtc0NvbmZpZ1tjb25maWdLZXldO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBuYXZQYXJhbU1hdGNoZWQgPSBuYXZQYXJhbXNbY29uZmlnS2V5XSAhPT0gdW5kZWZpbmVkICYmIHBhdHRlcm4udGVzdChuYXZQYXJhbXNbY29uZmlnS2V5XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdlBhcmFtTWF0Y2hlZCA9IChuYXZQYXJhbXNbY29uZmlnS2V5XSA9PT0gcGF0dGVybik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hdlBhcmFtTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgbm9uLW1hdGNoaW5nIG5hdlBhcmFtIC0+IHRoaXMgcm91dGUgZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIG1ldGhvZC9wYXRoL25hdlBhcmFtcyBhbGwgbWF0Y2hlZCwgZXh0cmFjdCB0aGUgbWF0Y2hlZCBwYXRoIHBhcmFtc1xuICAgIHZhciByb3V0ZVBhcmFtcyA9IHt9O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHNlbGYua2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByb3V0ZVBhcmFtc1tzZWxmLmtleXNbaV0ubmFtZV0gPSBwYXRoTWF0Y2hlc1tpKzFdO1xuICAgIH1cblxuICAgIHJldHVybiByb3V0ZVBhcmFtcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGF0aCBzdHJpbmcgd2l0aCB0aGlzIHJvdXRlLCB1c2luZyB0aGUgc3BlY2lmaWVkIHBhcmFtcy5cbiAqIEBtZXRob2QgbWFrZVBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgIFRoZSByb3V0ZSBwYXJhbWV0ZXJzIHRvIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBwYXRoIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBUaGUgZ2VuZXJhdGVkIHBhdGggc3RyaW5nLlxuICogQGZvciBSb3V0ZVxuICovXG5Sb3V0ZS5wcm90b3R5cGUubWFrZVBhdGggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJldmVyZW5kKHRoaXMuY29uZmlnLnBhdGgsIHBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnUm91dGUubWFrZVBhdGggZmFpbGVkLCBlID0gJywgZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQSBSb3V0ZXIgY2xhc3MgdGhhdCBwcm92aWRlcyByb3V0ZSBtYXRjaGluZyBhbmQgcm91dGUgZ2VuZXJhdGlvbiBmdW5jdGlvbmFsaXRpZXMuXG4gKiBAY2xhc3MgUm91dGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcm91dGVzICBSb3V0ZSB0YWJsZSwgd2hpY2ggaXMgYSBuYW1lIHRvIHJvdXRlciBjb25maWcgbWFwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXhhbXBsZVxuICAgIHZhciBSb3V0ZXIgPSByZXF1aXJlKCdyb3V0cicpLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIHJvdXRlO1xuXG4gICAgdmFyIHJvdXRlciA9IG5ldyBSb3V0ZXIoe1xuICAgICAgICB2aWV3X3VzZXI6IHtcbiAgICAgICAgICAgIHBhdGg6ICcvdXNlci86aWQnLFxuICAgICAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgICAgIGZvbzoge1xuICAgICAgICAgICAgICAgIGJhcjogJ2JheidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcm91dGUgPSByb3V0ZXIuZ2V0Um91dGUoJy91c2VyL2dhcmZpZWxkJyk7XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBvdXRwdXQ6XG4gICAgICAgIC8vICAgLSBcInZpZXdfdXNlclwiIGZvciByb3V0ZS5uYW1lXG4gICAgICAgIC8vICAgLSBcIi91c2VyL2dhcmZpZWxkXCIgZm9yIHJvdXRlLnVybFxuICAgICAgICAvLyAgIC0ge2lkOiBcImdhcmZpZWxkXCJ9IGZvciByb3V0ZS5wYXJhbXNcbiAgICAgICAgLy8gICAtIHtwYXRoOiBcIi91c2VyLzppZFwiLCBtZXRob2Q6IFwiZ2V0XCIsIGZvbzogeyBiYXI6IFwiYmF6XCJ9fSBmb3Igcm91dGUuY29uZmlnXG4gICAgICAgIGNvbnNvbGUubG9nKCdbUm91dGUgZm91bmRdOiBuYW1lPScsIHJvdXRlLm5hbWUsICd1cmw9Jywgcm91dGUudXJsLCAncGFyYW1zPScsIHJvdXRlLnBhcmFtcywgJ2NvbmZpZz0nLCByb3V0ZS5jb25maWcpO1xuICAgIH1cbiAqL1xuZnVuY3Rpb24gUm91dGVyKHJvdXRlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLl9yb3V0ZXMgPSB7fTtcbiAgICBkZWJ1ZygnbmV3IFJvdXRlciwgcm91dGVzID0gJywgcm91dGVzKTtcbiAgICBpZiAocm91dGVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChmdW5jdGlvbiBjcmVhdGVSb3V0ZShuYW1lKSB7XG4gICAgICAgICAgICBzZWxmLl9yb3V0ZXNbbmFtZV0gPSBuZXcgUm91dGUobmFtZSwgcm91dGVzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5fcm91dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIGZyZWV6ZVJvdXRlKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm91dGUgPSBzZWxmLl9yb3V0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShyb3V0ZS5jb25maWcpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUocm91dGUua2V5cyk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShyb3V0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUoc2VsZi5fcm91dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbWV0aG9kIGdldFJvdXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgVGhlIHVybCB0byBiZSB1c2VkIGZvciByb3V0ZSBtYXRjaGluZy4gIFF1ZXJ5IHN0cmluZ3MgYXJlICoqbm90KiogY29uc2lkZXJlZFxuICogICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHBlcmZvcm1pbmcgdGhlIG1hdGNoLiAgRS5nLiAvc29tZV9wYXRoP2Zvbz1iYXIgd291bGQgbWF0Y2ggdG8gdGhlIHNhbWUgcm91dGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgYXMgL3NvbWVfcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1nZXRdIFRoZSBjYXNlLWluc2Vuc2l0aXZlIEhUVFAgbWV0aG9kIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5uYXZpZ2F0ZV0gVGhlIG5hdmlnYXRpb24gaW5mby5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5uYXZpZ2F0ZS50eXBlXSBUaGUgbmF2aWdhdGlvbiB0eXBlOiAncGFnZWxvYWQnLCAnY2xpY2snLCAncG9wc3RhdGUnLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm5hdmlnYXRlLnBhcmFtc10gVGhlIG5hdmlnYXRpb24gcGFyYW1zICh0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgcGF0aCkuXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gVGhlIG1hdGNoZWQgcm91dGUgaW5mbyBpZiBwYXRoL21ldGhvZC9uYXZpZ2F0ZS5wYXJhbXMgbWF0Y2hlcyB0byBhIHJvdXRlOyBudWxsIG90aGVyd2lzZS5cbiAqL1xuUm91dGVyLnByb3RvdHlwZS5nZXRSb3V0ZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3JvdXRlcyk7XG4gICAgdmFyIHJvdXRlO1xuICAgIHZhciBtYXRjaDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJvdXRlID0gdGhpcy5fcm91dGVzW2tleXNbaV1dO1xuICAgICAgICBtYXRjaCA9IHJvdXRlLm1hdGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBrZXlzW2ldLFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHBhcmFtczogbWF0Y2gsXG4gICAgICAgICAgICAgICAgY29uZmlnOiByb3V0ZS5jb25maWcsXG4gICAgICAgICAgICAgICAgbmF2aWdhdGU6IG9wdGlvbnMgJiYgb3B0aW9ucy5uYXZpZ2F0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGF0aCBzdHJpbmcgd2l0aCB0aGUgcm91dGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBwYXJhbXMuXG4gKiBAbWV0aG9kIG1ha2VQYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgVGhlIHJvdXRlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgIFRoZSByb3V0ZSBwYXJhbWV0ZXJzIHRvIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBwYXRoIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBUaGUgZ2VuZXJhdGVkIHBhdGggc3RyaW5nLCBudWxsIGlmIHRoZXJlIGlzIG5vIHJvdXRlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKi9cblJvdXRlci5wcm90b3R5cGUubWFrZVBhdGggPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIChuYW1lICYmIHRoaXMuX3JvdXRlc1tuYW1lXSAmJiB0aGlzLl9yb3V0ZXNbbmFtZV0ubWFrZVBhdGgocGFyYW1zKSkgfHwgbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUm91dGVyOyIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIl1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkXVxuICAnKFtcXFxcLy5dKT8oPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXildKSopXFxcXCkpKFsrKj9dKT8nLFxuICAvLyBNYXRjaCByZWdleHAgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIGFsd2F5cyBlc2NhcGVkLlxuICAnKFsuKyo/PV4hOiR7fSgpW1xcXFxdfFxcXFwvXSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBncm91cFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpO1xufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7UmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSc7XG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAge1JlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICAgICAgaSxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogIGZhbHNlLFxuICAgICAgICByZXBlYXQ6ICAgIGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cyk7XG59XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgc3BlY2lmaWMgdGFncyB3aXRoIHJlZ2V4cCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VQYXRoIChwYXRoLCBrZXlzKSB7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSAoXywgZXNjYXBlZCwgcHJlZml4LCBrZXksIGNhcHR1cmUsIGdyb3VwLCBzdWZmaXgsIGVzY2FwZSkge1xuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG5cbiAgICBpZiAoZXNjYXBlKSB7XG4gICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlO1xuICAgIH1cblxuICAgIHZhciByZXBlYXQgICA9IHN1ZmZpeCA9PT0gJysnIHx8IHN1ZmZpeCA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IHN1ZmZpeCA9PT0gJz8nIHx8IHN1ZmZpeCA9PT0gJyonO1xuXG4gICAga2V5cy5wdXNoKHtcbiAgICAgIG5hbWU6ICAgICAga2V5IHx8IGluZGV4KyssXG4gICAgICBkZWxpbWl0ZXI6IHByZWZpeCB8fCAnLycsXG4gICAgICBvcHRpb25hbDogIG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiAgICByZXBlYXRcbiAgICB9KTtcblxuICAgIHByZWZpeCA9IHByZWZpeCA/ICgnXFxcXCcgKyBwcmVmaXgpIDogJyc7XG4gICAgY2FwdHVyZSA9IGVzY2FwZUdyb3VwKGNhcHR1cmUgfHwgZ3JvdXAgfHwgJ1teJyArIChwcmVmaXggfHwgJ1xcXFwvJykgKyAnXSs/Jyk7XG5cbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICBjYXB0dXJlID0gY2FwdHVyZSArICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgcGFyYW1ldGVyIHN1cHBvcnQuXG4gICAgcmV0dXJuIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gIH1cblxuICByZXR1cm4gcGF0aC5yZXBsYWNlKFBBVEhfUkVHRVhQLCByZXBsYWNlKTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhTdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgICAgICAgICBba2V5c11cbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgICAgW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBrZXlzID0ga2V5cyB8fCBbXTtcblxuICBpZiAoIWlzQXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0ga2V5cztcbiAgICBrZXlzID0gW107XG4gIH0gZWxzZSBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9IHJlcGxhY2VQYXRoKHBhdGgsIGtleXMpO1xuICB2YXIgZW5kc1dpdGhTbGFzaCA9IHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJztcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhTbGFzaCA/IHJvdXRlLnNsaWNlKDAsIC0yKSA6IHJvdXRlKSArICcoPzpcXFxcLyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoU2xhc2ggPyAnJyA6ICcoPz1cXFxcL3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyrilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAqXFxcbiDilIIgIENvcHlyaWdodCAoQykgMjAxNCBlQmF5IFNvZnR3YXJlIEZvdW5kYXRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4g4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuIOKUgiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgICAgICAgICAgIOKUglxuIOKUgiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiAgICAgICAgICDilIJcbiDilIIgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4g4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuIOKUgiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcbiDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG4g4pSCICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlICAgICAgIOKUglxuIOKUgiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCAgICAgICAgIOKUglxuIOKUgiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICDilIJcbiDilIIgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgICAgICAg4pSCXG4g4pSCICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuIFxcKuKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCovXG4gLy8gUmVnRXhwIHBhdHRlcm5zIHVzZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9wYXRoLXRvLXJlZ2V4cCAoTUlUKVxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGF0aDJyZWdleCA9IHJlcXVpcmUoJ3BhdGgtdG8tcmVnZXhwJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXZlcmVuZChyb3V0ZSwgb2JqKSB7XG4gICAgdmFyIGtleXMsIHBhdGgsIHJvdXRlUmVnZXg7XG5cbiAgICAvLyBTdXBwb3J0IGByb3V0ZWAgYmVpbmcgYW4gYXJyYXkgKHdoaWNoIHBhdGgtdG8tcmVnZXhwIHN1cHBvcnRzKSwgYW5kXG4gICAgLy8gcHJlZmVyIHRoZSBmaXJzdCBpdGVtIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYmVzdC1maXQgVVJMLlxuICAgIGlmIChBcnJheS5pc0FycmF5KHJvdXRlKSkge1xuICAgICAgICByb3V0ZSA9IHJvdXRlWzBdO1xuICAgIH1cblxuICAgIC8vIFJlc3RyaWN0IGByb3V0ZWAgdG8gU3RyaW5ncyBzaW5jZSBhIFJlZ0V4cCByb3V0ZSBjYW4ndCBiZSB1c2VkIHRvXG4gICAgLy8gZ2VuZXJhdGUgYSBwYXRoIChwYXRoLXRvLXJlZ2V4cCBzdXBwb3J0cyBSZWdFeHAgcm91dGUgcGF0aHMpLlxuICAgIGlmICh0eXBlb2Ygcm91dGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JvdXRlIG11c3QgYmUgYSBTdHJpbmcgcGF0aCcpO1xuICAgIH1cblxuICAgIGtleXMgPSBbXTtcbiAgICBwYXRoID0gcm91dGU7XG4gICAgcm91dGVSZWdleCA9IHBhdGgycmVnZXgocm91dGUsIGtleXMpO1xuXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlLCByZWdleDtcblxuICAgICAgICB2YWx1ZSA9IG9ialtrZXkubmFtZV07XG5cbiAgICAgICAgLy8gRW5mb3JjZSByZXF1aXJlZCBrZXlzIGhhdmluZyBhIHZhbHVlLlxuICAgICAgICBpZiAoIWtleS5vcHRpb25hbCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQSB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkIGZvcjogJyArIGtleS5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhdHRlcm4gdXNlZCBpbiBib3RoIHVubmFtZWQgKGUuZy4sIFwiL3Bvc3RzLyguKilcIikgYW5kIGN1c3RvbSBtYXRjaFxuICAgICAgICAvLyBwYXJhbWV0ZXJzIChlLmcuLCBcIi9wb3N0cy86aWQoXFxcXGQrKVwiKS5cbiAgICAgICAgcmVnZXggPSAnXFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSc7XG5cbiAgICAgICAgLy8gQSBrZXkncyBgbmFtZWAgd2lsbCBiZSBhIFN0cmluZyBmb3IgbmFtZWQgcGFyYW1ldGVycywgYW5kIGEgTnVtYmVyXG4gICAgICAgIC8vIGZvciB1bm5hbWVkIHBhcmFtZXRlcnMuIFRoaXMgcHJlZml4ZXMgdGhlIGJhc2UgcmVnZXhwIHBhdHRlcm4gd2l0aFxuICAgICAgICAvLyB0aGUgbmFtZSwgYW5kIG1ha2VzIHRoZSBjdXN0b20tbWF0Y2hpbmcgcGFydCBvcHRpb25hbCAod2hpY2ggZm9sbG93c1xuICAgICAgICAvLyB3aGF0IHBhdGgtdG8tcmVnZXhwIGRvZXMuKVxuICAgICAgICBpZiAodHlwZW9mIGtleS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVnZXggPSAnXFxcXDonICsga2V5Lm5hbWUgKyAnKD86JyArIHJlZ2V4ICsgJyk/JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBzdWZmaXggcGF0dGVybi5cbiAgICAgICAgcmVnZXggKz0gJyhbKyo/XSk/JztcblxuICAgICAgICBpZiAoa2V5Lm9wdGlvbmFsICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5vIHZhbHVlIHNvIHJlbW92ZSBwb3RlbnRpYWwgdHJhaWxpbmcgJy8nXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgcGF0aCBzZWdtZW50IGlzIG9wdGlvbmFsLlxuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIHJlZ2V4ICs9ICdcXFxcLz8nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAocmVnZXgpLCB2YWx1ZSk7XG4gICAgfSk7XG5cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYHBhdGhgIHByb2R1Y2VkIHdpbGwgYWN0dWFsbHkgYmUgbWF0Y2hlZCBieSB0aGUgYHJvdXRlYC5cbiAgICBpZiAoIXJvdXRlUmVnZXgudGVzdChwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCInICsgcGF0aCArICdcIiB3aWxsIG5vdCBtYXRjaDogXCInICsgcm91dGUgKyAnXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbn07XG4iLCIvKipcbiAqIEV4cG9zZSBgcGF0aHRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRodG9SZWdleHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggYWxyZWFkeSBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgaW5jb3JyZWN0bHkgYXBwZWFyXG4gIC8vIGluIGZ1dHVyZSBtYXRjaGVzLiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXRcbiAgLy8gc2hvdWxkbid0IGJlIHRyYW5zZm9ybWVkLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWRdXG4gICcoW1xcXFwvLl0pPyg/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W14pXSkqKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteKV0pKilcXFxcKSkoWysqP10pPycsXG4gIC8vIE1hdGNoIHJlZ2V4cCBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYWx3YXlzIGJlIGVzY2FwZWQuXG4gICcoWy4rKj89XiE6JHt9KClbXFxcXF18XFxcXC9dKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJyk7XG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHtSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gIGtleXNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xudmFyIGF0dGFjaEtleXMgPSBmdW5jdGlvbiAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG5cbiAgcmV0dXJuIHJlO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgc2hvdWxkIGJlIHBhc3NlZCBpbiwgd2hpY2ggd2lsbCBjb250YWluIHRoZSBwbGFjZWhvbGRlciBrZXlcbiAqIG5hbWVzLiBGb3IgZXhhbXBsZSBgL3VzZXIvOmlkYCB3aWxsIHRoZW4gY29udGFpbiBgW1wiaWRcIl1gLlxuICpcbiAqIEBwYXJhbSAgeyhTdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgICAgICAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aHRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmIChrZXlzICYmICFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IGtleXM7XG4gICAga2V5cyA9IG51bGw7XG4gIH1cblxuICBrZXlzID0ga2V5cyB8fCBbXTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgZmxhZ3MgPSBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gTWF0Y2ggYWxsIGNhcHR1cmluZyBncm91cHMgb2YgYSByZWdleHAuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpIHx8IFtdO1xuXG4gICAgLy8gTWFwIGFsbCB0aGUgbWF0Y2hlcyB0byB0aGVpciBudW1lcmljIGtleXMgYW5kIHB1c2ggaW50byB0aGUga2V5cy5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgZ3JvdXBzLm1hcChmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAgICAgIGluZGV4LFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiAgZmFsc2UsXG4gICAgICAgIHJlcGVhdDogICAgZmFsc2VcbiAgICAgIH07XG4gICAgfSkpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBzb3VyY2UgYmFjayB0byB0aGUgdXNlci5cbiAgICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgLy8gTWFwIGFycmF5IHBhcnRzIGludG8gcmVnZXhwcyBhbmQgcmV0dXJuIHRoZWlyIHNvdXJjZS4gV2UgYWxzbyBwYXNzXG4gICAgLy8gdGhlIHNhbWUga2V5cyBhbmQgb3B0aW9ucyBpbnN0YW5jZSBpbnRvIGV2ZXJ5IGdlbmVyYXRpb24gdG8gZ2V0XG4gICAgLy8gY29uc2lzdGVudCBtYXRjaGluZyBncm91cHMgYmVmb3JlIHdlIGpvaW4gdGhlIHNvdXJjZXMgdG9nZXRoZXIuXG4gICAgcGF0aCA9IHBhdGgubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhdGh0b1JlZ2V4cCh2YWx1ZSwga2V5cywgb3B0aW9ucykuc291cmNlO1xuICAgIH0pO1xuXG4gICAgLy8gR2VuZXJhdGUgYSBuZXcgcmVnZXhwIGluc3RhbmNlIGJ5IGpvaW5pbmcgYWxsIHRoZSBwYXJ0cyB0b2dldGhlci5cbiAgICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCcoPzonICsgcGF0aC5qb2luKCd8JykgKyAnKScsIGZsYWdzKSwga2V5cyk7XG4gIH1cblxuICAvLyBBbHRlciB0aGUgcGF0aCBzdHJpbmcgaW50byBhIHVzYWJsZSByZWdleHAuXG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoUEFUSF9SRUdFWFAsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgcHJlZml4LCBrZXksIGNhcHR1cmUsIGdyb3VwLCBzdWZmaXgsIGVzY2FwZSkge1xuICAgIC8vIEF2b2lkaW5nIHJlLWVzY2FwaW5nIGVzY2FwZWQgY2hhcmFjdGVycy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuXG4gICAgLy8gRXNjYXBlIHJlZ2V4cCBzcGVjaWFsIGNoYXJhY3RlcnMuXG4gICAgaWYgKGVzY2FwZSkge1xuICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVwZWF0ICAgPSBzdWZmaXggPT09ICcrJyB8fCBzdWZmaXggPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBzdWZmaXggPT09ICc/JyB8fCBzdWZmaXggPT09ICcqJztcblxuICAgIGtleXMucHVzaCh7XG4gICAgICBuYW1lOiAgICAgIGtleSB8fCBpbmRleCsrLFxuICAgICAgZGVsaW1pdGVyOiBwcmVmaXggfHwgJy8nLFxuICAgICAgb3B0aW9uYWw6ICBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogICAgcmVwZWF0XG4gICAgfSk7XG5cbiAgICAvLyBFc2NhcGUgdGhlIHByZWZpeCBjaGFyYWN0ZXIuXG4gICAgcHJlZml4ID0gcHJlZml4ID8gJ1xcXFwnICsgcHJlZml4IDogJyc7XG5cbiAgICAvLyBNYXRjaCB1c2luZyB0aGUgY3VzdG9tIGNhcHR1cmluZyBncm91cCwgb3IgZmFsbGJhY2sgdG8gY2FwdHVyaW5nXG4gICAgLy8gZXZlcnl0aGluZyB1cCB0byB0aGUgbmV4dCBzbGFzaCAob3IgbmV4dCBwZXJpb2QgaWYgdGhlIHBhcmFtIHdhc1xuICAgIC8vIHByZWZpeGVkIHdpdGggYSBwZXJpb2QpLlxuICAgIGNhcHR1cmUgPSBlc2NhcGVHcm91cChjYXB0dXJlIHx8IGdyb3VwIHx8ICdbXicgKyAocHJlZml4IHx8ICdcXFxcLycpICsgJ10rPycpO1xuXG4gICAgLy8gQWxsb3cgcGFyYW1ldGVycyB0byBiZSByZXBlYXRlZCBtb3JlIHRoYW4gb25jZS5cbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICBjYXB0dXJlID0gY2FwdHVyZSArICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgYSBwYXJhbWV0ZXIgdG8gYmUgb3B0aW9uYWwuXG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgcGFyYW1ldGVyIHN1cHBvcnQuXG4gICAgcmV0dXJuIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gIH0pO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgdGhlIHBhdGggZW5kcyBpbiBhIHNsYXNoIGFzIGl0IGFsdGVycyBzb21lIG1hdGNoIGJlaGF2aW91ci5cbiAgdmFyIGVuZHNXaXRoU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJztcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYW4gb3B0aW9uYWwgdHJhaWxpbmcgc2xhc2ggaW4gdGhlIG1hdGNoLiBJZlxuICAvLyB0aGUgcGF0aCB0byBtYXRjaCBhbHJlYWR5IGVuZGVkIHdpdGggYSBzbGFzaCwgd2UgbmVlZCB0byByZW1vdmUgaXQgZm9yXG4gIC8vIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2ggaXMgb25seSB2YWxpZCBhdCB0aGUgdmVyeSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3RcbiAgLy8gYW55d2hlcmUgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIG5vbi1lbmRpbmcgbW9kZSwgb3RoZXJ3aXNlXG4gIC8vIFwiL3Rlc3QvXCIgd2lsbCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHBhdGggPSAoZW5kc1dpdGhTbGFzaCA/IHBhdGguc2xpY2UoMCwgLTIpIDogcGF0aCkgKyAnKD86XFxcXC8oPz0kKSk/JztcbiAgfVxuXG4gIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCBwcm9tcHQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaFxuICAvLyBhcyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCBmb3IgdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgaWYgKCFlbmQpIHtcbiAgICBwYXRoICs9IHN0cmljdCAmJiBlbmRzV2l0aFNsYXNoID8gJycgOiAnKD89XFxcXC98JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyBwYXRoICsgKGVuZCA/ICckJyA6ICcnKSwgZmxhZ3MpLCBrZXlzKTtcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL0ZsdXhpYmxlJyk7XG5tb2R1bGUuZXhwb3J0cy5NaXhpbiA9IHJlcXVpcmUoJy4vbWl4aW5zL0ZsdXhpYmxlTWl4aW4nKTtcbm1vZHVsZS5leHBvcnRzLkZsdXhpYmxlTWl4aW4gPSBtb2R1bGUuZXhwb3J0cy5NaXhpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnRmx1eGlibGUnKTtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgRmx1eGlibGVDb250ZXh0ID0gcmVxdWlyZSgnLi9GbHV4aWJsZUNvbnRleHQnKTtcbnZhciBkaXNwYXRjaGVyQ2xhc3NGYWN0b3J5ID0gcmVxdWlyZSgnZGlzcGF0Y2hyJyk7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBzdHJ1Y3R1cmVkIHdheSBvZiByZWdpc3RlcmluZyBhbiBhcHBsaWNhdGlvbidzIGNvbmZpZ3VyYXRpb24gYW5kXG4gKiByZXNvdXJjZXMuXG4gKiBAY2xhc3MgRmx1eGlibGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hcHBDb21wb25lbnRdIFRoZSByb290IGFwcGxpY2F0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhQcmVmaXhdIFRoZSBwYXRoIHVzZWQgZm9yIGFwcGxpY2F0aW9uIGNhbGxzXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgICB2YXIgYXBwID0gbmV3IEZsdXhpYmxlKHtcbiAqICAgICAgICAgIGFwcENvbXBvbmVudDogcmVxdWlyZSgnLi9jb21wb25lbnRzL0FwcC5qc3gnKSxcbiAqICAgICAgICAgIHBsdWdpbnM6IFtcbiAqICAgICAgICAgICAgICByZXF1aXJlKCcuL3BsdWdpbnMvRm9vJylcbiAqICAgICAgICAgIF1cbiAqICAgICAgfSk7XG4gKi9cbmZ1bmN0aW9uIEZsdXhpYmxlKG9wdGlvbnMpIHtcbiAgICBkZWJ1ZygnRmx1eGlibGUgaW5zdGFuY2UgaW5zdGFudGlhdGVkJywgb3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBPcHRpb25zXG4gICAgdGhpcy5fYXBwQ29tcG9uZW50ID0gb3B0aW9ucy5hcHBDb21wb25lbnQ7XG4gICAgdGhpcy5fcGx1Z2lucyA9IFtdO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkZXBlbmRlbmNpZXNcbiAgICB0aGlzLl9kaXNwYXRjaGVyQ2xhc3MgPSBkaXNwYXRjaGVyQ2xhc3NGYWN0b3J5KCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpc29sYXRlZCBjb250ZXh0IGZvciBhIHJlcXVlc3Qvc2Vzc2lvblxuICogQG1ldGhvZCBjcmVhdGVDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7Rmx1eGlibGVDb250ZXh0fVxuICovXG5GbHV4aWJsZS5wcm90b3R5cGUuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmFwcCA9IHNlbGY7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgRmx1eGlibGVDb250ZXh0KG9wdGlvbnMpO1xuXG4gICAgLy8gUGx1ZyBjb250ZXh0IHdpdGggYXBwIHBsdWdpbnMgdGhhdCBpbXBsZW1lbnQgcGx1Z0NvbnRleHQgbWV0aG9kXG4gICAgdGhpcy5fcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIGVhY2hQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGlmIChwbHVnaW4ucGx1Z0NvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0UGx1Z2luID0gcGx1Z2luLnBsdWdDb250ZXh0KG9wdGlvbnMsIGNvbnRleHQsIHNlbGYpO1xuICAgICAgICAgICAgY29udGV4dFBsdWdpbi5uYW1lID0gY29udGV4dFBsdWdpbi5uYW1lIHx8IHBsdWdpbi5uYW1lO1xuICAgICAgICAgICAgY29udGV4dC5wbHVnKGNvbnRleHRQbHVnaW4pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBkaXNwYXRjaGVyIGluc3RhbmNlIHVzaW5nIHRoZSBhcHBsaWNhdGlvbidzIGRpc3BhdGNociBjbGFzcy4gVXNlZCBieVxuICogRmx1eGlibGVDb250ZXh0IHRvIGNyZWF0ZSBuZXcgZGlzcGF0Y2hlciBpbnN0YW5jZVxuICogQG1ldGhvZCBjcmVhdGVEaXNwYXRjaGVySW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBjb250ZXh0IG9iamVjdCB0byBiZSBwcm92aWRlZCB0byBlYWNoIHN0b3JlIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7RGlzcGF0Y2hlcn1cbiAqL1xuRmx1eGlibGUucHJvdG90eXBlLmNyZWF0ZURpc3BhdGNoZXJJbnN0YW5jZSA9IGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoZXJJbnN0YW5jZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyAodGhpcy5fZGlzcGF0Y2hlckNsYXNzKShjb250ZXh0KTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgcGx1Z2luIG1lY2hhbmlzbSBmb3IgYWRkaW5nIGFwcGxpY2F0aW9uIGxldmVsIHNldHRpbmdzIHRoYXQgYXJlIHBlcnNpc3RlZFxuICogYmV0d2VlbiBzZXJ2ZXIvY2xpZW50IGFuZCBhbHNvIG1vZGlmaWNhdGlvbiBvZiB0aGUgRmx1eGlibGVDb250ZXh0XG4gKiBAbWV0aG9kIHBsdWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW4ubmFtZSBOYW1lIG9mIHRoZSBwbHVnaW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbi5wbHVnQ29udGV4dCBNZXRob2QgY2FsbGVkIGFmdGVyIGNvbnRleHQgaXMgY3JlYXRlZCB0byBhbGxvd1xuICogIGR5bmFtaWNhbGx5IHBsdWdnaW5nIHRoZSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbi5kZWh5ZHJhdGVdIE1ldGhvZCBjYWxsZWQgdG8gc2VyaWFsaXplIHRoZSBwbHVnaW4gc2V0dGluZ3MgdG8gYmUgcGVyc2lzdGVkXG4gKiAgdG8gdGhlIGNsaWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtwbHVnaW4ucmVoeWRyYXRlXSBNZXRob2QgY2FsbGVkIHRvIHJlaHlkcmF0ZSB0aGUgcGx1Z2luIHNldHRpbmdzIGZyb20gdGhlIHNlcnZlclxuICovXG5GbHV4aWJsZS5wcm90b3R5cGUucGx1ZyA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBpZiAoIXBsdWdpbi5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXBwbGljYXRpb24gcGx1Z2luIG11c3QgaGF2ZSBhIG5hbWUnKTtcbiAgICB9XG4gICAgdGhpcy5fcGx1Z2lucy5wdXNoKHBsdWdpbik7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBhIHBsdWdpbiBpbnN0YW5jZSBieSBuYW1lXG4gKiBAbWV0aG9kIGdldFBsdWdpblxuICogQHBhcmFtIHtTdHJpbmd9IHBsdWdpbk5hbWUgVGhlIHBsdWdpbiBuYW1lXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5GbHV4aWJsZS5wcm90b3R5cGUuZ2V0UGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbk5hbWUpIHtcbiAgICB2YXIgcGx1Z2luID0gbnVsbDtcbiAgICB0aGlzLl9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgaWYgKHBsdWdpbk5hbWUgPT09IHAubmFtZSkge1xuICAgICAgICAgICAgcGx1Z2luID0gcDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwbHVnaW47XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgdGhlIHRvcCBsZXZlbCByZWFjdCBjb21wb25lbnQgZm9yIHRoZSBhcHBsaWNhdGlvblxuICogQG1ldGhvZCBnZXRBcHBDb21wb25lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbkZsdXhpYmxlLnByb3RvdHlwZS5nZXRBcHBDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRBcHBDb21wb25lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FwcENvbXBvbmVudDtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgc3RvcmUgdG8gdGhlIGRpc3BhdGNoZXIgc28gaXQgY2FuIGxpc3RlbiBmb3IgYWN0aW9uc1xuICogQG1ldGhvZCByZWdpc3RlclN0b3JlXG4gKi9cbkZsdXhpYmxlLnByb3RvdHlwZS5yZWdpc3RlclN0b3JlID0gZnVuY3Rpb24gcmVnaXN0ZXJTdG9yZSgpIHtcbiAgICBkZWJ1Zyhhcmd1bWVudHNbMF0uc3RvcmVOYW1lICsgJyBzdG9yZSByZWdpc3RlcmVkJyk7XG4gICAgdGhpcy5fZGlzcGF0Y2hlckNsYXNzLnJlZ2lzdGVyU3RvcmUuYXBwbHkodGhpcy5fZGlzcGF0Y2hlckNsYXNzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VyaWFsaXphYmxlIHN0YXRlIG9mIHRoZSBhcHBsaWNhdGlvbiBhbmQgYSBnaXZlbiBjb250ZXh0IGZvciBzZW5kaW5nIHRvIHRoZSBjbGllbnRcbiAqIEBtZXRob2QgZGVoeWRyYXRlXG4gKiBAcGFyYW0ge0ZsdXhpYmxlQ29udGV4dH0gY29udGV4dFxuICogQHJldHVybnMge09iamVjdH0gRGVoeWRyYXRlZCBzdGF0ZSBvYmplY3RcbiAqL1xuRmx1eGlibGUucHJvdG90eXBlLmRlaHlkcmF0ZSA9IGZ1bmN0aW9uIGRlaHlkcmF0ZShjb250ZXh0KSB7XG4gICAgZGVidWcoJ2RlaHlkcmF0ZScsIGNvbnRleHQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQuZGVoeWRyYXRlKCksXG4gICAgICAgIHBsdWdpbnM6IHt9XG4gICAgfTtcblxuICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgcGx1Z2luLmRlaHlkcmF0ZSkge1xuICAgICAgICAgICAgLy8gVXNlIGEgbmFtZXNwYWNlIGZvciBzdG9yaW5nIHBsdWdpbiBzdGF0ZSBhbmQgcHJvdmlkZSBhY2Nlc3MgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICBzdGF0ZS5wbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbi5kZWh5ZHJhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzdGF0ZTtcbn07XG5cbi8qKlxuICogUmVoeWRyYXRlcyB0aGUgYXBwbGljYXRpb24gYW5kIGNyZWF0ZXMgYSBuZXcgY29udGV4dCB3aXRoIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBtZXRob2QgcmVoeWRyYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFJhdyBvYmplY3Qgb2YgZGVoeWRyYXRlZCBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iai5wbHVnaW5zIERlaHlkcmF0ZWQgYXBwIHBsdWdpbiBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iai5jb250ZXh0IERlaHlkcmF0ZWQgY29udGV4dCBzdGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhc3luYyBSZWh5ZHJhdGlvbiBtYXkgcmVxdWlyZSBtb3JlIGFzc2V0IGxvYWRpbmcgb3IgYXN5bmMgSU8gY2FsbHNcbiAqL1xuRmx1eGlibGUucHJvdG90eXBlLnJlaHlkcmF0ZSA9IGZ1bmN0aW9uIHJlaHlkcmF0ZShvYmosIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ3JlaHlkcmF0ZScsIG9iaik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9iai5wbHVnaW5zID0gb2JqLnBsdWdpbnMgfHwge307XG4gICAgdmFyIHBsdWdpblRhc2tzID0gdGhpcy5fcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHBsdWdpbi5yZWh5ZHJhdGU7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhc3luY0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoMiA9PT0gcGx1Z2luLnJlaHlkcmF0ZS5sZW5ndGgpIHsgLy8gQXN5bmMgcGx1Z2luXG4gICAgICAgICAgICAgICAgcGx1Z2luLnJlaHlkcmF0ZShvYmoucGx1Z2luc1twbHVnaW4ubmFtZV0sIGFzeW5jQ2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gU3luYyBwbHVnaW5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ucmVoeWRyYXRlKG9iai5wbHVnaW5zW3BsdWdpbi5uYW1lXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBhc3luY0NhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGFzeW5jLnBhcmFsbGVsKHBsdWdpblRhc2tzLCBmdW5jdGlvbiByZWh5ZHJhdGVQbHVnaW5UYXNrcyhlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dCA9IHNlbGYuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgICBjb250ZXh0LnJlaHlkcmF0ZShvYmouY29udGV4dCk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRleHQpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbHV4aWJsZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnRmx1eGlibGU6Q29udGV4dCcpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnJlcXVpcmUoJ3NldGltbWVkaWF0ZScpO1xuXG4vKipcbiAqIEEgcmVxdWVzdCBvciBicm93c2VyLXNlc3Npb24gY29udGV4dFxuICogQGNsYXNzIEZsdXhpYmxlQ29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Rmx1eGlibGV9IG9wdGlvbnMuYXBwIFRoZSBGbHV4aWJsZSBpbnN0YW5jZSB1c2VkIHRvIGNyZWF0ZSB0aGUgY29udGV4dFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZsdXhDb250ZXh0KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIE9wdGlvbnNcbiAgICB0aGlzLl9hcHAgPSBvcHRpb25zLmFwcDtcblxuICAgIC8vIFRvIGJlIGNyZWF0ZWQgb24gZGVtYW5kXG4gICAgdGhpcy5fZGlzcGF0Y2hlciA9IG51bGw7XG5cbiAgICAvLyBQbHVnaW5zXG4gICAgdGhpcy5fcGx1Z2lucyA9IFtdO1xuXG4gICAgLy8gU2V0IHVwIGNvbnRleHRzXG4gICAgdGhpcy5fYWN0aW9uQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fY29tcG9uZW50Q29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fc3RvcmVDb250ZXh0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBhcHAgbGV2ZWwgY29tcG9uZW50IHdpdGggZ2l2ZW4gcHJvcHMgYW5kIGEgcHJvcGVyIGNvbXBvbmVudFxuICogY29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHJldHVybiB7UmVhY3RFbGVtZW50fVxuICovXG5GbHV4Q29udGV4dC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQocHJvcHMpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fYXBwLmdldEFwcENvbXBvbmVudCgpO1xuICAgIGlmICghQ29tcG9uZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gYXBwQ29tcG9uZW50IHdhcyBub3Qgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9uZW50KG9iamVjdEFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgY29udGV4dDogdGhpcy5nZXRDb21wb25lbnRDb250ZXh0KClcbiAgICB9KSk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIHBsdWdpbiBtZWNoYW5pc20gZm9yIGFkZGluZyBhcHBsaWNhdGlvbiBsZXZlbCBzZXR0aW5ncyB0aGF0IGFyZSBwZXJzaXN0ZWRcbiAqIGJldHdlZW4gc2VydmVyL2NsaWVudCBhbmQgYWxzbyBtb2RpZmljYXRpb24gb2YgdGhlIEZsdXhpYmxlQ29udGV4dFxuICogQG1ldGhvZCBwbHVnXG4gKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luXG4gKiBAcGFyYW0ge1N0cmluZ30gcGx1Z2luLm5hbWUgTmFtZSBvZiB0aGUgcGx1Z2luXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGx1Z2luLnBsdWdBY3Rpb25Db250ZXh0XSBNZXRob2QgY2FsbGVkIGFmdGVyIGFjdGlvbiBjb250ZXh0IGlzIGNyZWF0ZWQgdG8gYWxsb3dcbiAqICBkeW5hbWljYWxseSBtb2RpZnlpbmcgdGhlIGFjdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGx1Z2luLnBsdWdDb21wb25lbnRDb250ZXh0XSBNZXRob2QgY2FsbGVkIGFmdGVyIGNvbXBvbmVudCBjb250ZXh0IGlzIGNyZWF0ZWQgdG9cbiAqICBhbGxvdyBkeW5hbWljYWxseSBtb2RpZnlpbmcgdGhlIGNvbXBvbmVudCBjb250ZXh0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGx1Z2luLnBsdWdTdG9yZUNvbnRleHRdIE1ldGhvZCBjYWxsZWQgYWZ0ZXIgc3RvcmUgY29udGV4dCBpcyBjcmVhdGVkIHRvIGFsbG93XG4gKiAgZHluYW1pY2FsbHkgbW9kaWZ5aW5nIHRoZSBzdG9yZSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbi5kZWh5ZHJhdGVdIE1ldGhvZCBjYWxsZWQgdG8gc2VyaWFsaXplIHRoZSBwbHVnaW4gc2V0dGluZ3MgdG8gYmUgcGVyc2lzdGVkXG4gKiAgdG8gdGhlIGNsaWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtwbHVnaW4ucmVoeWRyYXRlXSBNZXRob2QgY2FsbGVkIHRvIHJlaHlkcmF0ZSB0aGUgcGx1Z2luIHNldHRpbmdzIGZyb20gdGhlIHNlcnZlclxuICovXG5GbHV4Q29udGV4dC5wcm90b3R5cGUucGx1ZyA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBpZiAoIXBsdWdpbi5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBwbHVnaW4gbXVzdCBoYXZlIGEgbmFtZScpO1xuICAgIH1cbiAgICB0aGlzLl9wbHVnaW5zLnB1c2gocGx1Z2luKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYW4gYWN0aW9uIHBhc3NpbmcgYW4gYWN0aW9uIGludGVyZmFjZSB0byBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQW4gYWN0aW9uIGNyZWF0b3IgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhY3Rpb25Db250ZXh0LCBwYXlsb2FkLFxuICogIGFuZCBkb25lIGFzIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFRoZSBhY3Rpb24gcGF5bG9hZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBNZXRob2QgdG8gYmUgY2FsbGVkIG9uY2UgYWN0aW9uIGV4ZWN1dGlvbiBoYXMgY29tcGxldGVkXG4gKi9cbkZsdXhDb250ZXh0LnByb3RvdHlwZS5leGVjdXRlQWN0aW9uID0gZnVuY3Rpb24gZXhlY3V0ZUFjdGlvbihhY3Rpb24sIHBheWxvYWQsIGRvbmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb25JbW1lZGlhdGUoKSB7XG4gICAgICAgIGRlYnVnKCdFeGVjdXRpbmcgYWN0aW9uICcgKyAoYWN0aW9uLm5hbWUpICsgJyB3aXRoIHBheWxvYWQnLCBwYXlsb2FkKTtcbiAgICAgICAgYWN0aW9uKHNlbGYuZ2V0QWN0aW9uQ29udGV4dCgpLCBwYXlsb2FkLCBkb25lKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgZGlzcGF0Y2hlciB3aXRoIGFjY2VzcyB0byB0aGUgc3RvcmUgY29udGV4dFxuICogQG1ldGhvZCBfaW5pdGlhbGl6ZURpc3BhdGNoZXJcbiAqIEBwcml2YXRlXG4gKi9cbkZsdXhDb250ZXh0LnByb3RvdHlwZS5faW5pdGlhbGl6ZURpc3BhdGNoZXIgPSBmdW5jdGlvbiBpbml0aWFsaXplRGlzcGF0Y2hlcigpIHtcbiAgICB0aGlzLl9kaXNwYXRjaGVyID0gdGhpcy5fYXBwLmNyZWF0ZURpc3BhdGNoZXJJbnN0YW5jZSh0aGlzLmdldFN0b3JlQ29udGV4dCgpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCBmb3IgYWN0aW9uIGNvbnRyb2xsZXJzXG4gKiBAbWV0aG9kIGdldEFjdGlvbkNvbnRleHRcbiAqIEByZXR1cm4ge09iamVjdH0gQWN0aW9uIGNvbnRleHQgaW5mb3JtYXRpb25cbiAqL1xuRmx1eENvbnRleHQucHJvdG90eXBlLmdldEFjdGlvbkNvbnRleHQgPSBmdW5jdGlvbiBnZXRBY3Rpb25Db250ZXh0KCkge1xuICAgIGlmICh0aGlzLl9hY3Rpb25Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25Db250ZXh0O1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuX2Rpc3BhdGNoZXIpIHtcbiAgICAgICAgc2VsZi5faW5pdGlhbGl6ZURpc3BhdGNoZXIoKTtcbiAgICB9XG5cbiAgICB2YXIgYWN0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgZGlzcGF0Y2g6IHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2guYmluZCh0aGlzLl9kaXNwYXRjaGVyKSxcbiAgICAgICAgZXhlY3V0ZUFjdGlvbjogdGhpcy5leGVjdXRlQWN0aW9uLmJpbmQodGhpcyksXG4gICAgICAgIGdldFN0b3JlOiB0aGlzLl9kaXNwYXRjaGVyLmdldFN0b3JlLmJpbmQodGhpcy5fZGlzcGF0Y2hlcilcbiAgICB9O1xuXG4gICAgc2VsZi5fcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIHBsdWdpbnNFYWNoKHBsdWdpbikge1xuICAgICAgICB2YXIgYWN0aW9uQ29udGV4dFBsdWdpbiA9IHBsdWdpbi5wbHVnQWN0aW9uQ29udGV4dDtcbiAgICAgICAgaWYgKGFjdGlvbkNvbnRleHRQbHVnaW4pIHtcbiAgICAgICAgICAgIGFjdGlvbkNvbnRleHRQbHVnaW4oYWN0aW9uQ29udGV4dCwgc2VsZiwgc2VsZi5fYXBwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2VsZi5fYWN0aW9uQ29udGV4dCA9IGFjdGlvbkNvbnRleHQ7XG5cbiAgICByZXR1cm4gc2VsZi5fYWN0aW9uQ29udGV4dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCBmb3IgYWN0aW9uIGNvbnRyb2xsZXJzXG4gKiBAbWV0aG9kIGdldENvbXBvbmVudENvbnRleHRcbiAqIEByZXR1cm4ge09iamVjdH0gQ29tcG9uZW50IGNvbnRleHQgaW5mb3JtYXRpb25cbiAqL1xuRmx1eENvbnRleHQucHJvdG90eXBlLmdldENvbXBvbmVudENvbnRleHQgPSBmdW5jdGlvbiBnZXRDb21wb25lbnRDb250ZXh0KCkge1xuICAgIGlmICh0aGlzLl9jb21wb25lbnRDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLl9kaXNwYXRjaGVyKSB7XG4gICAgICAgIHNlbGYuX2luaXRpYWxpemVEaXNwYXRjaGVyKCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudENvbnRleHQgPSB7XG4gICAgICAgIGdldFN0b3JlOiB0aGlzLl9kaXNwYXRjaGVyLmdldFN0b3JlLmJpbmQodGhpcy5fZGlzcGF0Y2hlciksXG4gICAgICAgIC8vIERpc2FsbG93cyBjb21wb25lbnRzIGZyb20gaGFuZGxpbmcgdGhlIGNhbGxiYWNrIGZvciBhbiBhY3Rpb25cbiAgICAgICAgZXhlY3V0ZUFjdGlvbjogZnVuY3Rpb24gY29tcG9uZW50RXhlY3V0ZUFjdGlvbihhY3Rpb24sIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHNlbGYuZXhlY3V0ZUFjdGlvbihhY3Rpb24sIHBheWxvYWQsIGZ1bmN0aW9uIGV4ZWN1dGVBY3Rpb25DYWxsYmFjayhlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBAVE9ETyBwcm92aWRlIGEgd2F5IHRvIGNvbmZpZ3VyZSBjb21wb25lbnQgYWN0aW9uIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdBY3Rpb24gcmV0dXJuZWQgZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5fcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIHBsdWdpbnNFYWNoKHBsdWdpbikge1xuICAgICAgICB2YXIgY29tcG9uZW50UGx1Z2luID0gcGx1Z2luLnBsdWdDb21wb25lbnRDb250ZXh0O1xuICAgICAgICBpZiAoY29tcG9uZW50UGx1Z2luKSB7XG4gICAgICAgICAgICBjb21wb25lbnRQbHVnaW4oY29tcG9uZW50Q29udGV4dCwgc2VsZiwgc2VsZi5fYXBwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2VsZi5fY29tcG9uZW50Q29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG4gICAgcmV0dXJuIHNlbGYuX2NvbXBvbmVudENvbnRleHQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRleHQgZm9yIHN0b3Jlc1xuICogQG1ldGhvZCBnZXRTdG9yZUNvbnRleHRcbiAqIEByZXR1cm4ge09iamVjdH0gU3RvcmUgY29udGV4dCBpbmZvcm1hdGlvblxuICovXG5GbHV4Q29udGV4dC5wcm90b3R5cGUuZ2V0U3RvcmVDb250ZXh0ID0gZnVuY3Rpb24gZ2V0U3RvcmVDb250ZXh0KCkge1xuICAgIGlmICh0aGlzLl9zdG9yZUNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdG9yZUNvbnRleHQgPSB7fTtcblxuICAgIHNlbGYuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiBwbHVnaW5zRWFjaChwbHVnaW4pIHtcbiAgICAgICAgdmFyIHN0b3JlQ29udGV4dFBsdWdpbiA9IHBsdWdpbi5wbHVnU3RvcmVDb250ZXh0O1xuICAgICAgICBpZiAoc3RvcmVDb250ZXh0UGx1Z2luKSB7XG4gICAgICAgICAgICBzdG9yZUNvbnRleHRQbHVnaW4oc3RvcmVDb250ZXh0LCBzZWxmLCBzZWxmLl9hcHApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZWxmLl9zdG9yZUNvbnRleHQgPSBzdG9yZUNvbnRleHQ7XG4gICAgcmV0dXJuIHNlbGYuX3N0b3JlQ29udGV4dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNlcmlhbGl6YWJsZSBjb250ZXh0IHN0YXRlXG4gKiBAbWV0aG9kIGRlaHlkcmF0ZVxuICogQHJldHVybiB7T2JqZWN0fSBTZWUgcmVoeWRyYXRlIG1ldGhvZCBmb3IgcHJvcGVydGllc1xuICovXG5GbHV4Q29udGV4dC5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gZGVoeWRyYXRlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGRpc3BhdGNoZXI6ICh0aGlzLl9kaXNwYXRjaGVyICYmIHRoaXMuX2Rpc3BhdGNoZXIuZGVoeWRyYXRlKCkpIHx8IHt9LFxuICAgICAgICBwbHVnaW5zOiB7fVxuICAgIH07XG5cbiAgICBzZWxmLl9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gcGx1Z2luc0VhY2gocGx1Z2luKSB7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgcGx1Z2luLmRlaHlkcmF0ZSkge1xuICAgICAgICAgICAgLy8gVXNlIGEgbmFtZXNwYWNlIGZvciBzdG9yaW5nIHBsdWdpbiBzdGF0ZSBhbmQgcHJvdmlkZSBhY2Nlc3MgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgICAgICBzdGF0ZS5wbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbi5kZWh5ZHJhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzdGF0ZTtcbn07XG5cbi8qKlxuICogUmVoeWRyYXRlcyB0aGUgY29udGV4dCBzdGF0ZVxuICogQG1ldGhvZCByZWh5ZHJhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogQ29uZmlndXJhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iai5wbHVnaW5zIERlaHlkcmF0ZWQgY29udGV4dCBwbHVnaW4gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmouZGlzcGF0Y2hlciBEZWh5ZHJhdGVkIGRpc3BhdGNoZXIgc3RhdGVcbiAqL1xuRmx1eENvbnRleHQucHJvdG90eXBlLnJlaHlkcmF0ZSA9IGZ1bmN0aW9uIHJlaHlkcmF0ZShvYmopIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgb2JqLnBsdWdpbnMgPSBvYmoucGx1Z2lucyB8fCB7fTtcbiAgICBzZWxmLl9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gcGx1Z2luc0VhY2gocGx1Z2luKSB7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgcGx1Z2luLnJlaHlkcmF0ZSkge1xuICAgICAgICAgICAgLy8gU2VuZCBpbiB0aGUgcGx1Z2luIG5hbWVzcGFjZSBzdGF0ZSBhbmQgcHJvdmlkZSBhY2Nlc3MgdG8gdGhlIGFwcGxpY2F0aW9uIGluc3RhbmNlXG4gICAgICAgICAgICBwbHVnaW4ucmVoeWRyYXRlKG9iai5wbHVnaW5zW3BsdWdpbi5uYW1lXSwgc2VsZik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNlbGYuX2Rpc3BhdGNoZXIgPSB0aGlzLl9hcHAuY3JlYXRlRGlzcGF0Y2hlckluc3RhbmNlKHNlbGYuZ2V0U3RvcmVDb250ZXh0KCkpO1xuICAgIHNlbGYuX2Rpc3BhdGNoZXIucmVoeWRyYXRlKG9iai5kaXNwYXRjaGVyIHx8IHt9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmx1eENvbnRleHQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVhY3QgbWl4aW4gZm9yIHN0YXRpY2x5IGRlY2xhcmluZyBhbmQgYWRkL3JlbW92ZS1pbmcgbGlzdGVuZXJzIGZvciBTdG9yZSBldmVudHMuXG4gKiBAY2xhc3MgRmx1eGlibGVNaXhpblxuICogQGV4YW1wbGVcbiAqIC8vIFJlZ2lzdGVyIGxpc3RlbmVyIGRlZmF1bHQgaGFuZGxlciBmdW5jdGlvbiBuYW1lXG4gKiB2YXIgQ29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIG1peGluczogW0ZsdXhpYmxlTWl4aW5dLFxuICogICAgIHN0YXRpY3M6IHtcbiAqICAgICAgICAgc3RvcmVMaXN0ZW5lcnM6IFtNb2NrU3RvcmVdXG4gKiAgICAgfSxcbiAqICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKCkge1xuICogICAgICAgICBkb25lKCk7XG4gKiAgICAgfSxcbiAqICAgICAuLi5cbiAqIH0pO1xuICogQGV4YW1wbGVcbiAqIC8vIFJlZ2lzdGVyIGxpc3RlbmVyIHdpdGggY3VzdG9tIG5hbWVkIGhhbmRsZXJcbiAqIHZhciBDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbRmx1eGlibGVNaXhpbl0sXG4gKiAgICAgc3RhdGljczoge1xuICogICAgICAgICBzdG9yZUxpc3RlbmVyczoge1xuICogICAgICAgICAgICAgJ29uQ2hhbmdlMic6IFtNb2NrU3RvcmVdXG4gKiAgICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIG9uQ2hhbmdlMjogZnVuY3Rpb24gKCkge1xuICogICAgICAgICBkb25lKCk7XG4gKiAgICAgfSxcbiAqICAgICAuLi5cbiAqIH0pO1xuICovXG52YXIgREVGQVVMVF9DSEFOR0VfSEFORExFUiA9ICdvbkNoYW5nZSc7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgRmx1eGlibGVNaXhpbiA9IHtcbiAgICBjb250ZXh0VHlwZXM6IHtcbiAgICAgICAgZ2V0U3RvcmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgICAgICBleGVjdXRlQWN0aW9uOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHN0YXRpY2x5IGRlY2xhcmVkIGxpc3RlbmVyc1xuICAgICAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBSZWdpc3RlciBzdGF0aWMgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuZ2V0TGlzdGVuZXJzKCkuZm9yRWFjaChmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgc2VsZi5fYXR0YWNoU3RvcmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhbiBhY3Rpb25cbiAgICAgKiBAbWV0aG9kIGV4ZWN1dGVBY3Rpb25cbiAgICAgKi9cbiAgICBleGVjdXRlQWN0aW9uOiBmdW5jdGlvbiBleGVjdXRlQWN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucHJvcHMuY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGlmICghY29udGV4dCB8fCAhY29udGV4dC5leGVjdXRlQWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4ZWN1dGVBY3Rpb24gd2FzIGNhbGxlZCBidXQgbm8gY29udGV4dCB3YXMgcHJvdmlkZWQuIFBhc3MgdGhlIGZsdXhpYmxlJyArXG4gICAgICAgICAgICAnY29udGV4dCB2aWEgYSBgY29udGV4dGAgcHJvcCBvciB2aWEgUmVhY3RcXCdzIGNvbnRleHQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXhlY3V0ZUFjdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3RvcmUgaW5zdGFuY2UgZnJvbSB0aGUgY29udGV4dFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBzdG9yZSBUaGUgc3RvcmUgdG8gZ2V0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAbWV0aG9kIGdldFN0b3JlXG4gICAgICovXG4gICAgZ2V0U3RvcmU6IGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICB2YXIgc3RvcmVJbnN0YW5jZSA9IHN0b3JlO1xuICAgICAgICBpZiAoJ29iamVjdCcgIT09IHR5cGVvZiBzdG9yZUluc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucHJvcHMuY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlTGlzdGVuZXIgbWl4aW4gd2FzIGNhbGxlZCBidXQgbm8gY29udGV4dCB3YXMgcHJvdmlkZWQgZm9yIGdldHRpbmcgdGhlIHN0b3JlLicgK1xuICAgICAgICAgICAgICAgICdQYXNzIHRoZSBmbHV4aWJsZSBjb250ZXh0IHZpYSBhIGBjb250ZXh0YCBwcm9wIG9yIHZpYSBSZWFjdFxcJ3MgY29udGV4dC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlSW5zdGFuY2UgPSBjb250ZXh0LmdldFN0b3JlKHN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmVJbnN0YW5jZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBmcm9tIHRoZSBjb250ZXh0IGFsbCBzdG9yZSBpbnN0YW5jZXMgcmVxdWlyZWQgYnkgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBtZXRob2QgZ2V0U3RvcmVzXG4gICAgICovXG4gICAgZ2V0U3RvcmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0b3Jlc0J5TmFtZSA9IHRoaXMuZ2V0TGlzdGVuZXJzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGFjY3VtW2xpc3RlbmVyLnN0b3JlLmNvbnN0cnVjdG9yLnN0b3JlTmFtZV0gPSBsaXN0ZW5lci5zdG9yZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmVzQnlOYW1lKS5tYXAoZnVuY3Rpb24oc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVzQnlOYW1lW3N0b3JlTmFtZV07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3RvcmUtY2hhbmdlIGhhbmRsZXIgZnJvbSB0aGUgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGhhbmRsZXIgVGhlIGhhbmRsZXIgdG8gZ2V0XG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAqIEBtZXRob2QgZ2V0SGFuZGxlclxuICAgICAqL1xuICAgIGdldEhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzW2hhbmRsZXJdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlTGlzdGVuZXIgYXR0ZW1wdGVkIHRvIGFkZCB1bmRlZmluZWQgaGFuZGxlci4gTWFrZSBzdXJlIGhhbmRsZXJzIGFyZSBhY3R1YWxseSBleGlzdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdGVuZXIgZGVzY3JpcHRvciBmb3IgYSBzdG9yZSBhbmQgc3RvcmUtY2hhbmdlIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gc3RvcmUgU3RvcmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gaGFuZGxlciBUaGUgaGFuZGxlciBmdW5jdGlvbiBvciBtZXRob2QgbmFtZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQG1ldGhvZCBnZXRMaXN0ZW5lclxuICAgICAqL1xuICAgIGdldExpc3RlbmVyOiBmdW5jdGlvbihzdG9yZSwgaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyID0gdGhpcy5nZXRIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB2YXIgc3RvcmVJbnN0YW5jZSA9IHRoaXMuZ2V0U3RvcmUoc3RvcmUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdG9yZTogc3RvcmVJbnN0YW5jZSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgc3RvcmUtY2hhbmdlIGxpc3RlbmVyIGRlc2NyaXB0b3JzIGZyb20gdGhlIGNvbXBvbmVudFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQG1ldGhvZCBnZXRMaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBnZXRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdG9yZUxpc3RlbmVycyA9IHNlbGYuY29uc3RydWN0b3Iuc3RvcmVMaXN0ZW5lcnM7IC8vIFN0YXRpYyBwcm9wZXJ0eSBvbiBjb21wb25lbnRcblxuICAgICAgICAvLyBnZXQgc3RhdGljIGxpc3RlbmVyc1xuICAgICAgICBpZiAoc3RvcmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0b3JlTGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZUxpc3RlbmVycy5tYXAoZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0TGlzdGVuZXIoc3RvcmUsIERFRkFVTFRfQ0hBTkdFX0hBTkRMRVIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RvcmVMaXN0ZW5lcnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGhhbmRsZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZXMgPSBzdG9yZUxpc3RlbmVyc1toYW5kbGVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdG9yZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZXMgPSBbc3RvcmVzXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0uY29uY2F0KHN0b3Jlcy5tYXAoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRMaXN0ZW5lcihzdG9yZSwgaGFuZGxlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCB3aXRoIGV2ZW50cywgd2lsbCBhdHRhY2ggbGlzdGVuZXJzIHRvIGV2ZW50cyBvbiBFdmVudEVtaXR0ZXIgb2JqZWN0cyhpLmUuIFN0b3JlcylcbiAgICAgKiBJZiB0aGUgY29tcG9uZW50IGlzbid0IG1vdW50ZWQsIGV2ZW50cyBhcmVuJ3QgYXR0YWNoZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyLnN0b3JlIFN0b3JlIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpc3RlbmVyLmhhbmRsZXIgSGFuZGxlciBmdW5jdGlvbiBvciBtZXRob2QgbmFtZVxuICAgICAqIEBtZXRob2QgX2F0dGFjaFN0b3JlTGlzdGVuZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hTdG9yZUxpc3RlbmVyOiBmdW5jdGlvbiBfYXR0YWNoU3RvcmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5pc01vdW50ZWQgJiYgIXRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RvcmVMaXN0ZW5lciBtaXhpbiBjYWxsZWQgbGlzdGVuIHdoZW4gY29tcG9uZW50IHdhc25cXCd0IG1vdW50ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lci5zdG9yZS5hZGRDaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lci5oYW5kbGVyKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVyc1xuICAgICAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5zdG9yZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lci5oYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGbHV4aWJsZU1peGluO1xuIiwiLyohXG4gKiBhc3luY1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luY1xuICpcbiAqIENvcHlyaWdodCAyMDEwLTIwMTQgQ2FvbGFuIE1jTWFob25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vKmpzaGludCBvbmV2YXI6IGZhbHNlLCBpbmRlbnQ6NCAqL1xuLypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgcm9vdCA9IHRoaXM7XG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgdmFyIF9lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5mb3JFYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmZvckVhY2goaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9tYXAgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLm1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvcih4LCBpLCBhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgdmFyIF9yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWVtbykge1xuICAgICAgICBpZiAoYXJyLnJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pO1xuICAgICAgICB9XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG5cbiAgICB2YXIgX2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIC8vLy8gZXhwb3J0ZWQgYXN5bmMgbW9kdWxlIGZ1bmN0aW9ucyAvLy8vXG5cbiAgICAvLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8ICEocHJvY2Vzcy5uZXh0VGljaykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBvbmx5X29uY2UoZG9uZSkgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaCA9IGFzeW5jLmVhY2g7XG5cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2NvbXBsZXRlZF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xuXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XG5cbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3guaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xuICAgIH07XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gaW5qZWN0IGFsaWFzXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xuICAgIC8vIGZvbGRsIGFsaWFzXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XG5cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvbGRyIGFsaWFzXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcblxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcbiAgICAvLyBzZWxlY3QgYWxpYXNcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xuXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFueSBhbGlhc1xuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XG5cbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbGwgYWxpYXNcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICB2YXIgcmVtYWluaW5nVGFza3MgPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1haW5pbmdUYXNrcy0tXG4gICAgICAgICAgICBfZWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBmaW5hbCBjYWxsYmFjayBmcm9tIGNhbGxpbmcgaXRzZWxmIGlmIGl0IGVycm9yc1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICAgICAgICB0aGVDYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2VhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gX2lzQXJyYXkodGFza3Nba10pID8gdGFza3Nba106IFt0YXNrc1trXV07XG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2VhY2goX2tleXMocmVzdWx0cyksIGZ1bmN0aW9uKHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIE1hdGguYWJzKHRhc2subGVuZ3RoIC0gMSkpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5yZXRyeSA9IGZ1bmN0aW9uKHRpbWVzLCB0YXNrLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XG4gICAgICAgIHZhciBhdHRlbXB0cyA9IFtdO1xuICAgICAgICAvLyBVc2UgZGVmYXVsdHMgaWYgdGltZXMgbm90IHBhc3NlZFxuICAgICAgICBpZiAodHlwZW9mIHRpbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2s7XG4gICAgICAgICAgICB0YXNrID0gdGltZXM7XG4gICAgICAgICAgICB0aW1lcyA9IERFRkFVTFRfVElNRVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRpbWVzIGlzIGEgbnVtYmVyXG4gICAgICAgIHRpbWVzID0gcGFyc2VJbnQodGltZXMsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB2YXIgd3JhcHBlZFRhc2sgPSBmdW5jdGlvbih3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgcmV0cnlBdHRlbXB0ID0gZnVuY3Rpb24odGFzaywgZmluYWxBdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2FsbGJhY2soIWVyciB8fCBmaW5hbEF0dGVtcHQsIHtlcnI6IGVyciwgcmVzdWx0OiByZXN1bHR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgd3JhcHBlZFJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHRpbWVzKSB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMucHVzaChyZXRyeUF0dGVtcHQodGFzaywgISh0aW1lcy09MSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jLnNlcmllcyhhdHRlbXB0cywgZnVuY3Rpb24oZG9uZSwgZGF0YSl7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAod3JhcHBlZENhbGxiYWNrIHx8IGNhbGxiYWNrKShkYXRhLmVyciwgZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHJ1biB0aGlzIGFzIGEgY29udHJvbGwgZmxvd1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyB3cmFwcGVkVGFzaygpIDogd3JhcHBlZFRhc2tcbiAgICB9O1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIV9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKF9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICh0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy51bnRpbCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICghdGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvVW50aWwoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcS5kcmFpbiA9IG51bGw7XG4gICAgICAgICAgICAgIHEudGFza3MgPSBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghcS5wYXVzZWQgJiYgd29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmVtcHR5ICYmIHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4gJiYgcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKHRhc2suZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IHRydWUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcbiAgICBcbiAgICBhc3luYy5wcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9jb21wYXJlVGFza3MoYSwgYil7XG4gICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gX2JpbmFyeVNlYXJjaChzZXF1ZW5jZSwgaXRlbSwgY29tcGFyZSkge1xuICAgICAgICAgIHZhciBiZWcgPSAtMSxcbiAgICAgICAgICAgICAgZW5kID0gc2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoYmVnIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gYmVnICsgKChlbmQgLSBiZWcgKyAxKSA+Pj4gMSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBzZXF1ZW5jZVttaWRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGJlZyA9IG1pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiZWc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoX2JpbmFyeVNlYXJjaChxLnRhc2tzLCBpdGVtLCBfY29tcGFyZVRhc2tzKSArIDEsIDAsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgICAgICB2YXIgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpO1xuICAgICAgICBcbiAgICAgICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcbiAgICAgICAgcS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHRhc2tzICAgICAgID0gW107XG5cbiAgICAgICAgdmFyIGNhcmdvID0ge1xuICAgICAgICAgICAgdGFza3M6IHRhc2tzLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBkcmFpbmVkOiB0cnVlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluICYmICFjYXJnby5kcmFpbmVkKSBjYXJnby5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0cyA9IHR5cGVvZiBwYXlsb2FkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFza3Muc3BsaWNlKDAsIHBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCwgdGFza3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZ287XG4gICAgfTtcblxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VxID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgICAgICB9XSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgIHJldHVybiBhc3luYy5zZXEuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgdmFyIF9hcHBseUVhY2ggPSBmdW5jdGlvbiAoZWFjaGZuLCBmbnMgLyphcmdzLi4uKi8pIHtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmFwcGx5RWFjaCA9IGRvUGFyYWxsZWwoX2FwcGx5RWFjaCk7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICAvLyBOb2RlLmpzXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL0Rpc3BhdGNoZXInKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ0Rpc3BhdGNocjpBY3Rpb24nKTtcblxuZnVuY3Rpb24gQWN0aW9uKG5hbWUsIHBheWxvYWQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5faGFuZGxlcnMgPSBudWxsO1xuICAgIHRoaXMuX2lzRXhlY3V0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5faXNDb21wbGV0ZWQgPSBudWxsO1xufVxuXG4vKipcbiAqIEdldHMgYSBuYW1lIGZyb20gYSBzdG9yZVxuICogQG1ldGhvZCBnZXRTdG9yZU5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gc3RvcmUgVGhlIHN0b3JlIG5hbWUgb3IgY2xhc3MgZnJvbSB3aGljaCB0byBleHRyYWN0XG4gKiAgICAgIHRoZSBuYW1lXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5BY3Rpb24ucHJvdG90eXBlLmdldFN0b3JlTmFtZSA9IGZ1bmN0aW9uIGdldFN0b3JlTmFtZShzdG9yZSkge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHN0b3JlKSB7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlLnN0b3JlTmFtZTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYWxsIGhhbmRsZXJzIGZvciB0aGUgYWN0aW9uXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gaGFuZGxlcnMgQSBtYXBwaW5nIG9mIHN0b3JlIG5hbWVzIHRvIGhhbmRsZXIgZnVuY3Rpb25cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBleGVjdXRlZFxuICovXG5BY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKGhhbmRsZXJzKSB7XG4gICAgaWYgKHRoaXMuX2lzRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9uIGlzIGFscmVhZHkgZGlzcGF0Y2hlZCcpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5faGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICB0aGlzLl9pc0V4ZWN1dGluZyA9IHRydWU7XG4gICAgdGhpcy5faXNDb21wbGV0ZWQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhoYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiBoYW5kbGVyc0VhY2goc3RvcmVOYW1lKSB7XG4gICAgICAgIHNlbGYuX2NhbGxIYW5kbGVyKHN0b3JlTmFtZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENhbGxzIGFuIGluZGl2aWR1YWwgc3RvcmUncyBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAbWV0aG9kIF9jYWxsSGFuZGxlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlTmFtZVxuICogQHByaXZhdGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBoYW5kbGVyIGRvZXMgbm90IGV4aXN0IGZvciBzdG9yZU5hbWVcbiAqL1xuQWN0aW9uLnByb3RvdHlwZS5fY2FsbEhhbmRsZXIgPSBmdW5jdGlvbiBjYWxsSGFuZGxlcihzdG9yZU5hbWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGhhbmRsZXJGbiA9IHNlbGYuX2hhbmRsZXJzW3N0b3JlTmFtZV07XG4gICAgaWYgKCFoYW5kbGVyRm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0b3JlTmFtZSArICcgZG9lcyBub3QgaGF2ZSBhIGhhbmRsZXIgZm9yIGFjdGlvbiAnICsgc2VsZi5uYW1lKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuX2lzQ29tcGxldGVkW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl9pc0NvbXBsZXRlZFtzdG9yZU5hbWVdID0gZmFsc2U7XG4gICAgZGVidWcoJ2V4ZWN1dGluZyBoYW5kbGVyIGZvciAnICsgc3RvcmVOYW1lKTtcbiAgICBoYW5kbGVyRm4oc2VsZi5wYXlsb2FkLCBzZWxmLm5hbWUpO1xuICAgIHNlbGYuX2lzQ29tcGxldGVkW3N0b3JlTmFtZV0gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBXYWl0cyB1bnRpbCBhbGwgc3RvcmVzIGhhdmUgZmluaXNoZWQgaGFuZGxpbmcgYW4gYWN0aW9uIGFuZCB0aGVuIGNhbGxzXG4gKiB0aGUgY2FsbGJhY2tcbiAqIEBtZXRob2Qgd2FpdEZvclxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW118Q29uc3RydWN0b3J8Q29uc3RydWN0b3JbXX0gc3RvcmVzIEFuIGFycmF5IG9mIHN0b3JlcyBhcyBzdHJpbmdzIG9yIGNvbnN0cnVjdG9ycyB0byB3YWl0IGZvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGFsbCBzdG9yZXMgaGF2ZSBjb21wbGV0ZWQgaGFuZGxpbmcgdGhlaXIgYWN0aW9uc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBhY3Rpb24gaXMgbm90IGJlaW5nIGV4ZWN1dGVkXG4gKi9cbkFjdGlvbi5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uIHdhaXRGb3Ioc3RvcmVzLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuX2lzRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2FpdEZvciBjYWxsZWQgZXZlbiB0aG91Z2ggdGhlcmUgaXMgbm8gYWN0aW9uIGJlaW5nIGV4ZWN1dGVkIScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RvcmVzKSkge1xuICAgICAgICBzdG9yZXMgPSBbc3RvcmVzXTtcbiAgICB9XG5cbiAgICBkZWJ1Zygnd2FpdGluZyBvbiAnICsgc3RvcmVzLmpvaW4oJywgJykpO1xuICAgIHN0b3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIHN0b3Jlc0VhY2goc3RvcmVOYW1lKSB7XG4gICAgICAgIHN0b3JlTmFtZSA9IHNlbGYuZ2V0U3RvcmVOYW1lKHN0b3JlTmFtZSk7XG4gICAgICAgIHNlbGYuX2NhbGxIYW5kbGVyKHN0b3JlTmFtZSk7XG4gICAgfSk7XG5cbiAgICBjYWxsYmFjaygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBY3Rpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBY3Rpb24gPSByZXF1aXJlKCcuL0FjdGlvbicpLFxuICAgIERFRkFVTFQgPSAnZGVmYXVsdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ0Rpc3BhdGNocjpkaXNwYXRjaGVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgRGlzcGF0Y2hlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGJlIHVzZWQgZm9yIHN0b3JlIGluc3RhbmNlc1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpc3BhdGNoZXIgKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zdG9yZUluc3RhbmNlcyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRBY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXJJbnRlcmZhY2UgPSB7XG4gICAgICAgICAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiBnZXRDb250ZXh0KCkgeyByZXR1cm4gY29udGV4dDsgfSxcbiAgICAgICAgICAgIGdldFN0b3JlOiB0aGlzLmdldFN0b3JlLmJpbmQodGhpcyksXG4gICAgICAgICAgICB3YWl0Rm9yOiB0aGlzLndhaXRGb3IuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIERpc3BhdGNoZXIuc3RvcmVzID0ge307XG4gICAgRGlzcGF0Y2hlci5oYW5kbGVycyA9IHtcbiAgICAgICAgJ2RlZmF1bHQnOiBbXVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBzdG9yZSBzbyB0aGF0IGl0IGNhbiBoYW5kbGUgYWN0aW9ucy5cbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyU3RvcmVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0b3JlIEEgc3RvcmUgY2xhc3MgdG8gYmUgcmVnaXN0ZXJlZC4gVGhlIHN0b3JlIHNob3VsZCBoYXZlIGEgc3RhdGljXG4gICAgICogICAgICBgbmFtZWAgcHJvcGVydHkgc28gdGhhdCBpdCBjYW4gYmUgbG9hZGVkIGxhdGVyLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBzdG9yZSBpcyBpbnZhbGlkXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHN0b3JlIGlzIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgICAqL1xuICAgIERpc3BhdGNoZXIucmVnaXN0ZXJTdG9yZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3RvcmUoc3RvcmUpIHtcbiAgICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBzdG9yZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWdpc3RlclN0b3JlIHJlcXVpcmVzIGEgY29uc3RydWN0b3IgYXMgZmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3JlTmFtZSA9IERpc3BhdGNoZXIuZ2V0U3RvcmVOYW1lKHN0b3JlKTtcbiAgICAgICAgaWYgKCFzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RvcmUgaXMgcmVxdWlyZWQgdG8gaGF2ZSBhIGBzdG9yZU5hbWVgIHByb3BlcnR5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEaXNwYXRjaGVyLnN0b3Jlc1tzdG9yZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoRGlzcGF0Y2hlci5zdG9yZXNbc3RvcmVOYW1lXSA9PT0gc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0b3JlIHdpdGggbmFtZSBgJyArIHN0b3JlTmFtZSArICdgIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBEaXNwYXRjaGVyLnN0b3Jlc1tzdG9yZU5hbWVdID0gc3RvcmU7XG4gICAgICAgIGlmIChzdG9yZS5oYW5kbGVycykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RvcmUuaGFuZGxlcnMpLmZvckVhY2goZnVuY3Rpb24gc3RvcmVIYW5kbGVyc0VhY2goYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBzdG9yZS5oYW5kbGVyc1thY3Rpb25dO1xuICAgICAgICAgICAgICAgIERpc3BhdGNoZXIuX3JlZ2lzdGVySGFuZGxlcihhY3Rpb24sIHN0b3JlTmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZGlzY292ZXIgaWYgYSBzdG9yZU5hbWUgaGFzIGJlZW4gcmVnaXN0ZXJlZFxuICAgICAqIEBtZXRob2QgaXNSZWdpc3RlcmVkXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gc3RvcmUgVGhlIHN0b3JlIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgRGlzcGF0Y2hlci5pc1JlZ2lzdGVyZWQgPSBmdW5jdGlvbiBpc1JlZ2lzdGVyZWQoc3RvcmUpIHtcbiAgICAgICAgdmFyIHN0b3JlTmFtZSA9IERpc3BhdGNoZXIuZ2V0U3RvcmVOYW1lKHN0b3JlKSxcbiAgICAgICAgICAgIHN0b3JlSW5zdGFuY2UgPSBEaXNwYXRjaGVyLnN0b3Jlc1tzdG9yZU5hbWVdO1xuXG4gICAgICAgIGlmICghc3RvcmVJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBzdG9yZSkge1xuICAgICAgICAgICAgaWYgKHN0b3JlICE9PSBzdG9yZUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbmFtZSBmcm9tIGEgc3RvcmVcbiAgICAgKiBAbWV0aG9kIGdldFN0b3JlTmFtZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHN0b3JlIFRoZSBzdG9yZSBuYW1lIG9yIGNsYXNzIGZyb20gd2hpY2ggdG8gZXh0cmFjdFxuICAgICAqICAgICAgdGhlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIERpc3BhdGNoZXIuZ2V0U3RvcmVOYW1lID0gZnVuY3Rpb24gZ2V0U3RvcmVOYW1lKHN0b3JlKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLnN0b3JlTmFtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGhhbmRsZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciB0aGUgZ2l2ZW4gYWN0aW9uXG4gICAgICogQG1ldGhvZCByZWdpc3RlckhhbmRsZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIE5hbWUgb2YgdGhlIGFjdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHN0b3JlIHRoYXQgaGFuZGxlcyB0aGUgYWN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGhhbmRsZXIgVGhlIGZ1bmN0aW9uIG9yIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IGhhbmRsZXMgdGhlIGFjdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgRGlzcGF0Y2hlci5fcmVnaXN0ZXJIYW5kbGVyID0gZnVuY3Rpb24gcmVnaXN0ZXJIYW5kbGVyKGFjdGlvbiwgbmFtZSwgaGFuZGxlcikge1xuICAgICAgICBEaXNwYXRjaGVyLmhhbmRsZXJzW2FjdGlvbl0gPSBEaXNwYXRjaGVyLmhhbmRsZXJzW2FjdGlvbl0gfHwgW107XG4gICAgICAgIERpc3BhdGNoZXIuaGFuZGxlcnNbYWN0aW9uXS5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IERpc3BhdGNoZXIuZ2V0U3RvcmVOYW1lKG5hbWUpLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERpc3BhdGNoZXIuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBzdG9yZSBpbnN0YW5jZSBhbmQgY3JlYXRlcyBvbmUgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0XG4gICAgICogQG1ldGhvZCBnZXRTdG9yZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzdG9yZSBpbnN0YW5jZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBzdG9yZSBpcyBub3QgcmVnaXN0ZXJlZFxuICAgICAqL1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLmdldFN0b3JlID0gZnVuY3Rpb24gZ2V0U3RvcmUobmFtZSkge1xuICAgICAgICB2YXIgc3RvcmVOYW1lID0gRGlzcGF0Y2hlci5nZXRTdG9yZU5hbWUobmFtZSk7XG4gICAgICAgIGlmICghdGhpcy5zdG9yZUluc3RhbmNlc1tzdG9yZU5hbWVdKSB7XG4gICAgICAgICAgICB2YXIgU3RvcmUgPSBEaXNwYXRjaGVyLnN0b3Jlc1tzdG9yZU5hbWVdO1xuICAgICAgICAgICAgaWYgKCFTdG9yZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RvcmUgJyArIHN0b3JlTmFtZSArICcgd2FzIG5vdCByZWdpc3RlcmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG9yZUluc3RhbmNlc1tzdG9yZU5hbWVdID0gbmV3IChEaXNwYXRjaGVyLnN0b3Jlc1tzdG9yZU5hbWVdKSh0aGlzLmRpc3BhdGNoZXJJbnRlcmZhY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlSW5zdGFuY2VzW3N0b3JlTmFtZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBuZXcgYWN0aW9uIG9yIHF1ZXVlcyBpdCB1cCBpZiBvbmUgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAqIEBtZXRob2QgZGlzcGF0Y2hcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uTmFtZSBOYW1lIG9mIHRoZSBhY3Rpb24gdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIFBhcmFtZXRlcnMgdG8gZGVzY3JpYmUgdGhlIGFjdGlvblxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBzdG9yZSBoYXMgaGFuZGxlciByZWdpc3RlcmVkIHRoYXQgZG9lcyBub3QgZXhpc3RcbiAgICAgKi9cbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbk5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBkaXNwYXRjaCB3aGlsZSBhbm90aGVyIGRpc3BhdGNoIGlzIGV4ZWN1dGluZy4gQXR0ZW1wdGVkIHRvIGV4ZWN1dGUgXFwnJyArIGFjdGlvbk5hbWUgKyAnXFwnIGJ1dCBcXCcnICsgdGhpcy5jdXJyZW50QWN0aW9uLm5hbWUgKyAnXFwnIGlzIGFscmVhZHkgZXhlY3V0aW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY3Rpb25IYW5kbGVycyA9IERpc3BhdGNoZXIuaGFuZGxlcnNbYWN0aW9uTmFtZV0gfHwgW10sXG4gICAgICAgICAgICBkZWZhdWx0SGFuZGxlcnMgPSBEaXNwYXRjaGVyLmhhbmRsZXJzW0RFRkFVTFRdIHx8IFtdO1xuICAgICAgICBpZiAoIWFjdGlvbkhhbmRsZXJzLmxlbmd0aCAmJiAhZGVmYXVsdEhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVidWcoYWN0aW9uTmFtZSArICcgZG9lcyBub3QgaGF2ZSBhbnkgcmVnaXN0ZXJlZCBoYW5kbGVycycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdkaXNwYXRjaGluZyAnICsgYWN0aW9uTmFtZSwgcGF5bG9hZCk7XG4gICAgICAgIHRoaXMuY3VycmVudEFjdGlvbiA9IG5ldyBBY3Rpb24oYWN0aW9uTmFtZSwgcGF5bG9hZCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGFsbEhhbmRsZXJzID0gYWN0aW9uSGFuZGxlcnMuY29uY2F0KGRlZmF1bHRIYW5kbGVycyksXG4gICAgICAgICAgICBoYW5kbGVyRm5zID0ge307XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFsbEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gYWN0aW9uSGFuZGxlcnNFYWNoKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJGbnNbc3RvcmUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2FsbCB0aGUgZGVmYXVsdCBpZiB0aGUgc3RvcmUgaGFzIGFuIGV4cGxpY2l0IGFjdGlvbiBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlSW5zdGFuY2UgPSBzZWxmLmdldFN0b3JlKHN0b3JlLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygc3RvcmUuaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyRm5zW3N0b3JlLm5hbWVdID0gc3RvcmUuaGFuZGxlci5iaW5kKHN0b3JlSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcmVJbnN0YW5jZVtzdG9yZS5oYW5kbGVyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0b3JlLm5hbWUgKyAnIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgY2FsbGVkICcgKyBzdG9yZS5oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyRm5zW3N0b3JlLm5hbWVdID0gc3RvcmVJbnN0YW5jZVtzdG9yZS5oYW5kbGVyXS5iaW5kKHN0b3JlSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWN0aW9uLmV4ZWN1dGUoaGFuZGxlckZucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkZWJ1ZygnZmluaXNoZWQgJyArIGFjdGlvbk5hbWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmF3IGRhdGEgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICAgICAqIGRpc3BhdGNoZXIgYW5kIGFsbCBzdG9yZSBpbnN0YW5jZXMuIElmIHRoZSBzdG9yZSBpbXBsZW1lbnRzIGEgc2hvdWxkRGVoZHlyYXRlXG4gICAgICogZnVuY3Rpb24sIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgYW5kIG9ubHkgZGVoeWRyYXRlIGlmIHRoZSBtZXRob2QgcmV0dXJucyBgdHJ1ZWBcbiAgICAgKiBAbWV0aG9kIGRlaHlkcmF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGRlaHlkcmF0ZWQgZGlzcGF0Y2hlciBkYXRhXG4gICAgICovXG4gICAgRGlzcGF0Y2hlci5wcm90b3R5cGUuZGVoeWRyYXRlID0gZnVuY3Rpb24gZGVoeWRyYXRlKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzdG9yZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5zdG9yZUluc3RhbmNlcykuZm9yRWFjaChmdW5jdGlvbiBzdG9yZUluc3RhbmNlc0VhY2goc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmUgPSBzZWxmLnN0b3JlSW5zdGFuY2VzW3N0b3JlTmFtZV07XG4gICAgICAgICAgICBpZiAoIXN0b3JlLmRlaHlkcmF0ZSB8fCAoc3RvcmUuc2hvdWxkRGVoeWRyYXRlICYmICFzdG9yZS5zaG91bGREZWh5ZHJhdGUoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZXNbc3RvcmVOYW1lXSA9IHN0b3JlLmRlaHlkcmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0b3Jlczogc3RvcmVzXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgcmF3IGRhdGEgb2JqZWN0IGFuZCByZWh5ZHJhdGVzIHRoZSBkaXNwYXRjaGVyIGFuZCBzdG9yZSBpbnN0YW5jZXNcbiAgICAgKiBAbWV0aG9kIHJlaHlkcmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaXNwYXRjaGVyU3RhdGUgcmF3IHN0YXRlIHR5cGljYWxseSByZXRyaWV2ZWQgZnJvbSBgZGVoeWRyYXRlYFxuICAgICAqICAgICAgbWV0aG9kXG4gICAgICovXG4gICAgRGlzcGF0Y2hlci5wcm90b3R5cGUucmVoeWRyYXRlID0gZnVuY3Rpb24gcmVoeWRyYXRlKGRpc3BhdGNoZXJTdGF0ZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChkaXNwYXRjaGVyU3RhdGUuc3RvcmVzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXNwYXRjaGVyU3RhdGUuc3RvcmVzKS5mb3JFYWNoKGZ1bmN0aW9uIHN0b3JlU3RhdGVFYWNoKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGRpc3BhdGNoZXJTdGF0ZS5zdG9yZXNbc3RvcmVOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUgPSBzZWxmLmdldFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlLnJlaHlkcmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5yZWh5ZHJhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdhaXRzIHVudGlsIGFsbCBzdG9yZXMgaGF2ZSBmaW5pc2hlZCBoYW5kbGluZyBhbiBhY3Rpb24gYW5kIHRoZW4gY2FsbHNcbiAgICAgKiB0aGUgY2FsbGJhY2tcbiAgICAgKiBAbWV0aG9kIHdhaXRGb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gc3RvcmVzIEFuIGFycmF5IG9mIHN0b3JlcyBhcyBzdHJpbmdzIHRvIHdhaXQgZm9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGFsbCBzdG9yZXMgaGF2ZSBjb21wbGV0ZWQgaGFuZGxpbmcgdGhlaXIgYWN0aW9uc1xuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSBpcyBubyBhY3Rpb24gZGlzcGF0Y2hpbmdcbiAgICAgKi9cbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS53YWl0Rm9yID0gZnVuY3Rpb24gd2FpdEZvcihzdG9yZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50QWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhaXRGb3IgY2FsbGVkIGV2ZW4gdGhvdWdoIHRoZXJlIGlzIG5vIGFjdGlvbiBkaXNwYXRjaGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudEFjdGlvbi53YWl0Rm9yKHN0b3JlcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICByZXR1cm4gRGlzcGF0Y2hlcjtcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBDSEFOR0VfRVZFTlQgPSAnY2hhbmdlJztcblxuLyoqXG4gKiBAY2xhc3MgQmFzZVN0b3JlXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBwYXJhbSBkaXNwYXRjaGVyIFRoZSBkaXNwYXRjaGVyIGludGVyZmFjZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJhc2VTdG9yZShkaXNwYXRjaGVyKSB7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgICB0aGlzLl9oYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoQmFzZVN0b3JlLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgZ2V0dGluZyB0aGUgc3RvcmUgY29udGV4dCBvYmplY3QuXG4gKiBAbWV0aG9kIGdldENvbnRleHRcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgc3RvcmUgY29udGV4dCBvYmplY3QuXG4gKi9cbkJhc2VTdG9yZS5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hlci5nZXRDb250ZXh0KCk7XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgZ2V0dGluZyB0aGUgc3RvcmUgY29udGV4dCBvYmplY3QuXG4gKiBAbWV0aG9kIGdldENvbnRleHRcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgc3RvcmUgY29udGV4dCBvYmplY3QuXG4gKi9cbkJhc2VTdG9yZS5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hlci5nZXRDb250ZXh0KCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciB0aGUgY2hhbmdlIGV2ZW50XG4gKiBAbWV0aG9kIGFkZENoYW5nZUxpc3RlbmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5CYXNlU3RvcmUucHJvdG90eXBlLmFkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkQ2hhbmdlTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uKENIQU5HRV9FVkVOVCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBsaXN0ZW5lciBmb3IgdGhlIGNoYW5nZSBldmVudFxuICogQG1ldGhvZCByZW1vdmVDaGFuZ2VMaXN0ZW5lclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuQmFzZVN0b3JlLnByb3RvdHlwZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUNoYW5nZUxpc3RlbmVyKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihDSEFOR0VfRVZFTlQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdG9yZSBzaG91bGQgZGVoeWRyYXRlIG9yIG5vdC4gQnkgZGVmYXVsdCwgb25seSBkZWh5ZHJhdGVzXG4gKiBpZiB0aGUgc3RvcmUgaGFzIGVtaXR0ZWQgYW4gdXBkYXRlIGV2ZW50LiBJZiBubyB1cGRhdGUgaGFzIGJlZW4gZW1pdHRlZCwgaXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgc3RvcmUgaXMgaW4gaXRzIGRlZmF1bHQgc3RhdGUgYW5kIHRoZXJlZm9yZSBkb2VzIG5vdCBuZWVkIHRvIGRlaHlkcmF0ZS5cbiAqIEBtZXRob2Qgc2hvdWxkRGVoeWRyYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQmFzZVN0b3JlLnByb3RvdHlwZS5zaG91bGREZWh5ZHJhdGUgPSBmdW5jdGlvbiBzaG91bGREZWh5ZHJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc0NoYW5nZWQ7XG59O1xuXG4vKipcbiAqIEVtaXQgYSBjaGFuZ2UgZXZlbnRcbiAqIEBtZXRob2QgZW1pdENoYW5nZVxuICogQHBhcmFtIHsqfSBwYXJhbT10aGlzXG4gKi9cbkJhc2VTdG9yZS5wcm90b3R5cGUuZW1pdENoYW5nZSA9IGZ1bmN0aW9uIGVtaXRDaGFuZ2UocGFyYW0pIHtcbiAgICB0aGlzLl9oYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoQ0hBTkdFX0VWRU5ULCBwYXJhbSB8fCB0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVN0b3JlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBCYXNlU3RvcmUgPSByZXF1aXJlKCcuL0Jhc2VTdG9yZScpLFxuICAgIElHTk9SRV9PTl9QUk9UT1RZUEUgPSBbJ3N0YXRpY3MnLCAnc3RvcmVOYW1lJywgJ2hhbmRsZXJzJywgJ21peGlucyddO1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgICAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWl4SW50byhkZXN0LCBzcmMpIHtcbiAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKC0xICE9PSBJR05PUkVfT05fUFJPVE9UWVBFLmluZGV4T2YocHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2luaXRpYWxpemUnID09PSBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWRlc3RbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICBkZXN0W3Byb3BdID0gc3JjW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0W3Byb3BdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKGRlc3RbcHJvcF0sIHNyY1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGVzdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWl4aW4gcHJvcGVydHkgY29sbGlzaW9uIGZvciBwcm9wZXJ0eSBcIicgKyBwcm9wICsgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0W3Byb3BdID0gc3JjW3Byb3BdO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBjcmVhdGluZyBhIHN0b3JlIGNsYXNzXG4gKiBAbWV0aG9kIGNyZWF0ZVN0b3JlXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICogQHBhcmFtIHtTdHJpbmd9IHNwZWMuc3RvcmVOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdG9yZVxuICogQHBhcmFtIHtPYmplY3R9IHNwZWMuaGFuZGxlcnMgSGFzaCBvZiBhY3Rpb24gbmFtZSB0byBtZXRob2QgbmFtZSBvZiBhY3Rpb24gaGFuZGxlcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNwZWMuaW5pdGlhbGl6ZSBGdW5jdGlvbiBjYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbiBmb3Igc2V0dGluZyB0aGUgZGVmYXVsdCBzdGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3BlYy5kZWh5ZHJhdGUgRnVuY3Rpb24gdGhhdCByZXR1cm5zIHNlcmlhbGl6YWJsZSBkYXRhIHRvIHNlbmQgdG8gdGhlIGNsaWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3BlYy5yZWh5ZHJhdGUgRnVuY3Rpb24gdGhhdCB0YWtlcyBpbiBzZXJpYWxpemFibGUgZGF0YSB0byByZWh5ZHJhdGUgdGhlIHN0b3JlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlU3RvcmUoc3BlYykge1xuICAgIHNwZWMuc3RhdGljcyA9IHNwZWMuc3RhdGljcyB8fCB7fTtcbiAgICBpZiAoIXNwZWMuc3RvcmVOYW1lICYmICFzcGVjLnN0YXRpY3Muc3RvcmVOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlU3RvcmUgY2FsbGVkIHdpdGhvdXQgYSBzdG9yZU5hbWUnKTtcbiAgICB9XG4gICAgdmFyIFN0b3JlID0gZnVuY3Rpb24gKGRpc3BhdGNoZXIpIHtcbiAgICAgICAgQmFzZVN0b3JlLmNhbGwodGhpcywgZGlzcGF0Y2hlcik7XG4gICAgfTtcblxuICAgIHV0aWwuaW5oZXJpdHMoU3RvcmUsIEJhc2VTdG9yZSk7XG5cbiAgICBPYmplY3Qua2V5cyhzcGVjLnN0YXRpY3MpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgU3RvcmVbcHJvcF0gPSBzcGVjLnN0YXRpY3NbcHJvcF07XG4gICAgfSk7XG5cbiAgICBTdG9yZS5zdG9yZU5hbWUgPSBzcGVjLnN0b3JlTmFtZSB8fCBTdG9yZS5zdG9yZU5hbWU7XG4gICAgU3RvcmUuaGFuZGxlcnMgPSBzcGVjLmhhbmRsZXJzIHx8IFN0b3JlLmhhbmRsZXJzO1xuICAgIFN0b3JlLm1peGlucyA9IHNwZWMubWl4aW5zIHx8IFN0b3JlLm1peGlucztcblxuICAgIGlmIChTdG9yZS5taXhpbnMpIHtcbiAgICAgICAgU3RvcmUubWl4aW5zLmZvckVhY2goZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgICAgICAgIG1peEludG8oU3RvcmUucHJvdG90eXBlLCBtaXhpbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaXhJbnRvKFN0b3JlLnByb3RvdHlwZSwgc3BlYyk7XG5cbiAgICByZXR1cm4gU3RvcmU7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSBwYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBwYXJ0aWFsbHlBcHBsaWVkKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwiXCIgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZGlzcGF0Y2hyL3V0aWxzL2NyZWF0ZVN0b3JlJyk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMby1EYXNoIDIuNC4xIChDdXN0b20gQnVpbGQpIDxodHRwOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gLW8gLi9kaXN0L2xvZGFzaC5qc2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTMgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuNS4yIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZSBFUzUgZW52aXJvbm1lbnRzICovXG4gIHZhciB1bmRlZmluZWQ7XG5cbiAgLyoqIFVzZWQgdG8gcG9vbCBhcnJheXMgYW5kIG9iamVjdHMgdXNlZCBpbnRlcm5hbGx5ICovXG4gIHZhciBhcnJheVBvb2wgPSBbXSxcbiAgICAgIG9iamVjdFBvb2wgPSBbXTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIHRvIHByZWZpeCBrZXlzIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGBfX3Byb3RvX19gIGFuZCBwcm9wZXJ0aWVzIG9uIGBPYmplY3QucHJvdG90eXBlYCAqL1xuICB2YXIga2V5UHJlZml4ID0gK25ldyBEYXRlICsgJyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gNzU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heCBzaXplIG9mIHRoZSBgYXJyYXlQb29sYCBhbmQgYG9iamVjdFBvb2xgICovXG4gIHZhciBtYXhQb29sU2l6ZSA9IDQwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBhbmQgdGVzdCB3aGl0ZXNwYWNlICovXG4gIHZhciB3aGl0ZXNwYWNlID0gKFxuICAgIC8vIHdoaXRlc3BhY2VcbiAgICAnIFxcdFxceDBCXFxmXFx4QTBcXHVmZWZmJyArXG5cbiAgICAvLyBsaW5lIHRlcm1pbmF0b3JzXG4gICAgJ1xcblxcclxcdTIwMjhcXHUyMDI5JyArXG5cbiAgICAvLyB1bmljb2RlIGNhdGVnb3J5IFwiWnNcIiBzcGFjZSBzZXBhcmF0b3JzXG4gICAgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDAnXG4gICk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZSAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIEVTNiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXG4gICAqIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWxpdGVyYWxzLXN0cmluZy1saXRlcmFsc1xuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkgKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IDA7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCBzaG9ydGN1dHMgKi9cbiAgdmFyIGFyZ3NDbGFzcyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlDbGFzcyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBib29sQ2xhc3MgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXScsXG4gICAgICBmdW5jQ2xhc3MgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgbnVtYmVyQ2xhc3MgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG9iamVjdENsYXNzID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgICByZWdleHBDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc3RyaW5nQ2xhc3MgPSAnW29iamVjdCBTdHJpbmddJztcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBvYmplY3QgY2xhc3NpZmljYXRpb25zIHRoYXQgYF8uY2xvbmVgIHN1cHBvcnRzICovXG4gIHZhciBjbG9uZWFibGVDbGFzc2VzID0ge307XG4gIGNsb25lYWJsZUNsYXNzZXNbZnVuY0NsYXNzXSA9IGZhbHNlO1xuICBjbG9uZWFibGVDbGFzc2VzW2FyZ3NDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2FycmF5Q2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tib29sQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tkYXRlQ2xhc3NdID1cbiAgY2xvbmVhYmxlQ2xhc3Nlc1tudW1iZXJDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW29iamVjdENsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbcmVnZXhwQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tzdHJpbmdDbGFzc10gPSB0cnVlO1xuXG4gIC8qKiBVc2VkIGFzIGFuIGludGVybmFsIGBfLmRlYm91bmNlYCBvcHRpb25zIG9iamVjdCAqL1xuICB2YXIgZGVib3VuY2VPcHRpb25zID0ge1xuICAgICdsZWFkaW5nJzogZmFsc2UsXG4gICAgJ21heFdhaXQnOiAwLFxuICAgICd0cmFpbGluZyc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yIGBfX2JpbmREYXRhX19gICovXG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICdjb25maWd1cmFibGUnOiBmYWxzZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IG51bGwsXG4gICAgJ3dyaXRhYmxlJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgKi9cbiAgdmFyIHJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KSB8fCB0aGlzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AgKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbiAgLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYCAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyAmJiBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBiaW5hcnkgc2VhcmNoZXNcbiAgICogb3IgYGZyb21JbmRleGAgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgMGAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGUuY2FjaGU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3ZhbHVlXSA/IDAgOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgIH1cbiAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWU7XG4gICAgY2FjaGUgPSAoY2FjaGUgPSBjYWNoZVt0eXBlXSkgJiYgY2FjaGVba2V5XTtcblxuICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnXG4gICAgICA/IChjYWNoZSAmJiBiYXNlSW5kZXhPZihjYWNoZSwgdmFsdWUpID4gLTEgPyAwIDogLTEpXG4gICAgICA6IChjYWNoZSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIHZhbHVlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNhY2hlIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAodHlwZUNhY2hlW2tleV0gfHwgKHR5cGVDYWNoZVtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5tYXhgIGFuZCBgXy5taW5gIGFzIHRoZSBkZWZhdWx0IGNhbGxiYWNrIHdoZW4gYSBnaXZlblxuICAgKiBjb2xsZWN0aW9uIGlzIGEgc3RyaW5nIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGNoYXJhY3RlciB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2RlIHVuaXQgb2YgZ2l2ZW4gY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhckF0Q2FsbGJhY2sodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBzb3J0QnlgIHRvIGNvbXBhcmUgdHJhbnNmb3JtZWQgYGNvbGxlY3Rpb25gIGVsZW1lbnRzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWMgPSBhLmNyaXRlcmlhLFxuICAgICAgICBiYyA9IGIuY3JpdGVyaWEsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFjLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhY1tpbmRleF0sXG4gICAgICAgICAgb3RoZXIgPSBiY1tpbmRleF07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gb3RoZXIgfHwgdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgb3RoZXIgfHwgdHlwZW9mIG90aGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yXG4gICAgLy8gYGFgIGFuZCBgYmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgIC8vIFNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2FjaGUgb2JqZWN0IHRvIG9wdGltaXplIGxpbmVhciBzZWFyY2hlcyBvZiBsYXJnZSBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICogQHJldHVybnMge251bGx8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBvYmplY3Qgb3IgYG51bGxgIGlmIGNhY2hpbmcgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBmaXJzdCA9IGFycmF5WzBdLFxuICAgICAgICBtaWQgPSBhcnJheVsobGVuZ3RoIC8gMikgfCAwXSxcbiAgICAgICAgbGFzdCA9IGFycmF5W2xlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PSAnb2JqZWN0JyAmJlxuICAgICAgICBtaWQgJiYgdHlwZW9mIG1pZCA9PSAnb2JqZWN0JyAmJiBsYXN0ICYmIHR5cGVvZiBsYXN0ID09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkXG4gICAqIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGFycmF5IGZyb20gdGhlIGFycmF5IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIGFycmF5IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcnJheSgpIHtcbiAgICByZXR1cm4gYXJyYXlQb29sLnBvcCgpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IGZyb20gdGhlIG9iamVjdCBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIHRoZSBwb29sIGlzIGVtcHR5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgb2JqZWN0IGZyb20gdGhlIHBvb2wuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIG9iamVjdFBvb2wucG9wKCkgfHwge1xuICAgICAgJ2FycmF5JzogbnVsbCxcbiAgICAgICdjYWNoZSc6IG51bGwsXG4gICAgICAnY3JpdGVyaWEnOiBudWxsLFxuICAgICAgJ2ZhbHNlJzogZmFsc2UsXG4gICAgICAnaW5kZXgnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cnVlJzogZmFsc2UsXG4gICAgICAndW5kZWZpbmVkJzogZmFsc2UsXG4gICAgICAndmFsdWUnOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gb2JqZWN0IGJhY2sgdG8gdGhlIG9iamVjdCBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZU9iamVjdChvYmplY3QpIHtcbiAgICB2YXIgY2FjaGUgPSBvYmplY3QuY2FjaGU7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICByZWxlYXNlT2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gICAgb2JqZWN0LmFycmF5ID0gb2JqZWN0LmNhY2hlID0gb2JqZWN0LmNyaXRlcmlhID0gb2JqZWN0Lm9iamVjdCA9IG9iamVjdC5udW1iZXIgPSBvYmplY3Quc3RyaW5nID0gb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICBpZiAob2JqZWN0UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgb2JqZWN0UG9vbC5wdXNoKG9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWNlcyB0aGUgYGNvbGxlY3Rpb25gIGZyb20gdGhlIGBzdGFydGAgaW5kZXggdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLFxuICAgKiB0aGUgYGVuZGAgaW5kZXguXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAgdG8gc3VwcG9ydCBub2RlIGxpc3RzXG4gICAqIGluIElFIDwgOSBhbmQgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIGluZGV4LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVuZCAtIHN0YXJ0IHx8IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uIHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0IG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCkge1xuICAgIC8vIEF2b2lkIGlzc3VlcyB3aXRoIHNvbWUgRVMzIGVudmlyb25tZW50cyB0aGF0IGF0dGVtcHQgdG8gdXNlIHZhbHVlcywgbmFtZWRcbiAgICAvLyBhZnRlciBidWlsdC1pbiBjb25zdHJ1Y3RvcnMgbGlrZSBgT2JqZWN0YCwgZm9yIHRoZSBjcmVhdGlvbiBvZiBsaXRlcmFscy5cbiAgICAvLyBFUzUgY2xlYXJzIHRoaXMgdXAgYnkgc3RhdGluZyB0aGF0IGxpdGVyYWxzIG11c3QgdXNlIGJ1aWx0LWluIGNvbnN0cnVjdG9ycy5cbiAgICAvLyBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKSA6IHJvb3Q7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBub0NvbmZsaWN0YCAqL1xuICAgIHZhciBvbGREYXNoID0gY29udGV4dC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgW1tDbGFzc11dIG9mIHZhbHVlcyAqL1xuICAgIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICAgIHZhciByZU5hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgU3RyaW5nKHRvU3RyaW5nKVxuICAgICAgICAucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxuICAgICAgICAucmVwbGFjZSgvdG9TdHJpbmd8IGZvciBbXlxcXV0rL2csICcuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgKi9cbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgY2xlYXJUaW1lb3V0ID0gY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2YgPSBpc05hdGl2ZShnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2UsXG4gICAgICAgIHVuc2hpZnQgPSBhcnJheVJlZi51bnNoaWZ0O1xuXG4gICAgLyoqIFVzZWQgdG8gc2V0IG1ldGEgZGF0YSBvbiBmdW5jdGlvbnMgKi9cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJRSA4IG9ubHkgYWNjZXB0cyBET00gZWxlbWVudHNcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge30sXG4gICAgICAgICAgICBmdW5jID0gaXNOYXRpdmUoZnVuYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgZnVuYyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMobywgbywgbykgJiYgZnVuYztcbiAgICAgIH0gY2F0Y2goZSkgeyB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKSk7XG5cbiAgICAvKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyBmb3IgbWV0aG9kcyB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcyAqL1xuICAgIHZhciBuYXRpdmVDcmVhdGUgPSBpc05hdGl2ZShuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSBpc05hdGl2ZShuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSkgJiYgbmF0aXZlSXNBcnJheSxcbiAgICAgICAgbmF0aXZlSXNGaW5pdGUgPSBjb250ZXh0LmlzRmluaXRlLFxuICAgICAgICBuYXRpdmVJc05hTiA9IGNvbnRleHQuaXNOYU4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBpc05hdGl2ZShuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMpICYmIG5hdGl2ZUtleXMsXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlUGFyc2VJbnQgPSBjb250ZXh0LnBhcnNlSW50LFxuICAgICAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCBhIGJ1aWx0LWluIGNvbnN0cnVjdG9yIGJ5IFtbQ2xhc3NdXSAqL1xuICAgIHZhciBjdG9yQnlDbGFzcyA9IHt9O1xuICAgIGN0b3JCeUNsYXNzW2FycmF5Q2xhc3NdID0gQXJyYXk7XG4gICAgY3RvckJ5Q2xhc3NbYm9vbENsYXNzXSA9IEJvb2xlYW47XG4gICAgY3RvckJ5Q2xhc3NbZGF0ZUNsYXNzXSA9IERhdGU7XG4gICAgY3RvckJ5Q2xhc3NbZnVuY0NsYXNzXSA9IEZ1bmN0aW9uO1xuICAgIGN0b3JCeUNsYXNzW29iamVjdENsYXNzXSA9IE9iamVjdDtcbiAgICBjdG9yQnlDbGFzc1tudW1iZXJDbGFzc10gPSBOdW1iZXI7XG4gICAgY3RvckJ5Q2xhc3NbcmVnZXhwQ2xhc3NdID0gUmVnRXhwO1xuICAgIGN0b3JCeUNsYXNzW3N0cmluZ0NsYXNzXSA9IFN0cmluZztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gZW5hYmxlIGludHVpdGl2ZVxuICAgICAqIG1ldGhvZCBjaGFpbmluZy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uIHRvIExvLURhc2ggbWV0aG9kcywgd3JhcHBlcnMgYWxzbyBoYXZlIHRoZSBmb2xsb3dpbmcgYEFycmF5YCBtZXRob2RzOlxuICAgICAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGByZXZlcnNlYCwgYHNoaWZ0YCwgYHNsaWNlYCwgYHNvcnRgLCBgc3BsaWNlYCxcbiAgICAgKiBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgYWZ0ZXJgLCBgYXNzaWduYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNoYWluYCwgYGNvbXBhY3RgLFxuICAgICAqIGBjb21wb3NlYCwgYGNvbmNhdGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsIGBjcmVhdGVDYWxsYmFja2AsIGBjdXJyeWAsXG4gICAgICogYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLFxuICAgICAqIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsXG4gICAgICogYGZ1bmN0aW9uc2AsIGBncm91cEJ5YCwgYGluZGV4QnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW52ZXJ0YCxcbiAgICAgKiBgaW52b2tlYCwgYGtleXNgLCBgbWFwYCwgYG1heGAsIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1pbmAsIGBvYmplY3RgLCBgb21pdGAsXG4gICAgICogYG9uY2VgLCBgcGFpcnNgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGlja2AsIGBwbHVja2AsIGBwdWxsYCwgYHB1c2hgLFxuICAgICAqIGByYW5nZWAsIGByZWplY3RgLCBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzaHVmZmxlYCwgYHNsaWNlYCwgYHNvcnRgLFxuICAgICAqIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aW1lc2AsIGB0b0FycmF5YCwgYHRyYW5zZm9ybWAsXG4gICAgICogYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsIGB1bnppcGAsIGB2YWx1ZXNgLCBgd2hlcmVgLCBgd2l0aG91dGAsIGB3cmFwYCxcbiAgICAgKiBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsXG4gICAgICogYGZpbmRLZXlgLCBgZmluZExhc3RgLCBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBoYXNgLCBgaWRlbnRpdHlgLFxuICAgICAqIGBpbmRleE9mYCwgYGlzQXJndW1lbnRzYCwgYGlzQXJyYXlgLCBgaXNCb29sZWFuYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLFxuICAgICAqIGBpc0VtcHR5YCwgYGlzRXF1YWxgLCBgaXNGaW5pdGVgLCBgaXNGdW5jdGlvbmAsIGBpc05hTmAsIGBpc051bGxgLCBgaXNOdW1iZXJgLFxuICAgICAqIGBpc09iamVjdGAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGpvaW5gLFxuICAgICAqIGBsYXN0SW5kZXhPZmAsIGBtaXhpbmAsIGBub0NvbmZsaWN0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCxcbiAgICAgKiBgcmVkdWNlUmlnaHRgLCBgcmVzdWx0YCwgYHNoaWZ0YCwgYHNpemVgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBydW5JbkNvbnRleHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGFuZCBgdmFsdWVgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBmdW5jdGlvbnMgYGZpcnN0YCBhbmQgYGxhc3RgIHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGBuYCBpc1xuICAgICAqIHByb3ZpZGVkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEV4cGxpY2l0IGNoYWluaW5nIGNhbiBiZSBlbmFibGVkIGJ5IHVzaW5nIHRoZSBgXy5jaGFpbmAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWVcbiAgICAgKiB3cmFwcGVkLnJlZHVjZShmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGEgd3JhcHBlZCB2YWx1ZVxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICogbnVtO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAvLyBkb24ndCB3cmFwIGlmIGFscmVhZHkgd3JhcHBlZCwgZXZlbiBpZiB3cmFwcGVkIGJ5IGEgZGlmZmVyZW50IGBsb2Rhc2hgIGNvbnN0cnVjdG9yXG4gICAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpXG4gICAgICAgPyB2YWx1ZVxuICAgICAgIDogbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZmFzdCBwYXRoIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoYWluQWxsIEEgZmxhZyB0byBlbmFibGUgY2hhaW5pbmcgZm9yIGFsbCBtZXRob2RzXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBgbmV3IGxvZGFzaFdyYXBwZXJgIGlzIGFuIGluc3RhbmNlIG9mIGBsb2Rhc2hgXG4gICAgbG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBsb2Rhc2gucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZmxhZyBlbnZpcm9ubWVudHMgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICB2YXIgc3VwcG9ydCA9IGxvZGFzaC5zdXBwb3J0ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgZnVuY3Rpb25zIGNhbiBiZSBkZWNvbXBpbGVkIGJ5IGBGdW5jdGlvbiN0b1N0cmluZ2BcbiAgICAgKiAoYWxsIGJ1dCBQUzMgYW5kIG9sZGVyIE9wZXJhIG1vYmlsZSBicm93c2VycyAmIGF2b2lkZWQgaW4gV2luZG93cyA4IGFwcHMpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNEZWNvbXAgPSAhaXNOYXRpdmUoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgLy8gYXZvaWQgYGFyZ3VtZW50c2Agb2JqZWN0IGRlb3B0aW1pemF0aW9ucyBieSB1c2luZyBgc2xpY2VgIGluc3RlYWRcbiAgICAgICAgICAvLyBvZiBgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGxgIGFuZCBub3QgYXNzaWduaW5nIGBhcmd1bWVudHNgIHRvIGFcbiAgICAgICAgICAvLyB2YXJpYWJsZSBhcyBhIHRlcm5hcnkgZXhwcmVzc2lvblxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UocGFydGlhbEFyZ3MpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShwYXJ0aWFsQXJncyk7XG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzIHx8IGlzQ3VycnkpIHtcbiAgICAgICAgICBhcmdzIHx8IChhcmdzID0gc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgICAgaWYgKHBhcnRpYWxSaWdodEFyZ3MpIHtcbiAgICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0N1cnJ5ICYmIGFyZ3MubGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgfD0gMTYgJiB+MzI7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUNyZWF0ZVdyYXBwZXIoW2Z1bmMsIChpc0N1cnJ5Qm91bmQgPyBiaXRtYXNrIDogYml0bWFzayAmIH4zKSwgYXJncywgbnVsbCwgdGhpc0FyZywgYXJpdHldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncyB8fCAoYXJncyA9IGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChpc0JpbmRLZXkpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0JpbmRpbmdba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKGZ1bmMucHJvdG90eXBlKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRpZmZlcmVuY2VgIHRoYXQgYWNjZXB0cyBhIHNpbmdsZSBhcnJheVxuICAgICAqIG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICBpc0xhcmdlID0gbGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmIGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBpbmRleE9mID0gY2FjaGVJbmRleE9mO1xuICAgICAgICAgIHZhbHVlcyA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoaW5kZXhPZih2YWx1ZXMsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3QodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aG91dCBzdXBwb3J0IGZvciBjYWxsYmFja1xuICAgICAqIHNob3J0aGFuZHMgb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3Q9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGFycmF5cyBhbmQgYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc3RhcnQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGlzU3RyaWN0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgJiYgKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUZsYXR0ZW4odmFsdWUsIGlzU2hhbGxvdywgaXNTdHJpY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsSW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgdmFsTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgICByZXNJbmRleCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICByZXN1bHQubGVuZ3RoICs9IHZhbExlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKyt2YWxJbmRleCA8IHZhbExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWVbdmFsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAsIHdpdGhvdXQgc3VwcG9ydCBmb3IgYHRoaXNBcmdgIGJpbmRpbmcsXG4gICAgICogdGhhdCBhbGxvd3MgcGFydGlhbCBcIl8ud2hlcmVcIiBzdHlsZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXNXaGVyZT1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHBlcmZvcm1pbmcgcGFydGlhbCBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0I9W11dIFRyYWNrcyB0cmF2ZXJzZWQgYGJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbChhLCBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhhLCBiKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIC8vIHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBhLFxuICAgICAgICAgIG90aGVyVHlwZSA9IHR5cGVvZiBiO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGZvciB1bmxpa2UgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgaWYgKGEgPT09IGEgJiZcbiAgICAgICAgICAhKGEgJiYgb2JqZWN0VHlwZXNbdHlwZV0pICYmXG4gICAgICAgICAgIShiICYmIG9iamVjdFR5cGVzW290aGVyVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXZvaWRpbmcgRVMzJ3MgRnVuY3Rpb24jY2FsbCBiZWhhdmlvclxuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgcmV0dXJuICthID09ICtiO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyQ2xhc3M6XG4gICAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIChhICE9ICthKVxuICAgICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgICAvLyBidXQgdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgICAgICAgIDogKGEgPT0gMCA/ICgxIC8gYSA9PSAxIC8gYikgOiBhID09ICtiKTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgKGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMTAuNi40KVxuICAgICAgICAgIC8vIHRyZWF0IHN0cmluZyBwcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCBpbnN0YW5jZXMgYXMgZXF1YWxcbiAgICAgICAgICByZXR1cm4gYSA9PSBTdHJpbmcoYik7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlmICghaXNBcnIpIHtcbiAgICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgICB2YXIgYVdyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgYldyYXBwZWQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgICAgIGlmIChhV3JhcHBlZCB8fCBiV3JhcHBlZCkge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhV3JhcHBlZCA/IGEuX193cmFwcGVkX18gOiBhLCBiV3JhcHBlZCA/IGIuX193cmFwcGVkX18gOiBiLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4aXQgZm9yIGZ1bmN0aW9ucyBhbmQgRE9NIG5vZGVzXG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gb2JqZWN0Q2xhc3MpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgT3BlcmEsIGBhcmd1bWVudHNgIG9iamVjdHMgaGF2ZSBgQXJyYXlgIGNvbnN0cnVjdG9yc1xuICAgICAgICB2YXIgY3RvckEgPSBhLmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgY3RvckIgPSBiLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICAgIGlmIChjdG9yQSAhPSBjdG9yQiAmJlxuICAgICAgICAgICAgICAhKGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiYgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQikgJiZcbiAgICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFzc3VtZSBjeWNsaWMgc3RydWN0dXJlcyBhcmUgZXF1YWxcbiAgICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgICAvLyBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuICAgICAgICByZXN1bHQgPSBzaXplID09IGxlbmd0aDtcblxuICAgICAgICBpZiAocmVzdWx0IHx8IGlzV2hlcmUpIHtcbiAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzXG4gICAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYltzaXplXTtcblxuICAgICAgICAgICAgaWYgKGlzV2hlcmUpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbaW5kZXhdLCB2YWx1ZSwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKGFbc2l6ZV0sIHZhbHVlLCBjYWxsYmFjaywgaXNXaGVyZSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBkZWVwIGNvbXBhcmUgb2JqZWN0cyB1c2luZyBgZm9ySW5gLCBpbnN0ZWFkIG9mIGBmb3JPd25gLCB0byBhdm9pZCBgT2JqZWN0LmtleXNgXG4gICAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXkpKSB7XG4gICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAvLyBkZWVwIGNvbXBhcmUgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICAgIGZvckluKGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGEpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9IC0tc2l6ZSA+IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tBLnBvcCgpO1xuICAgICAgc3RhY2tCLnBvcCgpO1xuXG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgIHNlZW4gPSBjYWNoZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY2FsbGJhY2sgPyBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSA6IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc1NvcnRlZFxuICAgICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICAgIDogaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbi5hcnJheSk7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWdncmVnYXRlcyBhIGNvbGxlY3Rpb24sIGNyZWF0aW5nIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2suIFRoZSBnaXZlbiBgc2V0dGVyYCBmdW5jdGlvbiBzZXRzIHRoZSBrZXlzIGFuZCB2YWx1ZXNcbiAgICAgKiBvZiB0aGUgY29tcG9zZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIHNldHRlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgc2V0dGVyKHJlc3VsdCwgdmFsdWUsIGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgXG4gICAgICogd2l0aCBhbiBvcHRpb25hbCBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIG1ldGhvZCBmbGFncyB0byBjb21wb3NlLlxuICAgICAqICBUaGUgYml0bWFzayBtYXkgYmUgY29tcG9zZWQgb2YgdGhlIGZvbGxvd2luZyBmbGFnczpcbiAgICAgKiAgMSAtIGBfLmJpbmRgXG4gICAgICogIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICA0IC0gYF8uY3VycnlgXG4gICAgICogIDggLSBgXy5jdXJyeWAgKGJvdW5kKVxuICAgICAqICAxNiAtIGBfLnBhcnRpYWxgXG4gICAgICogIDMyIC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsQXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2VcbiAgICAgKiAgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbFJpZ2h0QXJnc10gQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGZ1bmMsIGJpdG1hc2ssIHBhcnRpYWxBcmdzLCBwYXJ0aWFsUmlnaHRBcmdzLCB0aGlzQXJnLCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiAxLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiAyLFxuICAgICAgICAgIGlzQ3VycnkgPSBiaXRtYXNrICYgNCxcbiAgICAgICAgICBpc0N1cnJ5Qm91bmQgPSBiaXRtYXNrICYgOCxcbiAgICAgICAgICBpc1BhcnRpYWwgPSBiaXRtYXNrICYgMTYsXG4gICAgICAgICAgaXNQYXJ0aWFsUmlnaHQgPSBiaXRtYXNrICYgMzI7XG5cbiAgICAgIGlmICghaXNCaW5kS2V5ICYmICFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsICYmICFwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MTY7XG4gICAgICAgIGlzUGFydGlhbCA9IHBhcnRpYWxBcmdzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQgJiYgIXBhcnRpYWxSaWdodEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfjMyO1xuICAgICAgICBpc1BhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBiaW5kRGF0YSA9IGZ1bmMgJiYgZnVuYy5fX2JpbmREYXRhX187XG4gICAgICBpZiAoYmluZERhdGEgJiYgYmluZERhdGEgIT09IHRydWUpIHtcbiAgICAgICAgLy8gY2xvbmUgYGJpbmREYXRhYFxuICAgICAgICBiaW5kRGF0YSA9IHNsaWNlKGJpbmREYXRhKTtcbiAgICAgICAgaWYgKGJpbmREYXRhWzJdKSB7XG4gICAgICAgICAgYmluZERhdGFbMl0gPSBzbGljZShiaW5kRGF0YVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmREYXRhWzNdKSB7XG4gICAgICAgICAgYmluZERhdGFbM10gPSBzbGljZShiaW5kRGF0YVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICB1bnNoaWZ0LmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyAmJiByZU5hdGl2ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBpc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYSBnaXZlbiB2YWx1ZVxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgICAqIHRoZXJlIGFyZSBubyBgT2JqZWN0LnByb3RvdHlwZWAgZXh0ZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIGN0b3IsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAvLyBhdm9pZCBub24gT2JqZWN0IG9iamVjdHMsIGBhcmd1bWVudHNgIG9iamVjdHMsIGFuZCBET00gZWxlbWVudHNcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSB8fFxuICAgICAgICAgIChjdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIGlzRnVuY3Rpb24oY3RvcikgJiYgIShjdG9yIGluc3RhbmNlb2YgY3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgdmFyIHNoaW1LZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtleXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAgICogb2YgYSB0YWcgb3IgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgICAqL1xuICAgIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiMzOTsnXG4gICAgfTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gICAgdmFyIGh0bWxVbmVzY2FwZXMgPSBpbnZlcnQoaHRtbEVzY2FwZXMpO1xuXG4gICAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzICovXG4gICAgdmFyIHJlRXNjYXBlZEh0bWwgPSBSZWdFeHAoJygnICsga2V5cyhodG1sVW5lc2NhcGVzKS5qb2luKCd8JykgKyAnKScsICdnJyksXG4gICAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cCgnWycgKyBrZXlzKGh0bWxFc2NhcGVzKS5qb2luKCcnKSArICddJywgJ2cnKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICAgKiBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnZnJlZCcgfSwgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgYSA9PSAndW5kZWZpbmVkJyA/IGIgOiBhO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIGRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrKHJlc3VsdFtpbmRleF0sIGl0ZXJhYmxlW2luZGV4XSkgOiBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIHdpbGwgYWxzb1xuICAgICAqIGJlIGNsb25lZCwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBiZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKGNoYXJhY3RlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKGNoYXJhY3RlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oe1xuICAgICAqICAgJ2Nsb25lJzogXy5wYXJ0aWFsUmlnaHQoXy5jbG9uZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICogICB9KVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZShkb2N1bWVudC5ib2R5KTtcbiAgICAgKiBjbG9uZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgXG4gICAgICAvLyBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50cyBmb3IgYGlzRGVlcGAgYW5kIGBjYWxsYmFja2BcbiAgICAgIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlXG4gICAgICogZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtLiBGdW5jdGlvbnNcbiAgICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIGNsb25lZC4gVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZFxuICAgICAqIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoY2hhcmFjdGVycyk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwgeyAnY29uc3RydWN0b3InOiBDaXJjbGUgfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgd2l0aG91dCB1c2luZyBpdHNcbiAgICAgKiAgYGtleWAgYW5kIGBvYmplY3RgIGFyZ3VtZW50cyBhcyBzb3VyY2VzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIF8uZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2luZGV4XSA9PSAndW5kZWZpbmVkJykgcmVzdWx0W2luZGV4XSA9IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCwgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duUmlnaHQob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LFxuICAgICAqIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ21vdmUnLCAneScsIGFuZCAneCcgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHBhaXJzLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2socGFpcnNbbGVuZ3RoLS1dLCBwYWlyc1tsZW5ndGhdLCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQoeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbGVuZ3RoJywgJzEnLCBhbmQgJzAnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUgZXhpc3RzIGFzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLFxuICAgICAqIGluc3RlYWQgb2YgYW4gaW5oZXJpdGVkIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYga2V5IGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGFzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPyBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZlcnQoeyAnZmlyc3QnOiAnZnJlZCcsICdzZWNvbmQnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogJ2ZpcnN0JywgJ2Jhcm5leSc6ICdzZWNvbmQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYm9vbENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZGF0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm5vZGVUeXBlID09PSAxIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAgICogbGVuZ3RoIG9mIGAwYCBhbmQgb2JqZWN0cyB3aXRoIG5vIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvbnNpZGVyZWRcbiAgICAgKiBcImVtcHR5XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgnJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgaWYgKChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcyB8fCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IGFyZ3NDbGFzcyApIHx8XG4gICAgICAgICAgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyAmJiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3JPd24odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudCB0byBlYWNoIG90aGVyLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWRcbiAgICAgKiB0byBjb21wYXJlIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY29tcGFyaXNvbnMgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAoYSwgYikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PSBjb3B5O1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBjb3B5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgd29yZHMgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXJXb3JkcyA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKHdvcmRzLCBvdGhlcldvcmRzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICB2YXIgcmVHcmVldCA9IC9eKD86aGVsbG98aGkpJC9pLFxuICAgICAqICAgICAgIGFHcmVldCA9IF8uaXNTdHJpbmcoYSkgJiYgcmVHcmVldC50ZXN0KGEpLFxuICAgICAqICAgICAgIGJHcmVldCA9IF8uaXNTdHJpbmcoYikgJiYgcmVHcmVldC50ZXN0KGIpO1xuICAgICAqXG4gICAgICogICByZXR1cm4gKGFHcmVldCB8fCBiR3JlZXQpID8gKGFHcmVldCA9PSBiR3JlZXQpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYSwgYiwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMsIG9yIGNhbiBiZSBjb2VyY2VkIHRvLCBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzRmluaXRlYCB3aGljaCB3aWxsIHJldHVybiB0cnVlIGZvclxuICAgICAqIGJvb2xlYW5zIGFuZCBlbXB0eSBzdHJpbmdzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGZpbml0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKC0xMDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzEwJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSh0cnVlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSkgJiYgIW5hdGl2ZUlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3QuXG4gICAgICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDhcbiAgICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MVxuICAgICAgcmV0dXJuICEhKHZhbHVlICYmIG9iamVjdFR5cGVzW3R5cGVvZiB2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc05hTmAgd2hpY2ggd2lsbCByZXR1cm4gYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtZXJpYyB2YWx1ZXMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi40LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBgTmFOYCBhcyBhIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGZcbiAgICAgIC8vIChwZXJmb3JtIHRoZSBbW0NsYXNzXV0gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZSBob3N0IG9iamVjdHMgaW4gSUUpXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogYE5hTmAgaXMgY29uc2lkZXJlZCBhIG51bWJlci4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OC41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcig4LjQgKiA1KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlckNsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IFNoYXBlKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICB2YXIgaXNQbGFpbk9iamVjdCA9ICFnZXRQcm90b3R5cGVPZiA/IHNoaW1Jc1BsYWluT2JqZWN0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSBpc05hdGl2ZSh2YWx1ZU9mKSAmJiAob2JqUHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZU9mKSkgJiYgZ2V0UHJvdG90eXBlT2Yob2JqUHJvdG8pO1xuXG4gICAgICByZXR1cm4gb2JqUHJvdG9cbiAgICAgICAgPyAodmFsdWUgPT0gb2JqUHJvdG8gfHwgZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvKVxuICAgICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9mcmVkLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cENsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZCBieVxuICAgICAqIHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJvdWdoIHRoZSBjYWxsYmFjay5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdmFsdWVzIG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogM30gLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXBWYWx1ZXMoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0KHMpLCB0aGF0XG4gICAgICogZG9uJ3QgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGEgY2FsbGJhY2sgaXNcbiAgICAgKiBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uXG4gICAgICogYW5kIHNvdXJjZSBwcm9wZXJ0aWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBtZXJnaW5nIHdpbGxcbiAgICAgKiBiZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnaW5nIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbmFtZXMgPSB7XG4gICAgICogICAnY2hhcmFjdGVycyc6IFtcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdiYXJuZXknIH0sXG4gICAgICogICAgIHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICdhZ2UnOiAzNiB9LFxuICAgICAqICAgICB7ICdhZ2UnOiA0MCB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UobmFtZXMsIGFnZXMpO1xuICAgICAqIC8vID0+IHsgJ2NoYXJhY3RlcnMnOiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1dIH1cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYXBwbGUnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydiZWV0J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyRm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2JhbmFuYSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2NhcnJvdCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UoZm9vZCwgb3RoZXJGb29kLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICogICByZXR1cm4gXy5pc0FycmF5KGEpID8gYS5jb25jYXQoYikgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZnJ1aXRzJzogWydhcHBsZScsICdiYW5hbmEnXSwgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnLCAnY2Fycm90XSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2Uob2JqZWN0KSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBsZW5ndGggPSAyO1xuXG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgIHdpdGhvdXQgdXNpbmdcbiAgICAgIC8vIHRoZWlyIGBpbmRleGAgYW5kIGBjb2xsZWN0aW9uYCBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSAhPSAnbnVtYmVyJykge1xuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPiAzICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDJdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGFyZ3NbLS1sZW5ndGggLSAxXSwgYXJnc1tsZW5ndGgtLV0sIDIpO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIHR5cGVvZiBhcmdzW2xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tbGVuZ3RoXTtcbiAgICAgIH1cbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UoYXJndW1lbnRzLCAxLCBsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgc3RhY2tBID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBzdGFja0IgPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2VzW2luZGV4XSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGV4Y2x1ZGluZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgb21pdHRpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIHByb3BlcnRpZXMgdG8gb21pdCBvciB0aGVcbiAgICAgKiAgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aG91dCB0aGUgb21pdHRlZCBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ub21pdCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcic7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3BzID0gYmFzZURpZmZlcmVuY2UocHJvcHMsIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIGFuIG9iamVjdCdzIGtleS12YWx1ZSBwYWlycyxcbiAgICAgKiBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ2Jhcm5leSc6IDM2LCAnZnJlZCc6IDQwIH0pO1xuICAgICAqIC8vID0+IFtbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdXSAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBjb21wb3NlZCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoXG4gICAgICogcHJvcGVydHkgb2YgYG9iamVjdGAgcGlja2luZyB0aGUgcHJvcGVydGllcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleVxuICAgICAqIGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufC4uLnN0cmluZ3xzdHJpbmdbXX0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZXMgdG8gcGljaywgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgcHJvcGVydHlcbiAgICAgKiAgbmFtZXMgb3IgYXJyYXlzIG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCAnbmFtZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqXG4gICAgICogXy5waWNrKHsgJ25hbWUnOiAnZnJlZCcsICdfdXNlcmlkJzogJ2ZyZWQxJyB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5LmNoYXJBdCgwKSAhPSAnXyc7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGljayhvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpLFxuICAgICAgICAgICAgbGVuZ3RoID0gaXNPYmplY3Qob2JqZWN0KSA/IHByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWAgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgdGhyb3VnaCBhIGNhbGxiYWNrLCB3aXRoIGVhY2ggY2FsbGJhY2sgZXhlY3V0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzcXVhcmVzID0gXy50cmFuc2Zvcm0oWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXSwgZnVuY3Rpb24ocmVzdWx0LCBudW0pIHtcbiAgICAgKiAgIG51bSAqPSBudW07XG4gICAgICogICBpZiAobnVtICUgMikge1xuICAgICAqICAgICByZXR1cm4gcmVzdWx0LnB1c2gobnVtKSA8IDM7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzEsIDksIDI1XVxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc0Fycikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgICBwcm90byA9IGN0b3IgJiYgY3Rvci5wcm90b3R5cGU7XG5cbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGJhc2VDcmVhdGUocHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXhlcywgb3Iga2V5cywgb2YgdGhlXG4gICAgICogYGNvbGxlY3Rpb25gLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgaW5kZXhlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdfHN0cmluZ3xzdHJpbmdbXSl9IFtpbmRleF0gVGhlIGluZGV4ZXMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogICB0byByZXRyaWV2ZSwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgaW5kZXhlcyBvciBhcnJheXMgb2YgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgcHJvdmlkZWQgaW5kZXhlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hdChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCBbMCwgMiwgNF0pO1xuICAgICAqIC8vID0+IFsnYScsICdjJywgJ2UnXVxuICAgICAqXG4gICAgICogXy5hdChbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXSwgMCwgMik7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF0KGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmdzLCB0cnVlLCBmYWxzZSwgMSksXG4gICAgICAgICAgbGVuZ3RoID0gKGFyZ3NbMl0gJiYgYXJnc1syXVthcmdzWzFdXSA9PT0gY29sbGVjdGlvbikgPyAxIDogcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNvbGxlY3Rpb25bcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgcHJlc2VudCBpbiBhIGNvbGxlY3Rpb24gdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBjaGVjayBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHRhcmdldGAgZWxlbWVudCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnZnJlZCcpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoJ3BlYmJsZXMnLCAnZWInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpID4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmVzdWx0ID0gKGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KSA6IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCsraW5kZXggPj0gZnJvbUluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gIShyZXN1bHQgPSB2YWx1ZSA9PT0gdGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgdmFsdWUgZm9yICoqYWxsKiogZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgYWxsXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZXZlcnkoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gISFjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAhIWNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0XG4gICAgICogdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkgZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdCwgZmluZFdoZXJlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYSBjb2xsZWN0aW9uLCBleGVjdXRpbmcgdGhlIGNhbGxiYWNrIGZvciBlYWNoXG4gICAgICogZWxlbWVudC4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuIENhbGxiYWNrcyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnlcbiAgICAgKiBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogTm90ZTogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgYGxlbmd0aGAgcHJvcGVydHlcbiAgICAgKiBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgYF8uZm9ySW5gIG9yIGBfLmZvck93bmBcbiAgICAgKiBtYXkgYmUgdXNlZCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fHN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoKGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgYW5kIHJldHVybnMgdGhlIG9iamVjdCAocHJvcGVydHkgb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQgYWNyb3NzIGVudmlyb25tZW50cylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2hSaWdodChmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGxvZ3MgZWFjaCBudW1iZXIgZnJvbSByaWdodCB0byBsZWZ0IGFuZCByZXR1cm5zICczLDIsMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2xlbmd0aF0sIGxlbmd0aCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBrZXkgPSBwcm9wcyA/IHByb3BzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGEgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjay4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAgKiBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IHJlc3VsdFtrZXldID0gW10pLnB1c2godmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGdpdmVuIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS5cbiAgICAgKiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBrZXlzID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShrZXlzLCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmluZGV4QnkoY2hhcmFjdGVycywgZnVuY3Rpb24oa2V5KSB7IHRoaXMuZnJvbUNoYXJDb2RlKGtleS5jb2RlKTsgfSwgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGluZGV4QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBuYW1lZCBieSBgbWV0aG9kTmFtZWAgb24gZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmBcbiAgICAgKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBtZXRob2ROYW1lYCBpcyBhIGZ1bmN0aW9uIGl0XG4gICAgICogd2lsbCBiZSBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2UoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludm9rZShjb2xsZWN0aW9uLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IChpc0Z1bmMgPyBtZXRob2ROYW1lIDogdmFsdWVbbWV0aG9kTmFtZV0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGNvbGxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldIChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1hcChjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYC1JbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXgoY2hhcmFjdGVycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50ID4gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhIGNvbGxlY3Rpb24uIElmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5IG9yXG4gICAgICogZmFsc2V5IGBJbmZpbml0eWAgaXMgcmV0dXJuZWQuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIGZvciBlYWNoIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlXG4gICAgICogaXMgcmFua2VkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHsgcmV0dXJuIGNoci5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1pbihjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGZ1bmN0aW9ucyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZ1xuICAgICAgLy8gdGhlaXIgYGluZGV4YCBhcmd1bWVudCBhcyBhIGNhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2NhbGxiYWNrXSA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoY2FsbGJhY2sgPT0gbnVsbCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSlcbiAgICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmIChjdXJyZW50IDwgY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbXB1dGVkID0gY3VycmVudDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBhbGwgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soY2hhcmFjdGVycywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICB2YXIgcGx1Y2sgPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGEgY29sbGVjdGlvbiB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIHRoZSBjYWxsYmFjaywgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogY2FsbGJhY2sgZXhlY3V0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzIGV4ZWN1dGlvbi4gSWZcbiAgICAgKiBgYWNjdW11bGF0b3JgIGlzIG5vdCBwcm92aWRlZCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvbiB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgaW5pdGlhbCBgYWNjdW11bGF0b3JgIHZhbHVlLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3VtID0gXy5yZWR1Y2UoWzEsIDIsIDNdLCBmdW5jdGlvbihzdW0sIG51bSkge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAzLCAnYic6IDYsICdjJzogOSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uKSByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG5vYWNjdW0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNvbGxlY3Rpb25bKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgICAgOiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxpc3QgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICogdmFyIGZsYXQgPSBfLnJlZHVjZVJpZ2h0KGxpc3QsIGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuICAgICAgZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBhXG4gICAgICogY29sbGVjdGlvbiB0aGF0IHRoZSBjYWxsYmFjayBkb2VzICoqbm90KiogcmV0dXJuIHRydWV5IGZvci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGZhaWxlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvZGRzID0gXy5yZWplY3QoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZWplY3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgcmFuZG9tIGVsZW1lbnQgb3IgYG5gIHJhbmRvbSBlbGVtZW50cyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gQWxsb3dzIHdvcmtpbmcgd2l0aCBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgXG4gICAgICogIHdpdGhvdXQgdXNpbmcgdGhlaXIgYGluZGV4YCBhcmd1bWVudHMgYXMgYG5gLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIHNhbXBsZShzKSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgICBjb2xsZWN0aW9uID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb25bYmFzZVJhbmRvbSgwLCBjb2xsZWN0aW9uLmxlbmd0aCAtIDEpXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzaHVmZmxlKGNvbGxlY3Rpb24pO1xuICAgICAgcmVzdWx0Lmxlbmd0aCA9IG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZSBGaXNoZXItWWF0ZXNcbiAgICAgKiBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbSgwLCArK2luZGV4KTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYSB0cnVleSB2YWx1ZSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGFcbiAgICAgKiBjb2xsZWN0aW9uLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGEgcGFzc2luZyB2YWx1ZSBhbmRcbiAgICAgKiBkb2VzIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGFueVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgd2lsbCBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc29ydCBvcmRlclxuICAgICAqIG9mIGVxdWFsIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjb2xsZWN0aW9uXG4gICAgICogd2lsbCBiZSBzb3J0ZWQgYnkgZWFjaCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAyNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDMwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoXy5zb3J0QnkoY2hhcmFjdGVycywgJ2FnZScpLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPT4gW1snYmFybmV5JywgMjZdLCBbJ2ZyZWQnLCAzMF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICpcbiAgICAgKiAvLyBzb3J0aW5nIGJ5IG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICAgKiBfLm1hcChfLnNvcnRCeShjaGFyYWN0ZXJzLCBbJ25hbWUnLCAnYWdlJ10pLCBfLnZhbHVlcyk7XG4gICAgICogLy8gPSA+IFtbJ2Jhcm5leScsIDI2XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNBcnIgPSBpc0FycmF5KGNhbGxiYWNrKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB9XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFsrK2luZGV4XSA9IGdldE9iamVjdCgpO1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBvYmplY3QuY3JpdGVyaWEgPSBtYXAoY2FsbGJhY2ssIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKG9iamVjdC5jcml0ZXJpYSA9IGdldEFycmF5KCkpWzBdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQuc29ydChjb21wYXJlQXNjZW5kaW5nKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgICAgcmVsZWFzZUFycmF5KG9iamVjdC5jcml0ZXJpYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWFzZU9iamVjdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYGNvbGxlY3Rpb25gIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTsgfSkoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlKGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBvZiBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAgdG8gdGhlIGdpdmVuXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ3BldHMnOiBbJ2hvcHB5J10gfV1cbiAgICAgKlxuICAgICAqIF8ud2hlcmUoY2hhcmFjdGVycywgeyAncGV0cyc6IFsnZGlubyddIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1dXG4gICAgICovXG4gICAgdmFyIHdoZXJlID0gZmlsdGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGFsbCBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkIGFycmF5cyB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5cyBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzEsIDIsIDMsIDQsIDVdLCBbNSwgMiwgMTBdKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA8IDIwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICogICByZXR1cm4gY2hyLmFnZSA+IDMwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb3IgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrXG4gICAgICogaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmdcbiAgICAgKiBhcyB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkLCB0YWtlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maXJzdChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmZpcnN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXJzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYSBuZXN0ZWQgYXJyYXkgKHRoZSBuZXN0aW5nIGNhbiBiZSB0byBhbnkgZGVwdGgpLiBJZiBgaXNTaGFsbG93YFxuICAgICAqIGlzIHRydWV5LCB0aGUgYXJyYXkgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgcGFzc2VkIHRocm91Z2ggdGhlIGNhbGxiYWNrIGJlZm9yZVxuICAgICAqIGZsYXR0ZW5pbmcuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhIHNpbmdsZSBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZFxuICAgICAqICB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgW1s0XV1dO1xuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzMCwgJ3BldHMnOiBbJ2hvcHB5J10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmxhdHRlbihjaGFyYWN0ZXJzLCAncGV0cycpO1xuICAgICAqIC8vID0+IFsnaG9wcHknLCAnYmFieSBwdXNzJywgJ2Rpbm8nXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXksIGlzU2hhbGxvdywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2YgaXNTaGFsbG93ICE9ICdib29sZWFuJyAmJiBpc1NoYWxsb3cgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NoYWxsb3cgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbaXNTaGFsbG93XSA9PT0gYXJyYXkpID8gbnVsbCA6IGlzU2hhbGxvdztcbiAgICAgICAgaXNTaGFsbG93ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBhcnJheSA9IG1hcChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBpc1NoYWxsb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYXJyYXkgaXMgYWxyZWFkeSBzb3J0ZWRcbiAgICAgKiBwcm92aWRpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YCB3aWxsIHJ1biBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWBcbiAgICAgKiAgdG8gcGVyZm9ybSBhIGJpbmFyeSBzZWFyY2ggb24gYSBzb3J0ZWQgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyLCAzLCAzXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhXG4gICAgICogY2FsbGJhY2sgaXMgcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIGV4Y2x1ZGVkIGZyb21cbiAgICAgKiB0aGUgcmVzdWx0IGFzIGxvbmcgYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZFxuICAgICAqIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uaW5pdGlhbChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnBsdWNrKF8uaW5pdGlhbChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICduYScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogY2FsbGJhY2sgfHwgbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgMCwgbmF0aXZlTWluKG5hdGl2ZU1heCgwLCBsZW5ndGggLSBuKSwgbGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHByZXNlbnQgaW4gYWxsIHByb3ZpZGVkIGFycmF5cyB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgY2FjaGVzID0gZ2V0QXJyYXkoKSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIHRydXN0SW5kZXhPZiA9IGluZGV4T2YgPT09IGJhc2VJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSBnZXRBcnJheSgpO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBjYWNoZXMucHVzaCh0cnVzdEluZGV4T2YgJiYgdmFsdWUubGVuZ3RoID49IGxhcmdlQXJyYXlTaXplICYmXG4gICAgICAgICAgICBjcmVhdGVDYWNoZShhcmdzSW5kZXggPyBhcmdzW2FyZ3NJbmRleF0gOiBzZWVuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IGFyZ3NbMF0sXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWzBdO1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKHNlZW4sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgYXJnc0luZGV4ID0gYXJnc0xlbmd0aDtcbiAgICAgICAgICAoY2FjaGUgfHwgc2VlbikucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcmdzW2FyZ3NJbmRleF0sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0xlbmd0aF07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoY2FjaGVzKTtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmxhc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmxhc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgaW5kZXggKyBmcm9tSW5kZXgpIDogbmF0aXZlTWluKGZyb21JbmRleCwgaW5kZXggLSAxKSkgKyAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbChhcnJheSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYHN0b3BgIGFcbiAgICAgKiB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHR5cGVvZiBzdGVwID09ICdudW1iZXInID8gc3RlcCA6ICgrc3RlcCB8fCAxKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICAvLyB1c2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlc1xuICAgICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgdGhhdCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgIHRoaXMgbWV0aG9kIGdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvclxuICAgICAqIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZCBlbGVtZW50c1xuICAgICAqIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRyb3AsIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogbmF0aXZlTWF4KDAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYSBnaXZlbiBzb3J0ZWQgYXJyYXkgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnRcbiAgICAgKiBvcmRlciBvZiB0aGUgYXJyYXkuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzIwLCAzMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0ge1xuICAgICAqICAgJ3dvcmRUb051bWJlcic6IHsgJ3R3ZW50eSc6IDIwLCAndGhpcnR5JzogMzAsICdmb3VydHknOiA0MCwgJ2ZpZnR5JzogNTAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIGRpY3Qud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgLy8gZXhwbGljaXRseSByZWZlcmVuY2UgYGlkZW50aXR5YCBmb3IgYmV0dGVyIGlubGluaW5nIGluIEZpcmVmb3hcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpIDogaWRlbnRpdHk7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgICAgKGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWUpXG4gICAgICAgICAgPyBsb3cgPSBtaWQgKyAxXG4gICAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyLCAzXSwgWzUsIDIsIDEsIDRdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA1LCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW9uKCkge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIHNvcnRlZCwgcHJvdmlkaW5nXG4gICAgICogYHRydWVgIGZvciBgaXNTb3J0ZWRgIHdpbGwgdXNlIGEgZmFzdGVyIGFsZ29yaXRobS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZFxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmUgdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicgJiYgaXNTb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NvcnRlZCAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NvcnRlZF0gPT09IGFycmF5KSA/IG51bGwgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIHN5bW1ldHJpYyBkaWZmZXJlbmNlIG9mIHRoZSBwcm92aWRlZCBhcnJheXMuXG4gICAgICogU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDNdLCBbNSwgMiwgMSwgNF0pO1xuICAgICAqIC8vID0+IFszLCA1LCA0XVxuICAgICAqXG4gICAgICogXy54b3IoWzEsIDIsIDVdLCBbMiwgMywgNV0sIFszLCA0LCA1XSk7XG4gICAgICogLy8gPT4gWzEsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24geG9yKCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoYXJyYXkpIHx8IGlzQXJndW1lbnRzKGFycmF5KSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRcbiAgICAgICAgICAgID8gYmFzZVVuaXEoYmFzZURpZmZlcmVuY2UocmVzdWx0LCBhcnJheSkuY29uY2F0KGJhc2VEaWZmZXJlbmNlKGFycmF5LCByZXN1bHQpKSlcbiAgICAgICAgICAgIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuemlwXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gQXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2ZyZWQnLCAzMCwgdHJ1ZV0sIFsnYmFybmV5JywgNDAsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXAoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50cyA6IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gbWF4KHBsdWNrKGFycmF5LCAnbGVuZ3RoJykpIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBmcm9tIGFycmF5cyBvZiBga2V5c2AgYW5kIGB2YWx1ZXNgLiBQcm92aWRlXG4gICAgICogZWl0aGVyIGEgc2luZ2xlIHR3byBkaW1lbnNpb25hbCBhcnJheSwgaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gXG4gICAgICogb3IgdHdvIGFycmF5cywgb25lIG9mIGBrZXlzYCBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgb2JqZWN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgVGhlIGFycmF5IG9mIGtleXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgZ2l2ZW4ga2V5cyBhbmRcbiAgICAgKiAgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnZnJlZCcsICdiYXJuZXknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAzMCwgJ2Jhcm5leSc6IDQwIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzID8ga2V5cy5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICBpZiAoIXZhbHVlcyAmJiBsZW5ndGggJiYgIWlzQXJyYXkoa2V5c1swXSkpIHtcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyBgZnVuY2AsIHdpdGggIHRoZSBgdGhpc2AgYmluZGluZyBhbmRcbiAgICAgKiBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIG9ubHkgYWZ0ZXIgYmVpbmcgY2FsbGVkIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcbiAgICAgKiAgYGZ1bmNgIGlzIGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnRG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICdEb25lIHNhdmluZyEnLCBhZnRlciBhbGwgc2F2ZXMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMgPSBfLmJpbmQoZnVuYywgeyAnbmFtZSc6ICdmcmVkJyB9LCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluZChmdW5jLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGZ1bmMsIDE3LCBzbGljZShhcmd1bWVudHMsIDIpLCBudWxsLCB0aGlzQXJnKVxuICAgICAgICA6IGNyZWF0ZVdyYXBwZXIoZnVuYywgMSwgbnVsbCwgbnVsbCwgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC4gTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgbWV0aG9kIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkIGFsbCB0aGUgZnVuY3Rpb24gcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgIHdpbGwgYmUgYm91bmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gW21ldGhvZE5hbWVdIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvXG4gICAgICogIGJpbmQsIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIG1ldGhvZCBuYW1lcyBvciBhcnJheXMgb2YgbWV0aG9kIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpOyB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnLCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpIDogZnVuY3Rpb25zKG9iamVjdCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBmdW5jc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgMSwgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZEtleWAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBib3VuZFxuICAgICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAgICogcmVmZXJlbmNlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIGh0dHA6Ly9taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnbmFtZSc6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLm5hbWUgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kS2V5KG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGtleSwgMTksIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIG9iamVjdClcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGtleSwgMywgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNdIEZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhbE5hbWVNYXAgPSB7XG4gICAgICogICAncGViYmxlcyc6ICdwZW5lbG9wZSdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgIG5hbWUgPSByZWFsTmFtZU1hcFtuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XG4gICAgICogICByZXR1cm4gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICogICByZXR1cm4gJ0hpeWEgJyArIGZvcm1hdHRlZCArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHdlbGNvbWUgPSBfLmNvbXBvc2UoZ3JlZXQsIGZvcm1hdCk7XG4gICAgICogd2VsY29tZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdIaXlhIFBlbmVsb3BlISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jc1tsZW5ndGhdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJncyA9IFtmdW5jc1tsZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cbiAgICAgKiBpbnZva2VkIGVpdGhlciBleGVjdXRlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgY2FuIGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgY29uc29sZS5sb2coYSArIGIgKyBjKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSkge1xuICAgICAgYXJpdHkgPSB0eXBlb2YgYXJpdHkgPT0gJ251bWJlcicgPyBhcml0eSA6ICgrYXJpdHkgfHwgZnVuYy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgNCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAgICAgKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICAgICAqIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb25cbiAgICAgKiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgbGF6eUxheW91dCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBleGVjdXRlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSwgZmFsc2UpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGV4ZWN1dGluZyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG4gICAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7IGNvbnNvbGUubG9nKHRleHQpOyB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyBsb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG9yIG1vcmUgbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkgeyBjb25zb2xlLmxvZyh0ZXh0KTsgfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gbG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWxheShmdW5jLCB3YWl0KSB7XG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHRcbiAgICAgKiBiYXNlZCBvbiB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBUaGUgcmVzdWx0IGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIEEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmlib25hY2NpID0gXy5tZW1vaXplKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMiA/IG4gOiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZpYm9uYWNjaSg5KVxuICAgICAqIC8vID0+IDM0XG4gICAgICpcbiAgICAgKiB2YXIgZGF0YSA9IHtcbiAgICAgKiAgICdmcmVkJzogeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogLy8gbW9kaWZ5aW5nIHRoZSByZXN1bHQgY2FjaGVcbiAgICAgKiB2YXIgZ2V0ID0gXy5tZW1vaXplKGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGRhdGFbbmFtZV07IH0sIF8uaWRlbnRpdHkpO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKlxuICAgICAqIGdldC5jYWNoZS5wZWJibGVzLm5hbWUgPSAncGVuZWxvcGUnO1xuICAgICAqIGdldCgncGViYmxlcycpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAncGVuZWxvcGUnLCAnYWdlJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGUsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXlQcmVmaXggKyBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSlcbiAgICAgICAgICA/IGNhY2hlW2tleV1cbiAgICAgICAgICA6IChjYWNoZVtrZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVkLmNhY2hlID0ge307XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBleGVjdXRlIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHMgdG9cbiAgICAgKiB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBjYWxsLiBUaGUgYGZ1bmNgIGlzIGV4ZWN1dGVkXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gYGluaXRpYWxpemVgIGV4ZWN1dGVzIGBjcmVhdGVBcHBsaWNhdGlvbmAgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgdmFyIHJhbixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmFuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGBmdW5jYCB2YXJpYWJsZSBzbyB0aGUgZnVuY3Rpb24gbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggYW55IGFkZGl0aW9uYWxcbiAgICAgKiBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLiBUaGlzXG4gICAgICogbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHsgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTsgfTtcbiAgICAgKiB2YXIgaGkgPSBfLnBhcnRpYWwoZ3JlZXQsICdoaScpO1xuICAgICAqIGhpKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAxNiwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBgcGFydGlhbGAgYXJndW1lbnRzIGFyZVxuICAgICAqIGFwcGVuZGVkIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzRGVlcCA9IF8ucGFydGlhbFJpZ2h0KF8ubWVyZ2UsIF8uZGVmYXVsdHMpO1xuICAgICAqXG4gICAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAndmFyaWFibGUnOiAnZGF0YScsXG4gICAgICogICAnaW1wb3J0cyc6IHsgJ2pxJzogJCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzRGVlcChvcHRpb25zLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuICAgICAqXG4gICAgICogb3B0aW9ucy52YXJpYWJsZVxuICAgICAqIC8vID0+ICdkYXRhJ1xuICAgICAqXG4gICAgICogb3B0aW9ucy5pbXBvcnRzXG4gICAgICogLy8gPT4geyAnXyc6IF8sICdqcSc6ICQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxSaWdodChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlcihmdW5jLCAzMiwgbnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgb25seSBjYWxsIHRoZSBgZnVuY2AgZnVuY3Rpb25cbiAgICAgKiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG9cbiAgICAgKiBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZVxuICAgICAqIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIHRocm90dGxlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBleGVjdXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXNcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgZGVib3VuY2VPcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgZGVib3VuY2VPcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgZGVib3VuY2VPcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCBkZWJvdW5jZU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24gYXMgaXRzXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgd3JhcHBlciBmdW5jdGlvbi4gVGhlIHdyYXBwZXIgaXMgZXhlY3V0ZWQgd2l0aFxuICAgICAqIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnRnJlZCwgV2lsbWEsICYgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5GcmVkLCBXaWxtYSwgJmFtcDsgUGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIod3JhcHBlciwgMTYsIFt2YWx1ZV0pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAgICAgKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eVxuICAgICAqIG5hbWUgdGhlIGNyZWF0ZWQgY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogSWYgYGZ1bmNgIGlzIGFuIG9iamVjdCB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzXG4gICAgICogdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50IG9iamVjdCBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3cmFwIHRvIGNyZWF0ZSBjdXN0b20gY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8uY3JlYXRlQ2FsbGJhY2sgPSBfLndyYXAoXy5jcmVhdGVDYWxsYmFjaywgZnVuY3Rpb24oZnVuYywgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgKiAgIHZhciBtYXRjaCA9IC9eKC4rPylfXyhbZ2xddCkoLispJC8uZXhlYyhjYWxsYmFjayk7XG4gICAgICogICByZXR1cm4gIW1hdGNoID8gZnVuYyhjYWxsYmFjaywgdGhpc0FyZykgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgKiAgICAgcmV0dXJuIG1hdGNoWzJdID09ICdndCcgPyBvYmplY3RbbWF0Y2hbMV1dID4gbWF0Y2hbM10gOiBvYmplY3RbbWF0Y2hbMV1dIDwgbWF0Y2hbM107XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2FnZV9fZ3QzOCcpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmIChmdW5jID09IG51bGwgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIFwiXy5wbHVja1wiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmICh0eXBlICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eShmdW5jKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGtleXMoZnVuYyksXG4gICAgICAgICAga2V5ID0gcHJvcHNbMF0sXG4gICAgICAgICAgYSA9IGZ1bmNba2V5XTtcblxuICAgICAgLy8gaGFuZGxlIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrIHNob3J0aGFuZHNcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPT0gMSAmJiBhID09PSBhICYmICFpc09iamVjdChhKSkge1xuICAgICAgICAvLyBmYXN0IHBhdGggdGhlIGNvbW1vbiBjYXNlIG9mIHByb3ZpZGluZyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZVxuICAgICAgICAvLyBwcm9wZXJ0eSBjb250YWluaW5nIGEgcHJpbWl0aXZlIHZhbHVlXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICB2YXIgYiA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIHJldHVybiBhID09PSBiICYmIChhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYikpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwob2JqZWN0W3Byb3BzW2xlbmd0aF1dLCBmdW5jW3Byb3BzW2xlbmd0aF1dLCBudWxsLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBgJmAsIGA8YCwgYD5gLCBgXCJgLCBhbmQgYCdgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdGcmVkLCBXaWxtYSwgJiBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIFdpbG1hLCAmYW1wOyBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0O1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uIG1ldGhvZHMgd2lsbCBiZSBhZGRlZCB0byBpdHMgcHJvdG90eXBlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgZnVuY3Rpb25zIHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoYWluPXRydWVdIFNwZWNpZnkgd2hldGhlciB0aGUgZnVuY3Rpb25zIGFkZGVkIGFyZSBjaGFpbmFibGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICogICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICdjYXBpdGFsaXplJzogY2FwaXRhbGl6ZSB9KTtcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAnY2FwaXRhbGl6ZSc6IGNhcGl0YWxpemUgfSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcbiAgICAgKiBfKCdmcmVkJykuY2FwaXRhbGl6ZSgpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2hhaW4gPSB0cnVlLFxuICAgICAgICAgIG1ldGhvZE5hbWVzID0gc291cmNlICYmIGZ1bmN0aW9ucyhzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZSB8fCAoIW9wdGlvbnMgJiYgIW1ldGhvZE5hbWVzLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IGxvZGFzaFdyYXBwZXI7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gbG9kYXNoO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGZ1bmN0aW9ucyhzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmICdjaGFpbicgaW4gb3B0aW9ucykge1xuICAgICAgICBjaGFpbiA9IG9wdGlvbnMuY2hhaW47XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IG9iamVjdCxcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGN0b3IpO1xuXG4gICAgICBmb3JFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBmdW5jID0gb2JqZWN0W21ldGhvZE5hbWVdID0gc291cmNlW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgY3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgICAgICBhcmdzID0gW3ZhbHVlXTtcblxuICAgICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHJlc3VsdCAmJiBpc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGN0b3IocmVzdWx0KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSAnXycgdmFyaWFibGUgdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXG4gICAgICogdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgY29udGV4dC5fID0gb2xkRGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIF8ubm9vcChvYmplY3QpID09PSB1bmRlZmluZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICAgICAqICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3RhbXAgPSBfLm5vdygpO1xuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7IH0pO1xuICAgICAqIC8vID0+IGxvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqL1xuICAgIHZhciBub3cgPSBpc05hdGl2ZShub3cgPSBEYXRlLm5vdykgJiYgbm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogSWYgYHJhZGl4YCBpcyBgdW5kZWZpbmVkYCBvciBgMGAgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgdGhlXG4gICAgICogYHZhbHVlYCBpcyBhIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBhdm9pZHMgZGlmZmVyZW5jZXMgaW4gbmF0aXZlIEVTMyBhbmQgRVM1IGBwYXJzZUludGBcbiAgICAgKiBpbXBsZW1lbnRhdGlvbnMuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jRS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB1c2VkIHRvIGludGVycHJldCB0aGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbmV3IGludGVnZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqL1xuICAgIHZhciBwYXJzZUludCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSA9PSA4ID8gbmF0aXZlUGFyc2VJbnQgOiBmdW5jdGlvbih2YWx1ZSwgcmFkaXgpIHtcbiAgICAgIC8vIEZpcmVmb3ggPCAyMSBhbmQgT3BlcmEgPCAxNSBmb2xsb3cgdGhlIEVTMyBzcGVjaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgYHBhcnNlSW50YFxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KGlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UocmVMZWFkaW5nU3BhY2VzQW5kWmVyb3MsICcnKSA6IHZhbHVlLCByYWRpeCB8fCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFwiXy5wbHVja1wiIHN0eWxlIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIHRoZSBga2V5YCB2YWx1ZSBvZiBhXG4gICAgICogZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBnZXROYW1lID0gXy5wcm9wZXJ0eSgnbmFtZScpO1xuICAgICAqXG4gICAgICogXy5tYXAoY2hhcmFjdGVycywgZ2V0TmFtZSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShjaGFyYWN0ZXJzLCBnZXROYW1lKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSwgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShrZXkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIHRydWV5IG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzIGFcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmc9ZmFsc2VdIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWluID09ICdib29sZWFuJyAmJiBub01heCkge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5vTWF4ICYmIHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBga2V5YCBvbiBgb2JqZWN0YC4gSWYgYGtleWAgaXMgYSBmdW5jdGlvblxuICAgICAqIGl0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgb2JqZWN0YCBhbmQgaXRzIHJlc3VsdCByZXR1cm5lZCxcbiAgICAgKiBlbHNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXR1cm5lZC4gSWYgYG9iamVjdGAgaXMgZmFsc2V5IHRoZW4gYHVuZGVmaW5lZGBcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdjaGVlc2UnOiAnY3J1bXBldHMnLFxuICAgICAqICAgJ3N0dWZmJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiAnbm9uc2Vuc2UnO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdjaGVlc2UnKTtcbiAgICAgKiAvLyA9PiAnY3J1bXBldHMnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdHVmZicpO1xuICAgICAqIC8vID0+ICdub25zZW5zZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSA/IG9iamVjdFtrZXldKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1pY3JvLXRlbXBsYXRpbmcgbWV0aG9kIHRoYXQgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzXG4gICAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQsIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICAgKiBkZWJ1Z2dpbmcuIFNlZSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZTpcbiAgICAgKiBodHRwOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSBqcS5lYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+JywgbnVsbCwgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IGZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3JcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLm5hbWUgJT4hJywgbnVsbCwgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAgIHZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZTtcbiAgICAgKiAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLm5hbWUgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAgIHJldHVybiBfX3A7XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIGEgc3RhY2sgdHJhY2VcbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihjd2QsICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUodGV4dCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy9cbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0IHx8ICcnKTtcblxuICAgICAgLy8gYXZvaWQgbWlzc2luZyBkZXBlbmRlbmNpZXMgd2hlbiBgaXRlcmF0b3JUZW1wbGF0ZWAgaXMgbm90IGRlZmluZWRcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgc2V0dGluZ3MpO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gdmFsdWVzKGltcG9ydHMpO1xuXG4gICAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gY29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIGVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFsc1xuICAgICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyByZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0c1xuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIHJlcXVpcmVzIHJldHVybmluZyB0aGUgYG1hdGNoYFxuICAgICAgICAvLyBzdHJpbmcgaW4gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gaWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpblxuICAgICAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZSxcbiAgICAgICAgICBoYXNWYXJpYWJsZSA9IHZhcmlhYmxlO1xuXG4gICAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICAgIHZhcmlhYmxlID0gJ29iaic7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoICgnICsgdmFyaWFibGUgKyAnKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5nc1xuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArIHZhcmlhYmxlICsgJykge1xcbicgK1xuICAgICAgICAoaGFzVmFyaWFibGUgPyAnJyA6IHZhcmlhYmxlICsgJyB8fCAoJyArIHZhcmlhYmxlICsgJyA9IHt9KTtcXG4nKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlXCIgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICdcXG4vKlxcbi8vIyBzb3VyY2VVUkw9JyArIChvcHRpb25zLnNvdXJjZVVSTCB8fCAnL2xvZGFzaC90ZW1wbGF0ZS9zb3VyY2VbJyArICh0ZW1wbGF0ZUNvdW50ZXIrKykgKyAnXScpICsgJ1xcbiovJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uKGltcG9ydHNLZXlzLCAncmV0dXJuICcgKyBzb3VyY2UgKyBzb3VyY2VVUkwpLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGRhdGEpO1xuICAgICAgfVxuICAgICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2FsbGJhY2sgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHNcbiAgICAgKiBvZiBlYWNoIGNhbGxiYWNrIGV4ZWN1dGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZGljZVJvbGxzID0gXy50aW1lcygzLCBfLnBhcnRpYWwoXy5yYW5kb20sIDEsIDYpKTtcbiAgICAgKiAvLyA9PiBbMywgNiwgNF1cbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgZnVuY3Rpb24obikgeyBtYWdlLmNhc3RTcGVsbChuKTsgfSk7XG4gICAgICogLy8gPT4gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lcywgcGFzc2luZyBgbmAgb2YgYDBgLCBgMWAsIGFuZCBgMmAgcmVzcGVjdGl2ZWx5XG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgdGhpcy5jYXN0KG4pOyB9LCBtYWdlKTtcbiAgICAgKiAvLyA9PiBhbHNvIGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgbiA9IChuID0gK24pID4gLTEgPyBuIDogMDtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgICBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNhbGxiYWNrKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYCB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ0ZyZWQsIEJhcm5leSAmYW1wOyBQZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQsIEJhcm5leSAmIFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwcm92aWRlZCB0aGUgSUQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeF0gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiBTdHJpbmcocHJlZml4ID09IG51bGwgPyAnJyA6IHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QgdGhhdCB3cmFwcyB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCBleHBsaWNpdFxuICAgICAqIG1ldGhvZCBjaGFpbmluZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfLmNoYWluKGNoYXJhY3RlcnMpXG4gICAgICogICAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAgIC5tYXAoZnVuY3Rpb24oY2hyKSB7IHJldHVybiBjaHIubmFtZSArICcgaXMgJyArIGNoci5hZ2U7IH0pXG4gICAgICogICAgIC5maXJzdCgpXG4gICAgICogICAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV3IGxvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgICAgdmFsdWUuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBpbnRlcmNlcHRvcmAgd2l0aCB0aGUgYHZhbHVlYCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIGB2YWx1ZWAuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZFxuICAgICAqIGNoYWluIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW5cbiAgICAgKiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkgeyBhcnJheS5wb3AoKTsgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBleHBsaWNpdCBtZXRob2QgY2hhaW5pbmcgb24gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5maXJzdCgpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIHdpdGggZXhwbGljaXQgY2hhaW5pbmdcbiAgICAgKiBfKGNoYXJhY3RlcnMpLmNoYWluKClcbiAgICAgKiAgIC5maXJzdCgpXG4gICAgICogICAucGljaygnYWdlJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICAgIGxvZGFzaC5kcm9wID0gcmVzdDtcbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduO1xuICAgIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5vYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnNlbGVjdCA9IGZpbHRlcjtcbiAgICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gICAgbG9kYXNoLnVuaXF1ZSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuemlwID0gemlwO1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgICBtaXhpbihsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIG1peGluKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9XG4gICAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCksIGZhbHNlKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLnRha2UgPSBmaXJzdDtcbiAgICBsb2Rhc2guaGVhZCA9IGZpcnN0O1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNhbGxiYWNrYWJsZSA9IG1ldGhvZE5hbWUgIT09ICdzYW1wbGUnO1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV09IGZ1bmN0aW9uKG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmModGhpcy5fX3dyYXBwZWRfXywgbiwgZ3VhcmQpO1xuXG4gICAgICAgICAgcmV0dXJuICFjaGFpbkFsbCAmJiAobiA9PSBudWxsIHx8IChndWFyZCAmJiAhKGNhbGxiYWNrYWJsZSAmJiB0eXBlb2YgbiA9PSAnZnVuY3Rpb24nKSkpXG4gICAgICAgICAgICA/IHJlc3VsdFxuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgc3RyaW5nXG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSAnMi40LjEnO1xuXG4gICAgLy8gYWRkIFwiQ2hhaW5pbmdcIiBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXJcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSB3cmFwcGVyVG9TdHJpbmc7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZU9mO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IHdyYXBwZXJWYWx1ZU9mO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXNcbiAgICBmb3JFYWNoKFsnam9pbicsICdwb3AnLCAnc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYWluQWxsXG4gICAgICAgICAgPyBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKVxuICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgZXhpc3Rpbmcgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cyksIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gZXhwb3NlIExvLURhc2hcbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzIGxpa2Ugci5qcyBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvLURhc2ggdG8gdGhlIGdsb2JhbCBvYmplY3QgZXZlbiB3aGVuIGFuIEFNRCBsb2FkZXIgaXMgcHJlc2VudCBpblxuICAgIC8vIGNhc2UgTG8tRGFzaCBpcyBsb2FkZWQgd2l0aCBhIFJlcXVpcmVKUyBzaGltIGNvbmZpZy5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbCNjb25maWctc2hpbVxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBkZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KU1xuICAgIGlmIChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgfVxuICAgIC8vIGluIE5hcndoYWwgb3IgUmhpbm8gLXJlcXVpcmVcbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBUb09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIGtleXM7XG5cdHZhciB0byA9IFRvT2JqZWN0KHRhcmdldCk7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gYXJndW1lbnRzW3NdO1xuXHRcdGtleXMgPSBPYmplY3Qua2V5cyhPYmplY3QoZnJvbSkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZXNwb25kZXJFdmVudFBsdWdpblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCdyZWFjdC9saWIvRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgncmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgncmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCdyZWFjdC9saWIvYWNjdW11bGF0ZUludG8nKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9rZXlPZicpO1xuXG52YXIgaXNTdGFydGlzaCA9IEV2ZW50UGx1Z2luVXRpbHMuaXNTdGFydGlzaDtcbnZhciBpc01vdmVpc2ggPSBFdmVudFBsdWdpblV0aWxzLmlzTW92ZWlzaDtcbnZhciBpc0VuZGlzaCA9IEV2ZW50UGx1Z2luVXRpbHMuaXNFbmRpc2g7XG52YXIgZXhlY3V0ZURpcmVjdERpc3BhdGNoID0gRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlyZWN0RGlzcGF0Y2g7XG52YXIgaGFzRGlzcGF0Y2hlcyA9IEV2ZW50UGx1Z2luVXRpbHMuaGFzRGlzcGF0Y2hlcztcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlID1cbiAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlO1xuXG4vKipcbiAqIElEIG9mIGVsZW1lbnQgdGhhdCBzaG91bGQgcmVzcG9uZCB0byB0b3VjaC9tb3ZlIHR5cGVzIG9mIGludGVyYWN0aW9ucywgYXNcbiAqIGluZGljYXRlZCBleHBsaWNpdGx5IGJ5IHJlbGV2YW50IGNhbGxiYWNrcy5cbiAqL1xudmFyIHJlc3BvbmRlcklEID0gbnVsbDtcbnZhciBpc1ByZXNzaW5nID0gZmFsc2U7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICAvKipcbiAgICogT24gYSBgdG91Y2hTdGFydGAvYG1vdXNlRG93bmAsIGlzIGl0IGRlc2lyZWQgdGhhdCB0aGlzIGVsZW1lbnQgYmVjb21lIHRoZVxuICAgKiByZXNwb25kZXI/XG4gICAqL1xuICBzdGFydFNob3VsZFNldFJlc3BvbmRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25TdGFydFNob3VsZFNldFJlc3BvbmRlcjogbnVsbH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblN0YXJ0U2hvdWxkU2V0UmVzcG9uZGVyQ2FwdHVyZTogbnVsbH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBPbiBhIGBzY3JvbGxgLCBpcyBpdCBkZXNpcmVkIHRoYXQgdGhpcyBlbGVtZW50IGJlY29tZSB0aGUgcmVzcG9uZGVyPyBUaGlzXG4gICAqIGlzIHVzdWFsbHkgbm90IG5lZWRlZCwgYnV0IHNob3VsZCBiZSB1c2VkIHRvIHJldHJvYWN0aXZlbHkgaW5mZXIgdGhhdCBhXG4gICAqIGB0b3VjaFN0YXJ0YCBoYWQgb2NjdXJlZCBkdXJpbmcgbW9tZW50dW0gc2Nyb2xsLiBEdXJpbmcgYSBtb21lbnR1bSBzY3JvbGwsXG4gICAqIGEgdG91Y2ggc3RhcnQgd2lsbCBiZSBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHNjcm9sbCBldmVudCBpZiB0aGUgdmlldyBpc1xuICAgKiBjdXJyZW50bHkgc2Nyb2xsaW5nLlxuICAgKi9cbiAgc2Nyb2xsU2hvdWxkU2V0UmVzcG9uZGVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblNjcm9sbFNob3VsZFNldFJlc3BvbmRlcjogbnVsbH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblNjcm9sbFNob3VsZFNldFJlc3BvbmRlckNhcHR1cmU6IG51bGx9KVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT24gYSBgdG91Y2hNb3ZlYC9gbW91c2VNb3ZlYCwgaXMgaXQgZGVzaXJlZCB0aGF0IHRoaXMgZWxlbWVudCBiZWNvbWUgdGhlXG4gICAqIHJlc3BvbmRlcj9cbiAgICovXG4gIG1vdmVTaG91bGRTZXRSZXNwb25kZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW92ZVNob3VsZFNldFJlc3BvbmRlcjogbnVsbH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbk1vdmVTaG91bGRTZXRSZXNwb25kZXJDYXB0dXJlOiBudWxsfSlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpcmVjdCByZXNwb25kZXIgZXZlbnRzIGRpc3BhdGNoZWQgZGlyZWN0bHkgdG8gcmVzcG9uZGVyLiBEbyBub3QgYnViYmxlLlxuICAgKi9cbiAgcmVzcG9uZGVyTW92ZToge3JlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHtvblJlc3BvbmRlck1vdmU6IG51bGx9KX0sXG4gIHJlc3BvbmRlclJlbGVhc2U6IHtyZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7b25SZXNwb25kZXJSZWxlYXNlOiBudWxsfSl9LFxuICByZXNwb25kZXJUZXJtaW5hdGlvblJlcXVlc3Q6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7b25SZXNwb25kZXJUZXJtaW5hdGlvblJlcXVlc3Q6IG51bGx9KVxuICB9LFxuICByZXNwb25kZXJHcmFudDoge3JlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHtvblJlc3BvbmRlckdyYW50OiBudWxsfSl9LFxuICByZXNwb25kZXJSZWplY3Q6IHtyZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7b25SZXNwb25kZXJSZWplY3Q6IG51bGx9KX0sXG4gIHJlc3BvbmRlclRlcm1pbmF0ZToge3JlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHtvblJlc3BvbmRlclRlcm1pbmF0ZTogbnVsbH0pfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBuZWdvdGlhdGlvbiBiZXR3ZWVuIGFueSBleGlzdGluZy9jdXJyZW50IHJlc3BvbmRlciwgY2hlY2tzIHRvIHNlZSBpZlxuICogYW55IG5ldyBlbnRpdHkgaXMgaW50ZXJlc3RlZCBpbiBiZWNvbWluZyByZXNwb25kZXIsIHBlcmZvcm1zIHRoYXQgaGFuZHNoYWtlXG4gKiBhbmQgcmV0dXJucyBhbnkgZXZlbnRzIHRoYXQgbXVzdCBiZSBlbWl0dGVkIHRvIG5vdGlmeSB0aGUgcmVsZXZhbnQgcGFydGllcy5cbiAqXG4gKiBBIG5vdGUgYWJvdXQgZXZlbnQgb3JkZXJpbmcgaW4gdGhlIGBFdmVudFBsdWdpbkh1YmAuXG4gKlxuICogU3VwcG9zZSBwbHVnaW5zIGFyZSBpbmplY3RlZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICpcbiAqIGBbUiwgUywgQ11gXG4gKlxuICogVG8gaGVscCBpbGx1c3RyYXRlIHRoZSBleGFtcGxlLCBhc3N1bWUgYFNgIGlzIGBTaW1wbGVFdmVudFBsdWdpbmAgKGZvclxuICogYG9uQ2xpY2tgIGV0YykgYW5kIGBSYCBpcyBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gLlxuICpcbiAqIFwiRGVmZXJyZWQtRGlzcGF0Y2hlZCBFdmVudHNcIjpcbiAqXG4gKiAtIFRoZSBjdXJyZW50IGV2ZW50IHBsdWdpbiBzeXN0ZW0gd2lsbCB0cmF2ZXJzZSB0aGUgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLFxuICogICBpbiBvcmRlciwgYW5kIGV4dHJhY3QgZXZlbnRzIGJ5IGNvbGxlY3RpbmcgdGhlIHBsdWdpbidzIHJldHVybiB2YWx1ZSBvZlxuICogICBgZXh0cmFjdEV2ZW50cygpYC5cbiAqIC0gVGhlc2UgZXZlbnRzIHRoYXQgYXJlIHJldHVybmVkIGZyb20gYGV4dHJhY3RFdmVudHNgIGFyZSBcImRlZmVycmVkXG4gKiAgIGRpc3BhdGNoZWQgZXZlbnRzXCIuXG4gKiAtIFdoZW4gcmV0dXJuZWQgZnJvbSBgZXh0cmFjdEV2ZW50c2AsIGRlZmVycmVkLWRpc3BhdGNoZWQgZXZlbnRzIGNvbnRhaW4gYW5cbiAqICAgXCJhY2N1bXVsYXRpb25cIiBvZiBkZWZlcnJlZCBkaXNwYXRjaGVzLlxuICogLSBUaGVzZSBkZWZlcnJlZCBkaXNwYXRjaGVzIGFyZSBhY2N1bXVsYXRlZC9jb2xsZWN0ZWQgYmVmb3JlIHRoZXkgYXJlXG4gKiAgIHJldHVybmVkLCBidXQgcHJvY2Vzc2VkIGF0IGEgbGF0ZXIgdGltZSBieSB0aGUgYEV2ZW50UGx1Z2luSHViYCAoaGVuY2UgdGhlXG4gKiAgIG5hbWUgZGVmZXJyZWQpLlxuICpcbiAqIEluIHRoZSBwcm9jZXNzIG9mIHJldHVybmluZyB0aGVpciBkZWZlcnJlZC1kaXNwYXRjaGVkIGV2ZW50cywgZXZlbnQgcGx1Z2luc1xuICogdGhlbXNlbHZlcyBjYW4gZGlzcGF0Y2ggZXZlbnRzIG9uLWRlbWFuZCB3aXRob3V0IHJldHVybmluZyB0aGVtIGZyb21cbiAqIGBleHRyYWN0RXZlbnRzYC4gUGx1Z2lucyBtaWdodCB3YW50IHRvIGRvIHRoaXMsIHNvIHRoYXQgdGhleSBjYW4gdXNlIGV2ZW50XG4gKiBkaXNwYXRjaGluZyBhcyBhIHRvb2wgdGhhdCBoZWxwcyB0aGVtIGRlY2lkZSB3aGljaCBldmVudHMgc2hvdWxkIGJlIGV4dHJhY3RlZFxuICogaW4gdGhlIGZpcnN0IHBsYWNlLlxuICpcbiAqIFwiT24tRGVtYW5kLURpc3BhdGNoZWQgRXZlbnRzXCI6XG4gKlxuICogLSBPbi1kZW1hbmQtZGlzcGF0Y2hlZCBldmVudHMgYXJlIG5vdCByZXR1cm5lZCBmcm9tIGBleHRyYWN0RXZlbnRzYC5cbiAqIC0gT24tZGVtYW5kLWRpc3BhdGNoZWQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGR1cmluZyB0aGUgcHJvY2VzcyBvZiByZXR1cm5pbmdcbiAqICAgdGhlIGRlZmVycmVkLWRpc3BhdGNoZWQgZXZlbnRzLlxuICogLSBUaGV5IHNob3VsZCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gKiAtIFRoZXkgc2hvdWxkIGJlIGF2b2lkZWQsIGFuZC9vciBldmVudHVhbGx5IGJlIHJlcGxhY2VkIHdpdGggYW5vdGhlclxuICogICBhYnN0cmFjdGlvbiB0aGF0IGFsbG93cyBldmVudCBwbHVnaW5zIHRvIHBlcmZvcm0gbXVsdGlwbGUgXCJyb3VuZHNcIiBvZiBldmVudFxuICogICBleHRyYWN0aW9uLlxuICpcbiAqIFRoZXJlZm9yZSwgdGhlIHNlcXVlbmNlIG9mIGV2ZW50IGRpc3BhdGNoZXMgYmVjb21lczpcbiAqXG4gKiAtIGBSYHMgb24tZGVtYW5kIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBSYCBvbi1kZW1hbmQpXG4gKiAtIGBTYHMgb24tZGVtYW5kIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBTYCBvbi1kZW1hbmQpXG4gKiAtIGBDYHMgb24tZGVtYW5kIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBDYCBvbi1kZW1hbmQpXG4gKiAtIGBSYHMgZXh0cmFjdGVkIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBFdmVudFBsdWdpbkh1YmApXG4gKiAtIGBTYHMgZXh0cmFjdGVkIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBFdmVudFBsdWdpbkh1YmApXG4gKiAtIGBDYHMgZXh0cmFjdGVkIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBFdmVudFBsdWdpbkh1YmApXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgYFJlc3BvbmRlckV2ZW50UGx1Z2luYDogSWYgdGhlIGBzdGFydFNob3VsZFNldFJlc3BvbmRlcmBcbiAqIG9uLWRlbWFuZCBkaXNwYXRjaCByZXR1cm5zIGB0cnVlYCAoYW5kIHNvbWUgb3RoZXIgZGV0YWlscyBhcmUgc2F0aXNmaWVkKSB0aGVcbiAqIGBvblJlc3BvbmRlckdyYW50YCBkZWZlcnJlZCBkaXNwYXRjaGVkIGV2ZW50IGlzIHJldHVybmVkIGZyb21cbiAqIGBleHRyYWN0RXZlbnRzYC4gVGhlIHNlcXVlbmNlIG9mIGRpc3BhdGNoIGV4ZWN1dGlvbnMgaW4gdGhpcyBjYXNlXG4gKiB3aWxsIGFwcGVhciBhcyBmb2xsb3dzOlxuICpcbiAqIC0gYHN0YXJ0U2hvdWxkU2V0UmVzcG9uZGVyYCAoYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBkaXNwYXRjaGVzIG9uLWRlbWFuZClcbiAqIC0gYHRvdWNoU3RhcnRDYXB0dXJlYCAgICAgICAoYEV2ZW50UGx1Z2luSHViYCBkaXNwYXRjaGVzIGFzIHVzdWFsKVxuICogLSBgdG91Y2hTdGFydGAgICAgICAgICAgICAgIChgRXZlbnRQbHVnaW5IdWJgIGRpc3BhdGNoZXMgYXMgdXN1YWwpXG4gKiAtIGByZXNwb25kZXJHcmFudC9SZWplY3RgICAgKGBFdmVudFBsdWdpbkh1YmAgZGlzcGF0Y2hlcyBhcyB1c3VhbClcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBkZWVwZXN0IFJlYWN0IHJlbmRlcmVkIGVsZW1lbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqL1xuZnVuY3Rpb24gc2V0UmVzcG9uZGVyQW5kRXh0cmFjdFRyYW5zZmVyKFxuICAgIHRvcExldmVsVHlwZSxcbiAgICB0b3BMZXZlbFRhcmdldElELFxuICAgIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBzaG91bGRTZXRFdmVudFR5cGUgPVxuICAgIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSA/IGV2ZW50VHlwZXMuc3RhcnRTaG91bGRTZXRSZXNwb25kZXIgOlxuICAgIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpID8gZXZlbnRUeXBlcy5tb3ZlU2hvdWxkU2V0UmVzcG9uZGVyIDpcbiAgICBldmVudFR5cGVzLnNjcm9sbFNob3VsZFNldFJlc3BvbmRlcjtcblxuICB2YXIgYnViYmxlU2hvdWxkU2V0RnJvbSA9IHJlc3BvbmRlcklEIHx8IHRvcExldmVsVGFyZ2V0SUQ7XG4gIHZhciBzaG91bGRTZXRFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICBzaG91bGRTZXRFdmVudFR5cGUsXG4gICAgYnViYmxlU2hvdWxkU2V0RnJvbSxcbiAgICBuYXRpdmVFdmVudFxuICApO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc2hvdWxkU2V0RXZlbnQpO1xuICB2YXIgd2FudHNSZXNwb25kZXJJRCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoc2hvdWxkU2V0RXZlbnQpO1xuICBpZiAoIXNob3VsZFNldEV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgc2hvdWxkU2V0RXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShzaG91bGRTZXRFdmVudCk7XG4gIH1cblxuICBpZiAoIXdhbnRzUmVzcG9uZGVySUQgfHwgd2FudHNSZXNwb25kZXJJRCA9PT0gcmVzcG9uZGVySUQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZXh0cmFjdGVkO1xuICB2YXIgZ3JhbnRFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICBldmVudFR5cGVzLnJlc3BvbmRlckdyYW50LFxuICAgIHdhbnRzUmVzcG9uZGVySUQsXG4gICAgbmF0aXZlRXZlbnRcbiAgKTtcblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGdyYW50RXZlbnQpO1xuICBpZiAocmVzcG9uZGVySUQpIHtcbiAgICB2YXIgdGVybWluYXRpb25SZXF1ZXN0RXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgICBldmVudFR5cGVzLnJlc3BvbmRlclRlcm1pbmF0aW9uUmVxdWVzdCxcbiAgICAgIHJlc3BvbmRlcklELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXModGVybWluYXRpb25SZXF1ZXN0RXZlbnQpO1xuICAgIHZhciBzaG91bGRTd2l0Y2ggPSAhaGFzRGlzcGF0Y2hlcyh0ZXJtaW5hdGlvblJlcXVlc3RFdmVudCkgfHxcbiAgICAgIGV4ZWN1dGVEaXJlY3REaXNwYXRjaCh0ZXJtaW5hdGlvblJlcXVlc3RFdmVudCk7XG4gICAgaWYgKCF0ZXJtaW5hdGlvblJlcXVlc3RFdmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgdGVybWluYXRpb25SZXF1ZXN0RXZlbnQuY29uc3RydWN0b3IucmVsZWFzZSh0ZXJtaW5hdGlvblJlcXVlc3RFdmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFN3aXRjaCkge1xuICAgICAgdmFyIHRlcm1pbmF0ZVR5cGUgPSBldmVudFR5cGVzLnJlc3BvbmRlclRlcm1pbmF0ZTtcbiAgICAgIHZhciB0ZXJtaW5hdGVFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICAgICAgdGVybWluYXRlVHlwZSxcbiAgICAgICAgcmVzcG9uZGVySUQsXG4gICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICApO1xuICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyh0ZXJtaW5hdGVFdmVudCk7XG4gICAgICBleHRyYWN0ZWQgPSBhY2N1bXVsYXRlSW50byhleHRyYWN0ZWQsIFtncmFudEV2ZW50LCB0ZXJtaW5hdGVFdmVudF0pO1xuICAgICAgcmVzcG9uZGVySUQgPSB3YW50c1Jlc3BvbmRlcklEO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVqZWN0RXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgICAgIGV2ZW50VHlwZXMucmVzcG9uZGVyUmVqZWN0LFxuICAgICAgICB3YW50c1Jlc3BvbmRlcklELFxuICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgKTtcbiAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMocmVqZWN0RXZlbnQpO1xuICAgICAgZXh0cmFjdGVkID0gYWNjdW11bGF0ZUludG8oZXh0cmFjdGVkLCByZWplY3RFdmVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGV4dHJhY3RlZCA9IGFjY3VtdWxhdGVJbnRvKGV4dHJhY3RlZCwgZ3JhbnRFdmVudCk7XG4gICAgcmVzcG9uZGVySUQgPSB3YW50c1Jlc3BvbmRlcklEO1xuICB9XG4gIHJldHVybiBleHRyYWN0ZWQ7XG59XG5cbi8qKlxuICogQSB0cmFuc2ZlciBpcyBhIG5lZ290aWF0aW9uIGJldHdlZW4gYSBjdXJyZW50bHkgc2V0IHJlc3BvbmRlciBhbmQgdGhlIG5leHRcbiAqIGVsZW1lbnQgdG8gY2xhaW0gcmVzcG9uZGVyIHN0YXR1cy4gQW55IHN0YXJ0IGV2ZW50IGNvdWxkIHRyaWdnZXIgYSB0cmFuc2ZlclxuICogb2YgcmVzcG9uZGVySUQuIEFueSBtb3ZlIGV2ZW50IGNvdWxkIHRyaWdnZXIgYSB0cmFuc2Zlciwgc28gbG9uZyBhcyB0aGVyZSBpc1xuICogY3VycmVudGx5IGEgcmVzcG9uZGVyIHNldCAoaW4gb3RoZXIgd29yZHMgYXMgbG9uZyBhcyB0aGUgdXNlciBpcyBwcmVzc2luZ1xuICogZG93bikuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIHRyYW5zZmVyIG9mIHJlc3BvbmRlciBjb3VsZCBwb3NzaWJseSBvY2N1ci5cbiAqL1xuZnVuY3Rpb24gY2FuVHJpZ2dlclRyYW5zZmVyKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCB8fFxuICAgICAgICAgaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHx8XG4gICAgICAgICAoaXNQcmVzc2luZyAmJiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSk7XG59XG5cbi8qKlxuICogRXZlbnQgcGx1Z2luIGZvciBmb3JtYWxpemluZyB0aGUgbmVnb3RpYXRpb24gYmV0d2VlbiBjbGFpbWluZyBsb2NrcyBvblxuICogcmVjZWl2aW5nIHRvdWNoZXMuXG4gKi9cbnZhciBSZXNwb25kZXJFdmVudFBsdWdpbiA9IHtcblxuICBnZXRSZXNwb25kZXJJRDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJlc3BvbmRlcklEO1xuICB9LFxuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuICAgIHZhciBleHRyYWN0ZWQ7XG4gICAgLy8gTXVzdCBoYXZlIG1pc3NlZCBhbiBlbmQgZXZlbnQgLSByZXNldCB0aGUgc3RhdGUgaGVyZS5cbiAgICBpZiAocmVzcG9uZGVySUQgJiYgaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpKSB7XG4gICAgICByZXNwb25kZXJJRCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkpIHtcbiAgICAgIGlzUHJlc3NpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNFbmRpc2godG9wTGV2ZWxUeXBlKSkge1xuICAgICAgaXNQcmVzc2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2FuVHJpZ2dlclRyYW5zZmVyKHRvcExldmVsVHlwZSkpIHtcbiAgICAgIHZhciB0cmFuc2ZlciA9IHNldFJlc3BvbmRlckFuZEV4dHJhY3RUcmFuc2ZlcihcbiAgICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgKTtcbiAgICAgIGlmICh0cmFuc2Zlcikge1xuICAgICAgICBleHRyYWN0ZWQgPSBhY2N1bXVsYXRlSW50byhleHRyYWN0ZWQsIHRyYW5zZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGUgcmVzcG9uZGVyIGlzIHNldCBjb3JyZWN0bHksIHdlIGNhbiBkaXNwYXRjaFxuICAgIC8vIHJlc3BvbmRlciB0eXBlIGV2ZW50cyAoZGlyZWN0bHkgdG8gdGhlIHJlc3BvbmRlcikuXG4gICAgdmFyIHR5cGUgPSBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSA/IGV2ZW50VHlwZXMucmVzcG9uZGVyTW92ZSA6XG4gICAgICBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpID8gZXZlbnRUeXBlcy5yZXNwb25kZXJSZWxlYXNlIDpcbiAgICAgIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSA/IGV2ZW50VHlwZXMucmVzcG9uZGVyU3RhcnQgOiBudWxsO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICB2YXIgZ2VzdHVyZSA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcmVzcG9uZGVySUQgfHwgJycsXG4gICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICApO1xuICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhnZXN0dXJlKTtcbiAgICAgIGV4dHJhY3RlZCA9IGFjY3VtdWxhdGVJbnRvKGV4dHJhY3RlZCwgZ2VzdHVyZSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBldmVudFR5cGVzLnJlc3BvbmRlclJlbGVhc2UpIHtcbiAgICAgIHJlc3BvbmRlcklEID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbmRlckV2ZW50UGx1Z2luO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRhcEV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCdyZWFjdC9saWIvRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgncmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgncmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgncmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBUb3VjaEV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL1RvdWNoRXZlbnRVdGlscycpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgncmVhY3QvbGliL2tleU9mJyk7XG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBpc1N0YXJ0aXNoID0gRXZlbnRQbHVnaW5VdGlscy5pc1N0YXJ0aXNoO1xudmFyIGlzRW5kaXNoID0gRXZlbnRQbHVnaW5VdGlscy5pc0VuZGlzaDtcblxudmFyIGlzVG91Y2ggPSBmdW5jdGlvbih0b3BMZXZlbFR5cGUpIHtcbiAgdmFyIHRvdWNoVHlwZXMgPSBbXG4gICAgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbCxcbiAgICB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kLFxuICAgIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydCxcbiAgICB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZVxuICBdO1xuICByZXR1cm4gdG91Y2hUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPj0gMDtcbn1cblxuLyoqXG4gKiBOdW1iZXIgb2YgcGl4ZWxzIHRoYXQgYXJlIHRvbGVyYXRlZCBpbiBiZXR3ZWVuIGEgYHRvdWNoU3RhcnRgIGFuZCBgdG91Y2hFbmRgXG4gKiBpbiBvcmRlciB0byBzdGlsbCBiZSBjb25zaWRlcmVkIGEgJ3RhcCcgZXZlbnQuXG4gKi9cbnZhciB0YXBNb3ZlVGhyZXNob2xkID0gMTA7XG52YXIgaWdub3JlTW91c2VUaHJlc2hvbGQgPSA3NTA7XG52YXIgc3RhcnRDb29yZHMgPSB7eDogbnVsbCwgeTogbnVsbH07XG52YXIgbGFzdFRvdWNoRXZlbnQgPSBudWxsO1xuXG52YXIgQXhpcyA9IHtcbiAgeDoge3BhZ2U6ICdwYWdlWCcsIGNsaWVudDogJ2NsaWVudFgnLCBlbnZTY3JvbGw6ICdjdXJyZW50UGFnZVNjcm9sbExlZnQnfSxcbiAgeToge3BhZ2U6ICdwYWdlWScsIGNsaWVudDogJ2NsaWVudFknLCBlbnZTY3JvbGw6ICdjdXJyZW50UGFnZVNjcm9sbFRvcCd9XG59O1xuXG5mdW5jdGlvbiBnZXRBeGlzQ29vcmRPZkV2ZW50KGF4aXMsIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBzaW5nbGVUb3VjaCA9IFRvdWNoRXZlbnRVdGlscy5leHRyYWN0U2luZ2xlVG91Y2gobmF0aXZlRXZlbnQpO1xuICBpZiAoc2luZ2xlVG91Y2gpIHtcbiAgICByZXR1cm4gc2luZ2xlVG91Y2hbYXhpcy5wYWdlXTtcbiAgfVxuICByZXR1cm4gYXhpcy5wYWdlIGluIG5hdGl2ZUV2ZW50ID9cbiAgICBuYXRpdmVFdmVudFtheGlzLnBhZ2VdIDpcbiAgICBuYXRpdmVFdmVudFtheGlzLmNsaWVudF0gKyBWaWV3cG9ydE1ldHJpY3NbYXhpcy5lbnZTY3JvbGxdO1xufVxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShjb29yZHMsIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBwYWdlWCA9IGdldEF4aXNDb29yZE9mRXZlbnQoQXhpcy54LCBuYXRpdmVFdmVudCk7XG4gIHZhciBwYWdlWSA9IGdldEF4aXNDb29yZE9mRXZlbnQoQXhpcy55LCBuYXRpdmVFdmVudCk7XG4gIHJldHVybiBNYXRoLnBvdyhcbiAgICBNYXRoLnBvdyhwYWdlWCAtIGNvb3Jkcy54LCAyKSArIE1hdGgucG93KHBhZ2VZIC0gY29vcmRzLnksIDIpLFxuICAgIDAuNVxuICApO1xufVxuXG52YXIgZGVwZW5kZW5jaWVzID0gW1xuICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bixcbiAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmUsXG4gIHRvcExldmVsVHlwZXMudG9wTW91c2VVcFxuXTtcblxuaWYgKEV2ZW50UGx1Z2luVXRpbHMudXNlVG91Y2hFdmVudHMpIHtcbiAgZGVwZW5kZW5jaWVzLnB1c2goXG4gICAgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZCxcbiAgICB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQsXG4gICAgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmVcbiAgKTtcbn1cblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHRvdWNoVGFwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblRvdWNoVGFwOiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uVG91Y2hUYXBDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzXG4gIH1cbn07XG5cbnZhciBUYXBFdmVudFBsdWdpbiA9IHtcblxuICB0YXBNb3ZlVGhyZXNob2xkOiB0YXBNb3ZlVGhyZXNob2xkLFxuXG4gIGlnbm9yZU1vdXNlVGhyZXNob2xkOiBpZ25vcmVNb3VzZVRocmVzaG9sZCxcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcblxuICAgIGlmIChpc1RvdWNoKHRvcExldmVsVHlwZSkpIHtcbiAgICAgIGxhc3RUb3VjaEV2ZW50ID0gbmF0aXZlRXZlbnQudGltZVN0YW1wO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGFzdFRvdWNoRXZlbnQgJiYgKG5hdGl2ZUV2ZW50LnRpbWVTdGFtcCAtIGxhc3RUb3VjaEV2ZW50KSA8IGlnbm9yZU1vdXNlVGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpICYmICFpc0VuZGlzaCh0b3BMZXZlbFR5cGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gbnVsbDtcbiAgICB2YXIgZGlzdGFuY2UgPSBnZXREaXN0YW5jZShzdGFydENvb3JkcywgbmF0aXZlRXZlbnQpO1xuICAgIGlmIChpc0VuZGlzaCh0b3BMZXZlbFR5cGUpICYmIGRpc3RhbmNlIDwgdGFwTW92ZVRocmVzaG9sZCkge1xuICAgICAgZXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmdldFBvb2xlZChcbiAgICAgICAgZXZlbnRUeXBlcy50b3VjaFRhcCxcbiAgICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkpIHtcbiAgICAgIHN0YXJ0Q29vcmRzLnggPSBnZXRBeGlzQ29vcmRPZkV2ZW50KEF4aXMueCwgbmF0aXZlRXZlbnQpO1xuICAgICAgc3RhcnRDb29yZHMueSA9IGdldEF4aXNDb29yZE9mRXZlbnQoQXhpcy55LCBuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIGlmIChpc0VuZGlzaCh0b3BMZXZlbFR5cGUpKSB7XG4gICAgICBzdGFydENvb3Jkcy54ID0gMDtcbiAgICAgIHN0YXJ0Q29vcmRzLnkgPSAwO1xuICAgIH1cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhcEV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBUb3VjaEV2ZW50VXRpbHNcbiAqL1xuXG52YXIgVG91Y2hFdmVudFV0aWxzID0ge1xuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29tbW9uIGNhc2Ugb2YgZXh0cmFjdGluZyBvdXQgdGhlIHByaW1hcnkgdG91Y2ggZnJvbSBhXG4gICAqIHRvdWNoIGV2ZW50LlxuICAgKiAtIGB0b3VjaEVuZGAgZXZlbnRzIHVzdWFsbHkgZG8gbm90IGhhdmUgdGhlIGB0b3VjaGVzYCBwcm9wZXJ0eS5cbiAgICogICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM2NjY5MjkvXG4gICAqICAgbW9iaWxlLXNhcmFpLXRvdWNoZW5kLWV2ZW50LW5vdC1maXJpbmctd2hlbi1sYXN0LXRvdWNoLWlzLXJlbW92ZWRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gbmF0aXZlRXZlbnQgTmF0aXZlIGV2ZW50IHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYSB0b3VjaC5cbiAgICogQHJldHVybiB7VG91Y2hlc09iamVjdD99IGFuIG9iamVjdCB3aXRoIHBhZ2VYIGFuZCBwYWdlWSBvciBudWxsLlxuICAgKi9cbiAgZXh0cmFjdFNpbmdsZVRvdWNoOiBmdW5jdGlvbihuYXRpdmVFdmVudCkge1xuICAgIHZhciB0b3VjaGVzID0gbmF0aXZlRXZlbnQudG91Y2hlcztcbiAgICB2YXIgY2hhbmdlZFRvdWNoZXMgPSBuYXRpdmVFdmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICB2YXIgaGFzVG91Y2hlcyA9IHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPiAwO1xuICAgIHZhciBoYXNDaGFuZ2VkVG91Y2hlcyA9IGNoYW5nZWRUb3VjaGVzICYmIGNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDA7XG5cbiAgICByZXR1cm4gIWhhc1RvdWNoZXMgJiYgaGFzQ2hhbmdlZFRvdWNoZXMgPyBjaGFuZ2VkVG91Y2hlc1swXSA6XG4gICAgICAgICAgIGhhc1RvdWNoZXMgPyB0b3VjaGVzWzBdIDpcbiAgICAgICAgICAgbmF0aXZlRXZlbnQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG91Y2hFdmVudFV0aWxzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmplY3RUYXBFdmVudFBsdWdpbiAoKSB7XG4gIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbiAgUmVhY3QuaW5pdGlhbGl6ZVRvdWNoRXZlbnRzKHRydWUpO1xuXG4gIHJlcXVpcmUoJ3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1YicpLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFwiUmVzcG9uZGVyRXZlbnRQbHVnaW5cIjogcmVxdWlyZSgnLi9SZXNwb25kZXJFdmVudFBsdWdpbi5qcycpLFxuICAgIFwiVGFwRXZlbnRQbHVnaW5cIjogICAgICAgcmVxdWlyZSgnLi9UYXBFdmVudFBsdWdpbi5qcycpXG4gIH0pO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3Ioe2J1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsfSk7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50cztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luUmVnaXN0cnlcIik7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luVXRpbHNcIik7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoXCIuL2FjY3VtdWxhdGVJbnRvXCIpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoXCIuL2ZvckVhY2hBY2N1bXVsYXRlZFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIGlmIChldmVudCkge1xuICAgIHZhciBleGVjdXRlRGlzcGF0Y2ggPSBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaDtcbiAgICAvLyBQbHVnaW5zIGNhbiBwcm92aWRlIGN1c3RvbSBiZWhhdmlvciB3aGVuIGRpc3BhdGNoaW5nIGV2ZW50cy5cbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5nZXRQbHVnaW5Nb2R1bGVGb3JFdmVudChldmVudCk7XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZXhlY3V0ZURpc3BhdGNoKSB7XG4gICAgICBleGVjdXRlRGlzcGF0Y2ggPSBQbHVnaW5Nb2R1bGUuZXhlY3V0ZURpc3BhdGNoO1xuICAgIH1cbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgZXhlY3V0ZURpc3BhdGNoKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiAtIGBJbnN0YW5jZUhhbmRsZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgcGVyZm9ybXMgbG9naWNhbCB0cmF2ZXJzYWxzIG9mIERPTVxuICogICBoaWVyYXJjaHkgZ2l2ZW4gaWRzIG9mIHRoZSBsb2dpY2FsIERPTSBlbGVtZW50cyBpbnZvbHZlZC5cbiAqL1xudmFyIEluc3RhbmNlSGFuZGxlID0gbnVsbDtcblxuZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpIHtcbiAgdmFyIGludmFsaWQgPSAhSW5zdGFuY2VIYW5kbGV8fFxuICAgICFJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZVR3b1BoYXNlIHx8XG4gICAgIUluc3RhbmNlSGFuZGxlLnRyYXZlcnNlRW50ZXJMZWF2ZTtcbiAgaWYgKGludmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RhbmNlSGFuZGxlIG5vdCBpbmplY3RlZCBiZWZvcmUgdXNlIScpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV2ZW50UGx1Z2luSHViID0ge1xuXG4gIC8qKlxuICAgKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgaW5qZWN0aW9uOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gSW5qZWN0ZWRNb3VudFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RNb3VudDogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0TW91bnQsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24oSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgSW5zdGFuY2VIYW5kbGUgPSBJbmplY3RlZEluc3RhbmNlSGFuZGxlO1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEluc3RhbmNlSGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24oaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicsXG4gICAgICAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsXG4gICAgICByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXJcbiAgICApIDogaW52YXJpYW50KCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpKTtcblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9XG4gICAgICBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24oaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24oaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHMoXG4gICAgICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NFdmVudFF1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhZXZlbnRRdWV1ZSxcbiAgICAgICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgJyArXG4gICAgICAnYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nXG4gICAgKSA6IGludmFyaWFudCghZXZlbnRRdWV1ZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24oKSB7XG4gICAgbGlzdGVuZXJCYW5rID0ge307XG4gIH0sXG5cbiAgX19nZXRMaXN0ZW5lckJhbms6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsaXN0ZW5lckJhbms7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpbkh1YjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblJlZ2lzdHJ5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIUV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBFdmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBFdmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHBsdWdpbkluZGV4ID4gLTEsXG4gICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluICcgK1xuICAgICAgJ3RoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJyxcbiAgICAgIHBsdWdpbk5hbWVcbiAgICApIDogaW52YXJpYW50KHBsdWdpbkluZGV4ID4gLTEpKTtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyxcbiAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCAnICtcbiAgICAgICdtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsXG4gICAgICBwbHVnaW5OYW1lXG4gICAgKSA6IGludmFyaWFudChQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cykpO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHB1Ymxpc2hFdmVudEZvclBsdWdpbihcbiAgICAgICAgICBwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSxcbiAgICAgICAgICBQbHVnaW5Nb2R1bGUsXG4gICAgICAgICAgZXZlbnROYW1lXG4gICAgICAgICksXG4gICAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIHBsdWdpbk5hbWVcbiAgICAgICkgOiBpbnZhcmlhbnQocHVibGlzaEV2ZW50Rm9yUGx1Z2luKFxuICAgICAgICBwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSxcbiAgICAgICAgUGx1Z2luTW9kdWxlLFxuICAgICAgICBldmVudE5hbWVcbiAgICAgICkpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpLFxuICAgICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArXG4gICAgJ2V2ZW50IG5hbWUsIGAlc2AuJyxcbiAgICBldmVudE5hbWVcbiAgKSA6IGludmFyaWFudCghRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkpO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShcbiAgICAgICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lLFxuICAgICAgICAgIFBsdWdpbk1vZHVsZSxcbiAgICAgICAgICBldmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKFxuICAgICAgZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSxcbiAgICAgIFBsdWdpbk1vZHVsZSxcbiAgICAgIGV2ZW50TmFtZVxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdLFxuICAgICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArXG4gICAgJ3JlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsXG4gICAgcmVnaXN0cmF0aW9uTmFtZVxuICApIDogaW52YXJpYW50KCFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdKSk7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9XG4gICAgUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbihJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIUV2ZW50UGx1Z2luT3JkZXIsXG4gICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuICcgK1xuICAgICAgJ29uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nXG4gICAgKSA6IGludmFyaWFudCghRXZlbnRQbHVnaW5PcmRlcikpO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBFdmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24oaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fFxuICAgICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICAhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0sXG4gICAgICAgICAgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zICcgK1xuICAgICAgICAgICd1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsXG4gICAgICAgICAgcGx1Z2luTmFtZVxuICAgICAgICApIDogaW52YXJpYW50KCFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSkpO1xuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW1xuICAgICAgICBkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXG4gICAgICBdIHx8IG51bGw7XG4gICAgfVxuICAgIGZvciAodmFyIHBoYXNlIGluIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAoIWRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW1xuICAgICAgICBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1cbiAgICAgIF07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW5Nb2R1bGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luUmVnaXN0cnk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5VdGlsc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBNb3VudGA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBkb20gSURzIGFuZFxuICogICBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICBNb3VudDogbnVsbCxcbiAgaW5qZWN0TW91bnQ6IGZ1bmN0aW9uKEluamVjdGVkTW91bnQpIHtcbiAgICBpbmplY3Rpb24uTW91bnQgPSBJbmplY3RlZE1vdW50O1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIEluamVjdGVkTW91bnQgJiYgSW5qZWN0ZWRNb3VudC5nZXROb2RlLFxuICAgICAgICAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0TW91bnQoLi4uKTogSW5qZWN0ZWQgTW91bnQgbW9kdWxlICcgK1xuICAgICAgICAnaXMgbWlzc2luZyBnZXROb2RlLidcbiAgICAgICkgOiBpbnZhcmlhbnQoSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fFxuICAgICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kIHx8XG4gICAgICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmUgfHxcbiAgICAgICAgIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fFxuICAgICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ7XG59XG5cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBpZHNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJRHMpO1xuICAgIHZhciBJRHNMZW4gPSBpZHNJc0FyciA/IGRpc3BhdGNoSURzLmxlbmd0aCA6IGRpc3BhdGNoSURzID8gMSA6IDA7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID9cbiAgICAgIGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6XG4gICAgICBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGlkc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBJRHNMZW4gPT09IGxpc3RlbmVyc0xlbixcbiAgICAgICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJ1xuICAgICkgOiBpbnZhcmlhbnQoaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuKSk7XG4gIH07XG59XG5cbi8qKlxuICogSW52b2tlcyBgY2IoZXZlbnQsIGxpc3RlbmVyLCBpZClgLiBBdm9pZHMgdXNpbmcgY2FsbCBpZiBubyBzY29wZSBpc1xuICogcHJvdmlkZWQuIFRoZSBgKGxpc3RlbmVyLGlkKWAgcGFpciBlZmZlY3RpdmVseSBmb3JtcyB0aGUgXCJkaXNwYXRjaFwiIGJ1dCBhcmVcbiAqIGtlcHQgc2VwYXJhdGUgdG8gY29uc2VydmUgbWVtb3J5LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRXZlbnREaXNwYXRjaChldmVudCwgY2IpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGNiKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJRHNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGNiKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJRHMpO1xuICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBQbHVnaW5Nb2R1bGUuZXhlY3V0ZURpc3BhdGNoKCkuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tSUQgRE9NIGlkIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBkb21JRCkge1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoZG9tSUQpO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBsaXN0ZW5lcihldmVudCwgZG9tSUQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIGV4ZWN1dGVEaXNwYXRjaCkge1xuICBmb3JFYWNoRXZlbnREaXNwYXRjaChldmVudCwgZXhlY3V0ZURpc3BhdGNoKTtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zIHRydWUsIG9yXG4gKiBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJRHMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnNbaV0oZXZlbnQsIGRpc3BhdGNoSURzW2ldKSkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hJRHNbaV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKGV2ZW50LCBkaXNwYXRjaElEcykpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaElEcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlKGV2ZW50KSB7XG4gIHZhciByZXQgPSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCk7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSUQgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lciksXG4gICAgJ2V4ZWN1dGVEaXJlY3REaXNwYXRjaCguLi4pOiBJbnZhbGlkIGBldmVudGAuJ1xuICApIDogaW52YXJpYW50KCFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpKSk7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID9cbiAgICBkaXNwYXRjaExpc3RlbmVyKGV2ZW50LCBkaXNwYXRjaElEKSA6XG4gICAgbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbH0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cbmZ1bmN0aW9uIGhhc0Rpc3BhdGNoZXMoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcbiAgaXNNb3ZlaXNoOiBpc01vdmVpc2gsXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXG5cbiAgZXhlY3V0ZURpcmVjdERpc3BhdGNoOiBleGVjdXRlRGlyZWN0RGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaDogZXhlY3V0ZURpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcbiAgaW5qZWN0aW9uOiBpbmplY3Rpb24sXG4gIHVzZVRvdWNoRXZlbnRzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZShcIi4vYWNjdW11bGF0ZUludG9cIik7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZShcIi4vZm9yRWFjaEFjY3VtdWxhdGVkXCIpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpZCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPVxuICAgIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhkb21JRCwgdXB3YXJkcywgZXZlbnQpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmICghZG9tSUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlzcGF0Y2hpbmcgaWQgbXVzdCBub3QgYmUgbnVsbCcpO1xuICAgIH1cbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoZG9tSUQsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9XG4gICAgICBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGRvbUlEKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2FuIG5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZShcbiAgICAgIGV2ZW50LmRpc3BhdGNoTWFya2VyLFxuICAgICAgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyxcbiAgICAgIGV2ZW50XG4gICAgKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaWQsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9XG4gICAgICAgIGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBpZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5kaXNwYXRjaE1hcmtlciwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VFbnRlckxlYXZlKFxuICAgIGZyb21JRCxcbiAgICB0b0lELFxuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzLFxuICAgIGxlYXZlLFxuICAgIGVudGVyXG4gICk7XG59XG5cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuXG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBPYmplY3QuYXNzaWduXG4gKi9cblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5hc3NpZ25cblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlcykge1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIHRhcmdldCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIG5leHRJbmRleCA9IDE7IG5leHRJbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IG5leHRJbmRleCsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbbmV4dEluZGV4XTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IE9iamVjdChuZXh0U291cmNlKTtcblxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IGFjY2Vzc29ycyBub3IgcHJveGllcy4gVGhlcmVmb3JlIHRoaXNcbiAgICAvLyBjb3B5IGNhbm5vdCB0aHJvdy4gSWYgd2UgZXZlciBzdXBwb3J0ZWQgdGhpcyB0aGVuIHdlIG11c3QgaGFuZGxlXG4gICAgLy8gZXhjZXB0aW9ucyBhbmQgc2lkZS1lZmZlY3RzLiBXZSBkb24ndCBzdXBwb3J0IHN5bWJvbHMgc28gdGhleSB3b24ndFxuICAgIC8vIGJlIHRyYW5zZmVycmVkLlxuXG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24oYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzLFxuICAgICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLidcbiAgKSA6IGludmFyaWFudChpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSk7XG4gIGlmIChpbnN0YW5jZS5kZXN0cnVjdG9yKSB7XG4gICAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICB9XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMgKG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24oQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKFwiLi9nZXRFdmVudFRhcmdldFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IGdldEV2ZW50VGFyZ2V0LFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IGRpc3BhdGNoTWFya2VyO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID9cbiAgICBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDpcbiAgICBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xufVxuXG5hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA/IGV2ZW50LnByZXZlbnREZWZhdWx0KCkgOiBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA/IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpIDogZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBudWxsO1xuICAgIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24oQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gIGFzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLnRocmVlQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy50aHJlZUFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNVSUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRUYXJnZXRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVmlld3BvcnRNZXRyaWNzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoXCIuL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uXCIpO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQgPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0TWV0cmljcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWNjdW11bGF0ZUludG9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIG5leHQgIT0gbnVsbCxcbiAgICAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJ1xuICApIDogaW52YXJpYW50KG5leHQgIT0gbnVsbCkpO1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICB2YXIgY3VycmVudElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICB2YXIgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHQpO1xuXG4gIGlmIChjdXJyZW50SXNBcnJheSAmJiBuZXh0SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChjdXJyZW50SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChuZXh0SXNBcnJheSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZW1wdHlGdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7IHJldHVybiBhcmc7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb3JFYWNoQWNjdW11bGF0ZWRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gZnVuY3Rpb24oYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IDMgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudFRhcmdldDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFyaWFudCBWaW9sYXRpb246ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU1pcnJvclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopLFxuICAgICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJ1xuICApIDogaW52YXJpYW50KG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSk7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5T2ZcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG52YXIga2V5T2YgPSBmdW5jdGlvbihvbmVLZXlPYmopIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb25lS2V5T2JqKSB7XG4gICAgaWYgKCFvbmVLZXlPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRFxuICAgICAgICBkZWZpbmUoWydleHBvcnRzJywgJy4vbGliL2FuaW1hdGUnLCAnLi9saWIvU2Nyb2xsZXInXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gQ29tbW9uSlNcbiAgICAgICAgZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCcuL2xpYi9hbmltYXRlJyksIHJlcXVpcmUoJy4vbGliL1Njcm9sbGVyJykpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGFuaW1hdGUsIFNjcm9sbGVyKSB7XG4gICAgZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbiAgICBleHBvcnRzLlNjcm9sbGVyID0gU2Nyb2xsZXI7XG59KSk7XG4iLCIvKlxuICogU2Nyb2xsZXJcbiAqIGh0dHA6Ly9naXRodWIuY29tL3p5bmdhL3Njcm9sbGVyXG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFp5bmdhIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20venluZ2Evc2Nyb2xsZXIvbWFzdGVyL01JVC1MSUNFTlNFLnR4dFxuICpcbiAqIEJhc2VkIG9uIHRoZSB3b3JrIG9mOiBVbmlmeSBQcm9qZWN0ICh1bmlmeS1wcm9qZWN0Lm9yZylcbiAqIGh0dHA6Ly91bmlmeS1wcm9qZWN0Lm9yZ1xuICogQ29weXJpZ2h0IDIwMTEsIERldXRzY2hlIFRlbGVrb20gQUdcbiAqIExpY2Vuc2U6IE1JVCArIEFwYWNoZSAoVjIpXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKFsnLi9hbmltYXRlJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gQ29tbW9uSlNcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJy4vYW5pbWF0ZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgcm9vdC5TY3JvbGxlciA9IGZhY3Rvcnkocm9vdC5hbmltYXRlKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChhbmltYXRlKSB7XG4gICAgdmFyIE5PT1AgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgcHVyZSBsb2dpYyAnY29tcG9uZW50JyBmb3IgJ3ZpcnR1YWwnIHNjcm9sbGluZy96b29taW5nLlxuICAgICAqL1xuICAgIHZhciBTY3JvbGxlciA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9fY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvKiogRW5hYmxlIHNjcm9sbGluZyBvbiB4LWF4aXMgKi9cbiAgICAgICAgICAgIHNjcm9sbGluZ1g6IHRydWUsXG5cbiAgICAgICAgICAgIC8qKiBFbmFibGUgc2Nyb2xsaW5nIG9uIHktYXhpcyAqL1xuICAgICAgICAgICAgc2Nyb2xsaW5nWTogdHJ1ZSxcblxuICAgICAgICAgICAgLyoqIEVuYWJsZSBhbmltYXRpb25zIGZvciBkZWNlbGVyYXRpb24sIHNuYXAgYmFjaywgem9vbWluZyBhbmQgc2Nyb2xsaW5nICovXG4gICAgICAgICAgICBhbmltYXRpbmc6IHRydWUsXG5cbiAgICAgICAgICAgIC8qKiBkdXJhdGlvbiBmb3IgYW5pbWF0aW9ucyB0cmlnZ2VyZWQgYnkgc2Nyb2xsVG8vem9vbVRvICovXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMjUwLFxuXG4gICAgICAgICAgICAvKiogRW5hYmxlIGJvdW5jaW5nIChjb250ZW50IGNhbiBiZSBzbG93bHkgbW92ZWQgb3V0c2lkZSBhbmQganVtcHMgYmFjayBhZnRlciByZWxlYXNpbmcpICovXG4gICAgICAgICAgICBib3VuY2luZzogdHJ1ZSxcblxuICAgICAgICAgICAgLyoqIEVuYWJsZSBsb2NraW5nIHRvIHRoZSBtYWluIGF4aXMgaWYgdXNlciBtb3ZlcyBvbmx5IHNsaWdodGx5IG9uIG9uZSBvZiB0aGVtIGF0IHN0YXJ0ICovXG4gICAgICAgICAgICBsb2NraW5nOiB0cnVlLFxuXG4gICAgICAgICAgICAvKiogRW5hYmxlIHBhZ2luYXRpb24gbW9kZSAoc3dpdGNoaW5nIGJldHdlZW4gZnVsbCBwYWdlIGNvbnRlbnQgcGFuZXMpICovXG4gICAgICAgICAgICBwYWdpbmc6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKiogRW5hYmxlIHNuYXBwaW5nIG9mIGNvbnRlbnQgdG8gYSBjb25maWd1cmVkIHBpeGVsIGdyaWQgKi9cbiAgICAgICAgICAgIHNuYXBwaW5nOiBmYWxzZSxcblxuICAgICAgICAgICAgLyoqIEVuYWJsZSB6b29taW5nIG9mIGNvbnRlbnQgdmlhIEFQSSwgZmluZ2VycyBhbmQgbW91c2Ugd2hlZWwgKi9cbiAgICAgICAgICAgIHpvb21pbmc6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKiogTWluaW11bSB6b29tIGxldmVsICovXG4gICAgICAgICAgICBtaW5ab29tOiAwLjUsXG5cbiAgICAgICAgICAgIC8qKiBNYXhpbXVtIHpvb20gbGV2ZWwgKi9cbiAgICAgICAgICAgIG1heFpvb206IDMsXG5cbiAgICAgICAgICAgIC8qKiBNdWx0aXBseSBvciBkZWNyZWFzZSBzY3JvbGxpbmcgc3BlZWQgKiovXG4gICAgICAgICAgICBzcGVlZE11bHRpcGxpZXI6IDEsXG5cbiAgICAgICAgICAgIC8qKiBDYWxsYmFjayB0aGF0IGlzIGZpcmVkIG9uIHRoZSBsYXRlciBvZiB0b3VjaCBlbmQgb3IgZGVjZWxlcmF0aW9uIGVuZCxcbiAgICAgICAgICAgICAgICBwcm92aWRlZCB0aGF0IGFub3RoZXIgc2Nyb2xsaW5nIGFjdGlvbiBoYXMgbm90IGJlZ3VuLiBVc2VkIHRvIGtub3dcbiAgICAgICAgICAgICAgICB3aGVuIHRvIGZhZGUgb3V0IGEgc2Nyb2xsYmFyLiAqL1xuICAgICAgICAgICAgc2Nyb2xsaW5nQ29tcGxldGU6IE5PT1AsXG5cbiAgICAgICAgICAgIC8qKiBUaGlzIGNvbmZpZ3VyZXMgdGhlIGFtb3VudCBvZiBjaGFuZ2UgYXBwbGllZCB0byBkZWNlbGVyYXRpb24gd2hlbiByZWFjaGluZyBib3VuZGFyaWVzICAqKi9cbiAgICAgICAgICAgIHBlbmV0cmF0aW9uRGVjZWxlcmF0aW9uIDogMC4wMyxcblxuICAgICAgICAgICAgLyoqIFRoaXMgY29uZmlndXJlcyB0aGUgYW1vdW50IG9mIGNoYW5nZSBhcHBsaWVkIHRvIGFjY2VsZXJhdGlvbiB3aGVuIHJlYWNoaW5nIGJvdW5kYXJpZXMgICoqL1xuICAgICAgICAgICAgcGVuZXRyYXRpb25BY2NlbGVyYXRpb24gOiAwLjA4XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8gRWFzaW5nIEVxdWF0aW9ucyAoYykgMjAwMyBSb2JlcnQgUGVubmVyLCBhbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgIC8vIE9wZW4gc291cmNlIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwb3Mge051bWJlcn0gcG9zaXRpb24gYmV0d2VlbiAwIChzdGFydCBvZiBlZmZlY3QpIGFuZCAxIChlbmQgb2YgZWZmZWN0KVxuICAgICAqKi9cbiAgICB2YXIgZWFzZU91dEN1YmljID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KChwb3MgLSAxKSwgMykgKyAxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBvcyB7TnVtYmVyfSBwb3NpdGlvbiBiZXR3ZWVuIDAgKHN0YXJ0IG9mIGVmZmVjdCkgYW5kIDEgKGVuZCBvZiBlZmZlY3QpXG4gICAgICoqL1xuICAgIHZhciBlYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKChwb3MgLz0gMC41KSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdyhwb3MsIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnBvdygocG9zIC0gMiksIDMpICsgMik7XG4gICAgfTtcblxuXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgSU5URVJOQUwgRklFTERTIDo6IFNUQVRVU1xuICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAqL1xuXG4gICAgICAgIC8qKiB7Qm9vbGVhbn0gV2hldGhlciBvbmx5IGEgc2luZ2xlIGZpbmdlciBpcyB1c2VkIGluIHRvdWNoIGhhbmRsaW5nICovXG4gICAgICAgIF9faXNTaW5nbGVUb3VjaDogZmFsc2UsXG5cbiAgICAgICAgLyoqIHtCb29sZWFufSBXaGV0aGVyIGEgdG91Y2ggZXZlbnQgc2VxdWVuY2UgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgICAgICAgX19pc1RyYWNraW5nOiBmYWxzZSxcblxuICAgICAgICAvKioge0Jvb2xlYW59IFdoZXRoZXIgYSBkZWNlbGVyYXRpb24gYW5pbWF0aW9uIHdlbnQgdG8gY29tcGxldGlvbi4gKi9cbiAgICAgICAgX19kaWREZWNlbGVyYXRpb25Db21wbGV0ZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHtCb29sZWFufSBXaGV0aGVyIGEgZ2VzdHVyZSB6b29tL3JvdGF0ZSBldmVudCBpcyBpbiBwcm9ncmVzcy4gQWN0aXZhdGVzIHdoZW5cbiAgICAgICAgICogYSBnZXN0dXJlc3RhcnQgZXZlbnQgaGFwcGVucy4gVGhpcyBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gZHJhZ2dpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBfX2lzR2VzdHVyaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICoge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIgaGFzIG1vdmVkIGJ5IHN1Y2ggYSBkaXN0YW5jZSB0aGF0IHdlIGhhdmUgZW5hYmxlZFxuICAgICAgICAgKiBkcmFnZ2luZyBtb2RlLiBIaW50OiBJdCdzIG9ubHkgZW5hYmxlZCBhZnRlciBzb21lIHBpeGVscyBvZiBtb3ZlbWVudCB0b1xuICAgICAgICAgKiBub3QgaW50ZXJydXB0IHdpdGggY2xpY2tzIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgIF9faXNEcmFnZ2luZzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHtCb29sZWFufSBOb3QgdG91Y2hpbmcgYW5kIGRyYWdnaW5nIGFueW1vcmUsIGFuZCBzbW9vdGhseSBhbmltYXRpbmcgdGhlXG4gICAgICAgICAqIHRvdWNoIHNlcXVlbmNlIHVzaW5nIGRlY2VsZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIF9faXNEZWNlbGVyYXRpbmc6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB7Qm9vbGVhbn0gU21vb3RobHkgYW5pbWF0aW5nIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCBjaGFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIF9faXNBbmltYXRpbmc6IGZhbHNlLFxuXG5cblxuICAgICAgICAvKlxuICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIElOVEVSTkFMIEZJRUxEUyA6OiBESU1FTlNJT05TXG4gICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICovXG5cbiAgICAgICAgLyoqIHtJbnRlZ2VyfSBWaWV3cG9ydCBsZWZ0IGJvdW5kYXJ5ICovXG4gICAgICAgIF9fY2xpZW50TGVmdDogMCxcblxuICAgICAgICAvKioge0ludGVnZXJ9IFZpZXdwb3J0IHJpZ2h0IGJvdW5kYXJ5ICovXG4gICAgICAgIF9fY2xpZW50VG9wOiAwLFxuXG4gICAgICAgIC8qKiB7SW50ZWdlcn0gVmlld3BvcnQgd2lkdGggKi9cbiAgICAgICAgX19jbGllbnRXaWR0aDogMCxcblxuICAgICAgICAvKioge0ludGVnZXJ9IFZpZXdwb3J0IGhlaWdodCAqL1xuICAgICAgICBfX2NsaWVudEhlaWdodDogMCxcblxuICAgICAgICAvKioge0ludGVnZXJ9IEZ1bGwgY29udGVudCdzIHdpZHRoICovXG4gICAgICAgIF9fY29udGVudFdpZHRoOiAwLFxuXG4gICAgICAgIC8qKiB7SW50ZWdlcn0gRnVsbCBjb250ZW50J3MgaGVpZ2h0ICovXG4gICAgICAgIF9fY29udGVudEhlaWdodDogMCxcblxuICAgICAgICAvKioge0ludGVnZXJ9IFNuYXBwaW5nIHdpZHRoIGZvciBjb250ZW50ICovXG4gICAgICAgIF9fc25hcFdpZHRoOiAxMDAsXG5cbiAgICAgICAgLyoqIHtJbnRlZ2VyfSBTbmFwcGluZyBoZWlnaHQgZm9yIGNvbnRlbnQgKi9cbiAgICAgICAgX19zbmFwSGVpZ2h0OiAxMDAsXG5cbiAgICAgICAgLyoqIHtOdW1iZXJ9IFpvb20gbGV2ZWwgKi9cbiAgICAgICAgX196b29tTGV2ZWw6IDEsXG5cbiAgICAgICAgLyoqIHtOdW1iZXJ9IFNjcm9sbCBwb3NpdGlvbiBvbiB4LWF4aXMgKi9cbiAgICAgICAgX19zY3JvbGxMZWZ0OiAwLFxuXG4gICAgICAgIC8qKiB7TnVtYmVyfSBTY3JvbGwgcG9zaXRpb24gb24geS1heGlzICovXG4gICAgICAgIF9fc2Nyb2xsVG9wOiAwLFxuXG4gICAgICAgIC8qKiB7SW50ZWdlcn0gTWF4aW11bSBhbGxvd2VkIHNjcm9sbCBwb3NpdGlvbiBvbiB4LWF4aXMgKi9cbiAgICAgICAgX19tYXhTY3JvbGxMZWZ0OiAwLFxuXG4gICAgICAgIC8qKiB7SW50ZWdlcn0gTWF4aW11bSBhbGxvd2VkIHNjcm9sbCBwb3NpdGlvbiBvbiB5LWF4aXMgKi9cbiAgICAgICAgX19tYXhTY3JvbGxUb3A6IDAsXG5cbiAgICAgICAgLyoge051bWJlcn0gU2NoZWR1bGVkIGxlZnQgcG9zaXRpb24gKGZpbmFsIHBvc2l0aW9uIHdoZW4gYW5pbWF0aW5nKSAqL1xuICAgICAgICBfX3NjaGVkdWxlZExlZnQ6IDAsXG5cbiAgICAgICAgLyoge051bWJlcn0gU2NoZWR1bGVkIHRvcCBwb3NpdGlvbiAoZmluYWwgcG9zaXRpb24gd2hlbiBhbmltYXRpbmcpICovXG4gICAgICAgIF9fc2NoZWR1bGVkVG9wOiAwLFxuXG4gICAgICAgIC8qIHtOdW1iZXJ9IFNjaGVkdWxlZCB6b29tIGxldmVsIChmaW5hbCBzY2FsZSB3aGVuIGFuaW1hdGluZykgKi9cbiAgICAgICAgX19zY2hlZHVsZWRab29tOiAwLFxuXG5cblxuICAgICAgICAvKlxuICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIElOVEVSTkFMIEZJRUxEUyA6OiBMQVNUIFBPU0lUSU9OU1xuICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAqL1xuXG4gICAgICAgIC8qKiB7TnVtYmVyfSBMZWZ0IHBvc2l0aW9uIG9mIGZpbmdlciBhdCBzdGFydCAqL1xuICAgICAgICBfX2xhc3RUb3VjaExlZnQ6IG51bGwsXG5cbiAgICAgICAgLyoqIHtOdW1iZXJ9IFRvcCBwb3NpdGlvbiBvZiBmaW5nZXIgYXQgc3RhcnQgKi9cbiAgICAgICAgX19sYXN0VG91Y2hUb3A6IG51bGwsXG5cbiAgICAgICAgLyoqIHtEYXRlfSBUaW1lc3RhbXAgb2YgbGFzdCBtb3ZlIG9mIGZpbmdlci4gVXNlZCB0byBsaW1pdCB0cmFja2luZyByYW5nZSBmb3IgZGVjZWxlcmF0aW9uIHNwZWVkLiAqL1xuICAgICAgICBfX2xhc3RUb3VjaE1vdmU6IG51bGwsXG5cbiAgICAgICAgLyoqIHtBcnJheX0gTGlzdCBvZiBwb3NpdGlvbnMsIHVzZXMgdGhyZWUgaW5kZXhlcyBmb3IgZWFjaCBzdGF0ZTogbGVmdCwgdG9wLCB0aW1lc3RhbXAgKi9cbiAgICAgICAgX19wb3NpdGlvbnM6IG51bGwsXG5cblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgSU5URVJOQUwgRklFTERTIDo6IERFQ0VMRVJBVElPTiBTVVBQT1JUXG4gICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICovXG5cbiAgICAgICAgLyoqIHtJbnRlZ2VyfSBNaW5pbXVtIGxlZnQgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBkZWNlbGVyYXRpb24gKi9cbiAgICAgICAgX19taW5EZWNlbGVyYXRpb25TY3JvbGxMZWZ0OiBudWxsLFxuXG4gICAgICAgIC8qKiB7SW50ZWdlcn0gTWluaW11bSB0b3Agc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBkZWNlbGVyYXRpb24gKi9cbiAgICAgICAgX19taW5EZWNlbGVyYXRpb25TY3JvbGxUb3A6IG51bGwsXG5cbiAgICAgICAgLyoqIHtJbnRlZ2VyfSBNYXhpbXVtIGxlZnQgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBkZWNlbGVyYXRpb24gKi9cbiAgICAgICAgX19tYXhEZWNlbGVyYXRpb25TY3JvbGxMZWZ0OiBudWxsLFxuXG4gICAgICAgIC8qKiB7SW50ZWdlcn0gTWF4aW11bSB0b3Agc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBkZWNlbGVyYXRpb24gKi9cbiAgICAgICAgX19tYXhEZWNlbGVyYXRpb25TY3JvbGxUb3A6IG51bGwsXG5cbiAgICAgICAgLyoqIHtOdW1iZXJ9IEN1cnJlbnQgZmFjdG9yIHRvIG1vZGlmeSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbiB3aXRoIG9uIGV2ZXJ5IHN0ZXAgKi9cbiAgICAgICAgX19kZWNlbGVyYXRpb25WZWxvY2l0eVg6IG51bGwsXG5cbiAgICAgICAgLyoqIHtOdW1iZXJ9IEN1cnJlbnQgZmFjdG9yIHRvIG1vZGlmeSB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24gd2l0aCBvbiBldmVyeSBzdGVwICovXG4gICAgICAgIF9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZOiBudWxsLFxuXG5cblxuICAgICAgICAvKlxuICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIFBVQkxJQyBBUElcbiAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uZmlndXJlcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY2xpZW50IChvdXRlcikgYW5kIGNvbnRlbnQgKGlubmVyKSBlbGVtZW50cy5cbiAgICAgICAgICogUmVxdWlyZXMgdGhlIGF2YWlsYWJsZSBzcGFjZSBmb3IgdGhlIG91dGVyIGVsZW1lbnQgYW5kIHRoZSBvdXRlciBzaXplIG9mIHRoZSBpbm5lciBlbGVtZW50LlxuICAgICAgICAgKiBBbGwgdmFsdWVzIHdoaWNoIGFyZSBmYWxzeSAobnVsbCBvciB6ZXJvIGV0Yy4pIGFyZSBpZ25vcmVkIGFuZCB0aGUgb2xkIHZhbHVlIGlzIGtlcHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjbGllbnRXaWR0aCB7SW50ZWdlciA/IG51bGx9IElubmVyIHdpZHRoIG9mIG91dGVyIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIGNsaWVudEhlaWdodCB7SW50ZWdlciA/IG51bGx9IElubmVyIGhlaWdodCBvZiBvdXRlciBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50V2lkdGgge0ludGVnZXIgPyBudWxsfSBPdXRlciB3aWR0aCBvZiBpbm5lciBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBjb250ZW50SGVpZ2h0IHtJbnRlZ2VyID8gbnVsbH0gT3V0ZXIgaGVpZ2h0IG9mIGlubmVyIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHNldERpbWVuc2lvbnMgOiBmdW5jdGlvbiAoY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCwgY29udGVudFdpZHRoLCBjb250ZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSB2YWx1ZXMgd2hpY2ggYXJlIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChjbGllbnRXaWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jbGllbnRXaWR0aCA9IGNsaWVudFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2xpZW50SGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NsaWVudEhlaWdodCA9IGNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRlbnRXaWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb250ZW50V2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50SGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRlbnRIZWlnaHQgPSBjb250ZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWZyZXNoIG1heGltdW1zXG4gICAgICAgICAgICB0aGlzLl9fY29tcHV0ZVNjcm9sbE1heCgpO1xuXG4gICAgICAgICAgICAvLyBSZWZyZXNoIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLl9fc2Nyb2xsTGVmdCwgdGhpcy5fX3Njcm9sbFRvcCwgdHJ1ZSk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgY2xpZW50IGNvb3JkaW5hdGVzIGluIHJlbGF0aW9uIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnQge0ludGVnZXIgPyAwfSBMZWZ0IHBvc2l0aW9uIG9mIG91dGVyIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHRvcCB7SW50ZWdlciA/IDB9IFRvcCBwb3NpdGlvbiBvZiBvdXRlciBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBzZXRQb3NpdGlvbiA6IGZ1bmN0aW9uIChsZWZ0LCB0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuX19jbGllbnRMZWZ0ID0gbGVmdCB8fCAwO1xuICAgICAgICAgICAgdGhpcy5fX2NsaWVudFRvcCA9IHRvcCB8fCAwO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbmZpZ3VyZXMgdGhlIHNuYXBwaW5nICh3aGVuIHNuYXBwaW5nIGlzIGFjdGl2ZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHdpZHRoIHtJbnRlZ2VyfSBTbmFwcGluZyB3aWR0aFxuICAgICAgICAgKiBAcGFyYW0gaGVpZ2h0IHtJbnRlZ2VyfSBTbmFwcGluZyBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHNldFNuYXBTaXplIDogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX19zbmFwV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX19zbmFwSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNjcm9sbCBwb3NpdGlvbiBhbmQgem9vbWluZyB2YWx1ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7TWFwfSBgbGVmdGAgYW5kIGB0b3BgIHNjcm9sbCBwb3NpdGlvbiBhbmQgYHpvb21gIGxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuX19zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5fX3Njcm9sbFRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogdGhpcy5fX3Njcm9sbExlZnQgKyB0aGlzLl9fY2xpZW50V2lkdGgvdGhpcy5fX3pvb21MZXZlbCxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuX19zY3JvbGxUb3AgKyB0aGlzLl9fY2xpZW50SGVpZ2h0L3RoaXMuX196b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgem9vbTogdGhpcy5fX3pvb21MZXZlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcG9pbnQgaW4gaW4gY29udGVudCBzcGFjZSBmcm9tIHNjcm9sbCBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldFBvaW50IDogZnVuY3Rpb24gKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdCA6IHNjcm9sbExlZnQgLyB2YWx1ZXMuem9vbSxcbiAgICAgICAgICAgICAgICB0b3AgOiBzY3JvbGxUb3AgLyB2YWx1ZXMuem9vbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7TWFwfSBgbGVmdGAgYW5kIGB0b3BgIG1heGltdW0gc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2Nyb2xsTWF4IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLl9fbWF4U2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuX19tYXhTY3JvbGxUb3BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogWm9vbXMgdG8gdGhlIGdpdmVuIGxldmVsLiBTdXBwb3J0cyBvcHRpb25hbCBhbmltYXRpb24uIFpvb21zXG4gICAgICAgICAqIHRoZSBjZW50ZXIgd2hlbiBubyBjb29yZGluYXRlcyBhcmUgZ2l2ZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBsZXZlbCB7TnVtYmVyfSBMZXZlbCB0byB6b29tIHRvXG4gICAgICAgICAqIEBwYXJhbSBpc0FuaW1hdGVkIHtCb29sZWFuID8gZmFsc2V9IFdoZXRoZXIgdG8gdXNlIGFuaW1hdGlvblxuICAgICAgICAgKiBAcGFyYW0gZml4ZWRMZWZ0IHtOdW1iZXIgPyB1bmRlZmluZWR9IFN0YXRpb25hcnkgcG9pbnQncyBsZWZ0IGNvb3JkaW5hdGUgKHZlY3RvciBpbiBjbGllbnQgc3BhY2UpXG4gICAgICAgICAqIEBwYXJhbSBmaXhlZFRvcCB7TnVtYmVyID8gdW5kZWZpbmVkfSBTdGF0aW9uYXJ5IHBvaW50J3MgdG9wIGNvb3JkaW5hdGUgKHZlY3RvciBpbiBjbGllbnQgc3BhY2UpXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb24gPyBudWxsfSBBIGNhbGxiYWNrIHRoYXQgZ2V0cyBmaXJlZCB3aGVuIHRoZSB6b29tIGlzIGNvbXBsZXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgem9vbVRvIDogZnVuY3Rpb24gKGxldmVsLCBpc0FuaW1hdGVkLCBmaXhlZExlZnQsIGZpeGVkVG9wLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuem9vbWluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlpvb21pbmcgaXMgbm90IGVuYWJsZWQhXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgY2FsbGJhY2sgaWYgZXhpc3RzXG4gICAgICAgICAgICBpZihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuX196b29tQ29tcGxldGUgPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcCBkZWNlbGVyYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLl9faXNEZWNlbGVyYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRlLnN0b3AodGhpcy5fX2lzRGVjZWxlcmF0aW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNEZWNlbGVyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZExldmVsID0gdGhpcy5fX3pvb21MZXZlbDtcblxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGZpeGVkIHBvaW50IHRvIGNlbnRlciBvZiB2aWV3cG9ydCBpZiBub3QgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKGZpeGVkTGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZml4ZWRMZWZ0ID0gdGhpcy5fX2NsaWVudFdpZHRoIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpeGVkVG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaXhlZFRvcCA9IHRoaXMuX19jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMaW1pdCBsZXZlbCBhY2NvcmRpbmcgdG8gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgbGV2ZWwgPSBNYXRoLm1heChNYXRoLm1pbihsZXZlbCwgdGhpcy5vcHRpb25zLm1heFpvb20pLCB0aGlzLm9wdGlvbnMubWluWm9vbSk7XG5cbiAgICAgICAgICAgIC8vIFJlY29tcHV0ZSBtYXhpbXVtIHZhbHVlcyB3aGlsZSB0ZW1wb3JhcnkgdHdlYWtpbmcgbWF4aW11bSBzY3JvbGwgcmFuZ2VzXG4gICAgICAgICAgICB0aGlzLl9fY29tcHV0ZVNjcm9sbE1heChsZXZlbCk7XG5cbiAgICAgICAgICAgIC8vIFJlY29tcHV0ZSBsZWZ0IGFuZCB0b3Agc2Nyb2xsIHBvc2l0aW9ucyBiYXNlZCBvbiBuZXcgem9vbSBsZXZlbC5cbiAgICAgICAgICAgIC8vIENob29zaW5nIHRoZSBuZXcgdmlld3BvcnQgc28gdGhhdCB0aGUgb3JpZ2luJ3MgcG9zaXRpb24gcmVtYWluc1xuICAgICAgICAgICAgLy8gZml4ZWQsIHdlIGhhdmUgY2VudHJhbCBkaWxhdGlvbiBhYm91dCB0aGUgb3JpZ2luLlxuICAgICAgICAgICAgLy8gKiBGaXhlZCBwb2ludCwgJEYkLCByZW1haW5zIHN0YXRpb25hcnkgaW4gY29udGVudCBzcGFjZSBhbmQgaW4gdGhlXG4gICAgICAgICAgICAvLyB2aWV3cG9ydC5cbiAgICAgICAgICAgIC8vICogSW5pdGlhbCBzY3JvbGwgcG9zaXRpb24sICRTX2kkLCBpbiBjb250ZW50IHNwYWNlLlxuICAgICAgICAgICAgLy8gKiBGaW5hbCBzY3JvbGwgcG9zaXRpb24sICRTX2YkLCBpbiBjb250ZW50IHNwYWNlLlxuICAgICAgICAgICAgLy8gKiBJbml0aWFsIHNjYWxpbmcgZmFjdG9yLCAka19pJC5cbiAgICAgICAgICAgIC8vICogRmluYWwgc2NhbGluZyBmYWN0b3IsICRrX2YkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICogJFNfaSBcXG1hcHN0byBTX2YkLlxuICAgICAgICAgICAgLy8gKiAkKFNfaSAtIEYpIGtfaSA9IChTX2YgLSBGKSBrX2YkLlxuICAgICAgICAgICAgLy8gKiAkKFNfaSAtIEYpIGtfaS9rX2YgPSAoU19mIC0gRikkLlxuICAgICAgICAgICAgLy8gKiAkU19mID0gRiArIChTX2kgLSBGKSBrX2kva19mJC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGaXhlZCBwb2ludCBsb2NhdGlvbiwgJFxcdmVjdG9ye2Z9ID0gKEYgLSBTX2kpIGtfaSQuXG4gICAgICAgICAgICAvLyAqICRGID0gU19pICsgXFx2ZWN0b3J7Zn0va19pJC5cbiAgICAgICAgICAgIC8vICogJFNfZiA9IFNfaSArIFxcdmVjdG9ye2Z9L2tfaSArIChTX2kgLSBTX2kgLSBcXHZlY3RvcntmfS9rX2kpIGtfaS9rX2YkLlxuICAgICAgICAgICAgLy8gKiAkU19mID0gU19pICsgXFx2ZWN0b3J7Zn0va19pIC0gXFx2ZWN0b3J7Zn0va19mJC5cbiAgICAgICAgICAgIC8vICogJFNfZiBrX2YgPSBTX2kga19mICsgKGtfZi9rX2kgLSAxKVxcdmVjdG9ye2Z9JC5cbiAgICAgICAgICAgIC8vICogJFNfZiBrX2YgPSAoa19mL2tfaSkoU19pIGtfaSkgKyAoa19mL2tfaSAtIDEpIFxcdmVjdG9ye2Z9JC5cbiAgICAgICAgICAgIHZhciBrID0gbGV2ZWwgLyBvbGRMZXZlbDtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gayoodGhpcy5fX3Njcm9sbExlZnQgKyBmaXhlZExlZnQpIC0gZml4ZWRMZWZ0O1xuICAgICAgICAgICAgdmFyIHRvcCA9IGsqKHRoaXMuX19zY3JvbGxUb3AgKyBmaXhlZFRvcCkgLSBmaXhlZFRvcDtcblxuICAgICAgICAgICAgLy8gTGltaXQgeC1heGlzXG4gICAgICAgICAgICBpZiAobGVmdCA+IHRoaXMuX19tYXhTY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHRoaXMuX19tYXhTY3JvbGxMZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMaW1pdCB5LWF4aXNcbiAgICAgICAgICAgIGlmICh0b3AgPiB0aGlzLl9fbWF4U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gdGhpcy5fX21heFNjcm9sbFRvcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9wIDwgMCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFB1c2ggdmFsdWVzIG91dFxuICAgICAgICAgICAgdGhpcy5fX3B1Ymxpc2gobGVmdCwgdG9wLCBsZXZlbCwgaXNBbmltYXRlZCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogWm9vbXMgdGhlIGNvbnRlbnQgYnkgdGhlIGdpdmVuIGZhY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGZhY3RvciB7TnVtYmVyfSBab29tIGJ5IGdpdmVuIGZhY3RvclxuICAgICAgICAgKiBAcGFyYW0gaXNBbmltYXRlZCB7Qm9vbGVhbiA/IGZhbHNlfSBXaGV0aGVyIHRvIHVzZSBhbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIG9yaWdpbkxlZnQge051bWJlciA/IDB9IFpvb20gaW4gYXQgZ2l2ZW4gbGVmdCBjb29yZGluYXRlXG4gICAgICAgICAqIEBwYXJhbSBvcmlnaW5Ub3Age051bWJlciA/IDB9IFpvb20gaW4gYXQgZ2l2ZW4gdG9wIGNvb3JkaW5hdGVcbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbiA/IG51bGx9IEEgY2FsbGJhY2sgdGhhdCBnZXRzIGZpcmVkIHdoZW4gdGhlIHpvb20gaXMgY29tcGxldGUuXG4gICAgICAgICAqL1xuICAgICAgICB6b29tQnkgOiBmdW5jdGlvbiAoZmFjdG9yLCBpc0FuaW1hdGVkLCBvcmlnaW5MZWZ0LCBvcmlnaW5Ub3AsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21Ubyh0aGlzLl9fem9vbUxldmVsICogZmFjdG9yLCBpc0FuaW1hdGVkLCBvcmlnaW5MZWZ0LCBvcmlnaW5Ub3AsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGxzIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi4gUmVzcGVjdCBsaW1pdGF0aW9ucyBhbmQgc25hcHBpbmcgYXV0b21hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxlZnQge051bWJlcj9udWxsfSBIb3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbiwga2VlcHMgY3VycmVudCBpZiB2YWx1ZSBpcyA8Y29kZT5udWxsPC9jb2RlPlxuICAgICAgICAgKiBAcGFyYW0gdG9wIHtOdW1iZXI/bnVsbH0gVmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLCBrZWVwcyBjdXJyZW50IGlmIHZhbHVlIGlzIDxjb2RlPm51bGw8L2NvZGU+XG4gICAgICAgICAqIEBwYXJhbSBpc0FuaW1hdGVkIHtCb29sZWFuP2ZhbHNlfSBXaGV0aGVyIHRoZSBzY3JvbGxpbmcgc2hvdWxkIGhhcHBlbiB1c2luZyBhbiBhbmltYXRpb25cbiAgICAgICAgICogQHBhcmFtIHpvb20ge051bWJlcn0gWzEuMF0gWm9vbSBsZXZlbCB0byBnbyB0b1xuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsVG8gOiBmdW5jdGlvbiAobGVmdCwgdG9wLCBpc0FuaW1hdGVkLCB6b29tKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGRlY2VsZXJhdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuX19pc0RlY2VsZXJhdGluZykge1xuICAgICAgICAgICAgICAgIGFuaW1hdGUuc3RvcCh0aGlzLl9faXNEZWNlbGVyYXRpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pc0RlY2VsZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb3JyZWN0IGNvb3JkaW5hdGVzIGJhc2VkIG9uIG5ldyB6b29tIGxldmVsXG4gICAgICAgICAgICBpZiAoem9vbSAhPT0gdW5kZWZpbmVkICYmIHpvb20gIT09IHRoaXMuX196b29tTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy56b29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlpvb21pbmcgaXMgbm90IGVuYWJsZWQhXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlZnQgKj0gem9vbTtcbiAgICAgICAgICAgICAgICB0b3AgKj0gem9vbTtcblxuICAgICAgICAgICAgICAgIC8vIFJlY29tcHV0ZSBtYXhpbXVtIHZhbHVlcyB3aGlsZSB0ZW1wb3JhcnkgdHdlYWtpbmcgbWF4aW11bSBzY3JvbGwgcmFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbXB1dGVTY3JvbGxNYXgoem9vbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgem9vbSB3aGVuIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAgem9vbSA9IHRoaXMuX196b29tTGV2ZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNjcm9sbGluZ1gpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdGhpcy5fX3Njcm9sbExlZnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLnJvdW5kKGxlZnQgLyB0aGlzLl9fY2xpZW50V2lkdGgpICogdGhpcy5fX2NsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNuYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLnJvdW5kKGxlZnQgLyB0aGlzLl9fc25hcFdpZHRoKSAqIHRoaXMuX19zbmFwV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY3JvbGxpbmdZKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gdGhpcy5fX3Njcm9sbFRvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYWdpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5yb3VuZCh0b3AgLyB0aGlzLl9fY2xpZW50SGVpZ2h0KSAqIHRoaXMuX19jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc25hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5yb3VuZCh0b3AgLyB0aGlzLl9fc25hcEhlaWdodCkgKiB0aGlzLl9fc25hcEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpbWl0IGZvciBhbGxvd2VkIHJhbmdlc1xuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuX19tYXhTY3JvbGxMZWZ0LCBsZWZ0KSwgMCk7XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLl9fbWF4U2Nyb2xsVG9wLCB0b3ApLCAwKTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgYW5pbWF0ZSB3aGVuIG5vIGNoYW5nZSBkZXRlY3RlZCwgc3RpbGwgY2FsbCBwdWJsaXNoIHRvIG1ha2Ugc3VyZVxuICAgICAgICAgICAgLy8gdGhhdCByZW5kZXJlZCBwb3NpdGlvbiBpcyByZWFsbHkgaW4tc3luYyB3aXRoIGludGVybmFsIGRhdGFcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSB0aGlzLl9fc2Nyb2xsTGVmdCAmJiB0b3AgPT09IHRoaXMuX19zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICBpc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggbmV3IHZhbHVlc1xuICAgICAgICAgICAgdGhpcy5fX3B1Ymxpc2gobGVmdCwgdG9wLCB6b29tLCBpc0FuaW1hdGVkKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgYnkgdGhlIGdpdmVuIG9mZnNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCB7TnVtYmVyID8gMH0gU2Nyb2xsIHgtYXhpcyBieSBnaXZlbiBvZmZzZXRcbiAgICAgICAgICogQHBhcmFtIHRvcCB7TnVtYmVyID8gMH0gU2Nyb2xsIHgtYXhpcyBieSBnaXZlbiBvZmZzZXRcbiAgICAgICAgICogQHBhcmFtIGlzQW5pbWF0ZWQge0Jvb2xlYW4gPyBmYWxzZX0gV2hldGhlciB0byBhbmltYXRlIHRoZSBnaXZlbiBjaGFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIHNjcm9sbEJ5IDogZnVuY3Rpb24gKGxlZnQsIHRvcCwgaXNBbmltYXRlZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0TGVmdCA9IHRoaXMuX19pc0FuaW1hdGluZyA/IHRoaXMuX19zY2hlZHVsZWRMZWZ0IDogdGhpcy5fX3Njcm9sbExlZnQ7XG4gICAgICAgICAgICB2YXIgc3RhcnRUb3AgPSB0aGlzLl9faXNBbmltYXRpbmcgPyB0aGlzLl9fc2NoZWR1bGVkVG9wIDogdGhpcy5fX3Njcm9sbFRvcDtcblxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyhzdGFydExlZnQgKyAobGVmdCB8fCAwKSwgc3RhcnRUb3AgKyAodG9wIHx8IDApLCBpc0FuaW1hdGVkKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgRVZFTlQgQ0FMTEJBQ0tTXG4gICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIHdoZWVsIGhhbmRsZXIgZm9yIHpvb21pbmcgc3VwcG9ydFxuICAgICAgICAgKi9cbiAgICAgICAgZG9Nb3VzZVpvb20gOiBmdW5jdGlvbiAod2hlZWxEZWx0YSwgdGltZVN0YW1wLCBwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSB3aGVlbERlbHRhID4gMCA/IDAuOTcgOiAxLjAzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy56b29tVG8odGhpcy5fX3pvb21MZXZlbCAqIGNoYW5nZSwgZmFsc2UsIHBhZ2VYIC0gdGhpcy5fX2NsaWVudExlZnQsIHBhZ2VZIC0gdGhpcy5fX2NsaWVudFRvcCk7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2ggc3RhcnQgaGFuZGxlciBmb3Igc2Nyb2xsaW5nIHN1cHBvcnRcbiAgICAgICAgICovXG4gICAgICAgIGRvVG91Y2hTdGFydCA6IGZ1bmN0aW9uICh0b3VjaGVzLCB0aW1lU3RhbXApIHtcbiAgICAgICAgICAgIC8vIEFycmF5LWxpa2UgY2hlY2sgaXMgZW5vdWdoIGhlcmVcbiAgICAgICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b3VjaCBsaXN0OiBcIiArIHRvdWNoZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRpbWVTdGFtcCA9IHRpbWVTdGFtcC52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVTdGFtcCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGltZXN0YW1wIHZhbHVlOiBcIiArIHRpbWVTdGFtcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IGludGVycnVwdGVkQW5pbWF0aW9uIGZsYWdcbiAgICAgICAgICAgIHRoaXMuX19pbnRlcnJ1cHRlZEFuaW1hdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0b3AgZGVjZWxlcmF0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5fX2lzRGVjZWxlcmF0aW5nKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZS5zdG9wKHRoaXMuX19pc0RlY2VsZXJhdGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2lzRGVjZWxlcmF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludGVycnVwdGVkQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLl9faXNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRlLnN0b3AodGhpcy5fX2lzQW5pbWF0aW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9faW50ZXJydXB0ZWRBbmltYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgY2VudGVyIHBvaW50IHdoZW4gZGVhbGluZyB3aXRoIHR3byBmaW5nZXJzXG4gICAgICAgICAgICB2YXIgY3VycmVudFRvdWNoTGVmdCwgY3VycmVudFRvdWNoVG9wO1xuICAgICAgICAgICAgdmFyIGlzU2luZ2xlVG91Y2ggPSB0b3VjaGVzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIGlmIChpc1NpbmdsZVRvdWNoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRvdWNoTGVmdCA9IHRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgY3VycmVudFRvdWNoVG9wID0gdG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRvdWNoTGVmdCA9IE1hdGguYWJzKHRvdWNoZXNbMF0ucGFnZVggKyB0b3VjaGVzWzFdLnBhZ2VYKSAvIDI7XG4gICAgICAgICAgICAgICAgY3VycmVudFRvdWNoVG9wID0gTWF0aC5hYnModG91Y2hlc1swXS5wYWdlWSArIHRvdWNoZXNbMV0ucGFnZVkpIC8gMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBwb3NpdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX19pbml0aWFsVG91Y2hMZWZ0ID0gY3VycmVudFRvdWNoTGVmdDtcbiAgICAgICAgICAgIHRoaXMuX19pbml0aWFsVG91Y2hUb3AgPSBjdXJyZW50VG91Y2hUb3A7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5fX3pvb21MZXZlbFN0YXJ0ID0gdGhpcy5fX3pvb21MZXZlbDtcblxuICAgICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCB0b3VjaCBwb3NpdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX19sYXN0VG91Y2hMZWZ0ID0gY3VycmVudFRvdWNoTGVmdDtcbiAgICAgICAgICAgIHRoaXMuX19sYXN0VG91Y2hUb3AgPSBjdXJyZW50VG91Y2hUb3A7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGluaXRpYWwgbW92ZSB0aW1lIHN0YW1wXG4gICAgICAgICAgICB0aGlzLl9fbGFzdFRvdWNoTW92ZSA9IHRpbWVTdGFtcDtcblxuICAgICAgICAgICAgLy8gUmVzZXQgaW5pdGlhbCBzY2FsZVxuICAgICAgICAgICAgdGhpcy5fX2xhc3RTY2FsZSA9IDE7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IGxvY2tpbmcgZmxhZ3NcbiAgICAgICAgICAgIHRoaXMuX19lbmFibGVTY3JvbGxYID0gIWlzU2luZ2xlVG91Y2ggJiYgdGhpcy5vcHRpb25zLnNjcm9sbGluZ1g7XG4gICAgICAgICAgICB0aGlzLl9fZW5hYmxlU2Nyb2xsWSA9ICFpc1NpbmdsZVRvdWNoICYmIHRoaXMub3B0aW9ucy5zY3JvbGxpbmdZO1xuXG4gICAgICAgICAgICAvLyBSZXNldCB0cmFja2luZyBmbGFnXG4gICAgICAgICAgICB0aGlzLl9faXNUcmFja2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IGRlY2VsZXJhdGlvbiBjb21wbGV0ZSBmbGFnXG4gICAgICAgICAgICB0aGlzLl9fZGlkRGVjZWxlcmF0aW9uQ29tcGxldGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gRHJhZ2dpbmcgc3RhcnRzIGRpcmVjdGx5IHdpdGggdHdvIGZpbmdlcnMsIG90aGVyd2lzZSBsYXp5IHdpdGggYW4gb2Zmc2V0XG4gICAgICAgICAgICB0aGlzLl9faXNEcmFnZ2luZyA9ICFpc1NpbmdsZVRvdWNoO1xuXG4gICAgICAgICAgICAvLyBTb21lIGZlYXR1cmVzIGFyZSBkaXNhYmxlZCBpbiBtdWx0aSB0b3VjaCBzY2VuYXJpb3NcbiAgICAgICAgICAgIHRoaXMuX19pc1NpbmdsZVRvdWNoID0gaXNTaW5nbGVUb3VjaDtcblxuICAgICAgICAgICAgLy8gQ2xlYXJpbmcgZGF0YSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHRoaXMuX19wb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaCBtb3ZlIGhhbmRsZXIgZm9yIHNjcm9sbGluZyBzdXBwb3J0XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbMS4wXSBzY2FsZSAtIC4uLi5cbiAgICAgICAgICovXG4gICAgICAgIGRvVG91Y2hNb3ZlIDogZnVuY3Rpb24gKHRvdWNoZXMsIHRpbWVTdGFtcCwgc2NhbGUpIHtcbiAgICAgICAgICAgIC8vIEFycmF5LWxpa2UgY2hlY2sgaXMgZW5vdWdoIGhlcmVcbiAgICAgICAgICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b3VjaCBsaXN0OiBcIiArIHRvdWNoZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRpbWVTdGFtcCA9IHRpbWVTdGFtcC52YWx1ZU9mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpbWVTdGFtcCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGltZXN0YW1wIHZhbHVlOiBcIiArIHRpbWVTdGFtcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElnbm9yZSBldmVudCB3aGVuIHRyYWNraW5nIGlzIG5vdCBlbmFibGVkIChldmVudCBtaWdodCBiZSBvdXRzaWRlIG9mIGVsZW1lbnQpXG4gICAgICAgICAgICBpZiAoIXRoaXMuX19pc1RyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudFRvdWNoTGVmdCwgY3VycmVudFRvdWNoVG9wO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIG1vdmUgYmFzZWQgYXJvdW5kIG9mIGNlbnRlciBvZiBmaW5nZXJzXG4gICAgICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VG91Y2hMZWZ0ID0gTWF0aC5hYnModG91Y2hlc1swXS5wYWdlWCArIHRvdWNoZXNbMV0ucGFnZVgpIC8gMjtcbiAgICAgICAgICAgICAgICBjdXJyZW50VG91Y2hUb3AgPSBNYXRoLmFicyh0b3VjaGVzWzBdLnBhZ2VZICsgdG91Y2hlc1sxXS5wYWdlWSkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VG91Y2hMZWZ0ID0gdG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgICBjdXJyZW50VG91Y2hUb3AgPSB0b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5fX3Bvc2l0aW9ucztcblxuICAgICAgICAgICAgLy8gQXJlIHdlIGFscmVhZHkgaXMgZHJhZ2dpbmcgbW9kZT9cbiAgICAgICAgICAgIGlmICh0aGlzLl9faXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbW92ZSBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBtb3ZlWCA9IGN1cnJlbnRUb3VjaExlZnQgLSB0aGlzLl9fbGFzdFRvdWNoTGVmdDtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZVkgPSBjdXJyZW50VG91Y2hUb3AgLSB0aGlzLl9fbGFzdFRvdWNoVG9wO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVhZCBwcmV2aW91cyBzY3JvbGwgcG9zaXRpb24gYW5kIHpvb21pbmdcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuX19zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9fc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuX196b29tTGV2ZWw7XG5cbiAgICAgICAgICAgICAgICAvLyBXb3JrIHdpdGggc2NhbGluZ1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy56b29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRMZXZlbCA9IGxldmVsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29tcHV0ZSBsZXZlbCBiYXNlZCBvbiBwcmV2aW91cyBzY2FsZSBhbmQgbmV3IHNjYWxlXG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gbGV2ZWwgLyB0aGlzLl9fbGFzdFNjYWxlICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGltaXQgbGV2ZWwgYWNjb3JkaW5nIHRvIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBNYXRoLm1heChNYXRoLm1pbihsZXZlbCwgdGhpcy5vcHRpb25zLm1heFpvb20pLCB0aGlzLm9wdGlvbnMubWluWm9vbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBkbyBmdXJ0aGVyIGNvbXB1dGlvbiB3aGVuIGNoYW5nZSBoYXBwZW5lZFxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTGV2ZWwgIT09IGxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHJlbGF0aXZlIGV2ZW50IHBvc2l0aW9uIHRvIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb3VjaExlZnRSZWwgPSBjdXJyZW50VG91Y2hMZWZ0IC0gdGhpcy5fX2NsaWVudExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRvdWNoVG9wUmVsID0gY3VycmVudFRvdWNoVG9wIC0gdGhpcy5fX2NsaWVudFRvcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjb21wdXRlIGxlZnQgYW5kIHRvcCBjb29yZGluYXRlcyBiYXNlZCBvbiBuZXcgem9vbSBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9ICgoY3VycmVudFRvdWNoTGVmdFJlbCArIHNjcm9sbExlZnQpICogbGV2ZWwgLyBvbGRMZXZlbCkgLSBjdXJyZW50VG91Y2hMZWZ0UmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gKChjdXJyZW50VG91Y2hUb3BSZWwgKyBzY3JvbGxUb3ApICogbGV2ZWwgLyBvbGRMZXZlbCkgLSBjdXJyZW50VG91Y2hUb3BSZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY29tcHV0ZSBtYXggc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbXB1dGVTY3JvbGxNYXgobGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19lbmFibGVTY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgLT0gbW92ZVggKiB0aGlzLm9wdGlvbnMuc3BlZWRNdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4U2Nyb2xsTGVmdCA9IHRoaXMuX19tYXhTY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxMZWZ0ID4gbWF4U2Nyb2xsTGVmdCB8fCBzY3JvbGxMZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2xvdyBkb3duIG9uIHRoZSBlZGdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuY2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgKz0gKG1vdmVYIC8gMiAgKiB0aGlzLm9wdGlvbnMuc3BlZWRNdWx0aXBsaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsTGVmdCA+IG1heFNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0ID0gbWF4U2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5ldyB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2VuYWJsZVNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wIC09IG1vdmVZICogdGhpcy5vcHRpb25zLnNwZWVkTXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFNjcm9sbFRvcCA9IHRoaXMuX19tYXhTY3JvbGxUb3A7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA+IG1heFNjcm9sbFRvcCB8fCBzY3JvbGxUb3AgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTbG93IGRvd24gb24gdGhlIGVkZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5jaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wICs9IChtb3ZlWSAvIDIgKiB0aGlzLm9wdGlvbnMuc3BlZWRNdWx0aXBsaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsVG9wID4gbWF4U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gbWF4U2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gS2VlcCBsaXN0IGZyb20gZ3Jvd2luZyBpbmZpbml0ZWx5IChob2xkaW5nIG1pbiAxMCwgbWF4IDIwIG1lYXN1cmUgcG9pbnRzKVxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnMubGVuZ3RoID4gNjApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnNwbGljZSgwLCAzMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgc2Nyb2xsIG1vdmVtZW50IGZvciBkZWNsZXJhdGlvblxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHNjcm9sbExlZnQsIHNjcm9sbFRvcCwgdGltZVN0YW1wKTtcblxuICAgICAgICAgICAgICAgIC8vIFN5bmMgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5fX3B1Ymxpc2goc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wLCBsZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgZmlndXJlIG91dCB3aGV0aGVyIHdlIGFyZSBzd2l0Y2hpbmcgaW50byBkcmFnZ2luZyBtb2RlIG5vdy5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbmltdW1UcmFja2luZ0ZvclNjcm9sbCA9IHRoaXMub3B0aW9ucy5sb2NraW5nID8gMyA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIG1pbmltdW1UcmFja2luZ0ZvckRyYWcgPSA1O1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGguYWJzKGN1cnJlbnRUb3VjaExlZnQgLSB0aGlzLl9faW5pdGlhbFRvdWNoTGVmdCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWSA9IE1hdGguYWJzKGN1cnJlbnRUb3VjaFRvcCAtIHRoaXMuX19pbml0aWFsVG91Y2hUb3ApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fX2VuYWJsZVNjcm9sbFggPSB0aGlzLm9wdGlvbnMuc2Nyb2xsaW5nWCAmJiBkaXN0YW5jZVggPj0gbWluaW11bVRyYWNraW5nRm9yU2Nyb2xsO1xuICAgICAgICAgICAgICAgIHRoaXMuX19lbmFibGVTY3JvbGxZID0gdGhpcy5vcHRpb25zLnNjcm9sbGluZ1kgJiYgZGlzdGFuY2VZID49IG1pbmltdW1UcmFja2luZ0ZvclNjcm9sbDtcblxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHRoaXMuX19zY3JvbGxMZWZ0LCB0aGlzLl9fc2Nyb2xsVG9wLCB0aW1lU3RhbXApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lzRHJhZ2dpbmcgPSAodGhpcy5fX2VuYWJsZVNjcm9sbFggfHwgdGhpcy5fX2VuYWJsZVNjcm9sbFkpICYmIChkaXN0YW5jZVggPj0gbWluaW11bVRyYWNraW5nRm9yRHJhZyB8fCBkaXN0YW5jZVkgPj0gbWluaW11bVRyYWNraW5nRm9yRHJhZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19pbnRlcnJ1cHRlZEFuaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGxhc3QgdG91Y2ggcG9zaXRpb25zIGFuZCB0aW1lIHN0YW1wIGZvciBuZXh0IGV2ZW50XG4gICAgICAgICAgICB0aGlzLl9fbGFzdFRvdWNoTGVmdCA9IGN1cnJlbnRUb3VjaExlZnQ7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdFRvdWNoVG9wID0gY3VycmVudFRvdWNoVG9wO1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RUb3VjaE1vdmUgPSB0aW1lU3RhbXA7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdFNjYWxlID0gc2NhbGU7XG4gICAgICAgIH0sXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2ggZW5kIGhhbmRsZXIgZm9yIHNjcm9sbGluZyBzdXBwb3J0XG4gICAgICAgICAqL1xuICAgICAgICBkb1RvdWNoRW5kIDogZnVuY3Rpb24gKHRpbWVTdGFtcCkge1xuICAgICAgICAgICAgaWYgKHRpbWVTdGFtcCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICB0aW1lU3RhbXAgPSB0aW1lU3RhbXAudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lU3RhbXAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRpbWVzdGFtcCB2YWx1ZTogXCIgKyB0aW1lU3RhbXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQgd2hlbiB0cmFja2luZyBpcyBub3QgZW5hYmxlZCAobm8gdG91Y2hzdGFydCBldmVudCBvbiBlbGVtZW50KVxuICAgICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBhcyB0aGlzIGxpc3RlbmVyICgndG91Y2htb3ZlJykgc2l0cyBvbiB0aGUgZG9jdW1lbnQgYW5kIG5vdCBvbiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX19pc1RyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOb3QgdG91Y2hpbmcgYW55bW9yZSAod2hlbiB0d28gZmluZ2VyIGhpdCB0aGUgc2NyZWVuIHRoZXJlIGFyZSB0d28gdG91Y2ggZW5kIGV2ZW50cylcbiAgICAgICAgICAgIHRoaXMuX19pc1RyYWNraW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIEJlIHN1cmUgdG8gcmVzZXQgdGhlIGRyYWdnaW5nIGZsYWcgbm93LiBIZXJlIHdlIGFsc28gZGV0ZWN0IHdoZXRoZXJcbiAgICAgICAgICAgIC8vIHRoZSBmaW5nZXIgaGFzIG1vdmVkIGZhc3QgZW5vdWdoIHRvIHN3aXRjaCBpbnRvIGEgZGVjZWxlcmF0aW9uIGFuaW1hdGlvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLl9faXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGRyYWdnaW5nIGZsYWdcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZGVjZWxlcmF0aW9uXG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGxhc3QgbW92ZSBkZXRlY3RlZCB3YXMgaW4gc29tZSByZWxldmFudCB0aW1lIGZyYW1lXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pc1NpbmdsZVRvdWNoICYmIHRoaXMub3B0aW9ucy5hbmltYXRpbmcgJiYgKHRpbWVTdGFtcCAtIHRoaXMuX19sYXN0VG91Y2hNb3ZlKSA8PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiBmaWd1cmUgb3V0IHdoYXQgdGhlIHNjcm9sbCBwb3NpdGlvbiB3YXMgYWJvdXQgMTAwbXMgYWdvXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSB0aGlzLl9fcG9zaXRpb25zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUG9zID0gcG9zaXRpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFBvcyA9IGVuZFBvcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHBvaW50ZXIgdG8gcG9zaXRpb24gbWVhc3VyZWQgMTAwbXMgYWdvXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBlbmRQb3M7IGkgPiAwICYmIHBvc2l0aW9uc1tpXSA+ICh0aGlzLl9fbGFzdFRvdWNoTW92ZSAtIDEwMCk7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RhcnQgYW5kIHN0b3AgcG9zaXRpb24gaXMgaWRlbnRpY2FsIGluIGEgMTAwbXMgdGltZWZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgY29tcHV0ZSBhbnkgdXNlZnVsIGRlY2VsZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0UG9zICE9PSBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgbW92ZW1lbnQgYmV0d2VlbiB0aGVzZSB0d28gcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZU9mZnNldCA9IHBvc2l0aW9uc1tlbmRQb3NdIC0gcG9zaXRpb25zW3N0YXJ0UG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlZExlZnQgPSB0aGlzLl9fc2Nyb2xsTGVmdCAtIHBvc2l0aW9uc1tzdGFydFBvcyAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkVG9wID0gdGhpcy5fX3Njcm9sbFRvcCAtIHBvc2l0aW9uc1tzdGFydFBvcyAtIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlZCBvbiA1MG1zIGNvbXB1dGUgdGhlIG1vdmVtZW50IHRvIGFwcGx5IGZvciBlYWNoIHJlbmRlciBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlYID0gbW92ZWRMZWZ0IC8gdGltZU9mZnNldCAqICgxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WSA9IG1vdmVkVG9wIC8gdGltZU9mZnNldCAqICgxMDAwIC8gNjApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3cgbXVjaCB2ZWxvY2l0eSBpcyByZXF1aXJlZCB0byBzdGFydCB0aGUgZGVjZWxlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluVmVsb2NpdHlUb1N0YXJ0RGVjZWxlcmF0aW9uID0gdGhpcy5vcHRpb25zLnBhZ2luZyB8fCB0aGlzLm9wdGlvbnMuc25hcHBpbmcgPyA0IDogMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSBlbm91Z2ggdmVsb2NpdHkgdG8gc3RhcnQgZGVjZWxlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WCkgPiBtaW5WZWxvY2l0eVRvU3RhcnREZWNlbGVyYXRpb24gfHwgTWF0aC5hYnModGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WSkgPiBtaW5WZWxvY2l0eVRvU3RhcnREZWNlbGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fc3RhcnREZWNlbGVyYXRpb24odGltZVN0YW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodGltZVN0YW1wIC0gdGhpcy5fX2xhc3RUb3VjaE1vdmUpID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBzbG93ZXIgbW92ZSBpdCBpcyBwZXIgZGVmYXVsdCBub24gZGVjZWxlcmF0ZWQsIGJ1dCB0aGlzXG4gICAgICAgICAgICAvLyBzdGlsbCBtZWFucyB0aGF0IHdlIHdhbnQgc25hcCBiYWNrIHRvIHRoZSBib3VuZHMgd2hpY2ggaXMgZG9uZSBoZXJlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwbGFjZWQgb3V0c2lkZSB0aGUgY29uZGl0aW9uIGFib3ZlIHRvIGltcHJvdmUgZWRnZSBjYXNlIHN0YWJpbGl0eVxuICAgICAgICAgICAgLy8gZS5nLiB0b3VjaGVuZCBmaXJlZCB3aXRob3V0IGVuYWJsZWQgZHJhZ2dpbmcuIFRoaXMgc2hvdWxkIG5vcm1hbGx5IGRvIG5vdFxuICAgICAgICAgICAgLy8gaGF2ZSBtb2RpZmllZCB0aGUgc2Nyb2xsIHBvc2l0aW9ucyBvciBldmVuIHNob3dlZCB0aGUgc2Nyb2xsYmFycyB0aG91Z2guXG4gICAgICAgICAgICBpZiAoIXRoaXMuX19pc0RlY2VsZXJhdGluZykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faW50ZXJydXB0ZWRBbmltYXRpb24gfHwgdGhpcy5fX2lzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbGluZ0NvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8odGhpcy5fX3Njcm9sbExlZnQsIHRoaXMuX19zY3JvbGxUb3AsIHRydWUsIHRoaXMuX196b29tTGV2ZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGdWxseSBjbGVhbnVwIGxpc3RcbiAgICAgICAgICAgIHRoaXMuX19wb3NpdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcblxuXG5cbiAgICAgICAgLypcbiAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICBQUklWQVRFIEFQSVxuICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBsaWVzIHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIGNvbnRlbnQgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbGVmdCB7TnVtYmVyfSBMZWZ0IHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgKiBAcGFyYW0gdG9wIHtOdW1iZXJ9IFRvcCBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICogQHBhcmFtIGlzQW5pbWF0ZWQge0Jvb2xlYW4/ZmFsc2V9IFdoZXRoZXIgYW5pbWF0aW9uIHNob3VsZCBiZSB1c2VkIHRvIG1vdmUgdG8gdGhlIG5ldyBjb29yZGluYXRlc1xuICAgICAgICAgKi9cbiAgICAgICAgX19wdWJsaXNoIDogZnVuY3Rpb24gKGxlZnQsIHRvcCwgem9vbSwgaXNBbmltYXRlZCkge1xuICAgICAgICAgICAgLy8gUmVtZW1iZXIgd2hldGhlciB3ZSBoYWQgYW4gYW5pbWF0aW9uLCB0aGVuIHdlIHRyeSB0byBjb250aW51ZVxuICAgICAgICAgICAgLy8gYmFzZWQgb24gdGhlIGN1cnJlbnQgXCJkcml2ZVwiIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICB2YXIgd2FzQW5pbWF0aW5nID0gdGhpcy5fX2lzQW5pbWF0aW5nO1xuICAgICAgICAgICAgaWYgKHdhc0FuaW1hdGluZykge1xuICAgICAgICAgICAgICAgIGFuaW1hdGUuc3RvcCh3YXNBbmltYXRpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBbmltYXRlZCAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCBzY2hlZHVsZWQgcG9zaXRpb25zIGZvciBzY3JvbGxCeS96b29tQnkgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICAgICAgICB0aGlzLl9fc2NoZWR1bGVkTGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3NjaGVkdWxlZFRvcCA9IHRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLl9fc2NoZWR1bGVkWm9vbSA9IHpvb207XG5cbiAgICAgICAgICAgICAgICB2YXIgb2xkTGVmdCA9IHRoaXMuX19zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBvbGRUb3AgPSB0aGlzLl9fc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIHZhciBvbGRab29tID0gdGhpcy5fX3pvb21MZXZlbDtcblxuICAgICAgICAgICAgICAgIHZhciBkaWZmTGVmdCA9IGxlZnQgLSBvbGRMZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBkaWZmVG9wID0gdG9wIC0gb2xkVG9wO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmWm9vbSA9IHpvb20gLSBvbGRab29tO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAocGVyY2VudCwgbm93LCByZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3Njcm9sbExlZnQgPSBvbGRMZWZ0ICsgKGRpZmZMZWZ0ICogcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fc2Nyb2xsVG9wID0gb2xkVG9wICsgKGRpZmZUb3AgKiBwZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX196b29tTGV2ZWwgPSBvbGRab29tICsgKGRpZmZab29tICogcGVyY2VudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggdmFsdWVzIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jYWxsYmFjayh0aGlzLl9fc2Nyb2xsTGVmdCwgdGhpcy5fX3Njcm9sbFRvcCwgdGhpcy5fX3pvb21MZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVyaWZ5ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9faXNBbmltYXRpbmcgPT09IGlkO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbiAocmVuZGVyZWRGcmFtZXNQZXJTZWNvbmQsIGFuaW1hdGlvbklkLCB3YXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSWQgPT09IHRoaXMuX19pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kaWREZWNlbGVyYXRpb25Db21wbGV0ZSB8fCB3YXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbGluZ0NvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnpvb21pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb21wdXRlU2Nyb2xsTWF4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3pvb21Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX196b29tQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fem9vbUNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gY29udGludWluZyBiYXNlZCBvbiBwcmV2aW91cyBhbmltYXRpb24gd2UgY2hvb3NlIGFuIGVhc2Utb3V0IGFuaW1hdGlvbiBpbnN0ZWFkIG9mIGVhc2UtaW4tb3V0XG4gICAgICAgICAgICAgICAgdGhpcy5fX2lzQW5pbWF0aW5nID0gYW5pbWF0ZS5zdGFydChzdGVwLCB2ZXJpZnksIGNvbXBsZXRlZCwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLCB3YXNBbmltYXRpbmcgPyBlYXNlT3V0Q3ViaWMgOiBlYXNlSW5PdXRDdWJpYyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3NjaGVkdWxlZExlZnQgPSB0aGlzLl9fc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3NjaGVkdWxlZFRvcCA9IHRoaXMuX19zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3NjaGVkdWxlZFpvb20gPSB0aGlzLl9fem9vbUxldmVsID0gem9vbTtcblxuICAgICAgICAgICAgICAgIC8vIFB1c2ggdmFsdWVzIG91dFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NhbGxiYWNrKGxlZnQsIHRvcCwgem9vbSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRml4IG1heCBzY3JvbGwgcmFuZ2VzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29taW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jb21wdXRlU2Nyb2xsTWF4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fem9vbUNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fem9vbUNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fem9vbUNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvbXB1dGVzIHNjcm9sbCBtaW5pbXVtIHZhbHVlcyBiYXNlZCBvbiBjbGllbnQgZGltZW5zaW9ucyBhbmQgY29udGVudCBkaW1lbnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgX19jb21wdXRlU2Nyb2xsTWF4IDogZnVuY3Rpb24gKHpvb21MZXZlbCkge1xuICAgICAgICAgICAgaWYgKHpvb21MZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsID0gdGhpcy5fX3pvb21MZXZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX21heFNjcm9sbExlZnQgPSBNYXRoLm1heCh0aGlzLl9fY29udGVudFdpZHRoKnpvb21MZXZlbCAtIHRoaXMuX19jbGllbnRXaWR0aCwgMCk7XG4gICAgICAgICAgICB0aGlzLl9fbWF4U2Nyb2xsVG9wID0gTWF0aC5tYXgodGhpcy5fX2NvbnRlbnRIZWlnaHQqem9vbUxldmVsIC0gdGhpcy5fX2NsaWVudEhlaWdodCwgMCk7XG4gICAgICAgIH0sXG5cblxuXG4gICAgICAgIC8qXG4gICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgQU5JTUFUSU9OIChERUNFTEVSQVRJT04pIFNVUFBPUlRcbiAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYSB0b3VjaCBzZXF1ZW5jZSBlbmQgYW5kIHRoZSBzcGVlZCBvZiB0aGUgZmluZ2VyIHdhcyBoaWdoIGVub3VnaFxuICAgICAgICAgKiB0byBzd2l0Y2ggaW50byBkZWNlbGVyYXRpb24gbW9kZS5cbiAgICAgICAgICovXG4gICAgICAgIF9fc3RhcnREZWNlbGVyYXRpb24gOiBmdW5jdGlvbiAodGltZVN0YW1wKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhZ2luZykge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy5fX3Njcm9sbExlZnQsIHRoaXMuX19tYXhTY3JvbGxMZWZ0KSwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuX19zY3JvbGxUb3AsIHRoaXMuX19tYXhTY3JvbGxUb3ApLCAwKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50V2lkdGggPSB0aGlzLl9fY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudEhlaWdodCA9IHRoaXMuX19jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBsaW1pdCBkZWNlbGVyYXRpb24gbm90IHRvIHRoZSBtaW4vbWF4IHZhbHVlcyBvZiB0aGUgYWxsb3dlZCByYW5nZSwgYnV0IHRvIHRoZSBzaXplIG9mIHRoZSB2aXNpYmxlIGNsaWVudCBhcmVhLlxuICAgICAgICAgICAgICAgIC8vIEVhY2ggcGFnZSBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBzaXplIG9mIHRoZSBjbGllbnQgYXJlYS5cbiAgICAgICAgICAgICAgICB0aGlzLl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCA9IE1hdGguZmxvb3Ioc2Nyb2xsTGVmdCAvIGNsaWVudFdpZHRoKSAqIGNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX19taW5EZWNlbGVyYXRpb25TY3JvbGxUb3AgPSBNYXRoLmZsb29yKHNjcm9sbFRvcCAvIGNsaWVudEhlaWdodCkgKiBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fX21heERlY2VsZXJhdGlvblNjcm9sbExlZnQgPSBNYXRoLmNlaWwoc2Nyb2xsTGVmdCAvIGNsaWVudFdpZHRoKSAqIGNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxUb3AgPSBNYXRoLmNlaWwoc2Nyb2xsVG9wIC8gY2xpZW50SGVpZ2h0KSAqIGNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX21pbkRlY2VsZXJhdGlvblNjcm9sbExlZnQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX19taW5EZWNlbGVyYXRpb25TY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxMZWZ0ID0gdGhpcy5fX21heFNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fX21heERlY2VsZXJhdGlvblNjcm9sbFRvcCA9IHRoaXMuX19tYXhTY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdyYXAgY2xhc3MgbWV0aG9kXG4gICAgICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChwZXJjZW50LCBub3csIHJlbmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19zdGVwVGhyb3VnaERlY2VsZXJhdGlvbihyZW5kZXIpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBIb3cgbXVjaCB2ZWxvY2l0eSBpcyByZXF1aXJlZCB0byBrZWVwIHRoZSBkZWNlbGVyYXRpb24gcnVubmluZ1xuICAgICAgICAgICAgdmFyIG1pblZlbG9jaXR5VG9LZWVwRGVjZWxlcmF0aW5nID0gdGhpcy5vcHRpb25zLnNuYXBwaW5nID8gNCA6IDAuMTtcblxuICAgICAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgaXQncyBzdGlsbCB3b3J0aCB0byBjb250aW51ZSBhbmltYXRpbmcgc3RlcHNcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IHNsb3cgZW5vdWdoIHRvIG5vdCBiZWluZyB1c2VyIHBlcmNlaXZhYmxlIGFueW1vcmUsIHdlIHN0b3AgdGhlIHdob2xlIHByb2Nlc3MgaGVyZS5cbiAgICAgICAgICAgIHZhciB2ZXJpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNob3VsZENvbnRpbnVlID0gTWF0aC5hYnModGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WCkgPj0gbWluVmVsb2NpdHlUb0tlZXBEZWNlbGVyYXRpbmcgfHwgTWF0aC5hYnModGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WSkgPj0gbWluVmVsb2NpdHlUb0tlZXBEZWNlbGVyYXRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRDb250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGlkRGVjZWxlcmF0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkQ29udGludWU7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbiAocmVuZGVyZWRGcmFtZXNQZXJTZWNvbmQsIGFuaW1hdGlvbklkLCB3YXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX19pc0RlY2VsZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGlkRGVjZWxlcmF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbGluZ0NvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQW5pbWF0ZSB0byBncmlkIHdoZW4gc25hcHBpbmcgaXMgYWN0aXZlLCBvdGhlcndpc2UganVzdCBmaXggb3V0LW9mLWJvdW5kYXJ5IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8odGhpcy5fX3Njcm9sbExlZnQsIHRoaXMuX19zY3JvbGxUb3AsIHRoaXMub3B0aW9ucy5zbmFwcGluZyk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGFuaW1hdGlvbiBhbmQgc3dpdGNoIG9uIGZsYWdcbiAgICAgICAgICAgIHRoaXMuX19pc0RlY2VsZXJhdGluZyA9IGFuaW1hdGUuc3RhcnQoc3RlcCwgdmVyaWZ5LCBjb21wbGV0ZWQpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBvbiBldmVyeSBzdGVwIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGluTWVtb3J5IHtCb29sZWFuP2ZhbHNlfSBXaGV0aGVyIHRvIG5vdCByZW5kZXIgdGhlIGN1cnJlbnQgc3RlcCwgYnV0IGtlZXAgaXQgaW4gbWVtb3J5IG9ubHkuIFVzZWQgaW50ZXJuYWxseSBvbmx5IVxuICAgICAgICAgKi9cbiAgICAgICAgX19zdGVwVGhyb3VnaERlY2VsZXJhdGlvbiA6IGZ1bmN0aW9uIChyZW5kZXIpIHtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIENPTVBVVEUgTkVYVCBTQ1JPTEwgUE9TSVRJT05cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIC8vIEFkZCBkZWNlbGVyYXRpb24gdG8gc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuX19zY3JvbGxMZWZ0ICsgdGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLl9fc2Nyb2xsVG9wICsgdGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WTtcblxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSEFSRCBMSU1JVCBTQ1JPTEwgUE9TSVRJT04gRk9SIE5PTiBCT1VOQ0lORyBNT0RFXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5ib3VuY2luZykge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0Rml4ZWQgPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLl9fbWF4RGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCwgc2Nyb2xsTGVmdCksIHRoaXMuX19taW5EZWNlbGVyYXRpb25TY3JvbGxMZWZ0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsTGVmdEZpeGVkICE9PSBzY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0Rml4ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZWNlbGVyYXRpb25WZWxvY2l0eVggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3BGaXhlZCA9IE1hdGgubWF4KE1hdGgubWluKHRoaXMuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxUb3AsIHNjcm9sbFRvcCksIHRoaXMuX19taW5EZWNlbGVyYXRpb25TY3JvbGxUb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb3BGaXhlZCAhPT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcEZpeGVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVQREFURSBTQ1JPTEwgUE9TSVRJT05cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcHVibGlzaChzY3JvbGxMZWZ0LCBzY3JvbGxUb3AsIHRoaXMuX196b29tTGV2ZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3Njcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU0xPVyBET1dOXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAvLyBTbG93IGRvd24gdmVsb2NpdHkgb24gZXZlcnkgaXRlcmF0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wYWdpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmYWN0b3IgYXBwbGllZCB0byBldmVyeSBpdGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIC8vIHRvIHNsb3cgZG93biB0aGUgcHJvY2Vzcy4gVGhpcyBzaG91bGQgZW11bGF0ZSBuYXR1cmFsIGJlaGF2aW9yIHdoZXJlXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyBzbG93IGRvd24gd2hlbiB0aGUgaW5pdGlhdG9yIG9mIHRoZSBtb3ZlbWVudCBpcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgdmFyIGZyaWN0aW9uRmFjdG9yID0gMC45NTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX19kZWNlbGVyYXRpb25WZWxvY2l0eVggKj0gZnJpY3Rpb25GYWN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WSAqPSBmcmljdGlvbkZhY3RvcjtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQk9VTkNJTkcgU1VQUE9SVFxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuY2luZykge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxPdXRzaWRlWCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbE91dHNpZGVZID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29uZmlndXJlcyB0aGUgYW1vdW50IG9mIGNoYW5nZSBhcHBsaWVkIHRvIGRlY2VsZXJhdGlvbi9hY2NlbGVyYXRpb24gd2hlbiByZWFjaGluZyBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uRGVjZWxlcmF0aW9uID0gdGhpcy5vcHRpb25zLnBlbmV0cmF0aW9uRGVjZWxlcmF0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGlvbkFjY2VsZXJhdGlvbiA9IHRoaXMub3B0aW9ucy5wZW5ldHJhdGlvbkFjY2VsZXJhdGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGxpbWl0c1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxMZWZ0IDwgdGhpcy5fX21pbkRlY2VsZXJhdGlvblNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsT3V0c2lkZVggPSB0aGlzLl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCAtIHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxMZWZ0ID4gdGhpcy5fX21heERlY2VsZXJhdGlvblNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsT3V0c2lkZVggPSB0aGlzLl9fbWF4RGVjZWxlcmF0aW9uU2Nyb2xsTGVmdCAtIHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA8IHRoaXMuX19taW5EZWNlbGVyYXRpb25TY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsT3V0c2lkZVkgPSB0aGlzLl9fbWluRGVjZWxlcmF0aW9uU2Nyb2xsVG9wIC0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsVG9wID4gdGhpcy5fX21heERlY2VsZXJhdGlvblNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxPdXRzaWRlWSA9IHRoaXMuX19tYXhEZWNlbGVyYXRpb25TY3JvbGxUb3AgLSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2xvdyBkb3duIHVudGlsIHNsb3cgZW5vdWdoLCB0aGVuIGZsaXAgYmFjayB0byBzbmFwIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbE91dHNpZGVYICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxPdXRzaWRlWCAqIHRoaXMuX19kZWNlbGVyYXRpb25WZWxvY2l0eVggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WCArPSBzY3JvbGxPdXRzaWRlWCAqIHBlbmV0cmF0aW9uRGVjZWxlcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WCA9IHNjcm9sbE91dHNpZGVYICogcGVuZXRyYXRpb25BY2NlbGVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsT3V0c2lkZVkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbE91dHNpZGVZICogdGhpcy5fX2RlY2VsZXJhdGlvblZlbG9jaXR5WSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZICs9IHNjcm9sbE91dHNpZGVZICogcGVuZXRyYXRpb25EZWNlbGVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVjZWxlcmF0aW9uVmVsb2NpdHlZID0gc2Nyb2xsT3V0c2lkZVkgKiBwZW5ldHJhdGlvbkFjY2VsZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU2Nyb2xsZXI7XG59KSk7XG4iLCIvKlxuICogU2Nyb2xsZXJcbiAqIGh0dHA6Ly9naXRodWIuY29tL3p5bmdhL3Njcm9sbGVyXG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFp5bmdhIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20venluZ2Evc2Nyb2xsZXIvbWFzdGVyL01JVC1MSUNFTlNFLnR4dFxuICpcbiAqIEJhc2VkIG9uIHRoZSB3b3JrIG9mOiBVbmlmeSBQcm9qZWN0ICh1bmlmeS1wcm9qZWN0Lm9yZylcbiAqIGh0dHA6Ly91bmlmeS1wcm9qZWN0Lm9yZ1xuICogQ29weXJpZ2h0IDIwMTEsIERldXRzY2hlIFRlbGVrb20gQUdcbiAqIExpY2Vuc2U6IE1JVCArIEFwYWNoZSAoVjIpXG4gKi9cblxuLyoqXG4gKiBHZW5lcmljIGFuaW1hdGlvbiBjbGFzcyB3aXRoIHN1cHBvcnQgZm9yIGRyb3BwZWQgZnJhbWVzIGJvdGggb3B0aW9uYWwgZWFzaW5nIGFuZCBkdXJhdGlvbi5cbiAqXG4gKiBPcHRpb25hbCBkdXJhdGlvbiBpcyB1c2VmdWwgd2hlbiB0aGUgbGlmZXRpbWUgaXMgZGVmaW5lZCBieSBhbm90aGVyIGNvbmRpdGlvbiB0aGFuIHRpbWVcbiAqIGUuZy4gc3BlZWQgb2YgYW4gYW5pbWF0aW5nIG9iamVjdCwgZXRjLlxuICpcbiAqIERyb3BwZWQgZnJhbWUgbG9naWMgYWxsb3dzIHRvIGtlZXAgdXNpbmcgdGhlIHNhbWUgdXBkYXRlciBsb2dpYyBpbmRlcGVuZGVudCBmcm9tIHRoZSBhY3R1YWxcbiAqIHJlbmRlcmluZy4gVGhpcyBlYXNlcyBhIGxvdCBvZiBjYXNlcyB3aGVyZSBpdCBtaWdodCBiZSBwcmV0dHkgY29tcGxleCB0byBicmVhayBkb3duIGEgc3RhdGVcbiAqIGJhc2VkIG9uIHRoZSBwdXJlIHRpbWUgZGlmZmVyZW5jZS5cbiAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gQ29tbW9uSlNcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgZmFjdG9yeSgocm9vdC5hbmltYXRlID0ge30pKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgdmFyIGdsb2JhbCA9IHRoaXM7XG4gICAgdmFyIHRpbWUgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICB9O1xuICAgIHZhciBkZXNpcmVkRnJhbWVzID0gNjA7XG4gICAgdmFyIG1pbGxpc2Vjb25kc1BlclNlY29uZCA9IDEwMDA7XG4gICAgdmFyIHJ1bm5pbmcgPSB7fTtcbiAgICB2YXIgY291bnRlciA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3cmFwcGVyIC8gcG9seWZpbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBiZWZvcmUgdGhlIG5leHQgcmVwYWludC5cbiAgICAgKiBAcGFyYW0gcm9vdCB7SFRNTEVsZW1lbnR9IFRoZSByb290IGVsZW1lbnQgZm9yIHRoZSByZXBhaW50XG4gICAgICovXG4gICAgZXhwb3J0cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgcmVxdWVzdCBhbmltYXRpb24gRnJhbWUgc3VwcG9ydFxuICAgICAgICB2YXIgcmVxdWVzdEZyYW1lID0gZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBnbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZ2xvYmFsLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgICAgIHZhciBpc05hdGl2ZSA9ICEhcmVxdWVzdEZyYW1lO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0RnJhbWUgJiYgIS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXChcXClcXHMqXFx7XFxzKlxcW25hdGl2ZSBjb2RlXFxdXFxzKlxcfS9pLnRlc3QocmVxdWVzdEZyYW1lLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICBpc05hdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmF0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCByb290KSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEZyYW1lKGNhbGxiYWNrLCByb290KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgVEFSR0VUX0ZQUyA9IDYwO1xuICAgICAgICB2YXIgcmVxdWVzdHMgPSB7fTtcbiAgICAgICAgdmFyIHJlcXVlc3RDb3VudCA9IDA7XG4gICAgICAgIHZhciByYWZIYW5kbGUgPSAxO1xuICAgICAgICB2YXIgaW50ZXJ2YWxIYW5kbGUgPSBudWxsO1xuICAgICAgICB2YXIgbGFzdEFjdGl2ZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIHJvb3QpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0hhbmRsZSA9IHJhZkhhbmRsZSsrO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBjYWxsYmFja1xuICAgICAgICAgICAgcmVxdWVzdHNbY2FsbGJhY2tIYW5kbGVdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICByZXF1ZXN0Q291bnQrKztcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRpbWVvdXQgYXQgZmlyc3QgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKGludGVydmFsSGFuZGxlID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFJlcXVlc3RzID0gcmVxdWVzdHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBzdHJ1Y3R1cmUgYmVmb3JlIGV4ZWN1dGluZyBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdENvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiBjdXJyZW50UmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVxdWVzdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXF1ZXN0c1trZXldKHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RBY3RpdmUgPSB0aW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSB0aGUgdGltZW91dCB3aGVuIG5vdGhpbmcgaGFwcGVucyBmb3IgYSBjZXJ0YWluXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmlvZCBvZiB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lIC0gbGFzdEFjdGl2ZSA+IDI1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxIYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9LCAxMDAwIC8gVEFSR0VUX0ZQUyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFja0hhbmRsZTtcbiAgICAgICAgfTtcblxuICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgZ2l2ZW4gYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIHtJbnRlZ2VyfSBVbmlxdWUgYW5pbWF0aW9uIElEXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgYW5pbWF0aW9uIHdhcyBzdG9wcGVkIChha2EsIHdhcyBydW5uaW5nIGJlZm9yZSlcbiAgICAgKi9cbiAgICBleHBvcnRzLnN0b3AgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGNsZWFyZWQgPSAocnVubmluZ1tpZF0gIT09IG51bGwpO1xuICAgICAgICBpZiAoY2xlYXJlZCkge1xuICAgICAgICAgICAgcnVubmluZ1tpZF0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsZWFyZWQ7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZ2l2ZW4gYW5pbWF0aW9uIGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQge0ludGVnZXJ9IFVuaXF1ZSBhbmltYXRpb24gSURcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBhbmltYXRpb24gaXMgc3RpbGwgcnVubmluZ1xuICAgICAqL1xuICAgIGV4cG9ydHMuaXNSdW5uaW5nID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBydW5uaW5nW2lkXSAhPT0gbnVsbDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ZXBDYWxsYmFjayB7RnVuY3Rpb259IFBvaW50ZXIgdG8gZnVuY3Rpb24gd2hpY2ggaXMgZXhlY3V0ZWQgb24gZXZlcnkgc3RlcC5cbiAgICAgKiAgIFNpZ25hdHVyZSBvZiB0aGUgbWV0aG9kIHNob3VsZCBiZSBgZnVuY3Rpb24ocGVyY2VudCwgbm93LCB2aXJ0dWFsKSB7IHJldHVybiBjb250aW51ZVdpdGhBbmltYXRpb247IH1gXG4gICAgICogQHBhcmFtIHZlcmlmeUNhbGxiYWNrIHtGdW5jdGlvbn0gRXhlY3V0ZWQgYmVmb3JlIGV2ZXJ5IGFuaW1hdGlvbiBzdGVwLlxuICAgICAqICAgU2lnbmF0dXJlIG9mIHRoZSBtZXRob2Qgc2hvdWxkIGJlIGBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnRpbnVlV2l0aEFuaW1hdGlvbjsgfWBcbiAgICAgKiBAcGFyYW0gY29tcGxldGVkQ2FsbGJhY2sge0Z1bmN0aW9ufVxuICAgICAqICAgU2lnbmF0dXJlIG9mIHRoZSBtZXRob2Qgc2hvdWxkIGJlIGBmdW5jdGlvbihkcm9wcGVkRnJhbWVzLCBmaW5pc2hlZEFuaW1hdGlvbiwgb3B0aW9uYWwgd2FzRmluaXNoZWQpIHt9YFxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiB7SW50ZWdlcn0gTWlsbGlzZWNvbmRzIHRvIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIGVhc2luZ01ldGhvZCB7RnVuY3Rpb259IFBvaW50ZXIgdG8gZWFzaW5nIGZ1bmN0aW9uXG4gICAgICogICBTaWduYXR1cmUgb2YgdGhlIG1ldGhvZCBzaG91bGQgYmUgYGZ1bmN0aW9uKHBlcmNlbnQpIHsgcmV0dXJuIG1vZGlmaWVkVmFsdWU7IH1gXG4gICAgICogQHBhcmFtIHJvb3Qge0VsZW1lbnR9IFJlbmRlciByb290LiBVc2VkIGZvciBpbnRlcm5hbCB1c2FnZSBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gICAgICogQHJldHVybiB7SW50ZWdlcn0gSWRlbnRpZmllciBvZiBhbmltYXRpb24uIENhbiBiZSB1c2VkIHRvIHN0b3AgaXQgYW55IHRpbWUuXG4gICAgICovXG4gICAgZXhwb3J0cy5zdGFydCA9IGZ1bmN0aW9uIChzdGVwQ2FsbGJhY2ssIHZlcmlmeUNhbGxiYWNrLCBjb21wbGV0ZWRDYWxsYmFjaywgZHVyYXRpb24sIGVhc2luZ01ldGhvZCwgcm9vdCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aW1lKCk7XG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSBzdGFydDtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgICAgICB2YXIgZHJvcENvdW50ZXIgPSAwO1xuICAgICAgICB2YXIgaWQgPSBjb3VudGVyKys7XG5cbiAgICAgICAgLy8gQ29tcGFjdGluZyBydW5uaW5nIGRiIGF1dG9tYXRpY2FsbHkgZXZlcnkgZmV3IG5ldyBhbmltYXRpb25zXG4gICAgICAgIGlmIChpZCAlIDIwID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgbmV3UnVubmluZyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgdXNlZElkIGluIHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdSdW5uaW5nW3VzZWRJZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVubmluZyA9IG5ld1J1bm5pbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbnRlcm5hbCBzdGVwIG1ldGhvZCB3aGljaCBpcyBjYWxsZWQgZXZlcnkgZmV3IG1pbGxpc2Vjb25kc1xuICAgICAgICB2YXIgc3RlcCA9IGZ1bmN0aW9uICh2aXJ0dWFsKSB7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB2aXJ0dWFsIHZhbHVlXG4gICAgICAgICAgICB2YXIgcmVuZGVyID0gdmlydHVhbCAhPT0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgdGltZVxuICAgICAgICAgICAgdmFyIG5vdyA9IHRpbWUoKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZpY2F0aW9uIGlzIGV4ZWN1dGVkIGJlZm9yZSBuZXh0IGFuaW1hdGlvbiBzdGVwXG4gICAgICAgICAgICBpZiAoIXJ1bm5pbmdbaWRdIHx8ICh2ZXJpZnlDYWxsYmFjayAmJiAhdmVyaWZ5Q2FsbGJhY2soaWQpKSkge1xuXG4gICAgICAgICAgICAgICAgcnVubmluZ1tpZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZENhbGxiYWNrKGRlc2lyZWRGcmFtZXMgLSAoZHJvcENvdW50ZXIgLyAoKG5vdyAtIHN0YXJ0KSAvIG1pbGxpc2Vjb25kc1BlclNlY29uZCkpLCBpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3IgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIHRvIGFwcGx5IGxldCdzIHVwZGF0ZSBvbWl0dGVkIHN0ZXBzIGluIG1lbW9yeS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIGJyaW5nIGludGVybmFsIHN0YXRlIHZhcmlhYmxlcyB1cC10by1kYXRlIHdpdGggcHJvZ3Jlc3MgaW4gdGltZS5cbiAgICAgICAgICAgIGlmIChyZW5kZXIpIHtcblxuICAgICAgICAgICAgICAgIHZhciBkcm9wcGVkRnJhbWVzID0gTWF0aC5yb3VuZCgobm93IC0gbGFzdEZyYW1lKSAvIChtaWxsaXNlY29uZHNQZXJTZWNvbmQgLyBkZXNpcmVkRnJhbWVzKSkgLSAxO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgTWF0aC5taW4oZHJvcHBlZEZyYW1lcywgNCk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdGVwKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkcm9wQ291bnRlcisrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHBlcmNlbnQgdmFsdWVcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnQpIC8gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBzdGVwIGNhbGxiYWNrLCB0aGVuLi4uXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlYXNpbmdNZXRob2QgPyBlYXNpbmdNZXRob2QocGVyY2VudCkgOiBwZXJjZW50O1xuICAgICAgICAgICAgaWYgKChzdGVwQ2FsbGJhY2sodmFsdWUsIG5vdywgcmVuZGVyKSA9PT0gZmFsc2UgfHwgcGVyY2VudCA9PT0gMSkgJiYgcmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1tpZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZENhbGxiYWNrKGRlc2lyZWRGcmFtZXMgLSAoZHJvcENvdW50ZXIgLyAoKG5vdyAtIHN0YXJ0KSAvIG1pbGxpc2Vjb25kc1BlclNlY29uZCkpLCBpZCwgcGVyY2VudCA9PT0gMSB8fCBkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgbGFzdEZyYW1lID0gbm93O1xuICAgICAgICAgICAgICAgIGV4cG9ydHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAsIHJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1hcmsgYXMgcnVubmluZ1xuICAgICAgICBydW5uaW5nW2lkXSA9IHRydWU7XG5cbiAgICAgICAgLy8gSW5pdCBmaXJzdCBzdGVwXG4gICAgICAgIGV4cG9ydHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAsIHJvb3QpO1xuXG4gICAgICAgIC8vIFJldHVybiB1bmlxdWUgYW5pbWF0aW9uIElEXG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xufSkpO1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlcicpO1xudmFyIHJlZHVjZSA9IHJlcXVpcmUoJ3JlZHVjZScpO1xuXG4vKipcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxuICovXG5cbnZhciByb290ID0gJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHdpbmRvd1xuICA/IHRoaXNcbiAgOiB3aW5kb3c7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBUT0RPOiBmdXR1cmUgcHJvb2YsIG1vdmUgdG8gY29tcG9lbnQgbGFuZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0hvc3Qob2JqKSB7XG4gIHZhciBzdHIgPSB7fS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IEZvcm1EYXRhXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5mdW5jdGlvbiBnZXRYSFIoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgJiYgKCdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbCB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAobnVsbCAhPSBvYmpba2V5XSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG4gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbiAvKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYXJ0cztcbiAgdmFyIHBhaXI7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBhcnRzID0gcGFpci5zcGxpdCgnPScpO1xuICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFydHNbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0c1sxXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbiByZXF1ZXN0LnNlcmlhbGl6ZSA9IHtcbiAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG4gfTtcblxuIC8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgZmllbGRzID0ge307XG4gIHZhciBpbmRleDtcbiAgdmFyIGxpbmU7XG4gIHZhciBmaWVsZDtcbiAgdmFyIHZhbDtcblxuICBsaW5lcy5wb3AoKTsgLy8gdHJhaWxpbmcgQ1JMRlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGZpZWxkID0gbGluZS5zbGljZSgwLCBpbmRleCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB0cmltKGxpbmUuc2xpY2UoaW5kZXggKyAxKSk7XG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0eXBlKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlYWRlciBmaWVsZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcmFtcyhzdHIpe1xuICByZXR1cm4gcmVkdWNlKHN0ci5zcGxpdCgvICo7ICovKSwgZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKVxuICAgICAgLCBrZXkgPSBwYXJ0cy5zaGlmdCgpXG4gICAgICAsIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZWAgd2l0aCB0aGUgZ2l2ZW4gYHhocmAuXG4gKlxuICogIC0gc2V0IGZsYWdzICgub2ssIC5lcnJvciwgZXRjKVxuICogIC0gcGFyc2UgaGVhZGVyXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcbiAqXG4gKiAgICAgIHJlcXVlc3QgPSBzdXBlcmFnZW50O1xuICpcbiAqICBXZSBjYW4gdXNlIHRoZSBwcm9taXNlLWxpa2UgQVBJLCBvciBwYXNzIGNhbGxiYWNrczpcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJywgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5zZW5kKClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnBvc3QoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIE9yIGZ1cnRoZXIgcmVkdWNlZCB0byBhIHNpbmdsZSBjYWxsIGZvciBzaW1wbGUgY2FzZXM6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJywgeyBuYW1lOiAndGonIH0sIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2UocmVxLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIHRoaXMudGV4dCA9IHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyBcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHQgXG4gICAgIDogbnVsbDtcbiAgdGhpcy5zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcbiAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgID8gdGhpcy5wYXJzZUJvZHkodGhpcy50ZXh0KVxuICAgIDogbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnNldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAvLyBjb250ZW50LXR5cGVcbiAgdmFyIGN0ID0gdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICB0aGlzLnR5cGUgPSB0eXBlKGN0KTtcblxuICAvLyBwYXJhbXNcbiAgdmFyIG9iaiA9IHBhcmFtcyhjdCk7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHRoaXNba2V5XSA9IG9ialtrZXldO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYm9keSBgc3RyYC5cbiAqXG4gKiBVc2VkIGZvciBhdXRvLXBhcnNpbmcgb2YgYm9kaWVzLiBQYXJzZXJzXG4gKiBhcmUgZGVmaW5lZCBvbiB0aGUgYHN1cGVyYWdlbnQucGFyc2VgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlLnByb3RvdHlwZS5wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpe1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgc3RyLmxlbmd0aFxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnNldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgLy8gYmFzaWNzXG4gIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgID8gdGhpcy50b0Vycm9yKClcbiAgICA6IGZhbHNlO1xuXG4gIC8vIHN1Z2FyXG4gIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXMgfHwgMTIyMyA9PSBzdGF0dXM7XG4gIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9O1xuICB0aGlzLl9oZWFkZXIgPSB7fTtcbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICB2YXIgZXJyID0gbnVsbDtcbiAgICB2YXIgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7IFxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgfVxuXG4gICAgc2VsZi5jYWxsYmFjayhlcnIsIHJlcyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNldCB0aW1lb3V0IHRvIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKG1zKXtcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5fdGltZW91dCA9IDA7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuO1xuICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhoci5hYm9ydCgpO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEF1dGhvcml6YXRpb24gZmllbGQgdmFsdWUgd2l0aCBgdXNlcmAgYW5kIGBwYXNzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IHBhc3NcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcyl7XG4gIHZhciBzdHIgPSBidG9hKHVzZXIgKyAnOicgKyBwYXNzKTtcbiAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIHN0cik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4qIEFkZCBxdWVyeS1zdHJpbmcgYHZhbGAuXG4qXG4qIEV4YW1wbGVzOlxuKlxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiogICAgIC5xdWVyeSh7IGNvbG9yOiAnYmx1ZScgfSlcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4qIEBhcGkgcHVibGljXG4qL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAgZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiXG4gKiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpe1xuICBpZiAoIXRoaXMuX2Zvcm1EYXRhKSB0aGlzLl9mb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB0aGlzLl9mb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBmaWxlbmFtZWAuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBmaWxlbmFtZSl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHRoaXMuX2Zvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gIHRoaXMuX2Zvcm1EYXRhLmFwcGVuZChmaWVsZCwgZmlsZSwgZmlsZW5hbWUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAsIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gcXVlcnlzdHJpbmdcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvc2VhcmNoJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtdWx0aXBsZSBkYXRhIFwid3JpdGVzXCJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvc2VhcmNoJylcbiAqICAgICAgICAgLnNlbmQoeyBzZWFyY2g6ICdxdWVyeScgfSlcbiAqICAgICAgICAgLnNlbmQoeyByYW5nZTogJzEuLjUnIH0pXG4gKiAgICAgICAgIC5zZW5kKHsgb3JkZXI6ICdkZXNjJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAgKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAgKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBvYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldEhlYWRlcignQ29udGVudC1UeXBlJyk7XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKG9iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IHRoaXMuX2RhdGEgKyAnJicgKyBkYXRhXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGBlcnJgIGFuZCBgcmVzYFxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIHJlcyl7XG4gIHZhciBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICBpZiAoMiA9PSBmbi5sZW5ndGgpIHJldHVybiBmbihlcnIsIHJlcyk7XG4gIGlmIChlcnIpIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgZm4ocmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ09yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnRpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcigndGltZW91dCBvZiAnICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9IHRoaXMueGhyID0gZ2V0WEhSKCk7XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIGlmICgwID09IHhoci5zdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLmFib3J0ZWQpIHJldHVybiBzZWxmLnRpbWVvdXRFcnJvcigpO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIGlmICh4aHIudXBsb2FkKSB7XG4gICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZSl7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgJiYgIXRoaXMuX3RpbWVyKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICAvLyBxdWVyeXN0cmluZ1xuICBpZiAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0KHF1ZXJ5KTtcbiAgICB0aGlzLnVybCArPSB+dGhpcy51cmwuaW5kZXhPZignPycpXG4gICAgICA/ICcmJyArIHF1ZXJ5XG4gICAgICA6ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICFpc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbdGhpcy5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpXTtcbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcbiAgeGhyLnNlbmQoZGF0YSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlcXVlc3RgLlxuICovXG5cbnJlcXVlc3QuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogSXNzdWUgYSByZXF1ZXN0OlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgIHJlcXVlc3QoJ0dFVCcsICcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXG4gKiAgICByZXF1ZXN0KCcvdXNlcnMnLCBjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gdXJsIG9yIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIC8vIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVxdWVzdChtZXRob2QsIHVybCk7XG59XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gZGF0YSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5kZWwgPSBmdW5jdGlvbih1cmwsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKXtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiXG4vKipcbiAqIFJlZHVjZSBgYXJyYCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtNaXhlZH0gaW5pdGlhbFxuICpcbiAqIFRPRE86IGNvbWJhdGlibGUgZXJyb3IgaGFuZGxpbmc/XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIGZuLCBpbml0aWFsKXsgIFxuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciBjdXJyID0gYXJndW1lbnRzLmxlbmd0aCA9PSAzXG4gICAgPyBpbml0aWFsXG4gICAgOiBhcnJbaWR4KytdO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBjdXJyID0gZm4uY2FsbChudWxsLCBjdXJyLCBhcnJbaWR4XSwgKytpZHgsIGFycik7XG4gIH1cbiAgXG4gIHJldHVybiBjdXJyO1xufTsiXX0=
